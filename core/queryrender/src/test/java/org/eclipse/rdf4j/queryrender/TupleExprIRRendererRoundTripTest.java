/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex

package org.eclipse.rdf4j.queryrender;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatCode;

import org.eclipse.rdf4j.query.QueryLanguage;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.LeftJoin;
import org.eclipse.rdf4j.query.algebra.QueryModelNode;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractQueryModelVisitor;
import org.eclipse.rdf4j.query.parser.ParsedQuery;
import org.eclipse.rdf4j.query.parser.QueryParserUtil;
import org.eclipse.rdf4j.queryrender.sparql.TupleExprIRRenderer;
import org.junit.jupiter.api.RepeatedTest;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.parallel.Execution;
import org.junit.jupiter.api.parallel.ExecutionMode;

@Execution(ExecutionMode.SAME_THREAD)
class TupleExprIRRendererRoundTripTest {

	private static final String COMPLEX_QUERY_PREFIXED = "PREFIX lib: <http://example.com/theme/library/>\n" +
			"PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>\n" +
			"SELECT (COUNT(DISTINCT ?branch) AS ?count) WHERE {\n" +
			"  { ?branch a lib:Branch . }\n" +
			"  UNION\n" +
			"  { ?branch a lib:Branch ; lib:name ?name . }\n" +
			"  OPTIONAL { ?copy lib:locatedAt ?branch . BIND(?copy AS ?optCopy) }\n" +
			"  FILTER(?optCopy != ?branch)\n" +
			"  MINUS { ?branch lib:name ?name2 .\n" +
			"          FILTER(CONTAINS(LCASE(STR(?name2)), \"branch 0\")) }\n" +
			"}";

	@RepeatedTest(10)
	void roundTrip_countDistinct_union_optional_bind_filter_minus() {
		String sparql = "SELECT (COUNT(DISTINCT ?branch) AS ?count) WHERE {\n" +
				"  {\n" +
				"    ?branch a <http://example.com/theme/library/Branch> .\n" +
				"  }\n" +
				"  UNION\n" +
				"  {\n" +
				"    ?branch a <http://example.com/theme/library/Branch> .\n" +
				"    ?branch <http://example.com/theme/library/name> ?name .\n" +
				"  }\n" +
				"  OPTIONAL {\n" +
				"    ?copy <http://example.com/theme/library/locatedAt> ?branch .\n" +
				"    BIND(?copy AS ?optCopy)\n" +
				"  }\n" +
				"  FILTER (?optCopy != ?branch)\n" +
				"  MINUS {\n" +
				"    ?branch <http://example.com/theme/library/name> ?name2 .\n" +
				"    FILTER (CONTAINS(LCASE(STR(?name2)), \"branch 0\"))\n" +
				"  }\n" +
				"}";

		assertRoundTrip(sparql);
	}

	@RepeatedTest(10)
	void roundTrip_countDistinct_union_optional_bind_filter_minus_withPrefixes() {
		assertRoundTrip(COMPLEX_QUERY_PREFIXED);
	}

	@Test
	void verifyRoundTrip_ignores_algorithmNames() {
		TupleExpr tupleExpr = parseTupleExpr(COMPLEX_QUERY_PREFIXED);
		addJoinAlgorithmNames(tupleExpr);
		addCostAndSizeAnnotations(tupleExpr);

		TupleExprIRRenderer.Config cfg = new TupleExprIRRenderer.Config();
		cfg.verifyRoundTrip = true;

		assertThatCode(() -> new TupleExprIRRenderer(cfg).render(tupleExpr, null))
				.doesNotThrowAnyException();
	}

	@Test
	void verifyRoundTrip_ignores_costAndSizeAnnotations() {
		String sparql = "SELECT (COUNT(DISTINCT ?branch) AS ?count) WHERE {\n" +
				"  { ?branch a <http://example.com/theme/library/Branch> . }\n" +
				"  UNION\n" +
				"  { ?branch a <http://example.com/theme/library/Branch> ; <http://example.com/theme/library/name> ?name . }\n"
				+
				"}";
		TupleExpr tupleExpr = parseTupleExpr(sparql);
		addCostAndSizeAnnotations(tupleExpr);

		TupleExprIRRenderer.Config cfg = new TupleExprIRRenderer.Config();
		cfg.verifyRoundTrip = true;

		assertThatCode(() -> new TupleExprIRRenderer(cfg).render(tupleExpr, null))
				.doesNotThrowAnyException();
	}

	private static void assertRoundTrip(String sparql) {
		TupleExpr original = parseTupleExpr(sparql);

		TupleExprIRRenderer.Config cfg = new TupleExprIRRenderer.Config();
		cfg.verifyRoundTrip = true;

		String rendered = new TupleExprIRRenderer(cfg).render(original, null).trim();
		TupleExpr roundTripped = parseTupleExpr(rendered);

		assertThat(VarNameNormalizer.normalizeVars(roundTripped.toString()))
				.isEqualTo(VarNameNormalizer.normalizeVars(original.toString()));

		String rendered2 = new TupleExprIRRenderer(cfg).render(roundTripped, null).trim();
		TupleExpr roundTripped2 = parseTupleExpr(rendered2);
		assertThat(VarNameNormalizer.normalizeVars(roundTripped2.toString()))
				.isEqualTo(VarNameNormalizer.normalizeVars(original.toString()));
	}

	private static TupleExpr parseTupleExpr(String sparql) {
		ParsedQuery parsedQuery = QueryParserUtil.parseQuery(QueryLanguage.SPARQL, sparql, null);
		return parsedQuery.getTupleExpr();
	}

	private static void addCostAndSizeAnnotations(TupleExpr tupleExpr) {
		tupleExpr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			protected void meetNode(QueryModelNode node) {
				node.setCostEstimate(123.45);
				node.setResultSizeEstimate(678.0);
				node.setResultSizeActual(9_101);
				super.meetNode(node);
			}
		});
	}

	private static void addJoinAlgorithmNames(TupleExpr tupleExpr) {
		tupleExpr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			protected void meetNode(QueryModelNode node) {
				if (node instanceof Join) {
					((Join) node).setAlgorithm("JoinIterator");
				} else if (node instanceof LeftJoin) {
					((LeftJoin) node).setAlgorithm("LeftJoinIterator");
				}
				super.meetNode(node);
			}
		});
	}
}
