/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.queryrender;

import static org.junit.jupiter.api.Assertions.assertNotNull;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.MalformedQueryException;
import org.eclipse.rdf4j.query.QueryLanguage;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.SparqlUoOptimizer;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.UnionScopeChangeOptimizer;
import org.eclipse.rdf4j.query.impl.EmptyBindingSet;
import org.eclipse.rdf4j.query.impl.SimpleDataset;
import org.eclipse.rdf4j.query.parser.ParsedQuery;
import org.eclipse.rdf4j.query.parser.QueryParserUtil;
import org.eclipse.rdf4j.queryrender.sparql.TupleExprIRRenderer;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

/**
 * IR diff tests for SPARQL-UO rewrites: dump raw/transformed IR, rendered SPARQL, and TupleExpr snapshots before and
 * after optimization. Artifacts are written to surefire-reports for inspection.
 */
public class SparqlUoOptimizerIrDiffTest {

	private static final Dataset DATASET = new SimpleDataset();
	private static final BindingSet BINDINGS = EmptyBindingSet.getInstance();

	private static TupleExprIRRenderer.Config cfg() {
		TupleExprIRRenderer.Config style = new TupleExprIRRenderer.Config();
		style.valuesPreserveOrder = true;
		return style;
	}

	private static TupleExpr parseAlgebra(String sparql) {
		try {
			ParsedQuery pq = QueryParserUtil.parseQuery(QueryLanguage.SPARQL, sparql, null);
			return pq.getTupleExpr();
		} catch (MalformedQueryException e) {
			throw new MalformedQueryException(
					"Failed to parse SPARQL query.\n###### QUERY ######\n" + sparql + "\n\n######################",
					e);
		}
	}

	private static void writeReportFile(String base, String label, String content) {
		Path dir = Paths.get("target", "surefire-reports");
		try {
			Files.createDirectories(dir);
			Path file = dir.resolve(base + "_" + label + ".txt");
			Files.writeString(file, content == null ? "" : content, StandardCharsets.UTF_8);
		} catch (IOException ioe) {
			System.err.println("[sparql-uo-ir] Failed to write " + label + ": " + ioe);
		}
	}

	private static void dump(String baseName, String sparql, TupleExprIRRenderer.Config style) {
		TupleExpr before = parseAlgebra(sparql);
		assertNotNull(before);
		TupleExpr after = before.clone();

		new UnionScopeChangeOptimizer().optimize(after, DATASET, BINDINGS);
		new SparqlUoOptimizer(new EvaluationStatistics(), true).optimize(after, DATASET, BINDINGS);

		TupleExprIRRenderer renderer = new TupleExprIRRenderer(style);
		writeReportFile(baseName, "SPARQL_input", sparql);
		writeReportFile(baseName, "IR_raw_before", renderer.dumpIRRaw(before));
		writeReportFile(baseName, "IR_transformed_before", renderer.dumpIRTransformed(before));
		writeReportFile(baseName, "IR_raw_after", renderer.dumpIRRaw(after));
		writeReportFile(baseName, "IR_transformed_after", renderer.dumpIRTransformed(after));
		writeReportFile(baseName, "SPARQL_rendered_before", renderer.render(before, null).trim());
		writeReportFile(baseName, "SPARQL_rendered_after", renderer.render(after, null).trim());
		writeReportFile(baseName, "TupleExpr_before", VarNameNormalizer.normalizeVars(before.toString()));
		writeReportFile(baseName, "TupleExpr_after", VarNameNormalizer.normalizeVars(after.toString()));
	}

	@Test
	@DisplayName("IR diff: UNION common-prefix pull-up")
	void irDiff_unionCommonPrefixPullUp() {
		String q = "SELECT * WHERE {\n" +
				"  { ?s <urn:p1> ?o . ?s <urn:p2> ?x }\n" +
				"  UNION\n" +
				"  { ?s <urn:p1> ?o . ?s <urn:p3> ?y }\n" +
				"}";
		dump("SparqlUo_ir_union_common_prefix", q, cfg());
	}

	@Test
	@DisplayName("IR diff: OPTIONAL-safe lifting")
	void irDiff_optionalSafeLift() {
		String q = "SELECT * WHERE {\n" +
				"  ?s <urn:p1> ?o\n" +
				"  OPTIONAL { ?s <urn:p2> ?o2 }\n" +
				"  ?s <urn:p3> ?o3\n" +
				"}";
		dump("SparqlUo_ir_optional_lift_safe", q, cfg());
	}

	@Test
	@DisplayName("IR diff: OPTIONAL lifting negative control")
	void irDiff_optionalLiftNegative() {
		String q = "SELECT * WHERE {\n" +
				"  ?s <urn:p1> ?o\n" +
				"  OPTIONAL { ?s <urn:p2> ?x }\n" +
				"  ?s <urn:p3> ?x\n" +
				"}";
		dump("SparqlUo_ir_optional_lift_negative", q, cfg());
	}
}
