/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.queryrender;

import static org.junit.jupiter.api.Assertions.assertNotNull;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Comparator;

import org.eclipse.rdf4j.common.iteration.CloseableIteration;
import org.eclipse.rdf4j.common.order.StatementOrder;
import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Resource;
import org.eclipse.rdf4j.model.Statement;
import org.eclipse.rdf4j.model.Value;
import org.eclipse.rdf4j.model.ValueFactory;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.MalformedQueryException;
import org.eclipse.rdf4j.query.QueryEvaluationException;
import org.eclipse.rdf4j.query.QueryLanguage;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.evaluation.TripleSource;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.DefaultEvaluationStrategy;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.SparqlUoQueryOptimizerPipeline;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.sparqluo.SparqlUoConfig;
import org.eclipse.rdf4j.query.impl.EmptyBindingSet;
import org.eclipse.rdf4j.query.impl.SimpleDataset;
import org.eclipse.rdf4j.query.parser.ParsedQuery;
import org.eclipse.rdf4j.query.parser.QueryParserUtil;
import org.eclipse.rdf4j.queryrender.sparql.TupleExprIRRenderer;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

/**
 * IR diff tests for SPARQL-UO rewrites: dump raw/transformed IR, rendered SPARQL, and TupleExpr snapshots before and
 * after optimization. Artifacts are written to surefire-reports for inspection.
 */
public class SparqlUoOptimizerIrDiffTest {

	private static final Dataset DATASET = new SimpleDataset();
	private static final BindingSet BINDINGS = EmptyBindingSet.getInstance();

	private static TupleExprIRRenderer.Config cfg() {
		TupleExprIRRenderer.Config style = new TupleExprIRRenderer.Config();
		style.valuesPreserveOrder = true;
		return style;
	}

	private static TupleExpr parseAlgebra(String sparql) {
		try {
			ParsedQuery pq = QueryParserUtil.parseQuery(QueryLanguage.SPARQL, sparql, null);
			return pq.getTupleExpr();
		} catch (MalformedQueryException e) {
			throw new MalformedQueryException(
					"Failed to parse SPARQL query.\n###### QUERY ######\n" + sparql + "\n\n######################",
					e);
		}
	}

	private static void writeReportFile(String base, String label, String content) {
		Path dir = Paths.get("target", "surefire-reports");
		try {
			Files.createDirectories(dir);
			Path file = dir.resolve(base + "_" + label + ".txt");
			Files.writeString(file, content == null ? "" : content, StandardCharsets.UTF_8);
		} catch (IOException ioe) {
			System.err.println("[sparql-uo-ir] Failed to write " + label + ": " + ioe);
		}
	}

	private static void dump(String baseName, String sparql, TupleExprIRRenderer.Config style) {
		TupleExpr before = parseAlgebra(sparql);
		assertNotNull(before);
		TupleExpr after = before.clone();

		optimizeWithPipeline(after);

		TupleExprIRRenderer renderer = new TupleExprIRRenderer(style);
		writeReportFile(baseName, "SPARQL_input", sparql);
		writeReportFile(baseName, "IR_raw_before", renderer.dumpIRRaw(before));
		writeReportFile(baseName, "IR_transformed_before", renderer.dumpIRTransformed(before));
		writeReportFile(baseName, "IR_raw_after", renderer.dumpIRRaw(after));
		writeReportFile(baseName, "IR_transformed_after", renderer.dumpIRTransformed(after));
		writeReportFile(baseName, "SPARQL_rendered_before", renderer.render(before, null).trim());
		writeReportFile(baseName, "SPARQL_rendered_after", renderer.render(after, null).trim());
		writeReportFile(baseName, "TupleExpr_before", VarNameNormalizer.normalizeVars(before.toString()));
		writeReportFile(baseName, "TupleExpr_after", VarNameNormalizer.normalizeVars(after.toString()));
	}

	private static void optimizeWithPipeline(TupleExpr expr) {
		EmptyTripleSource tripleSource = new EmptyTripleSource();
		EvaluationStatistics evaluationStatistics = new EvaluationStatistics();
		DefaultEvaluationStrategy strategy = new DefaultEvaluationStrategy(tripleSource, null, null, 0L,
				evaluationStatistics);
		SparqlUoConfig config = SparqlUoConfig.builder().allowNonImprovingTransforms(true).build();
		strategy.setOptimizerPipeline(
				new SparqlUoQueryOptimizerPipeline(strategy, tripleSource, evaluationStatistics, config));
		strategy.optimize(expr, evaluationStatistics, BINDINGS);
	}

	@Test
	@DisplayName("IR diff: UNION common-prefix pull-up")
	void irDiff_unionCommonPrefixPullUp() {
		String q = "SELECT * WHERE {\n" +
				"  { ?s <urn:p1> ?o . ?s <urn:p2> ?x }\n" +
				"  UNION\n" +
				"  { ?s <urn:p1> ?o . ?s <urn:p3> ?y }\n" +
				"}";
		dump("SparqlUo_ir_union_common_prefix", q, cfg());
	}

	@Test
	@DisplayName("IR diff: UNION common-filter hoist")
	void irDiff_unionCommonFilterHoist() {
		String q = "SELECT * WHERE {\n" +
				"  { ?s <urn:p1> ?name . FILTER(?name != \"\") FILTER(?name != \"x\") }\n" +
				"  UNION\n" +
				"  { ?s <urn:p2> ?name . FILTER(?name != \"x\") FILTER(?name != \"\") }\n" +
				"}";
		dump("SparqlUo_ir_union_filter_hoist", q, cfg());
	}

	@Test
	@DisplayName("IR diff: OPTIONAL-safe lifting")
	void irDiff_optionalSafeLift() {
		String q = "SELECT * WHERE {\n" +
				"  ?s <urn:p1> ?o\n" +
				"  OPTIONAL { ?s <urn:p2> ?o2 }\n" +
				"  ?s <urn:p3> ?o3\n" +
				"}";
		dump("SparqlUo_ir_optional_lift_safe", q, cfg());
	}

	@Test
	@DisplayName("IR diff: OPTIONAL lifting negative control")
	void irDiff_optionalLiftNegative() {
		String q = "SELECT * WHERE {\n" +
				"  ?s <urn:p1> ?o\n" +
				"  OPTIONAL { ?s <urn:p2> ?x }\n" +
				"  ?s <urn:p3> ?x\n" +
				"}";
		dump("SparqlUo_ir_optional_lift_negative", q, cfg());
	}

	@Test
	@DisplayName("IR diff: MINUS UNION split")
	void irDiff_minusUnionSplit() {
		String q = "SELECT * WHERE {\n" +
				"  ?s <urn:p1> ?o\n" +
				"  MINUS { { ?s <urn:p2> ?o2 } UNION { ?s <urn:p3> ?o3 } }\n" +
				"}";
		dump("SparqlUo_ir_minus_union_split", q, cfg());
	}

	private static final class EmptyTripleSource implements TripleSource {
		private final ValueFactory vf = SimpleValueFactory.getInstance();

		@Override
		public ValueFactory getValueFactory() {
			return vf;
		}

		@Override
		public CloseableIteration<? extends Statement> getStatements(Resource subj, IRI pred, Value obj,
				Resource... contexts) throws QueryEvaluationException {
			return TripleSource.EMPTY_ITERATION;
		}

		@Override
		public CloseableIteration<? extends Statement> getStatements(StatementOrder order, Resource subj, IRI pred,
				Value obj, Resource... contexts) throws QueryEvaluationException {
			return TripleSource.EMPTY_ITERATION;
		}

		@Override
		public Comparator<Value> getComparator() {
			return null;
		}
	}
}
