/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.sail.nativerdf;

import static org.assertj.core.api.Assertions.assertThat;

import java.io.IOException;
import java.lang.reflect.Field;
import java.nio.ByteBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.nio.channels.ReadableByteChannel;
import java.nio.channels.WritableByteChannel;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.EnumSet;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

class MemoryMappedTxnStatusFileFsyncTest {

	private static final String DISABLE_SHUTDOWN_FSYNC_PROP = "org.eclipse.rdf4j.sail.nativerdf.disableShutdownFsync";

	@TempDir
	Path tempDir;

	@AfterEach
	void tearDown() {
		System.clearProperty(DISABLE_SHUTDOWN_FSYNC_PROP);
		MemoryMappedTxnStatusFile.ALWAYS_FORCE_SYNC = true; // reset static to default
	}

	@Test
	void closeSkipsForceWhenShutdownFsyncDisabled() throws Exception {
		System.setProperty(DISABLE_SHUTDOWN_FSYNC_PROP, "true");

		MemoryMappedTxnStatusFile file = new MemoryMappedTxnStatusFile(tempDir.toFile());
		TrackingFileChannel tracking = injectTrackingChannel(file);
		tracking.reset();

		file.close();

		assertThat(tracking.forceTrueCount).isZero();
		assertThat(tracking.forceFalseCount).isZero();
	}

	private static TrackingFileChannel injectTrackingChannel(MemoryMappedTxnStatusFile file) throws Exception {
		Field channelField = MemoryMappedTxnStatusFile.class.getDeclaredField("channel");
		channelField.setAccessible(true);
		FileChannel delegate = (FileChannel) channelField.get(file);

		TrackingFileChannel tracking = new TrackingFileChannel(delegate);
		channelField.set(file, tracking);
		return tracking;
	}

	private static final class TrackingFileChannel extends FileChannel {
		private final FileChannel delegate;
		volatile int forceTrueCount;
		volatile int forceFalseCount;

		TrackingFileChannel(FileChannel delegate) {
			this.delegate = delegate;
		}

		void reset() {
			forceTrueCount = 0;
			forceFalseCount = 0;
		}

		@Override
		public void force(boolean metaData) throws IOException {
			if (metaData) {
				forceTrueCount++;
			} else {
				forceFalseCount++;
			}
			delegate.force(metaData);
		}

		@Override
		public int read(ByteBuffer dst) throws IOException {
			return delegate.read(dst);
		}

		@Override
		public long read(ByteBuffer[] dsts, int offset, int length) throws IOException {
			return delegate.read(dsts, offset, length);
		}

		@Override
		public int write(ByteBuffer src) throws IOException {
			return delegate.write(src);
		}

		@Override
		public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {
			return delegate.write(srcs, offset, length);
		}

		@Override
		public long position() throws IOException {
			return delegate.position();
		}

		@Override
		public FileChannel position(long newPosition) throws IOException {
			delegate.position(newPosition);
			return this;
		}

		@Override
		public long size() throws IOException {
			return delegate.size();
		}

		@Override
		public FileChannel truncate(long size) throws IOException {
			delegate.truncate(size);
			return this;
		}

		@Override
		public void implCloseChannel() throws IOException {
			delegate.close();
		}

		@Override
		public int read(ByteBuffer dst, long position) throws IOException {
			return delegate.read(dst, position);
		}

		@Override
		public int write(ByteBuffer src, long position) throws IOException {
			return delegate.write(src, position);
		}

		@Override
		public long transferTo(long position, long count, WritableByteChannel target) throws IOException {
			return delegate.transferTo(position, count, target);
		}

		@Override
		public long transferFrom(ReadableByteChannel src, long position, long count) throws IOException {
			return delegate.transferFrom(src, position, count);
		}

		@Override
		public FileLock lock(long position, long size, boolean shared) throws IOException {
			return delegate.lock(position, size, shared);
		}

		@Override
		public FileLock tryLock(long position, long size, boolean shared) throws IOException {
			return delegate.tryLock(position, size, shared);
		}

		@Override
		public MappedByteBuffer map(MapMode mode, long position, long size) throws IOException {
			return delegate.map(mode, position, size);
		}
	}
}
