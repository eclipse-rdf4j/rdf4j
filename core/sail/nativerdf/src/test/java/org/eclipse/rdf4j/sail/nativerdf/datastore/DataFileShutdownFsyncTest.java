/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.sail.nativerdf.datastore;

import static org.assertj.core.api.Assertions.assertThat;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Field;
import java.nio.ByteBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.nio.channels.ReadableByteChannel;
import java.nio.channels.WritableByteChannel;

import org.eclipse.rdf4j.common.io.NioFile;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

class DataFileShutdownFsyncTest {

	private static final String DISABLE_SHUTDOWN_FSYNC_PROP = "org.eclipse.rdf4j.sail.nativerdf.disableShutdownFsync";

	@TempDir
	File tempDir;

	@AfterEach
	void tearDown() {
		System.clearProperty(DISABLE_SHUTDOWN_FSYNC_PROP);
	}

	@Test
	void closeSkipsForceWhenShutdownFsyncDisabled() throws Exception {
		System.setProperty(DISABLE_SHUTDOWN_FSYNC_PROP, "true");

		File target = new File(tempDir, "values.dat");
		TrackingFileChannel tracking;
		try (DataFile df = new DataFile(target, /* forceSync= */ false)) {
			tracking = injectTrackingChannel(df);
			tracking.reset();
			df.storeData("abc".getBytes());
		}

		assertThat(tracking.forceTrueCount)
				.as("DataFile.close should not force metadata when shutdown fsync is disabled")
				.isZero();
		assertThat(tracking.forceFalseCount)
				.as("DataFile.close should not force content when shutdown fsync is disabled")
				.isZero();
	}

	private static TrackingFileChannel injectTrackingChannel(DataFile df) throws Exception {
		Field nioFileField = DataFile.class.getDeclaredField("nioFile");
		nioFileField.setAccessible(true);
		NioFile nio = (NioFile) nioFileField.get(df);

		Field fcField = NioFile.class.getDeclaredField("fc");
		fcField.setAccessible(true);
		FileChannel delegate = (FileChannel) fcField.get(nio);

		TrackingFileChannel tracking = new TrackingFileChannel(delegate);
		fcField.set(nio, tracking);
		return tracking;
	}

	private static final class TrackingFileChannel extends FileChannel {
		private final FileChannel delegate;
		volatile int forceTrueCount;
		volatile int forceFalseCount;

		TrackingFileChannel(FileChannel delegate) {
			this.delegate = delegate;
		}

		void reset() {
			forceTrueCount = 0;
			forceFalseCount = 0;
		}

		@Override
		public void force(boolean metaData) throws IOException {
			if (metaData) {
				forceTrueCount++;
			} else {
				forceFalseCount++;
			}
			delegate.force(metaData);
		}

		@Override
		public int read(ByteBuffer dst) throws IOException {
			return delegate.read(dst);
		}

		@Override
		public long read(ByteBuffer[] dsts, int offset, int length) throws IOException {
			return delegate.read(dsts, offset, length);
		}

		@Override
		public int write(ByteBuffer src) throws IOException {
			return delegate.write(src);
		}

		@Override
		public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {
			return delegate.write(srcs, offset, length);
		}

		@Override
		public long position() throws IOException {
			return delegate.position();
		}

		@Override
		public FileChannel position(long newPosition) throws IOException {
			delegate.position(newPosition);
			return this;
		}

		@Override
		public long size() throws IOException {
			return delegate.size();
		}

		@Override
		public FileChannel truncate(long size) throws IOException {
			delegate.truncate(size);
			return this;
		}

		@Override
		protected void implCloseChannel() throws IOException {
			delegate.close();
		}

		@Override
		public int read(ByteBuffer dst, long position) throws IOException {
			return delegate.read(dst, position);
		}

		@Override
		public int write(ByteBuffer src, long position) throws IOException {
			return delegate.write(src, position);
		}

		@Override
		public long transferTo(long position, long count, WritableByteChannel target) throws IOException {
			return delegate.transferTo(position, count, target);
		}

		@Override
		public long transferFrom(ReadableByteChannel src, long position, long count) throws IOException {
			return delegate.transferFrom(src, position, count);
		}

		@Override
		public FileLock lock(long position, long size, boolean shared) throws IOException {
			return delegate.lock(position, size, shared);
		}

		@Override
		public FileLock tryLock(long position, long size, boolean shared) throws IOException {
			return delegate.tryLock(position, size, shared);
		}

		@Override
		public MappedByteBuffer map(MapMode mode, long position, long size) throws IOException {
			return delegate.map(mode, position, size);
		}
	}
}
