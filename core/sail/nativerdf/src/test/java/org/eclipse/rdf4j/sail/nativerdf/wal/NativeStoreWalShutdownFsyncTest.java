/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.sail.nativerdf.wal;

import static org.assertj.core.api.Assertions.assertThat;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.nio.channels.ReadableByteChannel;
import java.nio.channels.WritableByteChannel;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.eclipse.rdf4j.model.ValueFactory;
import org.eclipse.rdf4j.sail.NotifyingSailConnection;
import org.eclipse.rdf4j.sail.nativerdf.NativeStore;
import org.eclipse.rdf4j.sail.nativerdf.wal.ValueStoreWalConfig;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

class NativeStoreWalShutdownFsyncTest {

	private static final String DISABLE_SHUTDOWN_FSYNC_PROP = "org.eclipse.rdf4j.sail.nativerdf.disableShutdownFsync";

	@TempDir
	Path tempDir;

	@AfterEach
	void resetChannelOpener() {
		ValueStoreWAL.resetChannelOpenerForTesting();
		System.clearProperty(DISABLE_SHUTDOWN_FSYNC_PROP);
	}

	@Test
	void shutdownForcesWalWithMetadataEvenWhenSyncDisabled() throws Exception {
		List<ForceCall> forces = Collections.synchronizedList(new ArrayList<>());
		ValueStoreWAL.setChannelOpenerForTesting(
				(path, options) -> new ForceTrackingFileChannel(FileChannel.open(path, options), path, forces));

		NativeStore store = new NativeStore(tempDir.toFile());
		store.setWalSyncPolicy(ValueStoreWalConfig.SyncPolicy.INTERVAL); // disable fsync during normal operation
		store.init();

		try (NotifyingSailConnection conn = store.getConnection()) {
			ValueFactory vf = store.getValueFactory();
			conn.begin();
			conn.addStatement(vf.createIRI("urn:s"), vf.createIRI("urn:p"), vf.createLiteral("o"));
			conn.commit();
		} finally {
			store.shutDown();
		}

		assertThat(forces)
				.as("NativeStore.shutdown should fsync WAL with metadata even when WAL fsync is otherwise disabled")
				.anySatisfy(call -> {
					assertThat(call.metaData).isTrue();
					assertThat(call.path.getFileName().toString()).startsWith("wal-");
				});
	}

	@Test
	void shutdownFsyncCanBeDisabledViaProperty() throws Exception {
		System.setProperty(DISABLE_SHUTDOWN_FSYNC_PROP, "true");

		List<ForceCall> forces = Collections.synchronizedList(new ArrayList<>());
		ValueStoreWAL.setChannelOpenerForTesting(
				(path, options) -> new ForceTrackingFileChannel(FileChannel.open(path, options), path, forces));

		NativeStore store = new NativeStore(tempDir.toFile());
		store.setWalSyncPolicy(ValueStoreWalConfig.SyncPolicy.INTERVAL);
		store.init();

		try (NotifyingSailConnection conn = store.getConnection()) {
			ValueFactory vf = store.getValueFactory();
			conn.begin();
			conn.addStatement(vf.createIRI("urn:s"), vf.createIRI("urn:p"), vf.createLiteral("o"));
			conn.commit();
		} finally {
			store.shutDown();
		}

		assertThat(forces)
				.as("When system property disables shutdown fsync, WAL close must not force metadata")
				.isEmpty();
	}

	private static final class ForceCall {
		final Path path;
		final boolean metaData;

		private ForceCall(Path path, boolean metaData) {
			this.path = path;
			this.metaData = metaData;
		}
	}

	private static final class ForceTrackingFileChannel extends FileChannel {
		private final FileChannel delegate;
		private final Path path;
		private final List<ForceCall> forces;

		private ForceTrackingFileChannel(FileChannel delegate, Path path, List<ForceCall> forces) {
			this.delegate = delegate;
			this.path = path;
			this.forces = forces;
		}

		@Override
		public int read(ByteBuffer dst) throws IOException {
			return delegate.read(dst);
		}

		@Override
		public long read(ByteBuffer[] dsts, int offset, int length) throws IOException {
			return delegate.read(dsts, offset, length);
		}

		@Override
		public int write(ByteBuffer src) throws IOException {
			return delegate.write(src);
		}

		@Override
		public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {
			return delegate.write(srcs, offset, length);
		}

		@Override
		public long position() throws IOException {
			return delegate.position();
		}

		@Override
		public FileChannel position(long newPosition) throws IOException {
			delegate.position(newPosition);
			return this;
		}

		@Override
		public long size() throws IOException {
			return delegate.size();
		}

		@Override
		public FileChannel truncate(long size) throws IOException {
			delegate.truncate(size);
			return this;
		}

		@Override
		public void force(boolean metaData) throws IOException {
			forces.add(new ForceCall(path, metaData));
			delegate.force(metaData);
		}

		@Override
		public long transferTo(long position, long count, WritableByteChannel target) throws IOException {
			return delegate.transferTo(position, count, target);
		}

		@Override
		public long transferFrom(ReadableByteChannel src, long position, long count) throws IOException {
			return delegate.transferFrom(src, position, count);
		}

		@Override
		public int read(ByteBuffer dst, long position) throws IOException {
			return delegate.read(dst, position);
		}

		@Override
		public int write(ByteBuffer src, long position) throws IOException {
			return delegate.write(src, position);
		}

		@Override
		protected void implCloseChannel() throws IOException {
			delegate.close();
		}

		@Override
		public FileLock lock(long position, long size, boolean shared) throws IOException {
			return delegate.lock(position, size, shared);
		}

		@Override
		public FileLock tryLock(long position, long size, boolean shared) throws IOException {
			return delegate.tryLock(position, size, shared);
		}

		@Override
		public MappedByteBuffer map(MapMode mode, long position, long size) throws IOException {
			return delegate.map(mode, position, size);
		}
	}
}
