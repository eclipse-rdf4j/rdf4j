/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.sail.nativerdf;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.fail;

import java.io.File;
import java.lang.reflect.Method;

import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.ValueFactory;
import org.eclipse.rdf4j.query.TupleQuery;
import org.eclipse.rdf4j.query.TupleQueryResult;
import org.eclipse.rdf4j.query.algebra.evaluation.EvaluationStrategyFactory;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.repository.Repository;
import org.eclipse.rdf4j.repository.RepositoryConnection;
import org.eclipse.rdf4j.repository.sail.SailRepository;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

public class LearningJoinOptimizerTest {

	private static final String FACTORY_CLASS = "org.eclipse.rdf4j.query.algebra.evaluation.impl.LearningEvaluationStrategyFactory";

	@TempDir
	public File dataDir;

	@Test
	public void learnsJoinOrderAcrossRuns() throws Exception {
		EvaluationStrategyFactory factory = newLearningFactory();
		NativeStore store = new NativeStore(dataDir);
		store.setEvaluationStrategyFactory(factory);
		Repository repo = new SailRepository(store);
		repo.init();

		try (RepositoryConnection conn = repo.getConnection()) {
			ValueFactory vf = conn.getValueFactory();
			IRI highPred = vf.createIRI("http://example.org/highCardPred");
			IRI lowPred = vf.createIRI("http://example.org/lowCardPred");
			String hotValue = "hot";

			for (int i = 1; i <= 1000; i++) {
				IRI subj = vf.createIRI("http://example.org/Subject" + i);
				conn.add(subj, highPred, vf.createLiteral(hotValue));
				if (i <= 10) {
					conn.add(subj, lowPred, vf.createLiteral("lowVal" + i));
				}
			}

			String query = "SELECT ?s ?v2 WHERE { "
					+ "?s <http://example.org/highCardPred> \"hot\" . "
					+ "?s <http://example.org/lowCardPred> ?v2 . "
					+ "}";

			long callsBefore = getTotalCalls(factory);
			int resultsFirst = runQuery(conn, query);
			long callsAfterFirst = getTotalCalls(factory);
			long callsFirst = callsAfterFirst - callsBefore;

			int resultsSecond = runQuery(conn, query);
			long callsAfterSecond = getTotalCalls(factory);
			long callsSecond = callsAfterSecond - callsAfterFirst;

			assertEquals(10, resultsFirst);
			assertEquals(10, resultsSecond);
			assertEquals(1001L, callsFirst);
			assertEquals(11L, callsSecond);
		} finally {
			repo.shutDown();
		}
	}

	private static int runQuery(RepositoryConnection conn, String query) {
		TupleQuery tupleQuery = conn.prepareTupleQuery(query);
		int count = 0;
		try (TupleQueryResult result = tupleQuery.evaluate()) {
			while (result.hasNext()) {
				result.next();
				count++;
			}
		}
		return count;
	}

	private static EvaluationStrategyFactory newLearningFactory() {
		try {
			Class<?> clazz = Class.forName(FACTORY_CLASS);
			return (EvaluationStrategyFactory) clazz.getDeclaredConstructor(EvaluationStatistics.class)
					.newInstance(new EvaluationStatistics());
		} catch (ClassNotFoundException e) {
			fail("Missing LearningEvaluationStrategyFactory. Implement " + FACTORY_CLASS);
		} catch (ReflectiveOperationException e) {
			fail("Failed to instantiate LearningEvaluationStrategyFactory: " + e.getMessage());
		}
		return null;
	}

	private static long getTotalCalls(EvaluationStrategyFactory factory) {
		try {
			Method getStatsProvider = factory.getClass().getMethod("getStatsProvider");
			Object statsProvider = getStatsProvider.invoke(factory);
			Method getTotalCalls = statsProvider.getClass().getMethod("getTotalCalls");
			Object total = getTotalCalls.invoke(statsProvider);
			return ((Number) total).longValue();
		} catch (ReflectiveOperationException e) {
			fail("Failed to read stats provider totals: " + e.getMessage());
		}
		return -1;
	}
}
