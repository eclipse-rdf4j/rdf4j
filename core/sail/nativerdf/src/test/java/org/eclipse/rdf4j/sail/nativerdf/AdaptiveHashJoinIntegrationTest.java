/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.sail.nativerdf;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.io.File;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.ValueFactory;
import org.eclipse.rdf4j.query.TupleQuery;
import org.eclipse.rdf4j.query.TupleQueryResult;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.LearningEvaluationStrategyFactory;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.JoinStatsProvider;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.PatternKey;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned.LearnedJoinConfig;
import org.eclipse.rdf4j.repository.Repository;
import org.eclipse.rdf4j.repository.RepositoryConnection;
import org.eclipse.rdf4j.repository.sail.SailRepository;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

class AdaptiveHashJoinIntegrationTest {

	private static final int ROWS = 1000;

	@TempDir
	public File dataDir;

	@Test
	void adaptiveHashJoinAvoidsBoundInnerLookups() {
		File nestedDir = new File(dataDir, "nested");
		File adaptiveDir = new File(dataDir, "adaptive");

		CountingJoinStats nestedStats = new CountingJoinStats();
		CountingJoinStats adaptiveStats = new CountingJoinStats();

		long nestedBoundCalls = runQueryWithConfig(nestedDir, nestedStats, newConfig(false));
		long adaptiveBoundCalls = runQueryWithConfig(adaptiveDir, adaptiveStats, newConfig(true));

		assertEquals(ROWS, nestedBoundCalls);
		assertEquals(0L, adaptiveBoundCalls);
		assertTrue(adaptiveBoundCalls < nestedBoundCalls);
	}

	private long runQueryWithConfig(File dir, CountingJoinStats statsProvider, LearnedJoinConfig config) {
		LearningEvaluationStrategyFactory factory = new LearningEvaluationStrategyFactory(statsProvider, null, config);
		NativeStore store = new NativeStore(dir);
		store.setEvaluationStrategyFactory(factory);
		Repository repo = new SailRepository(store);
		repo.init();

		try (RepositoryConnection conn = repo.getConnection()) {
			ValueFactory vf = conn.getValueFactory();
			IRI predA = vf.createIRI("http://example.org/aPred");
			IRI predB = vf.createIRI("http://example.org/bPred");
			loadData(conn, vf, predA, predB);

			String query = "SELECT ?x ?y WHERE { "
					+ "?x <http://example.org/aPred> \"hot\" . "
					+ "?x <http://example.org/bPred> ?y . "
					+ "}";

			int results = runQuery(conn, query);
			assertEquals(ROWS, results);

			return statsProvider.getBoundSubjectCalls(predA, predB);
		} finally {
			repo.shutDown();
		}
	}

	private static int runQuery(RepositoryConnection conn, String query) {
		TupleQuery tupleQuery = conn.prepareTupleQuery(query);
		int count = 0;
		try (TupleQueryResult result = tupleQuery.evaluate()) {
			while (result.hasNext()) {
				result.next();
				count++;
			}
		}
		return count;
	}

	private static void loadData(RepositoryConnection conn, ValueFactory vf, IRI predA, IRI predB) {
		for (int i = 1; i <= ROWS; i++) {
			IRI subj = vf.createIRI("http://example.org/x" + i);
			conn.add(subj, predA, vf.createLiteral("hot"));
			conn.add(subj, predB, vf.createLiteral("y" + i));
		}
	}

	private static LearnedJoinConfig newConfig(boolean enableAdaptiveHashJoin) {
		return new LearnedJoinConfig(
				LearnedJoinConfig.DEFAULT_DP_THRESHOLD,
				true,
				true,
				false,
				LearnedJoinConfig.DEFAULT_RUNTIME_SAMPLING_MAX_OPERANDS,
				LearnedJoinConfig.DEFAULT_RUNTIME_SAMPLING_MAX_STATEMENTS,
				enableAdaptiveHashJoin,
				5,
				10_000L);
	}

	private static final class CountingJoinStats implements JoinStatsProvider {

		private final Map<PatternKey, AtomicLong> calls = new ConcurrentHashMap<>();

		long getBoundSubjectCalls(IRI predA, IRI predB) {
			int predAUnboundMask = PatternKey.PREDICATE_BOUND | PatternKey.OBJECT_BOUND;
			int predABoundMask = PatternKey.SUBJECT_BOUND | predAUnboundMask;
			int predBBoundMask = PatternKey.SUBJECT_BOUND | PatternKey.PREDICATE_BOUND;

			long predABound = countCalls(new PatternKey(predA, predABoundMask));
			long predBBound = countCalls(new PatternKey(predB, predBBoundMask));

			return predABound + predBBound;
		}

		private long countCalls(PatternKey key) {
			AtomicLong counter = calls.get(key);
			return counter == null ? 0L : counter.get();
		}

		@Override
		public void reset() {
			calls.clear();
		}

		@Override
		public void recordCall(PatternKey key) {
			calls.computeIfAbsent(key, ignored -> new AtomicLong()).incrementAndGet();
		}

		@Override
		public void recordResults(PatternKey key, long resultCount) {
			// ignore
		}

		@Override
		public void seedIfAbsent(PatternKey key, double defaultCardinality, long priorCalls) {
			// ignore
		}

		@Override
		public double getAverageResults(PatternKey key) {
			return 0.0d;
		}

		@Override
		public boolean hasStats(PatternKey key) {
			return false;
		}

		@Override
		public long getTotalCalls() {
			return calls.values().stream().mapToLong(AtomicLong::get).sum();
		}
	}
}
