/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.sail.nativerdf;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.io.File;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicLong;

import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.ValueFactory;
import org.eclipse.rdf4j.query.TupleQuery;
import org.eclipse.rdf4j.query.TupleQueryResult;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.LearningEvaluationStrategyFactory;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.JoinStatsProvider;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.PatternKey;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned.LearnedJoinConfig;
import org.eclipse.rdf4j.repository.Repository;
import org.eclipse.rdf4j.repository.RepositoryConnection;
import org.eclipse.rdf4j.repository.sail.SailRepository;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

class DpJoinOrderingIntegrationTest {

	@TempDir
	public File dataDir;

	@Test
	void dpPlannerReducesTripleSourceCalls() {
		File greedyDir = new File(dataDir, "greedy");
		File dpDir = new File(dataDir, "dp");

		FixedJoinStats greedyStats = FixedJoinStats.forDefaults();
		FixedJoinStats dpStats = FixedJoinStats.forDefaults();

		long greedyCalls = runQueryWithConfig(greedyDir, greedyStats, newConfig(false));
		long dpCalls = runQueryWithConfig(dpDir, dpStats, newConfig(true));

		assertEquals(1101L, greedyCalls);
		assertEquals(111L, dpCalls);
		assertTrue(dpCalls < greedyCalls);
	}

	private long runQueryWithConfig(File dir, FixedJoinStats statsProvider, LearnedJoinConfig config) {
		LearningEvaluationStrategyFactory factory = new LearningEvaluationStrategyFactory(statsProvider, null, config);
		NativeStore store = new NativeStore(dir);
		store.setEvaluationStrategyFactory(factory);
		Repository repo = new SailRepository(store);
		repo.init();

		try (RepositoryConnection conn = repo.getConnection()) {
			ValueFactory vf = conn.getValueFactory();
			IRI predA = vf.createIRI("http://example.org/aPred");
			IRI predB = vf.createIRI("http://example.org/bPred");
			IRI predC = vf.createIRI("http://example.org/cPred");
			loadData(conn, vf, predA, predB, predC);

			statsProvider.configure(predA, predB, predC);

			String query = "SELECT ?x ?y WHERE { "
					+ "?x <http://example.org/aPred> \"hot\" . "
					+ "?x <http://example.org/bPred> ?y . "
					+ "?y <http://example.org/cPred> \"cold\" . "
					+ "}";

			long callsBefore = statsProvider.getTotalCalls();
			int results = runQuery(conn, query);
			long callsAfter = statsProvider.getTotalCalls();

			assertEquals(10, results);
			return callsAfter - callsBefore;
		} finally {
			repo.shutDown();
		}
	}

	private static int runQuery(RepositoryConnection conn, String query) {
		TupleQuery tupleQuery = conn.prepareTupleQuery(query);
		int count = 0;
		try (TupleQueryResult result = tupleQuery.evaluate()) {
			while (result.hasNext()) {
				result.next();
				count++;
			}
		}
		return count;
	}

	private static void loadData(RepositoryConnection conn, ValueFactory vf, IRI predA, IRI predB, IRI predC) {
		for (int i = 1; i <= 1000; i++) {
			IRI subj = vf.createIRI("http://example.org/x" + i);
			conn.add(subj, predA, vf.createLiteral("hot"));
			if (i <= 100) {
				IRI obj = vf.createIRI("http://example.org/y" + i);
				conn.add(subj, predB, obj);
				if (i <= 10) {
					conn.add(obj, predC, vf.createLiteral("cold"));
				}
			}
		}
	}

	private static LearnedJoinConfig newConfig(boolean enableDp) {
		return new LearnedJoinConfig(
				LearnedJoinConfig.DEFAULT_DP_THRESHOLD,
				enableDp,
				true,
				false,
				LearnedJoinConfig.DEFAULT_RUNTIME_SAMPLING_MAX_OPERANDS,
				LearnedJoinConfig.DEFAULT_RUNTIME_SAMPLING_MAX_STATEMENTS,
				false,
				LearnedJoinConfig.DEFAULT_ADAPTIVE_NESTED_LOOP_THRESHOLD,
				LearnedJoinConfig.DEFAULT_HASH_JOIN_MAX_BUILD_ROWS);
	}

	private static final class FixedJoinStats implements JoinStatsProvider {

		private final AtomicLong totalCalls = new AtomicLong();
		private volatile Map<PatternKey, Double> averages;

		static FixedJoinStats forDefaults() {
			FixedJoinStats stats = new FixedJoinStats();
			stats.averages = Map.of();
			return stats;
		}

		void configure(IRI predA, IRI predB, IRI predC) {
			Objects.requireNonNull(predA, "predA");
			Objects.requireNonNull(predB, "predB");
			Objects.requireNonNull(predC, "predC");
			averages = Map.of(
					new PatternKey(predA, PatternKey.PREDICATE_BOUND | PatternKey.OBJECT_BOUND), 1.0d,
					new PatternKey(predA,
							PatternKey.SUBJECT_BOUND | PatternKey.PREDICATE_BOUND | PatternKey.OBJECT_BOUND),
					0.1d,
					new PatternKey(predB, PatternKey.PREDICATE_BOUND), 100.0d,
					new PatternKey(predB, PatternKey.SUBJECT_BOUND | PatternKey.PREDICATE_BOUND), 1000.0d,
					new PatternKey(predB, PatternKey.PREDICATE_BOUND | PatternKey.OBJECT_BOUND), 1000.0d,
					new PatternKey(predC, PatternKey.PREDICATE_BOUND | PatternKey.OBJECT_BOUND), 1000.0d,
					new PatternKey(predC,
							PatternKey.SUBJECT_BOUND | PatternKey.PREDICATE_BOUND | PatternKey.OBJECT_BOUND),
					1.0d);
		}

		@Override
		public void reset() {
			averages = Map.of();
			totalCalls.set(0);
		}

		@Override
		public void recordCall(PatternKey key) {
			totalCalls.incrementAndGet();
		}

		@Override
		public void recordResults(PatternKey key, long resultCount) {
			// ignore to keep averages fixed
		}

		@Override
		public void seedIfAbsent(PatternKey key, double defaultCardinality, long priorCalls) {
			// ignore to keep averages fixed
		}

		@Override
		public double getAverageResults(PatternKey key) {
			Double value = averages.get(key);
			return value == null ? 0.0d : value;
		}

		@Override
		public boolean hasStats(PatternKey key) {
			return averages.containsKey(key);
		}

		@Override
		public long getTotalCalls() {
			return totalCalls.get();
		}
	}
}
