/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.sail.lmdb.estimate;

import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.eclipse.rdf4j.sail.lmdb.util.GroupMatcher;

public final class LmdbPageCardinalityEstimator implements Closeable {

	private final LmdbDataFile dataFile;
	private volatile SnapshotCache lastSnapshot;

	public LmdbPageCardinalityEstimator(File dataMdbFile) throws IOException {
		this.dataFile = new LmdbDataFile(dataMdbFile);
	}

	public long estimateEntries(long txnId, String dbName, byte[] minKey, int minKeyLength, byte[] maxKey,
			int maxKeyLength,
			GroupMatcher matcher) throws IOException {
		SnapshotCache snapshot = snapshot(txnId);
		LmdbDb db = namedDb(snapshot, dbName);
		if (db == null || db.isEmpty()) {
			return 0;
		}

		LmdbBtreeRangeCounter counter = new LmdbBtreeRangeCounter(dataFile, snapshot.meta);
		RangeCountResult result = counter.countRange(db, minKey, minKeyLength, maxKey, maxKeyLength, matcher);
		return result.entries;
	}

	public long totalEntries(long txnId, String dbName) throws IOException {
		SnapshotCache snapshot = snapshot(txnId);
		LmdbDb db = namedDb(snapshot, dbName);
		return db == null ? 0 : db.entries;
	}

	@Override
	public void close() throws IOException {
		dataFile.close();
	}

	private SnapshotCache snapshot(long txnId) throws IOException {
		SnapshotCache cached = lastSnapshot;
		if (cached != null && cached.txnId == txnId) {
			return cached;
		}
		LmdbMeta meta = dataFile.readMetaForTxn(txnId);
		SnapshotCache refreshed = new SnapshotCache(txnId, meta);
		lastSnapshot = refreshed;
		return refreshed;
	}

	private LmdbDb namedDb(SnapshotCache snapshot, String dbName) throws IOException {
		LmdbDb cached = snapshot.namedDbs.get(dbName);
		if (cached != null) {
			return cached;
		}

		LmdbBtreeRangeCounter counter = new LmdbBtreeRangeCounter(dataFile, snapshot.meta);
		RangeCountResult lookupStats = new RangeCountResult();

		byte[] key = dbName.getBytes(StandardCharsets.UTF_8);
		byte[] keyWithTerminator = new byte[key.length + 1];
		System.arraycopy(key, 0, keyWithTerminator, 0, key.length);

		byte[] value = counter.findValueByExactKey(snapshot.meta.mainDb, key, key.length, lookupStats);
		if (value == null) {
			value = counter.findValueByExactKey(snapshot.meta.mainDb, keyWithTerminator, keyWithTerminator.length,
					lookupStats);
		}
		if (value == null) {
			return null;
		}

		ByteBuffer valueBuffer = ByteBuffer.wrap(value).order(snapshot.meta.byteOrder);
		LmdbDb parsed = LmdbDb.parse(valueBuffer, 0);
		LmdbDb existing = snapshot.namedDbs.putIfAbsent(dbName, parsed);
		return existing == null ? parsed : existing;
	}

	private static final class SnapshotCache {
		final long txnId;
		final LmdbMeta meta;
		final Map<String, LmdbDb> namedDbs = new ConcurrentHashMap<>();

		SnapshotCache(long txnId, LmdbMeta meta) {
			this.txnId = txnId;
			this.meta = meta;
		}
	}

}
