/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.sail.lmdb.estimate;

import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.channels.FileChannel;
import java.nio.file.StandardOpenOption;

final class LmdbDataFile implements Closeable {

	private static final int META_PROBE_BYTES = 4096;
	private static final int META_BASE_OFFSET = LmdbFormat.PAGE_HEADER_SIZE;
	private static final int MIN_PAGE_SIZE = 512;
	private static final int MAX_PAGE_SIZE = 65536;

	private final File dataFile;
	private final FileChannel channel;

	LmdbDataFile(File dataFile) throws IOException {
		this.dataFile = dataFile;
		this.channel = FileChannel.open(dataFile.toPath(), StandardOpenOption.READ);
	}

	LmdbMeta readMetaForTxn(long pinnedTxnId) throws IOException {
		ByteOrder order = detectByteOrder();
		int pageSize = probePageSize(order);
		LmdbMeta meta0 = readMetaPage(0, pageSize, order);
		LmdbMeta meta1 = readMetaPage(1, pageSize, order);

		LmdbMeta selected = null;
		for (LmdbMeta candidate : new LmdbMeta[] { meta0, meta1 }) {
			if (candidate == null) {
				continue;
			}
			if (candidate.txnId == pinnedTxnId) {
				return candidate;
			}
			if (candidate.txnId <= pinnedTxnId && (selected == null || candidate.txnId > selected.txnId)) {
				selected = candidate;
			}
		}

		if (selected == null) {
			throw new IOException("No valid LMDB meta page for pinned txn " + pinnedTxnId + " in " + dataFile);
		}
		return selected;
	}

	LmdbPage readPage(long pgno, LmdbMeta meta) throws IOException {
		long offset = pgno * meta.pageSize;
		if (offset < 0 || offset + meta.pageSize > meta.mapSize) {
			throw new IOException("Page " + pgno + " is outside map bounds (mapsize=" + meta.mapSize + ")");
		}
		ByteBuffer page = readAt(offset, meta.pageSize, meta.byteOrder);
		return LmdbPage.parse(pgno, page, meta.pageSize);
	}

	@Override
	public void close() throws IOException {
		channel.close();
	}

	private LmdbMeta readMetaPage(int metaPage, int pageSize, ByteOrder order) throws IOException {
		ByteBuffer page = readAt((long) metaPage * pageSize, pageSize, order);
		int flags = LmdbFormat.unsignedShort(page, 10);
		if ((flags & LmdbFormat.P_META) == 0) {
			return null;
		}

		int magic = page.getInt(META_BASE_OFFSET + LmdbFormat.META_MAGIC_OFFSET);
		if (magic != LmdbFormat.MDB_MAGIC) {
			return null;
		}
		int version = page.getInt(META_BASE_OFFSET + LmdbFormat.META_VERSION_OFFSET);
		if (version != LmdbFormat.MDB_DATA_VERSION && version != LmdbFormat.MDB_DATA_VERSION_DEVEL) {
			return null;
		}

		long mapSize = page.getLong(META_BASE_OFFSET + LmdbFormat.META_MAP_SIZE_OFFSET);
		LmdbDb freeDb = LmdbDb.parse(page, META_BASE_OFFSET + LmdbFormat.META_DBS_OFFSET);
		LmdbDb mainDb = LmdbDb.parse(page, META_BASE_OFFSET + LmdbFormat.META_DBS_OFFSET + LmdbFormat.META_DB_SIZE);
		long lastPage = page.getLong(META_BASE_OFFSET + LmdbFormat.META_LAST_PG_OFFSET);
		long txnId = page.getLong(META_BASE_OFFSET + LmdbFormat.META_TXNID_OFFSET);
		return new LmdbMeta(metaPage, txnId, freeDb.pad, mapSize, lastPage, freeDb, mainDb, order);
	}

	private int probePageSize(ByteOrder order) throws IOException {
		ByteBuffer probe = readAt(0, META_PROBE_BYTES, order);
		int pageSize = probe.getInt(META_BASE_OFFSET + LmdbFormat.META_DBS_OFFSET + LmdbFormat.MDB_DB_PAD_OFFSET);
		if (pageSize < MIN_PAGE_SIZE || pageSize > MAX_PAGE_SIZE || (pageSize & (pageSize - 1)) != 0) {
			throw new IOException("Invalid LMDB page size " + pageSize + " in " + dataFile);
		}
		return pageSize;
	}

	private ByteOrder detectByteOrder() throws IOException {
		ByteBuffer magicBytes = readAt(0, META_PROBE_BYTES, ByteOrder.BIG_ENDIAN);
		int beMagic = magicBytes.getInt(META_BASE_OFFSET + LmdbFormat.META_MAGIC_OFFSET);
		if (beMagic == LmdbFormat.MDB_MAGIC) {
			return ByteOrder.BIG_ENDIAN;
		}
		if (Integer.reverseBytes(beMagic) == LmdbFormat.MDB_MAGIC) {
			return ByteOrder.LITTLE_ENDIAN;
		}
		throw new IOException("Unable to detect LMDB byte order for " + dataFile);
	}

	private ByteBuffer readAt(long offset, int length, ByteOrder order) throws IOException {
		ByteBuffer buffer = ByteBuffer.allocate(length).order(order);
		int read = 0;
		while (read < length) {
			int n = channel.read(buffer, offset + read);
			if (n < 0) {
				throw new IOException("Unexpected EOF while reading " + dataFile + " at " + (offset + read));
			}
			read += n;
		}
		buffer.flip();
		return buffer;
	}

}
