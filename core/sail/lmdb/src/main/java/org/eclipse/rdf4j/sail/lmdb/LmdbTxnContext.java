/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.sail.lmdb;

import java.io.IOException;
import java.lang.management.LockInfo;
import java.lang.management.ManagementFactory;
import java.lang.management.ThreadInfo;
import java.lang.management.ThreadMXBean;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

import org.eclipse.rdf4j.common.transaction.IsolationLevel;
import org.eclipse.rdf4j.common.transaction.IsolationLevels;
import org.eclipse.rdf4j.model.BNode;
import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Literal;
import org.eclipse.rdf4j.model.Namespace;
import org.eclipse.rdf4j.model.Resource;
import org.eclipse.rdf4j.model.Triple;
import org.eclipse.rdf4j.model.Value;
import org.eclipse.rdf4j.model.ValueFactory;
import org.eclipse.rdf4j.model.impl.SimpleNamespace;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.sail.InterruptedSailException;
import org.eclipse.rdf4j.sail.SailException;
import org.eclipse.rdf4j.sail.base.Changeset.SimpleStatementPattern;
import org.eclipse.rdf4j.sail.lmdb.TxnManager.Txn;
import org.eclipse.rdf4j.sail.lmdb.model.LmdbValue;

class LmdbTxnContext {

	private final LmdbSailStore store;
	private final ReentrantLock writeTxnLock;
	private final NamespaceTxn namespaceTxn = new NamespaceTxn();
	private final Set<Quad> addedExplicit = new LinkedHashSet<>();
	private final Set<Quad> removedExplicit = new LinkedHashSet<>();
	private final Set<Quad> addedInferred = new LinkedHashSet<>();
	private final Set<Quad> removedInferred = new LinkedHashSet<>();
	private final Set<Quad> deprecatedExplicit = new LinkedHashSet<>();
	private final Set<Quad> deprecatedInferred = new LinkedHashSet<>();
	private final Deque<PendingChanges> pendingUpdates = new ArrayDeque<>();

	private IsolationLevel level;
	private boolean initialized;
	private boolean writeActive;
	private boolean finished;
	private boolean writeLockHeld;
	private boolean managedTransaction;
	private boolean deferWrites;
	private boolean overlayChanges;
	private boolean snapshotReadMode;
	private boolean snapshotWriteMode;
	private boolean pinnedSnapshotTransactionScoped;
	private int pinnedSnapshotRefCount;
	private long ownerThreadId = -1;

	private Txn pinnedTripleReadTxn;
	private ValueStore.PinnedReadTxn pinnedValueReadTxn;
	private Set<SimpleStatementPattern> observedExplicit;
	private Set<SimpleStatementPattern> observedInferred;

	LmdbTxnContext(LmdbSailStore store) {
		this.store = store;
		this.writeTxnLock = store.getWriteTxnLock();
	}

	void init(IsolationLevel level) throws SailException {
		if (finished) {
			resetStateForNewTransaction();
		}
		if (initialized) {
			return;
		}
		this.level = level;
		initialized = true;
		snapshotWriteMode = IsolationLevels.SNAPSHOT.equals(level);
		boolean serializable = IsolationLevels.SERIALIZABLE.equals(level);
		snapshotReadMode = snapshotWriteMode || IsolationLevels.SNAPSHOT_READ.equals(level) || serializable;
		if (snapshotWriteMode || serializable) {
			ensurePinnedReadSnapshot();
			pinnedSnapshotTransactionScoped = true;
		}
		if (snapshotReadMode) {
			deferWrites = true;
			overlayChanges = true;
		}
	}

	boolean deferWrites() {
		return deferWrites;
	}

	boolean shouldOverlayChanges() {
		return overlayChanges;
	}

	boolean hasStatementChanges() {
		return !(addedExplicit.isEmpty() && removedExplicit.isEmpty() && addedInferred.isEmpty()
				&& removedInferred.isEmpty());
	}

	void markManagedTransaction() {
		managedTransaction = true;
		deferWrites = true;
		overlayChanges = true;
	}

	boolean isManagedTransaction() {
		return managedTransaction;
	}

	boolean isSerializable() {
		return level != null && level.isCompatibleWith(IsolationLevels.SERIALIZABLE);
	}

	boolean usesPinnedReadTxn() {
		return pinnedTripleReadTxn != null;
	}

	void recordObserved(boolean explicit, Set<SimpleStatementPattern> observed) {
		if (observed == null || observed.isEmpty()) {
			return;
		}
		Set<SimpleStatementPattern> target = explicit ? observedExplicit : observedInferred;
		if (target == null) {
			target = new LinkedHashSet<>(observed);
			if (explicit) {
				observedExplicit = target;
			} else {
				observedInferred = target;
			}
		} else {
			target.addAll(observed);
		}
	}

	Set<SimpleStatementPattern> getObserved(boolean explicit) {
		return explicit ? observedExplicit : observedInferred;
	}

	Txn acquireReadTxn(IsolationLevel level) throws SailException {
		init(level);
		verifyThread();
		try {
			if (snapshotReadMode && !pinnedSnapshotTransactionScoped) {
				ensurePinnedReadSnapshot();
				pinnedSnapshotRefCount++;
			}
			if (pinnedTripleReadTxn != null) {
				return store.getTripleStore().getTxnManager().createTxn(pinnedTripleReadTxn.get());
			}
			return store.getTripleStore().createReadTxnForCurrentThread();
		} catch (IOException e) {
			throw new SailException(e);
		}
	}

	Txn acquirePinnedReadTxn() throws SailException {
		init(level);
		verifyThread();
		try {
			if (pinnedTripleReadTxn != null) {
				return store.getTripleStore().getTxnManager().createTxn(pinnedTripleReadTxn.get());
			}
			return store.getTripleStore().createReadTxnForCurrentThread();
		} catch (IOException e) {
			throw new SailException(e);
		}
	}

	void ensureWriteTxn(IsolationLevel level) throws SailException {
		init(level);
		ensureWriteTxnInitialized();
	}

	private void ensurePinnedReadSnapshot() throws SailException {
		if (pinnedTripleReadTxn != null) {
			verifyThread();
			return;
		}
		bindToCurrentThread();
		store.acquireCommitReadLock();
		try {
			if (pinnedTripleReadTxn == null) {
				pinnedTripleReadTxn = store.getTripleStore().createPinnedReadTxn();
			}
			if (pinnedValueReadTxn == null) {
				pinnedValueReadTxn = store.getValueStore().pinReadTxn();
			}
		} catch (IOException e) {
			if (pinnedTripleReadTxn != null) {
				pinnedTripleReadTxn.close();
				pinnedTripleReadTxn = null;
			}
			if (pinnedValueReadTxn != null) {
				store.getValueStore().clearPinnedReadTxn(pinnedValueReadTxn);
				pinnedValueReadTxn = null;
			}
			throw new SailException(e);
		} finally {
			store.releaseCommitReadLock();
		}
	}

	private void ensureWriteTxnInitialized() throws SailException {
		if (writeActive) {
			verifyThread();
			return;
		}
		bindToCurrentThread();
		try {
			boolean b = writeTxnLock.tryLock(10, TimeUnit.SECONDS);
			int i = 0;
			while (!b) {
				i++;
				System.err.println(
						Thread.currentThread() + " - LMDB writeTxnLock wait took more than " + i * 10 + " seconds");
				// print lock diagnostics
				printWriteTxnLockDiagnostics(i * 10, i == 1 || i % 6 == 0);

				b = writeTxnLock.tryLock(10, TimeUnit.SECONDS);
				if (Thread.currentThread().isInterrupted()) {
					throw new InterruptedSailException();
				}
			}

			writeLockHeld = true;
		} catch (InterruptedException e) {
			Thread.currentThread().interrupt();
			throw new InterruptedSailException(e);
		}
		try {
			store.getTripleStore().startTransaction();
			store.getValueStore().startTransaction(true);
			writeActive = true;
		} catch (IOException e) {
			releaseWriteLock();
			throw new SailException(e);
		}
	}

	void commit() throws SailException {
		if (finished) {
			return;
		}
		verifyThread();
		boolean commitLockHeld = false;
		try {
			boolean hasBufferedWrites = deferWrites && hasStatementChanges();
			if (writeActive || hasBufferedWrites) {
				if (!writeActive) {
					ensureWriteTxn(level);
				}
				store.acquireCommitWriteLock();
				commitLockHeld = true;
				checkSerializableConflicts();
				if (hasBufferedWrites) {
					store.applyBufferedChanges(this);
				}
				store.getTripleStore().commit();
				store.filterUsedIdsInTripleStore();
				store.handleRemovedIdsInValueStore();
				store.getValueStore().commit();
			}
			namespaceTxn.apply(store.getNamespaceStore());
			store.getNamespaceStore().sync();
			clearStatementChanges();
		} catch (org.eclipse.rdf4j.sail.SailConflictException e) {
			rollbackSilently();
			throw e;
		} catch (IOException e) {
			rollbackSilently();
			throw new SailException(e);
		} finally {
			if (commitLockHeld) {
				store.releaseCommitWriteLock();
			}
			cleanup();
			finished = true;
		}
	}

	void checkSerializableConflictsForPrepare() throws SailException {
		if (!isSerializable()) {
			return;
		}
		if ((observedExplicit == null || observedExplicit.isEmpty())
				&& (observedInferred == null || observedInferred.isEmpty())) {
			return;
		}
		store.acquireCommitReadLock();
		try {
			checkSerializableConflicts();
		} finally {
			store.releaseCommitReadLock();
		}
	}

	private void checkSerializableConflicts() throws SailException {
		if ((observedExplicit == null || observedExplicit.isEmpty())
				&& (observedInferred == null || observedInferred.isEmpty())) {
			return;
		}
		try (Txn snapshotTxn = acquirePinnedReadTxn();
				Txn currentTxn = store.getTripleStore().getTxnManager().createReadTxn()) {
			store.ensureObservedPatternsUnchanged(snapshotTxn, currentTxn, observedExplicit, true);
			store.ensureObservedPatternsUnchanged(snapshotTxn, currentTxn, observedInferred, false);
		} catch (IOException e) {
			throw new SailException(e);
		}
	}

	void releaseReadSnapshot() {
		if (!snapshotReadMode || pinnedSnapshotTransactionScoped) {
			return;
		}
		if (pinnedSnapshotRefCount > 0) {
			pinnedSnapshotRefCount--;
		}
		if (pinnedSnapshotRefCount == 0) {
			closePinnedReadSnapshot();
		}
	}

	void rollback() throws SailException {
		if (finished) {
			return;
		}
		verifyThread();
		try {
			if (writeActive) {
				store.getTripleStore().rollback();
				store.getValueStore().rollback();
			}
			store.clearUnusedIds();
			namespaceTxn.clear();
			clearStatementChanges();
		} catch (IOException e) {
			throw new SailException(e);
		} finally {
			cleanup();
			finished = true;
		}
	}

	void close() throws SailException {
		if (!finished) {
			rollback();
		}
	}

	void setNamespace(String prefix, String name) {
		namespaceTxn.set(prefix, name);
	}

	void removeNamespace(String prefix) {
		namespaceTxn.remove(prefix);
	}

	void clearNamespaces() {
		namespaceTxn.clearAll();
	}

	void beginUpdate() throws SailException {
		if (finished) {
			resetStateForNewTransaction();
		}
		deferWrites = true;
		overlayChanges = true;
		if (!managedTransaction && !snapshotReadMode && level != null) {
			ensureWriteTxn(level);
		}
		pendingUpdates.push(new PendingChanges());
	}

	void endUpdate() throws SailException {
		if (pendingUpdates.isEmpty()) {
			return;
		}
		PendingChanges completed = pendingUpdates.pop();
		PendingChanges parent = pendingUpdates.peek();
		if (parent != null) {
			parent.mergeFrom(completed);
			return;
		}
		if (deferWrites) {
			mergeIntoMain(completed);
			if (managedTransaction) {
				return;
			}
			try {
				if (!writeActive && level != null) {
					ensureWriteTxn(level);
				}
				store.applyBufferedChanges(this);
			} catch (IOException e) {
				throw new SailException(e);
			} finally {
				clearStatementChanges();
				deferWrites = false;
				overlayChanges = false;
			}
		} else {
			mergeIntoMain(completed);
		}
	}

	void abortUpdate() {
		if (!pendingUpdates.isEmpty()) {
			pendingUpdates.pop();
		}
		if (pendingUpdates.isEmpty() && deferWrites) {
			if (managedTransaction) {
				return;
			}
			clearStatementChanges();
			deferWrites = false;
			overlayChanges = false;
		}
	}

	void recordAdd(Resource subj, IRI pred, Value obj, Resource ctx, boolean explicit) {
		if (!deferWrites) {
			return;
		}
		Quad quad = new Quad(subj, pred, obj, ctx);
		PendingChanges pending = pendingUpdates.peek();
		if (pending != null) {
			pending.recordAdd(quad, explicit);
			return;
		}
		if (explicit) {
			if (deferWrites) {
				applyAddIfMissing(addedExplicit, removedExplicit, quad, true);
			} else {
				applyAdd(addedExplicit, removedExplicit, quad);
			}
		} else {
			if (deferWrites) {
				applyAddIfMissing(addedInferred, removedInferred, quad, false);
			} else {
				applyAdd(addedInferred, removedInferred, quad);
			}
		}
	}

	void recordRemove(Resource subj, IRI pred, Value obj, Resource ctx, boolean explicit) {
		if (!deferWrites) {
			return;
		}
		Quad quad = new Quad(subj, pred, obj, ctx);
		PendingChanges pending = pendingUpdates.peek();
		if (pending != null) {
			pending.recordRemove(quad, explicit);
			return;
		}
		if (explicit) {
			deprecatedExplicit.add(quad);
			applyRemove(addedExplicit, removedExplicit, quad);
		} else {
			deprecatedInferred.add(quad);
			applyRemove(addedInferred, removedInferred, quad);
		}
	}

	Set<Quad> getAdded(boolean explicit) {
		return explicit ? addedExplicit : addedInferred;
	}

	Set<Quad> getRemoved(boolean explicit) {
		return explicit ? removedExplicit : removedInferred;
	}

	ChangeView snapshotChanges(boolean explicit) {
		Set<Quad> added = new LinkedHashSet<>(explicit ? addedExplicit : addedInferred);
		Set<Quad> removed = new LinkedHashSet<>(explicit ? removedExplicit : removedInferred);
		return new ChangeView(added, removed);
	}

	Set<Quad> snapshotDeprecated(boolean explicit) {
		Set<Quad> deprecated = new LinkedHashSet<>(explicit ? deprecatedExplicit : deprecatedInferred);
		applyPendingDeprecatedTo(deprecated, explicit);
		return deprecated;
	}

	String getNamespace(String prefix) {
		return namespaceTxn.get(prefix, store.getNamespaceStore());
	}

	List<Namespace> getNamespaces() {
		return namespaceTxn.snapshot(store.getNamespaceStore());
	}

	private void bindToCurrentThread() throws SailException {
		long currentThreadId = Thread.currentThread().getId();
		if (ownerThreadId == -1) {
			ownerThreadId = currentThreadId;
		} else if (ownerThreadId != currentThreadId) {
			throw new SailException("LMDB transactions are thread-bound; use a single thread per transaction");
		}
	}

	private void verifyThread() throws SailException {
		if (ownerThreadId != -1 && ownerThreadId != Thread.currentThread().getId()) {
			if (!managedTransaction && !writeActive) {
				return;
			}
			throw new SailException("LMDB transactions are thread-bound; use a single thread per transaction");
		}
	}

	private void cleanup() {
		clearStatementChanges();
		observedExplicit = null;
		observedInferred = null;
		managedTransaction = false;
		ownerThreadId = -1;
		writeActive = false;
		deferWrites = false;
		overlayChanges = false;
		snapshotReadMode = false;
		snapshotWriteMode = false;
		pinnedSnapshotTransactionScoped = false;
		pinnedSnapshotRefCount = 0;
		closePinnedReadSnapshot();
		releaseWriteLock();
	}

	private void resetStateForNewTransaction() {
		finished = false;
		initialized = false;
		writeActive = false;
		writeLockHeld = false;
		managedTransaction = false;
		deferWrites = false;
		overlayChanges = false;
		snapshotReadMode = false;
		snapshotWriteMode = false;
		pinnedSnapshotTransactionScoped = false;
		pinnedSnapshotRefCount = 0;
		observedExplicit = null;
		observedInferred = null;
		ownerThreadId = -1;
		clearStatementChanges();
		closePinnedReadSnapshot();
	}

	private void releaseWriteLock() {
		if (writeLockHeld) {
			writeLockHeld = false;
			writeTxnLock.unlock();
		}
	}

	private void rollbackSilently() {
		try {
			if (writeActive) {
				store.getTripleStore().rollback();
				store.getValueStore().rollback();
			}
		} catch (IOException e) {
			// ignore
		} finally {
			store.clearUnusedIds();
		}
	}

	private void closePinnedReadSnapshot() {
		if (pinnedTripleReadTxn != null) {
			pinnedTripleReadTxn.close();
			pinnedTripleReadTxn = null;
		}
		if (pinnedValueReadTxn != null) {
			store.getValueStore().clearPinnedReadTxn(pinnedValueReadTxn);
			pinnedValueReadTxn = null;
		}
	}

	private void clearStatementChanges() {
		addedExplicit.clear();
		removedExplicit.clear();
		addedInferred.clear();
		removedInferred.clear();
		deprecatedExplicit.clear();
		deprecatedInferred.clear();
		pendingUpdates.clear();
	}

	private void mergeIntoMain(PendingChanges changes) {
		applyPendingRemovals(changes, true);
		applyPendingRemovals(changes, false);
		applyPendingAdds(changes, true);
		applyPendingAdds(changes, false);
		applyPendingDeprecated(changes, true);
		applyPendingDeprecated(changes, false);
	}

	private static void applyAdd(Set<Quad> added, Set<Quad> removed, Quad quad) {
		removed.remove(quad);
		added.add(quad);
	}

	private void applyAddIfMissing(Set<Quad> added, Set<Quad> removed, Quad quad, boolean explicit) {
		if (added.contains(quad)) {
			return;
		}
		if (removed.remove(quad)) {
			added.add(quad);
			return;
		}
		if (existsInStore(quad, explicit)) {
			return;
		}
		added.add(quad);
	}

	private static void applyRemove(Set<Quad> added, Set<Quad> removed, Quad quad) {
		if (added.remove(quad)) {
			return;
		}
		removed.add(quad);
	}

	private void applyPendingRemovals(PendingChanges changes, boolean explicit) {
		Set<Quad> removedSource = explicit ? changes.removedExplicit : changes.removedInferred;
		Set<Quad> added = explicit ? addedExplicit : addedInferred;
		Set<Quad> removed = explicit ? removedExplicit : removedInferred;
		for (Quad quad : removedSource) {
			applyRemove(added, removed, quad);
		}
	}

	private void applyPendingAdds(PendingChanges changes, boolean explicit) {
		Set<Quad> addedSource = explicit ? changes.addedExplicit : changes.addedInferred;
		Set<Quad> added = explicit ? addedExplicit : addedInferred;
		Set<Quad> removed = explicit ? removedExplicit : removedInferred;
		for (Quad quad : addedSource) {
			applyAddIfMissing(added, removed, quad, explicit);
		}
	}

	private void applyPendingDeprecated(PendingChanges changes, boolean explicit) {
		Set<Quad> deprecated = explicit ? deprecatedExplicit : deprecatedInferred;
		changes.applyDeprecatedTo(deprecated, explicit);
	}

	private void applyPendingTo(Set<Quad> added, Set<Quad> removed, boolean explicit) {
		if (pendingUpdates.isEmpty()) {
			return;
		}
		for (var iterator = pendingUpdates.descendingIterator(); iterator.hasNext();) {
			PendingChanges pending = iterator.next();
			pending.applyTo(added, removed, explicit);
		}
	}

	private void applyPendingDeprecatedTo(Set<Quad> deprecated, boolean explicit) {
		if (pendingUpdates.isEmpty()) {
			return;
		}
		for (var iterator = pendingUpdates.descendingIterator(); iterator.hasNext();) {
			PendingChanges pending = iterator.next();
			pending.applyDeprecatedTo(deprecated, explicit);
		}
	}

	private boolean existsInStore(Quad quad, boolean explicit) {
		store.acquireCommitReadLock();
		Txn txn = null;
		boolean releaseSnapshot = false;
		try {
			txn = acquireReadTxn(level);
			releaseSnapshot = snapshotReadMode && !pinnedSnapshotTransactionScoped;
			ValueStore valueStore = store.getValueStore();
			long subjId = valueStore.getId(quad.subj, false);
			if (subjId == LmdbValue.UNKNOWN_ID) {
				return false;
			}
			long predId = valueStore.getId(quad.pred, false);
			if (predId == LmdbValue.UNKNOWN_ID) {
				return false;
			}
			long objId = valueStore.getId(quad.obj, false);
			if (objId == LmdbValue.UNKNOWN_ID) {
				return false;
			}
			long ctxId = 0L;
			if (quad.ctx != null) {
				ctxId = valueStore.getId(quad.ctx, false);
				if (ctxId == LmdbValue.UNKNOWN_ID) {
					return false;
				}
			}
			RecordIterator records = store.getTripleStore().getTriples(txn, subjId, predId, objId, ctxId, explicit);
			if (records == null) {
				return false;
			}
			try {
				return records.next() != null;
			} finally {
				records.close();
			}
		} catch (IOException e) {
			throw new SailException(e);
		} finally {
			if (txn != null) {
				txn.close();
			}
			if (releaseSnapshot) {
				releaseReadSnapshot();
			}
			store.releaseCommitReadLock();
		}
	}

	static final class Quad {
		private static final ValueFactory VALUE_FACTORY = SimpleValueFactory.getInstance();

		final Resource subj;
		final IRI pred;
		final Value obj;
		final Resource ctx;

		Quad(Resource subj, IRI pred, Value obj, Resource ctx) {
			this.subj = (Resource) normalizeValue(subj);
			this.pred = (IRI) normalizeValue(pred);
			this.obj = normalizeValue(obj);
			this.ctx = (Resource) normalizeValue(ctx);
		}

		private static Value normalizeValue(Value value) {
			if (value == null) {
				return null;
			}
			if (value instanceof LmdbValue) {
				((LmdbValue) value).init();
			}
			if (value instanceof IRI) {
				return VALUE_FACTORY.createIRI(value.stringValue());
			}
			if (value instanceof BNode) {
				return VALUE_FACTORY.createBNode(((BNode) value).getID());
			}
			if (value instanceof Literal) {
				Literal literal = (Literal) value;
				return literal.getLanguage()
						.map(language -> VALUE_FACTORY.createLiteral(literal.getLabel(), language))
						.orElseGet(() -> VALUE_FACTORY.createLiteral(literal.getLabel(), literal.getDatatype()));
			}
			if (value instanceof Triple) {
				Triple triple = (Triple) value;
				Resource subj = (Resource) normalizeValue(triple.getSubject());
				IRI pred = (IRI) normalizeValue(triple.getPredicate());
				Value obj = normalizeValue(triple.getObject());
				return VALUE_FACTORY.createTriple(subj, pred, obj);
			}
			return value;
		}

		@Override
		public boolean equals(Object other) {
			if (this == other) {
				return true;
			}
			if (!(other instanceof Quad)) {
				return false;
			}
			Quad quad = (Quad) other;
			return Objects.equals(subj, quad.subj) && Objects.equals(pred, quad.pred)
					&& Objects.equals(obj, quad.obj) && Objects.equals(ctx, quad.ctx);
		}

		@Override
		public int hashCode() {
			return Objects.hash(subj, pred, obj, ctx);
		}
	}

	static final class ChangeView {
		final Set<Quad> added;
		final Set<Quad> removed;

		ChangeView(Set<Quad> added, Set<Quad> removed) {
			this.added = added;
			this.removed = removed;
		}
	}

	private static final class PendingChanges {
		private final Set<Quad> addedExplicit = new LinkedHashSet<>();
		private final Set<Quad> removedExplicit = new LinkedHashSet<>();
		private final Set<Quad> addedInferred = new LinkedHashSet<>();
		private final Set<Quad> removedInferred = new LinkedHashSet<>();
		private final Set<Quad> deprecatedExplicit = new LinkedHashSet<>();
		private final Set<Quad> deprecatedInferred = new LinkedHashSet<>();

		void recordAdd(Quad quad, boolean explicit) {
			if (explicit) {
				applyAdd(addedExplicit, removedExplicit, quad);
			} else {
				applyAdd(addedInferred, removedInferred, quad);
			}
		}

		void recordRemove(Quad quad, boolean explicit) {
			if (explicit) {
				applyRemove(addedExplicit, removedExplicit, quad);
				deprecatedExplicit.add(quad);
			} else {
				applyRemove(addedInferred, removedInferred, quad);
				deprecatedInferred.add(quad);
			}
		}

		void mergeFrom(PendingChanges other) {
			other.applyTo(addedExplicit, removedExplicit, true);
			other.applyTo(addedInferred, removedInferred, false);
			other.applyDeprecatedTo(deprecatedExplicit, true);
			other.applyDeprecatedTo(deprecatedInferred, false);
		}

		void applyTo(Set<Quad> added, Set<Quad> removed, boolean explicit) {
			Set<Quad> removedSource = explicit ? removedExplicit : removedInferred;
			for (Quad quad : removedSource) {
				applyRemove(added, removed, quad);
			}
			Set<Quad> addedSource = explicit ? addedExplicit : addedInferred;
			for (Quad quad : addedSource) {
				applyAdd(added, removed, quad);
			}
		}

		void applyDeprecatedTo(Set<Quad> deprecated, boolean explicit) {
			if (explicit) {
				deprecated.addAll(deprecatedExplicit);
			} else {
				deprecated.addAll(deprecatedInferred);
			}
		}
	}

	private static final class NamespaceTxn {

		private final Map<String, String> additions = new LinkedHashMap<>();
		private final Set<String> removals = new HashSet<>();
		private boolean cleared;

		void set(String prefix, String name) {
			additions.put(prefix, name);
			removals.remove(prefix);
		}

		void remove(String prefix) {
			additions.remove(prefix);
			removals.add(prefix);
		}

		void clearAll() {
			cleared = true;
			additions.clear();
			removals.clear();
		}

		void clear() {
			cleared = false;
			additions.clear();
			removals.clear();
		}

		boolean hasChanges() {
			return cleared || !additions.isEmpty() || !removals.isEmpty();
		}

		String get(String prefix, NamespaceStore base) {
			if (removals.contains(prefix)) {
				return null;
			}
			String added = additions.get(prefix);
			if (added != null) {
				return added;
			}
			if (cleared) {
				return null;
			}
			return base.getNamespace(prefix);
		}

		List<Namespace> snapshot(NamespaceStore base) {
			Map<String, SimpleNamespace> map = new LinkedHashMap<>();
			if (!cleared) {
				for (SimpleNamespace ns : base) {
					map.put(ns.getPrefix(), new SimpleNamespace(ns.getPrefix(), ns.getName()));
				}
			}
			for (String removed : removals) {
				map.remove(removed);
			}
			for (Map.Entry<String, String> entry : additions.entrySet()) {
				map.put(entry.getKey(), new SimpleNamespace(entry.getKey(), entry.getValue()));
			}
			return new ArrayList<>(map.values());
		}

		void apply(NamespaceStore base) {
			if (!hasChanges()) {
				return;
			}
			if (cleared) {
				base.clear();
			}
			for (String prefix : removals) {
				base.removeNamespace(prefix);
			}
			for (Map.Entry<String, String> entry : additions.entrySet()) {
				base.setNamespace(entry.getKey(), entry.getValue());
			}
			clear();
		}
	}

	private void printWriteTxnLockDiagnostics(int waitedSeconds, boolean includeThreadDump) {
		try {
			System.err.println("LMDB writeTxnLock diagnostics after waiting " + waitedSeconds + " seconds");
			System.err.println("  lock=" + writeTxnLock);
			System.err.println("  isLocked=" + writeTxnLock.isLocked()
					+ ", isHeldByCurrentThread=" + writeTxnLock.isHeldByCurrentThread()
					+ ", holdCount=" + writeTxnLock.getHoldCount()
					+ ", hasQueuedThreads=" + writeTxnLock.hasQueuedThreads()
					+ ", queueLength~=" + writeTxnLock.getQueueLength()
					+ ", isFair=" + writeTxnLock.isFair());

			ThreadMXBean bean = ManagementFactory.getThreadMXBean();

			// Deadlock detection can be very useful when a lock wait stretches out.
			try {
				long[] deadlocked = bean.findDeadlockedThreads();
				if (deadlocked != null && deadlocked.length > 0) {
					System.err.println("  DEADLOCK DETECTED (thread ids): " + java.util.Arrays.toString(deadlocked));
					ThreadInfo[] infos = bean.getThreadInfo(deadlocked, true, true);
					if (infos != null) {
						for (ThreadInfo info : infos) {
							if (info != null) {
								printThreadInfo(info, 80);
							}
						}
					}
				}
			} catch (Throwable t) {
				System.err.println("  (Deadlock detection failed: " + t + ")");
			}

			// Try to identify and dump the owner thread stack if the lock can tell us.
			String ownerThreadName = extractOwnerThreadName(writeTxnLock.toString());
			if (ownerThreadName != null) {
				dumpThreadByName(ownerThreadName, 120);
			}

			// Full-ish dump is intentionally throttled (e.g., first time and then every ~60s).
			if (includeThreadDump) {
				System.err.println("  --- Threads waiting on / holding ReentrantLock synchronizers (best effort) ---");
				ThreadInfo[] all = bean.dumpAllThreads(true, true);
				if (all != null) {
					for (ThreadInfo info : all) {
						if (info == null) {
							continue;
						}
						if (isReentrantLockRelated(info)
								|| (ownerThreadName != null && ownerThreadName.equals(info.getThreadName()))) {
							printThreadInfo(info, 60);
						}
					}
				}
			}
		} catch (Throwable t) {
			// Diagnostics must never prevent progress/interrupt handling.
			System.err.println("LMDB writeTxnLock diagnostics failed: " + t);
		}
	}

	private static boolean isReentrantLockRelated(ThreadInfo info) {
		LockInfo lock = info.getLockInfo();
		if (lock != null && lock.getClassName() != null
				&& lock.getClassName().startsWith("java.util.concurrent.locks.ReentrantLock")) {
			return true;
		}
		LockInfo[] synchronizers = info.getLockedSynchronizers();
		if (synchronizers != null) {
			for (LockInfo li : synchronizers) {
				if (li != null && li.getClassName() != null
						&& li.getClassName().startsWith("java.util.concurrent.locks.ReentrantLock")) {
					return true;
				}
			}
		}
		return false;
	}

	private static void printThreadInfo(ThreadInfo info, int maxFrames) {
		System.err.println("Thread \"" + info.getThreadName() + "\" id=" + info.getThreadId()
				+ " state=" + info.getThreadState());
		if (info.getLockInfo() != null) {
			System.err.println("  waitingOn=" + info.getLockInfo());
		}
		if (info.getLockOwnerName() != null) {
			System.err.println("  lockOwner=" + info.getLockOwnerName() + " (id=" + info.getLockOwnerId() + ")");
		}
		StackTraceElement[] stack = info.getStackTrace();
		if (stack != null) {
			int limit = Math.min(stack.length, Math.max(0, maxFrames));
			for (int frame = 0; frame < limit; frame++) {
				System.err.println("\tat " + stack[frame]);
			}
			if (stack.length > limit) {
				System.err.println("\t... " + (stack.length - limit) + " more");
			}
		}
		System.err.println();
	}

	private static String extractOwnerThreadName(String lockString) {
		if (lockString == null) {
			return null;
		}
		int idx = lockString.indexOf("Locked by thread ");
		if (idx < 0) {
			return null;
		}
		int start = idx + "Locked by thread ".length();
		int end = lockString.indexOf(']', start);
		if (end < 0) {
			end = lockString.length();
		}
		String name = lockString.substring(start, end).trim();
		return name.isEmpty() ? null : name;
	}

	private static void dumpThreadByName(String threadName, int maxFrames) {
		try {
			for (Map.Entry<Thread, StackTraceElement[]> entry : Thread.getAllStackTraces().entrySet()) {
				Thread t = entry.getKey();
				if (t != null && threadName.equals(t.getName())) {
					System.err.println("  --- Owner thread stack (" + t + ") ---");
					StackTraceElement[] stack = entry.getValue();
					if (stack != null) {
						int limit = Math.min(stack.length, Math.max(0, maxFrames));
						for (int frame = 0; frame < limit; frame++) {
							System.err.println("\tat " + stack[frame]);
						}
						if (stack.length > limit) {
							System.err.println("\t... " + (stack.length - limit) + " more");
						}
					}
					System.err.println();
					return;
				}
			}
			System.err.println("  (Could not find owner thread named: " + threadName + ")");

			System.err.println("----------------------------------------------------------");
			System.err.println("  Available threads: ");

			for (Map.Entry<Thread, StackTraceElement[]> entry : Thread.getAllStackTraces().entrySet()) {
				Thread t = entry.getKey();
				if (t != null) {
					System.err.println("    - " + t.getName() + " (id=" + t.getId() + ")");
				}
			}
			System.err.println("----------------------------------------------------------");
			System.err.println();

		} catch (Throwable t) {
			System.err.println("  (Owner thread dump failed: " + t + ")");
		}
	}
}
