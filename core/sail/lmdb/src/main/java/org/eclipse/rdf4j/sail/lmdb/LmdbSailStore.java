/*******************************************************************************
 * Copyright (c) 2021 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.sail.lmdb;

import java.io.File;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.IdentityHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.function.Function;

import org.eclipse.rdf4j.common.iteration.CloseableIteration;
import org.eclipse.rdf4j.common.iteration.CloseableIteratorIteration;
import org.eclipse.rdf4j.common.iteration.ConvertingIteration;
import org.eclipse.rdf4j.common.iteration.FilterIteration;
import org.eclipse.rdf4j.common.iteration.IterationWrapper;
import org.eclipse.rdf4j.common.iteration.UnionIteration;
import org.eclipse.rdf4j.common.order.StatementOrder;
import org.eclipse.rdf4j.common.transaction.IsolationLevel;
import org.eclipse.rdf4j.common.transaction.IsolationLevels;
import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Model;
import org.eclipse.rdf4j.model.Namespace;
import org.eclipse.rdf4j.model.Resource;
import org.eclipse.rdf4j.model.Statement;
import org.eclipse.rdf4j.model.Value;
import org.eclipse.rdf4j.model.ValueFactory;
import org.eclipse.rdf4j.model.impl.LinkedHashModel;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.sail.InterruptedSailException;
import org.eclipse.rdf4j.sail.SailConflictException;
import org.eclipse.rdf4j.sail.SailException;
import org.eclipse.rdf4j.sail.base.BackingSailSource;
import org.eclipse.rdf4j.sail.base.Changeset;
import org.eclipse.rdf4j.sail.base.Changeset.SimpleStatementPattern;
import org.eclipse.rdf4j.sail.base.SailDataset;
import org.eclipse.rdf4j.sail.base.SailSink;
import org.eclipse.rdf4j.sail.base.SailSource;
import org.eclipse.rdf4j.sail.base.SailStore;
import org.eclipse.rdf4j.sail.lmdb.TxnManager.Txn;
import org.eclipse.rdf4j.sail.lmdb.config.LmdbStoreConfig;
import org.eclipse.rdf4j.sail.lmdb.model.LmdbValue;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A disk based {@link SailStore} implementation that keeps committed statements in a {@link TripleStore}.
 */
class LmdbSailStore implements SailStore {

	final Logger logger = LoggerFactory.getLogger(LmdbSailStore.class);

	private final TripleStore tripleStore;

	private final ValueStore valueStore;

	private final ExecutorService tripleStoreExecutor = Executors.newCachedThreadPool();
	private final CircularBuffer<Operation> opQueue = new CircularBuffer<>(1024);
	private volatile Throwable tripleStoreException;
	private final AtomicBoolean running = new AtomicBoolean(false);
	private boolean multiThreadingActive;
	private volatile boolean asyncTransactionFinished;
	private volatile boolean nextTransactionAsync;
	private volatile boolean mayHaveInferred;

	boolean enableMultiThreading = true;

	private PersistentSetFactory<Long> setFactory;
	private PersistentSet<Long> unusedIds, nextUnusedIds;

	/**
	 * A fast non-blocking circular buffer backed by an array.
	 *
	 * @param <T> Type of elements within this buffer
	 */
	static final class CircularBuffer<T> {

		private final T[] elements;
		private volatile int head = 0;
		private volatile int tail = 0;

		CircularBuffer(int size) {
			this.elements = (T[]) new Object[size];
		}

		boolean add(T element) {
			// faster version of:
			// tail == Math.floorMod(head - 1, elements.length)
			if (head > 0 ? tail == head - 1 : tail == elements.length - 1) {
				return false;
			}
			elements[tail] = element;
			tail = (tail + 1) % elements.length;
			return true;
		}

		T remove() {
			T result = null;
			if (tail != head) {
				result = elements[head];
				head = (head + 1) % elements.length;
			}
			return result;
		}
	}

	/**
	 * An operation that can be executed asynchronously.
	 */
	interface Operation {
		void execute() throws Exception;
	}

	/**
	 * Special operation that commits the current transaction.
	 */
	static final Operation COMMIT_TRANSACTION = () -> {
	};

	/**
	 * Special operation that rolls the current transaction back.
	 */
	static final Operation ROLLBACK_TRANSACTION = () -> {
	};

	/**
	 * Operation for adding a new quad.
	 */
	class AddQuadOperation implements Operation {
		long s, p, o, c;
		boolean explicit;

		@Override
		public void execute() throws IOException {
			if (!explicit) {
				mayHaveInferred = true;
			}
			if (!unusedIds.isEmpty()) {
				// these ids are used again
				unusedIds.remove(s);
				unusedIds.remove(p);
				unusedIds.remove(o);
				unusedIds.remove(c);
			}
			tripleStore.storeTriple(s, p, o, c, explicit);
		}
	}

	/**
	 * Super-class for operations that capture their finished state.
	 */
	abstract static class StatefulOperation implements Operation {
		volatile boolean finished = false;
	}

	private final NamespaceStore namespaceStore;

	/**
	 * A lock to control concurrent access by {@link LmdbSailSink} to the TripleStore, ValueStore, and NamespaceStore.
	 * Each sink method that directly accesses one of these store obtains the lock and releases it immediately when
	 * done.
	 */
	private final ReentrantLock sinkStoreAccessLock = new ReentrantLock();

	/**
	 * Global write lock to serialize LMDB write transactions.
	 */
	private final ReentrantLock writeTxnLock = new ReentrantLock();
	/**
	 * Guard against readers starting mid-commit across LMDB environments.
	 */
	private final ReentrantReadWriteLock commitLock = new ReentrantReadWriteLock();

	private final Object defaultContextKey = new Object();
	private final Object contextLock = new Object();
	private final Map<Object, ContextState> contexts = new IdentityHashMap<>();

	private static final class ContextState {
		private final LmdbTxnContext context;
		private int refCount;

		private ContextState(LmdbTxnContext context) {
			this.context = context;
			this.refCount = 1;
		}
	}

	final class ConnectionSailStore implements SailStore {
		private final Object contextKey = new Object();
		private LmdbTxnContext transactionContext;
		private boolean transactionInitialized;
		private boolean updateContextInitialized;

		void initTransaction(IsolationLevel level) throws SailException {
			if (!transactionInitialized) {
				transactionContext = acquireContext(contextKey);
				transactionInitialized = true;
				updateContextInitialized = false;
			}
			transactionContext.init(level);
			transactionContext.markManagedTransaction();
		}

		void endTransaction(boolean commit) throws SailException {
			if (!transactionInitialized) {
				return;
			}
			try {
				if (transactionContext != null) {
					if (commit) {
						transactionContext.commit();
					} else {
						transactionContext.rollback();
					}
				}
			} finally {
				try {
					releaseContext(contextKey, transactionContext);
				} finally {
					transactionContext = null;
					transactionInitialized = false;
					updateContextInitialized = false;
				}
			}
		}

		void beginUpdate() throws SailException {
			if (!transactionInitialized) {
				transactionContext = acquireContext(contextKey);
				transactionInitialized = true;
				updateContextInitialized = true;
			}
			if (transactionContext != null) {
				transactionContext.beginUpdate();
			}
		}

		void endUpdate() throws SailException {
			if (!transactionInitialized || transactionContext == null) {
				return;
			}
			transactionContext.endUpdate();
			if (updateContextInitialized) {
				releaseContext(contextKey, transactionContext);
				transactionContext = null;
				transactionInitialized = false;
				updateContextInitialized = false;
			}
		}

		void abortUpdate() throws SailException {
			if (!transactionInitialized || transactionContext == null) {
				return;
			}
			transactionContext.abortUpdate();
			if (updateContextInitialized) {
				releaseContext(contextKey, transactionContext);
				transactionContext = null;
				transactionInitialized = false;
				updateContextInitialized = false;
			}
		}

		@Override
		public ValueFactory getValueFactory() {
			return LmdbSailStore.this.getValueFactory();
		}

		@Override
		public EvaluationStatistics getEvaluationStatistics() {
			return LmdbSailStore.this.getEvaluationStatistics();
		}

		@Override
		public SailSource getExplicitSailSource() {
			return new LmdbSailSource(true, selectContextKey());
		}

		@Override
		public SailSource getInferredSailSource() {
			return new LmdbSailSource(false, selectContextKey());
		}

		private Object selectContextKey() {
			return transactionInitialized ? contextKey : new Object();
		}

		@Override
		public void close() throws SailException {
			// no-op: backing store manages lifecycle
		}
	}

	/**
	 * Creates a new {@link LmdbSailStore}.
	 */
	public LmdbSailStore(File dataDir, LmdbStoreConfig config) throws IOException, SailException {
		this.setFactory = new PersistentSetFactory<>(dataDir);
		Function<Long, byte[]> encode = element -> {
			ByteBuffer bb = ByteBuffer.allocate(Long.BYTES).order(ByteOrder.BIG_ENDIAN);
			bb.putLong(element);
			return bb.array();
		};
		Function<ByteBuffer, Long> decode = buffer -> buffer.order(ByteOrder.BIG_ENDIAN).getLong();
		this.unusedIds = setFactory.createSet("unusedIds", encode, decode);
		this.nextUnusedIds = setFactory.createSet("nextUnusedIds", encode, decode);
		boolean initialized = false;
		try {
			namespaceStore = new NamespaceStore(dataDir);
			var valueStore = new ValueStore(new File(dataDir, "values"), config);
			this.valueStore = valueStore;
			tripleStore = new TripleStore(new File(dataDir, "triples"), config, valueStore);
			mayHaveInferred = tripleStore.hasTriples(false);
			initialized = true;
		} finally {
			if (!initialized) {
				close();
			}
		}
	}

	@Override
	public ValueFactory getValueFactory() {
		return valueStore;
	}

	void rollback() throws SailException {
		sinkStoreAccessLock.lock();
		try {
			valueStore.rollback();
			tripleStore.rollback();
			clearUnusedIds();
		} catch (Exception e) {
			logger.warn("Failed to rollback LMDB transaction", e);
			throw e instanceof SailException ? (SailException) e : new SailException(e);
		} finally {
			sinkStoreAccessLock.unlock();
		}
	}

	@Override
	public void close() throws SailException {
		try {
			try {
				if (namespaceStore != null) {
					namespaceStore.close();
				}
			} finally {
				try {
					if (valueStore != null) {
						valueStore.close();
					}
				} finally {
					try {
						if (tripleStore != null) {
							try {
								running.set(false);
								tripleStoreExecutor.shutdown();
								try {
									while (!tripleStoreExecutor.awaitTermination(1, TimeUnit.SECONDS)) {
										logger.warn("Waiting for triple store executor to terminate");
									}
								} catch (InterruptedException e) {
									Thread.currentThread().interrupt();
									throw new InterruptedSailException(e);
								}
							} finally {
								tripleStore.close();
							}
						}
					} finally {
						if (setFactory != null) {
							setFactory.close();
							setFactory = null;
						}
					}
				}
			}
		} catch (IOException e) {
			logger.warn("Failed to close store", e);
			throw new SailException(e);
		}
	}

	SailException wrapTripleStoreException() {
		return tripleStoreException instanceof SailException ? (SailException) tripleStoreException
				: new SailException(tripleStoreException);
	}

	@Override
	public EvaluationStatistics getEvaluationStatistics() {
		return new LmdbEvaluationStatistics(valueStore, tripleStore);
	}

	ReentrantLock getWriteTxnLock() {
		return writeTxnLock;
	}

	void acquireCommitReadLock() {
		commitLock.readLock().lock();
	}

	void releaseCommitReadLock() {
		commitLock.readLock().unlock();
	}

	void acquireCommitWriteLock() {
		commitLock.writeLock().lock();
	}

	void releaseCommitWriteLock() {
		commitLock.writeLock().unlock();
	}

	ConnectionSailStore createConnectionStore() {
		return new ConnectionSailStore();
	}

	private LmdbTxnContext acquireContext(Object key) {
		synchronized (contextLock) {
			ContextState state = contexts.get(key);
			if (state == null) {
				state = new ContextState(new LmdbTxnContext(this));
				contexts.put(key, state);
			} else {
				state.refCount++;
			}
			return state.context;
		}
	}

	private void releaseContext(Object key, LmdbTxnContext context) throws SailException {
		LmdbTxnContext toClose = null;
		synchronized (contextLock) {
			ContextState state = contexts.get(key);
			if (state == null || state.context != context) {
				return;
			}
			state.refCount--;
			if (state.refCount <= 0) {
				contexts.remove(key);
				toClose = state.context;
			}
		}
		if (toClose != null) {
			toClose.close();
		}
	}

	private LmdbTxnContext peekContext(Object key) {
		synchronized (contextLock) {
			ContextState state = contexts.get(key);
			return state == null ? null : state.context;
		}
	}

	NamespaceStore getNamespaceStore() {
		return namespaceStore;
	}

	TripleStore getTripleStore() {
		return tripleStore;
	}

	ValueStore getValueStore() {
		return valueStore;
	}

	void applyBufferedChanges(LmdbTxnContext context) throws IOException {
		applyRemoved(context.getRemoved(true), true);
		applyRemoved(context.getRemoved(false), false);
		applyAdded(context.getAdded(true), true);
		applyAdded(context.getAdded(false), false);
	}

	private void applyAdded(Set<LmdbTxnContext.Quad> added, boolean explicit) throws IOException {
		if (added.isEmpty()) {
			return;
		}
		for (LmdbTxnContext.Quad quad : added) {
			long subjId = valueStore.getId(quad.subj, true);
			long predId = valueStore.getId(quad.pred, true);
			long objId = valueStore.getId(quad.obj, true);
			long ctxId = quad.ctx == null ? 0L : valueStore.getId(quad.ctx, true);
			if (!explicit) {
				mayHaveInferred = true;
			}
			if (!unusedIds.isEmpty()) {
				unusedIds.remove(subjId);
				unusedIds.remove(predId);
				unusedIds.remove(objId);
				unusedIds.remove(ctxId);
			}
			tripleStore.storeTriple(subjId, predId, objId, ctxId, explicit);
		}
	}

	private void applyRemoved(Set<LmdbTxnContext.Quad> removed, boolean explicit) throws IOException {
		if (removed.isEmpty()) {
			return;
		}
		for (LmdbTxnContext.Quad quad : removed) {
			long subjId = valueStore.getId(quad.subj, false);
			if (subjId == LmdbValue.UNKNOWN_ID) {
				continue;
			}
			long predId = valueStore.getId(quad.pred, false);
			if (predId == LmdbValue.UNKNOWN_ID) {
				continue;
			}
			long objId = valueStore.getId(quad.obj, false);
			if (objId == LmdbValue.UNKNOWN_ID) {
				continue;
			}
			long ctxId = 0L;
			if (quad.ctx != null) {
				ctxId = valueStore.getId(quad.ctx, false);
				if (ctxId == LmdbValue.UNKNOWN_ID) {
					continue;
				}
			}
			tripleStore.removeTriplesByContext(subjId, predId, objId, ctxId, explicit, quadIds -> {
				for (long id : quadIds) {
					if (id != 0L) {
						unusedIds.add(id);
					}
				}
			});
		}
	}

	void clearUnusedIds() {
		unusedIds.clear();
		nextUnusedIds.clear();
	}

	void filterUsedIdsInTripleStore() throws IOException {
		if (!unusedIds.isEmpty()) {
			tripleStore.filterUsedIds(unusedIds);
		}
	}

	void handleRemovedIdsInValueStore() throws IOException {
		if (!unusedIds.isEmpty()) {
			do {
				valueStore.gcIds(unusedIds, nextUnusedIds);
				unusedIds.clear();
				if (!nextUnusedIds.isEmpty()) {
					// swap sets
					PersistentSet<Long> ids = unusedIds;
					unusedIds = nextUnusedIds;
					nextUnusedIds = ids;
					filterUsedIdsInTripleStore();
				}
			} while (!unusedIds.isEmpty());
		}
	}

	@Override
	public SailSource getExplicitSailSource() {
		return new LmdbSailSource(true, defaultContextKey);
	}

	@Override
	public SailSource getInferredSailSource() {
		return new LmdbSailSource(false, defaultContextKey);
	}

	CloseableIteration<Resource> getContexts() throws IOException {
		Txn txn = tripleStore.getTxnManager().createReadTxn();
		RecordIterator records = tripleStore.getAllTriplesSortedByContext(txn);
		CloseableIteration<? extends Statement> stIter1;
		if (records == null) {
			// Iterator over all statements
			stIter1 = createStatementIterator(txn, null, null, null, true);
		} else {
			stIter1 = new LmdbStatementIterator(records, valueStore);
		}

		FilterIteration<Statement> stIter2 = new FilterIteration<>(
				stIter1) {
			@Override
			protected boolean accept(Statement st) {
				return st.getContext() != null;
			}

			@Override
			protected void handleClose() {

			}
		};

		return new ConvertingIteration<>(stIter2) {
			@Override
			protected Resource convert(Statement sourceObject) throws SailException {
				return sourceObject.getContext();
			}

			@Override
			protected void handleClose() throws SailException {
				// correctly close read txn
				txn.close();
				super.handleClose();
			}
		};
	}

	/**
	 * Creates a statement iterator based on the supplied pattern.
	 *
	 * @param subj     The subject of the pattern, or <tt>null</tt> to indicate a wildcard.
	 * @param pred     The predicate of the pattern, or <tt>null</tt> to indicate a wildcard.
	 * @param obj      The object of the pattern, or <tt>null</tt> to indicate a wildcard.
	 * @param contexts The context(s) of the pattern. Note that this parameter is a vararg and as such is optional. If
	 *                 no contexts are supplied the method operates on the entire repository.
	 * @return A StatementIterator that can be used to iterate over the statements that match the specified pattern.
	 */
	CloseableIteration<? extends Statement> createStatementIterator(
			Txn txn, Resource subj, IRI pred, Value obj, boolean explicit, Resource... contexts) throws IOException {
		if (!explicit && !mayHaveInferred) {
			// there are no inferred statements and the iterator should only return inferred statements
			return CloseableIteration.EMPTY_STATEMENT_ITERATION;
		}
		long subjID = LmdbValue.UNKNOWN_ID;
		if (subj != null) {
			subjID = valueStore.getId(subj);
			if (subjID == LmdbValue.UNKNOWN_ID) {
				return CloseableIteration.EMPTY_STATEMENT_ITERATION;
			}
		}

		long predID = LmdbValue.UNKNOWN_ID;
		if (pred != null) {
			predID = valueStore.getId(pred);
			if (predID == LmdbValue.UNKNOWN_ID) {
				return CloseableIteration.EMPTY_STATEMENT_ITERATION;
			}
		}

		long objID = LmdbValue.UNKNOWN_ID;
		if (obj != null) {
			objID = valueStore.getId(obj);

			if (objID == LmdbValue.UNKNOWN_ID) {
				return CloseableIteration.EMPTY_STATEMENT_ITERATION;
			}
		}

		List<Long> contextIDList = new ArrayList<>(contexts.length);
		if (contexts.length == 0) {
			contextIDList.add(LmdbValue.UNKNOWN_ID);
		} else {
			for (Resource context : contexts) {
				if (context == null) {
					contextIDList.add(0L);
				} else if (!context.isTriple()) {
					long contextID = valueStore.getId(context);

					if (contextID != LmdbValue.UNKNOWN_ID) {
						contextIDList.add(contextID);
					}
				}
			}
		}

		ArrayList<LmdbStatementIterator> perContextIterList = new ArrayList<>(contextIDList.size());

		for (long contextID : contextIDList) {
			RecordIterator records = tripleStore.getTriples(txn, subjID, predID, objID, contextID, explicit);
			perContextIterList.add(new LmdbStatementIterator(records, valueStore));
		}

		if (perContextIterList.size() == 1) {
			return perContextIterList.get(0);
		} else {
			return new UnionIteration<>(perContextIterList);
		}
	}

	void ensureObservedPatternsUnchanged(Txn snapshotTxn, Txn currentTxn,
			Set<SimpleStatementPattern> observed, boolean explicit) throws IOException {
		if (observed == null || observed.isEmpty()) {
			return;
		}
		for (SimpleStatementPattern pattern : observed) {
			if (!recordsEqual(snapshotTxn, currentTxn, pattern, explicit)) {
				throw new SailConflictException("Observed State has Changed");
			}
		}
	}

	private boolean recordsEqual(Txn snapshotTxn, Txn currentTxn, SimpleStatementPattern pattern, boolean explicit)
			throws IOException {
		Resource subj = pattern.getSubject();
		IRI pred = pattern.getPredicate();
		Value obj = pattern.getObject();
		Resource context = pattern.getContext();
		boolean allContexts = pattern.isAllContexts();

		long snapshotSubjId = LmdbValue.UNKNOWN_ID;
		long currentSubjId = LmdbValue.UNKNOWN_ID;
		boolean snapshotEmpty = false;
		boolean currentEmpty = false;
		if (subj != null) {
			snapshotSubjId = valueStore.getId(subj);
			currentSubjId = valueStore.getIdUnpinned(subj);
			if (snapshotSubjId == LmdbValue.UNKNOWN_ID) {
				snapshotEmpty = true;
			}
			if (currentSubjId == LmdbValue.UNKNOWN_ID) {
				currentEmpty = true;
			}
		}

		long snapshotPredId = LmdbValue.UNKNOWN_ID;
		long currentPredId = LmdbValue.UNKNOWN_ID;
		if (pred != null) {
			snapshotPredId = valueStore.getId(pred);
			currentPredId = valueStore.getIdUnpinned(pred);
			if (snapshotPredId == LmdbValue.UNKNOWN_ID) {
				snapshotEmpty = true;
			}
			if (currentPredId == LmdbValue.UNKNOWN_ID) {
				currentEmpty = true;
			}
		}

		long snapshotObjId = LmdbValue.UNKNOWN_ID;
		long currentObjId = LmdbValue.UNKNOWN_ID;
		if (obj != null) {
			snapshotObjId = valueStore.getId(obj);
			currentObjId = valueStore.getIdUnpinned(obj);
			if (snapshotObjId == LmdbValue.UNKNOWN_ID) {
				snapshotEmpty = true;
			}
			if (currentObjId == LmdbValue.UNKNOWN_ID) {
				currentEmpty = true;
			}
		}

		long snapshotContextId = LmdbValue.UNKNOWN_ID;
		long currentContextId = LmdbValue.UNKNOWN_ID;
		if (allContexts) {
			snapshotContextId = LmdbValue.UNKNOWN_ID;
			currentContextId = LmdbValue.UNKNOWN_ID;
		} else if (context == null) {
			snapshotContextId = 0L;
			currentContextId = 0L;
		} else if (context.isTriple()) {
			snapshotEmpty = true;
			currentEmpty = true;
		} else {
			snapshotContextId = valueStore.getId(context);
			currentContextId = valueStore.getIdUnpinned(context);
			if (snapshotContextId == LmdbValue.UNKNOWN_ID) {
				snapshotEmpty = true;
			}
			if (currentContextId == LmdbValue.UNKNOWN_ID) {
				currentEmpty = true;
			}
		}

		if (snapshotEmpty && currentEmpty) {
			return true;
		}

		RecordIterator snapshotIter = null;
		RecordIterator currentIter = null;
		try {
			if (!snapshotEmpty) {
				snapshotIter = tripleStore.getTriples(snapshotTxn, snapshotSubjId, snapshotPredId, snapshotObjId,
						snapshotContextId, explicit);
			}
			if (!currentEmpty) {
				currentIter = tripleStore.getTriples(currentTxn, currentSubjId, currentPredId, currentObjId,
						currentContextId, explicit);
			}
			return recordsEqual(snapshotIter, currentIter);
		} finally {
			if (snapshotIter != null) {
				snapshotIter.close();
			}
			if (currentIter != null) {
				currentIter.close();
			}
		}
	}

	private boolean recordsEqual(RecordIterator snapshotIter, RecordIterator currentIter) {
		if (snapshotIter == null) {
			return currentIter == null || currentIter.next() == null;
		}
		if (currentIter == null) {
			return snapshotIter.next() == null;
		}
		while (true) {
			long[] snapshotRecord = snapshotIter.next();
			long[] currentRecord = currentIter.next();
			if (snapshotRecord == null || currentRecord == null) {
				return snapshotRecord == null && currentRecord == null;
			}
			if (!Arrays.equals(snapshotRecord, currentRecord)) {
				return false;
			}
		}
	}

	private final class LmdbSailSource extends BackingSailSource {

		private final boolean explicit;
		private final Object contextKey;

		public LmdbSailSource(boolean explicit, Object contextKey) {
			this.explicit = explicit;
			this.contextKey = contextKey;
		}

		@Override
		public SailSource fork() {
			return new LmdbSailSource(explicit, contextKey);
		}

		@Override
		public void prepare() throws SailException {
			if (!explicit) {
				return;
			}
			LmdbTxnContext context = peekContext(contextKey);
			if (context != null) {
				context.checkSerializableConflictsForPrepare();
			}
		}

		@Override
		public SailSink sink(IsolationLevel level) throws SailException {
			LmdbTxnContext context = acquireContext(contextKey);
			return new LmdbSailSink(explicit, contextKey, context, level);
		}

		@Override
		public LmdbSailDataset dataset(IsolationLevel level) throws SailException {
			LmdbTxnContext context = acquireContext(contextKey);
			return new LmdbSailDataset(explicit, contextKey, context, level);
		}

		@Override
		public void flush() throws SailException {
			LmdbTxnContext context = peekContext(contextKey);
			if (context != null) {
				context.commit();
			}
		}

		@Override
		public void close() throws SailException {
			LmdbTxnContext context = peekContext(contextKey);
			if (context != null && !context.isManagedTransaction()) {
				context.close();
			}
		}
	}

	private final class LmdbSailSink extends Changeset {

		private final boolean explicit;
		private final Object contextKey;
		private final LmdbTxnContext txnContext;
		private final IsolationLevel level;

		public LmdbSailSink(boolean explicit, Object contextKey, LmdbTxnContext txnContext, IsolationLevel level)
				throws SailException {
			this.explicit = explicit;
			this.contextKey = contextKey;
			this.txnContext = txnContext;
			this.level = level;
			this.txnContext.init(level);
		}

		@Override
		public void close() throws SailException {
			try {
				if (!txnContext.isManagedTransaction()) {
					txnContext.rollback();
				}
			} finally {
				releaseContext(contextKey, txnContext);
			}
		}

		@Override
		public void prepare() throws SailException {
			super.prepare();
			if (level == null || !level.isCompatibleWith(IsolationLevels.SERIALIZABLE)) {
				return;
			}
			Set<SimpleStatementPattern> observed = getObserved();
			if (observed != null && !observed.isEmpty()) {
				txnContext.recordObserved(explicit, observed);
			}
			Set<SimpleStatementPattern> checkObserved = txnContext.getObserved(explicit);
			if (checkObserved == null || checkObserved.isEmpty()) {
				return;
			}
			LmdbSailStore.this.acquireCommitReadLock();
			try (Txn snapshotTxn = txnContext.acquirePinnedReadTxn();
					Txn currentTxn = tripleStore.getTxnManager().createReadTxn()) {
				ensureObservedPatternsUnchanged(snapshotTxn, currentTxn, checkObserved, explicit);
			} catch (IOException e) {
				throw new SailException(e);
			} finally {
				LmdbSailStore.this.releaseCommitReadLock();
			}
		}

		@Override
		public Model createEmptyModel() {
			return new LinkedHashModel();
		}

		@Override
		public void flush() throws SailException {
			if (!txnContext.isManagedTransaction()) {
				txnContext.commit();
			}
		}

		@Override
		public void setNamespace(String prefix, String name) throws SailException {
			sinkStoreAccessLock.lock();
			try {
				txnContext.setNamespace(prefix, name);
			} finally {
				sinkStoreAccessLock.unlock();
			}
		}

		@Override
		public void removeNamespace(String prefix) throws SailException {
			sinkStoreAccessLock.lock();
			try {
				txnContext.removeNamespace(prefix);
			} finally {
				sinkStoreAccessLock.unlock();
			}
		}

		@Override
		public void clearNamespaces() throws SailException {
			sinkStoreAccessLock.lock();
			try {
				txnContext.clearNamespaces();
			} finally {
				sinkStoreAccessLock.unlock();
			}
		}

		@Override
		public void observe(Resource subj, IRI pred, Value obj, Resource... contexts) throws SailException {
			super.observe(subj, pred, obj, contexts);
		}

		@Override
		public boolean hasDeprecated(Resource subj, IRI pred, Value obj, Resource[] contexts) {
			Set<LmdbTxnContext.Quad> removed = txnContext.snapshotDeprecated(explicit);
			if (removed.isEmpty()) {
				return false;
			}
			boolean matchAllContexts = contexts == null || contexts.length == 0;
			Set<Resource> contextSet = matchAllContexts ? Set.of() : normalizeContexts(contexts);
			LmdbTxnContext.Quad probe = new LmdbTxnContext.Quad(subj, pred, obj, null);
			for (LmdbTxnContext.Quad deprecated : removed) {
				if (probe.subj != null && !Objects.equals(probe.subj, deprecated.subj)) {
					continue;
				}
				if (probe.pred != null && !Objects.equals(probe.pred, deprecated.pred)) {
					continue;
				}
				if (probe.obj != null && !Objects.equals(probe.obj, deprecated.obj)) {
					continue;
				}
				if (matchAllContexts || contextSet.contains(deprecated.ctx)) {
					return true;
				}
			}
			return false;
		}

		private Set<Resource> normalizeContexts(Resource... contexts) {
			Set<Resource> resolved = new LinkedHashSet<>();
			for (Resource context : contexts) {
				if (context == null) {
					resolved.add(null);
				} else if (!context.isTriple()) {
					LmdbTxnContext.Quad quad = new LmdbTxnContext.Quad(null, null, null, context);
					resolved.add(quad.ctx);
				}
			}
			return resolved;
		}

		@Override
		public void clear(Resource... contexts) throws SailException {
			removeStatements(null, null, null, explicit, contexts);
		}

		@Override
		public void approve(Resource subj, IRI pred, Value obj, Resource ctx) throws SailException {
			addStatement(subj, pred, obj, explicit, ctx);
		}

		@Override
		public void approveAll(Set<Statement> approved, Set<Resource> approvedContexts) {
			Statement last = null;

			sinkStoreAccessLock.lock();
			try {
				boolean deferWrites = txnContext.deferWrites();
				if (!deferWrites) {
					ensureWriteTxn();
				}

				for (Statement statement : approved) {
					last = statement;
					Resource subj = statement.getSubject();
					IRI pred = statement.getPredicate();
					Value obj = statement.getObject();
					Resource context = statement.getContext();

					if (deferWrites) {
						if (!explicit) {
							mayHaveInferred = true;
						}
						txnContext.recordAdd(subj, pred, obj, context, explicit);
					} else {
						AddQuadOperation q = new AddQuadOperation();
						q.s = valueStore.storeValue(subj);
						q.p = valueStore.storeValue(pred);
						q.o = valueStore.storeValue(obj);
						q.c = context == null ? 0 : valueStore.storeValue(context);
						q.explicit = explicit;

						q.execute();
						txnContext.recordAdd(subj, pred, obj, context, explicit);
					}

				}
			} catch (IOException | RuntimeException e) {
				txnContext.rollback();
				logger.error(
						"Encountered an unexpected problem while trying to add a statement. Last statement that was attempted to be added: [ {} ]",
						last, e);

				if (e instanceof RuntimeException) {
					throw (RuntimeException) e;
				}
				throw new SailException(e);
			} finally {
				sinkStoreAccessLock.unlock();
			}
		}

		@Override
		public void deprecate(Statement statement) throws SailException {
			if (txnContext.deferWrites()) {
				txnContext.recordRemove(statement.getSubject(), statement.getPredicate(), statement.getObject(),
						statement.getContext(), explicit);
				return;
			}
			removeStatements(statement.getSubject(), statement.getPredicate(), statement.getObject(), explicit,
					statement.getContext());
		}

		private void ensureWriteTxn() throws SailException {
			txnContext.ensureWriteTxn(level);
		}

		private void addStatement(Resource subj, IRI pred, Value obj, boolean explicit, Resource context)
				throws SailException {
			sinkStoreAccessLock.lock();
			try {
				boolean deferWrites = txnContext.deferWrites();
				if (deferWrites) {
					if (!explicit) {
						mayHaveInferred = true;
					}
					txnContext.recordAdd(subj, pred, obj, context, explicit);
					return;
				}

				ensureWriteTxn();

				AddQuadOperation q = new AddQuadOperation();
				q.s = valueStore.storeValue(subj);
				q.p = valueStore.storeValue(pred);
				q.o = valueStore.storeValue(obj);
				q.c = context == null ? 0 : valueStore.storeValue(context);
				q.explicit = explicit;

				q.execute();
				txnContext.recordAdd(subj, pred, obj, context, explicit);
			} catch (IOException e) {
				txnContext.rollback();
				throw new SailException(e);
			} catch (RuntimeException e) {
				txnContext.rollback();
				logger.error("Encountered an unexpected problem while trying to add a statement", e);
				throw e;
			} finally {
				sinkStoreAccessLock.unlock();
			}
		}

		private long removeStatements(long subj, long pred, long obj, boolean explicit, long[] contexts)
				throws IOException {
			long[] removeCount = { 0 };
			for (long contextId : contexts) {
				tripleStore.removeTriplesByContext(subj, pred, obj, contextId, explicit, quad -> {
					removeCount[0]++;
					try {
						Resource subjValue = (Resource) valueStore.getLazyValue(quad[0]);
						IRI predValue = (IRI) valueStore.getLazyValue(quad[1]);
						Value objValue = valueStore.getLazyValue(quad[2]);
						Resource ctxValue = quad[3] == 0 ? null : (Resource) valueStore.getLazyValue(quad[3]);
						txnContext.recordRemove(subjValue, predValue, objValue, ctxValue, explicit);
					} catch (IOException e) {
						throw new RuntimeException(e);
					}
					for (long id : quad) {
						if (id != 0L) {
							unusedIds.add(id);
						}
					}
				});
			}
			return removeCount[0];
		}

		private long removeStatements(Resource subj, IRI pred, Value obj, boolean explicit, Resource... contexts)
				throws SailException {
			Objects.requireNonNull(contexts,
					"contexts argument may not be null; either the value should be cast to Resource or an empty array should be supplied");

			sinkStoreAccessLock.lock();
			try {
				if (txnContext.deferWrites()) {
					return bufferRemoveStatements(subj, pred, obj, explicit, contexts);
				}
				ensureWriteTxn();
				final long subjID;
				if (subj != null) {
					subjID = valueStore.getId(subj);
					if (subjID == LmdbValue.UNKNOWN_ID) {
						return 0;
					}
				} else {
					subjID = LmdbValue.UNKNOWN_ID;
				}
				final long predID;
				if (pred != null) {
					predID = valueStore.getId(pred);
					if (predID == LmdbValue.UNKNOWN_ID) {
						return 0;
					}
				} else {
					predID = LmdbValue.UNKNOWN_ID;
				}
				final long objID;
				if (obj != null) {
					objID = valueStore.getId(obj);
					if (objID == LmdbValue.UNKNOWN_ID) {
						return 0;
					}
				} else {
					objID = LmdbValue.UNKNOWN_ID;
				}

				final long[] contextIds = new long[contexts.length == 0 ? 1 : contexts.length];
				if (contexts.length == 0) { // remove from all contexts
					contextIds[0] = LmdbValue.UNKNOWN_ID;
				} else {
					for (int i = 0; i < contexts.length; i++) {
						Resource context = contexts[i];
						if (context == null) {
							contextIds[i] = 0;
						} else {
							long id = valueStore.getId(context);
							// unknown_id cannot be used (would result in removal from all contexts)
							// TODO check if Long.MAX_VALUE is correct here
							contextIds[i] = (id != LmdbValue.UNKNOWN_ID) ? id : Long.MAX_VALUE;
						}
					}
				}

				return removeStatements(subjID, predID, objID, explicit, contextIds);
			} catch (IOException e) {
				txnContext.rollback();
				throw new SailException(e);
			} catch (RuntimeException e) {
				txnContext.rollback();
				logger.error("Encountered an unexpected problem while trying to remove statements", e);
				throw e;
			} finally {
				sinkStoreAccessLock.unlock();
			}
		}

		private long bufferRemoveStatements(Resource subj, IRI pred, Value obj, boolean explicit, Resource... contexts)
				throws SailException {
			Set<LmdbTxnContext.Quad> removed = new LinkedHashSet<>();
			SailSource source = new LmdbSailSource(explicit, contextKey);
			try (SailDataset dataset = source.dataset(level);
					CloseableIteration<? extends Statement> iter = dataset.getStatements(subj, pred, obj, contexts)) {
				while (iter.hasNext()) {
					Statement statement = iter.next();
					LmdbTxnContext.Quad quad = new LmdbTxnContext.Quad(statement.getSubject(),
							statement.getPredicate(), statement.getObject(), statement.getContext());
					if (removed.add(quad)) {
						txnContext.recordRemove(statement.getSubject(), statement.getPredicate(), statement.getObject(),
								statement.getContext(), explicit);
					}
				}
			}
			return removed.size();
		}

		@Override
		public boolean deprecateByQuery(Resource subj, IRI pred, Value obj, Resource[] contexts) {
			return removeStatements(subj, pred, obj, explicit, contexts) > 0;
		}

		@Override
		public boolean supportsDeprecateByQuery() {
			return true;
		}
	}

	private final class LmdbSailDataset implements SailDataset {

		private final boolean explicit;
		private final Object contextKey;
		private final LmdbTxnContext txnContext;
		private final IsolationLevel level;
		private final Txn sharedTxn;

		public LmdbSailDataset(boolean explicit, Object contextKey, LmdbTxnContext txnContext, IsolationLevel level)
				throws SailException {
			this.explicit = explicit;
			this.contextKey = contextKey;
			this.txnContext = txnContext;
			this.level = level;
			Txn localTxn = null;
			LmdbSailStore.this.acquireCommitReadLock();
			try {
				if (txnContext != null) {
					localTxn = txnContext.acquireReadTxn(level);
				} else {
					localTxn = tripleStore.getTxnManager().createReadTxn();
				}
			} catch (IOException e) {
				if (localTxn != null) {
					localTxn.close();
				}
				throw new SailException(e);
			} finally {
				LmdbSailStore.this.releaseCommitReadLock();
			}
			this.sharedTxn = localTxn;
		}

		@Override
		public void close() {
			// close the associated txn
			try {
				if (sharedTxn != null) {
					sharedTxn.close();
				}
			} finally {
				if (txnContext != null) {
					txnContext.releaseReadSnapshot();
				}
				releaseContext(contextKey, txnContext);
			}
		}

		@Override
		public String getNamespace(String prefix) throws SailException {
			if (txnContext != null) {
				return txnContext.getNamespace(prefix);
			}
			return namespaceStore.getNamespace(prefix);
		}

		@Override
		public CloseableIteration<? extends Namespace> getNamespaces() {
			if (txnContext != null) {
				return new CloseableIteratorIteration<Namespace>(txnContext.getNamespaces().iterator());
			}
			return new CloseableIteratorIteration<Namespace>(namespaceStore.iterator());
		}

		@Override
		public CloseableIteration<? extends Resource> getContextIDs() throws SailException {
			recordObservedPattern(null, null, null);
			if (txnContext != null && txnContext.shouldOverlayChanges()) {
				LmdbTxnContext.ChangeView changeView = txnContext.snapshotChanges(explicit);
				if (!changeView.added.isEmpty() || !changeView.removed.isEmpty()) {
					Set<Resource> contexts = new LinkedHashSet<>();
					try (CloseableIteration<? extends Statement> iter = getStatements(null, null, null)) {
						while (iter.hasNext()) {
							Resource ctx = iter.next().getContext();
							if (ctx != null) {
								contexts.add(ctx);
							}
						}
					}
					return new CloseableIteratorIteration<>(contexts.iterator());
				}
			}
			try {
				return new LmdbContextIterator(tripleStore.getContexts(sharedTxn), valueStore);
			} catch (IOException e) {
				throw new SailException("Unable to get contexts", e);
			}
		}

		@Override
		public CloseableIteration<? extends Statement> getStatements(Resource subj, IRI pred, Value obj,
				Resource... contexts) throws SailException {
			recordObservedPattern(subj, pred, obj, contexts);
			try {
				CloseableIteration<? extends Statement> baseIter = createStatementIterator(sharedTxn, subj, pred, obj,
						explicit, contexts);
				if (txnContext == null || !txnContext.shouldOverlayChanges()) {
					return baseIter;
				}
				LmdbTxnContext.ChangeView changeView = txnContext.snapshotChanges(explicit);
				Set<LmdbTxnContext.Quad> added = changeView.added;
				Set<LmdbTxnContext.Quad> removed = new LinkedHashSet<>(changeView.removed);
				if (added.isEmpty() && removed.isEmpty()) {
					return baseIter;
				}
				boolean matchAllContexts = contexts.length == 0;
				Set<Resource> contextSet = matchAllContexts ? Set.of() : resolveContexts(contexts);
				if (!matchAllContexts && contextSet.isEmpty()) {
					baseIter.close();
					return CloseableIteration.EMPTY_STATEMENT_ITERATION;
				}
				CloseableIteration<? extends Statement> filtered = new FilterIteration<Statement>(baseIter) {
					@Override
					protected boolean accept(Statement st) throws SailException {
						LmdbTxnContext.Quad quad = toQuad(st);
						return !removed.contains(quad) && !added.contains(quad);
					}

					@Override
					protected void handleClose() {
						// handled by base iteration
					}
				};
				List<Statement> addedStatements = collectAddedStatements(added, removed, subj, pred, obj, contextSet,
						matchAllContexts);
				if (addedStatements.isEmpty()) {
					return filtered;
				}
				CloseableIteration<Statement> addedIter = new CloseableIteratorIteration<>(addedStatements.iterator());
				return new UnionIteration<>(List.of(filtered, addedIter));
			} catch (IOException e) {
				try {
					logger.warn("Failed to get statements, retrying", e);
					// try once more before giving up
					Thread.yield();
					Txn retryTxn = txnContext != null ? txnContext.acquireReadTxn(level)
							: tripleStore.getTxnManager().createReadTxn();
					CloseableIteration<? extends Statement> baseIter = createStatementIterator(retryTxn, subj, pred,
							obj,
							explicit, contexts);
					return new TxnClosingIteration<>(baseIter, retryTxn);
				} catch (IOException e2) {
					throw new SailException("Unable to get statements", e);
				}
			}
		}

		private Set<Resource> resolveContexts(Resource... contexts) {
			Set<Resource> resolved = new LinkedHashSet<>();
			for (Resource context : contexts) {
				if (context == null) {
					resolved.add(null);
				} else if (!context.isTriple()) {
					resolved.add(context);
				}
			}
			return resolved;
		}

		private void recordObservedPattern(Resource subj, IRI pred, Value obj, Resource... contexts) {
			if (txnContext == null || level == null || !level.isCompatibleWith(IsolationLevels.SERIALIZABLE)) {
				return;
			}
			Set<SimpleStatementPattern> patterns = new LinkedHashSet<>();
			if (contexts == null) {
				patterns.add(new SimpleStatementPattern(subj, pred, obj, null, false));
			} else if (contexts.length == 0) {
				patterns.add(new SimpleStatementPattern(subj, pred, obj, null, true));
			} else {
				for (Resource context : contexts) {
					patterns.add(new SimpleStatementPattern(subj, pred, obj, context, false));
				}
			}
			txnContext.recordObserved(explicit, patterns);
		}

		private final class TxnClosingIteration<T> extends IterationWrapper<T> {
			private final Txn txn;

			private TxnClosingIteration(CloseableIteration<? extends T> iter, Txn txn) {
				super(iter);
				this.txn = txn;
			}

			@Override
			protected void handleClose() {
				try {
					super.handleClose();
				} finally {
					txn.close();
				}
			}
		}

		private LmdbTxnContext.Quad toQuad(Statement statement) throws SailException {
			return new LmdbTxnContext.Quad(statement.getSubject(), statement.getPredicate(), statement.getObject(),
					statement.getContext());
		}

		private List<Statement> collectAddedStatements(Set<LmdbTxnContext.Quad> added, Set<LmdbTxnContext.Quad> removed,
				Resource subj, IRI pred, Value obj, Set<Resource> contextSet, boolean matchAllContexts)
				throws SailException {
			if (added.isEmpty()) {
				return List.of();
			}
			List<Statement> statements = new ArrayList<>();
			for (LmdbTxnContext.Quad quad : added) {
				if (removed.contains(quad)) {
					continue;
				}
				if (!matches(quad, subj, pred, obj, contextSet, matchAllContexts)) {
					continue;
				}
				statements.add(toStatement(quad));
			}
			return statements;
		}

		private boolean matches(LmdbTxnContext.Quad quad, Resource subj, IRI pred, Value obj,
				Set<Resource> contextSet, boolean matchAllContexts) {
			if (subj != null && !Objects.equals(subj, quad.subj)) {
				return false;
			}
			if (pred != null && !Objects.equals(pred, quad.pred)) {
				return false;
			}
			if (obj != null && !Objects.equals(obj, quad.obj)) {
				return false;
			}
			if (matchAllContexts) {
				return true;
			}
			return contextSet.contains(quad.ctx);
		}

		private Statement toStatement(LmdbTxnContext.Quad quad) throws SailException {
			return valueStore.createStatement(quad.subj, quad.pred, quad.obj, quad.ctx);
		}

		@Override
		public CloseableIteration<? extends Statement> getStatements(StatementOrder statementOrder, Resource subj,
				IRI pred, Value obj, Resource... contexts) throws SailException {
			throw new UnsupportedOperationException("Not implemented yet");
		}

		@Override
		public Set<StatementOrder> getSupportedOrders(Resource subj, IRI pred, Value obj, Resource... contexts) {
			return Set.of();
		}

		@Override
		public Comparator<Value> getComparator() {
			return null;
		}
	}
}
