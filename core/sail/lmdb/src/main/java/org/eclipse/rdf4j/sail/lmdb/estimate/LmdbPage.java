/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.sail.lmdb.estimate;

import java.io.IOException;
import java.nio.ByteBuffer;

final class LmdbPage {

	final long expectedPgno;
	final ByteBuffer buffer;
	final int pageSize;
	final long pgno;
	final int pad;
	final int flags;
	final int lower;
	final int upper;
	final int overflowPages;
	final int numKeys;

	private LmdbPage(long expectedPgno, ByteBuffer buffer, int pageSize, long pgno, int pad, int flags, int lower,
			int upper, int overflowPages, int numKeys) {
		this.expectedPgno = expectedPgno;
		this.buffer = buffer;
		this.pageSize = pageSize;
		this.pgno = pgno;
		this.pad = pad;
		this.flags = flags;
		this.lower = lower;
		this.upper = upper;
		this.overflowPages = overflowPages;
		this.numKeys = numKeys;
	}

	static LmdbPage parse(long expectedPgno, ByteBuffer page, int pageSize) throws IOException {
		if (page.remaining() < pageSize) {
			throw new IOException("Unexpected short page read for page " + expectedPgno);
		}
		long pgno = page.getLong(0);
		int pad = LmdbFormat.unsignedShort(page, 8);
		int flags = LmdbFormat.unsignedShort(page, 10);
		int lower;
		int upper;
		int overflowPages;
		int numKeys;

		if ((flags & LmdbFormat.P_OVERFLOW) != 0) {
			overflowPages = page.getInt(12);
			lower = 0;
			upper = 0;
			numKeys = 0;
		} else {
			lower = LmdbFormat.unsignedShort(page, 12);
			upper = LmdbFormat.unsignedShort(page, 14);
			overflowPages = 0;
			numKeys = LmdbFormat.numKeys(lower);
			if (lower < LmdbFormat.PAGE_HEADER_SIZE || lower > pageSize || upper < 0 || upper > pageSize
					|| upper < lower) {
				throw new IOException("Corrupt page bounds for page " + expectedPgno + ": lower=" + lower + ", upper="
						+ upper + ", pageSize=" + pageSize);
			}
			if (numKeys < 0 || numKeys > (pageSize - LmdbFormat.PAGE_HEADER_SIZE) / 2) {
				throw new IOException("Corrupt node count for page " + expectedPgno + ": " + numKeys);
			}
		}

		return new LmdbPage(expectedPgno, page, pageSize, pgno, pad, flags, lower, upper, overflowPages, numKeys);
	}

	boolean isBranch() {
		return (flags & LmdbFormat.P_BRANCH) != 0;
	}

	boolean isLeaf() {
		return (flags & LmdbFormat.P_LEAF) != 0;
	}

	boolean isLeaf2() {
		return (flags & LmdbFormat.P_LEAF2) != 0;
	}

	boolean isOverflow() {
		return (flags & LmdbFormat.P_OVERFLOW) != 0;
	}

	LmdbNode node(int index) throws IOException {
		if (index < 0 || index >= numKeys) {
			throw new IOException("Node index out of bounds " + index + " for page " + expectedPgno);
		}
		int ptrOffset = LmdbFormat.PAGE_HEADER_SIZE + (index * Short.BYTES);
		int nodeOffset = LmdbFormat.unsignedShort(buffer, ptrOffset);
		if (nodeOffset < LmdbFormat.PAGE_HEADER_SIZE || nodeOffset >= pageSize) {
			throw new IOException("Invalid node offset " + nodeOffset + " in page " + expectedPgno);
		}
		if (nodeOffset + LmdbFormat.NODE_SIZE > pageSize) {
			throw new IOException("Node header exceeds page bounds on page " + expectedPgno);
		}

		int keySize = LmdbFormat.unsignedShort(buffer, nodeOffset + LmdbFormat.NODE_KEYSIZE_OFFSET);
		int keyOffset = nodeOffset + LmdbFormat.NODE_DATA_OFFSET;
		if (keyOffset + keySize > pageSize) {
			throw new IOException("Node key exceeds page bounds on page " + expectedPgno);
		}

		if (isBranch()) {
			long childPgno = LmdbFormat.nodeBranchPgno(buffer, nodeOffset);
			return new LmdbNode(nodeOffset, keyOffset, keySize, -1, -1, 0, childPgno);
		}

		int nodeFlags = LmdbFormat.unsignedShort(buffer, nodeOffset + LmdbFormat.NODE_FLAGS_OFFSET);
		int valueSize = LmdbFormat.nodeDataSize(buffer, nodeOffset);
		int valueOffset = keyOffset + keySize;
		if (valueOffset + valueSize > pageSize) {
			throw new IOException("Node value exceeds page bounds on page " + expectedPgno);
		}
		return new LmdbNode(nodeOffset, keyOffset, keySize, valueOffset, valueSize, nodeFlags, -1);
	}

	void copyKey(int index, byte[] destination) throws IOException {
		LmdbNode node = node(index);
		buffer.position(node.keyOffset);
		buffer.get(destination, 0, node.keySize);
	}

}
