/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.sail.lmdb.benchmark;

import static org.junit.jupiter.api.Assertions.fail;

import java.io.File;
import java.io.IOException;

import org.eclipse.rdf4j.benchmark.common.ThemeQueryCatalog;
import org.eclipse.rdf4j.benchmark.rio.util.ThemeDataSetGenerator;
import org.eclipse.rdf4j.benchmark.rio.util.ThemeDataSetGenerator.Theme;
import org.eclipse.rdf4j.common.transaction.IsolationLevels;
import org.eclipse.rdf4j.query.TupleQueryResult;
import org.eclipse.rdf4j.query.algebra.evaluation.EvaluationStrategyFactory;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.StrictEvaluationStrategyFactory;
import org.eclipse.rdf4j.query.explanation.Explanation;
import org.eclipse.rdf4j.repository.sail.SailRepository;
import org.eclipse.rdf4j.repository.sail.SailRepositoryConnection;
import org.eclipse.rdf4j.repository.util.RDFInserter;
import org.eclipse.rdf4j.sail.lmdb.LmdbStore;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

class LmdbThemeQueryRegressionTest {

	private static final Theme THEME = Theme.PHARMA;
	private static final int ITERATIONS = 3;

	@TempDir
	File dataDir;

	@Test
	void pharmaQueryIndex8RepeatsCorrectly() throws IOException {
		assertQueryCountRepeated(8);
	}

	@Test
	void pharmaQueryIndex10RepeatsCorrectly() throws IOException {
		assertQueryCountRepeated(10);
	}

	@Test
	void pharmaQueryIndex8StrictEvaluationMatchesExpected() throws IOException {
		assertQueryCountRepeated(8, new StrictEvaluationStrategyFactory());
	}

	@Test
	void pharmaQueryIndex10StrictEvaluationMatchesExpected() throws IOException {
		assertQueryCountRepeated(10, new StrictEvaluationStrategyFactory());
	}

	private void assertQueryCountRepeated(int queryIndex) throws IOException {
		assertQueryCountRepeated(queryIndex, null);
	}

	private void assertQueryCountRepeated(int queryIndex, EvaluationStrategyFactory factory) throws IOException {
		LmdbStore store = new LmdbStore(dataDir, ConfigUtil.createConfig());
		if (factory != null) {
			store.setEvaluationStrategyFactory(factory);
		}
		SailRepository repository = new SailRepository(store);
		repository.init();
		try {
			loadData(repository);
			String query = ThemeQueryCatalog.queryFor(THEME, queryIndex);
			long expected = ThemeQueryCatalog.expectedCountFor(THEME, queryIndex);
			for (int iteration = 1; iteration <= ITERATIONS; iteration++) {
				long actual = executeCount(repository, query);
				if (actual != expected) {
					String plan = explain(repository, query);
					fail("Unexpected count for theme " + THEME + " queryIndex " + queryIndex
							+ " on iteration " + iteration + ": expected " + expected + " but got " + actual
							+ "\nOptimized plan:\n" + plan);
				}
			}
		} finally {
			repository.shutDown();
		}
	}

	private void loadData(SailRepository repository) throws IOException {
		try (SailRepositoryConnection connection = repository.getConnection()) {
			connection.begin(IsolationLevels.NONE);
			RDFInserter inserter = new RDFInserter(connection);
			ThemeDataSetGenerator.generate(THEME, inserter);
			connection.commit();
		}
	}

	private long executeCount(SailRepository repository, String query) {
		try (SailRepositoryConnection connection = repository.getConnection();
				TupleQueryResult result = connection.prepareTupleQuery(query).evaluate()) {
			long count = 0L;
			while (result.hasNext()) {
				result.next();
				count++;
			}
			return count;
		}
	}

	private String explain(SailRepository repository, String query) {
		try (SailRepositoryConnection connection = repository.getConnection()) {
			return connection.prepareTupleQuery(query)
					.explain(Explanation.Level.Optimized)
					.toString();
		}
	}
}
