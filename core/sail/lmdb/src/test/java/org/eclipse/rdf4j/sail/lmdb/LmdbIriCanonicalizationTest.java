/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.sail.lmdb;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.io.File;

import org.eclipse.rdf4j.common.transaction.IsolationLevels;
import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Statement;
import org.eclipse.rdf4j.model.ValueFactory;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.query.TupleQueryResult;
import org.eclipse.rdf4j.repository.sail.SailRepository;
import org.eclipse.rdf4j.repository.sail.SailRepositoryConnection;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

class LmdbIriCanonicalizationTest {

	private static final ValueFactory VF = SimpleValueFactory.getInstance();
	private static final String NS = "http://example.com/theme/pharma/";

	@TempDir
	File dataDir;

	@Test
	void sparqlConstantMatchesIriWithSlashInLocalName() {
		IRI subject = VF.createIRI(NS, "drug/1");
		IRI predicate = VF.createIRI(NS, "targets");
		IRI object = VF.createIRI(NS, "target/1");

		SailRepository repository = new SailRepository(new LmdbStore(dataDir));
		repository.init();
		try (SailRepositoryConnection connection = repository.getConnection()) {
			connection.begin(IsolationLevels.NONE);
			connection.add(subject, predicate, object);
			connection.commit();
		} finally {
			repository.shutDown();
		}

		SailRepository reopened = new SailRepository(new LmdbStore(dataDir));
		reopened.init();
		try {
			long directCount = countStatements(reopened, subject, predicate);
			String query = "SELECT ?o WHERE { <" + subject.stringValue() + "> <" + predicate.stringValue() + "> ?o }";
			long queryCount = countQueryResults(reopened, query);

			assertEquals(1L, directCount, "Expected direct getStatements to return the inserted triple");
			assertEquals(1L, queryCount,
					"Expected SPARQL constant to match stored IRI after reopen. directCount=" + directCount);
		} finally {
			reopened.shutDown();
		}
	}

	private static long countStatements(SailRepository repository, IRI subject, IRI predicate) {
		try (SailRepositoryConnection connection = repository.getConnection()) {
			try (var statements = connection.getStatements(subject, predicate, null)) {
				long count = 0L;
				while (statements.hasNext()) {
					Statement stmt = statements.next();
					if (stmt != null) {
						count++;
					}
				}
				return count;
			}
		}
	}

	private static long countQueryResults(SailRepository repository, String query) {
		try (SailRepositoryConnection connection = repository.getConnection();
				TupleQueryResult result = connection.prepareTupleQuery(query).evaluate()) {
			long count = 0L;
			while (result.hasNext()) {
				result.next();
				count++;
			}
			return count;
		}
	}
}
