/*******************************************************************************
 * Copyright (c) 2021 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.sail.lmdb;

import static org.junit.Assert.assertEquals;

import java.io.File;
import java.io.IOException;

import org.eclipse.rdf4j.sail.lmdb.TxnManager.Txn;
import org.eclipse.rdf4j.sail.lmdb.config.LmdbStoreConfig;
import org.eclipse.rdf4j.sail.lmdb.model.LmdbValue;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

/**
 * Low-level tests for {@link TripleStore}.
 */
public class CardinalityTest {

	@TempDir
	File tempFolder;

	protected TripleStore tripleStore;

	@BeforeEach
	public void before() throws Exception {
		File dataDir = new File(tempFolder, "triplestore");
		dataDir.mkdir();
		tripleStore = new TripleStore(dataDir, new LmdbStoreConfig("spoc,posc")
				.setPageCardinalityEstimator(true), null);
	}

	int count(RecordIterator it) {
		int count = 0;
		while (it.next() != null) {
			count++;
		}
		return count;
	}

	private int countBoth(Txn txn, long subj, long pred, long obj, long context) throws IOException {
		return count(tripleStore.getTriples(txn, subj, pred, obj, context, true))
				+ count(tripleStore.getTriples(txn, subj, pred, obj, context, false));
	}

	@Test
	public void testExactBoundCardinalityHitAndMiss() throws Exception {
		tripleStore.startTransaction();
		tripleStore.storeTriple(1, 2, 3, 4, true);
		tripleStore.commit();

		assertEquals(1.0, tripleStore.cardinality(1, 2, 3, 4), 0.0);
		assertEquals(0.0, tripleStore.cardinality(1, 2, 3, 5), 0.0);
	}

	@Test
	public void testNonContiguousConstraintRequiresMatcherFiltering() throws Exception {
		tripleStore.startTransaction();
		tripleStore.storeTriple(1, 10, 100, 7, true);
		tripleStore.storeTriple(1, 11, 101, 7, true);
		tripleStore.storeTriple(1, 12, 102, 8, true);
		tripleStore.storeTriple(1, 13, 103, 8, true);
		tripleStore.storeTriple(1, 14, 104, 8, true);
		tripleStore.storeTriple(1, 15, 105, 8, true);
		tripleStore.commit();

		try (Txn txn = tripleStore.getTxnManager().createReadTxn()) {
			int exact = count(tripleStore.getTriples(txn, 1, LmdbValue.UNKNOWN_ID, LmdbValue.UNKNOWN_ID, 7, true));
			assertEquals(2, exact);
			assertEquals((double) exact, tripleStore.cardinality(1, LmdbValue.UNKNOWN_ID, LmdbValue.UNKNOWN_ID, 7),
					0.0);
		}
	}

	@Test
	public void testUnboundPatternReturnsTotalExplicitAndInferredEntries() throws Exception {
		tripleStore.startTransaction();
		tripleStore.storeTriple(1, 2, 3, 4, true);
		tripleStore.storeTriple(5, 6, 7, 8, true);
		tripleStore.storeTriple(1, 2, 3, 4, false);
		tripleStore.commit();

		assertEquals(3.0,
				tripleStore.cardinality(LmdbValue.UNKNOWN_ID, LmdbValue.UNKNOWN_ID, LmdbValue.UNKNOWN_ID,
						LmdbValue.UNKNOWN_ID),
				0.0);
	}

	@Test
	public void testCardinalityMatchesIteratorAcrossMixedPatterns() throws Exception {
		tripleStore.startTransaction();
		tripleStore.storeTriple(1, 2, 3, 4, true);
		tripleStore.storeTriple(1, 5, 6, 7, true);
		tripleStore.storeTriple(2, 2, 3, 7, true);
		tripleStore.storeTriple(2, 8, 9, 10, true);
		tripleStore.storeTriple(1, 2, 9, 7, false);
		tripleStore.storeTriple(2, 2, 3, 11, false);
		tripleStore.storeTriple(3, 5, 6, 7, false);
		tripleStore.commit();

		try (Txn txn = tripleStore.getTxnManager().createReadTxn()) {
			assertEquals((double) countBoth(txn, 1, LmdbValue.UNKNOWN_ID, LmdbValue.UNKNOWN_ID, 7),
					tripleStore.cardinality(1, LmdbValue.UNKNOWN_ID, LmdbValue.UNKNOWN_ID, 7), 0.0);

			assertEquals((double) countBoth(txn, LmdbValue.UNKNOWN_ID, 2, LmdbValue.UNKNOWN_ID, 7),
					tripleStore.cardinality(LmdbValue.UNKNOWN_ID, 2, LmdbValue.UNKNOWN_ID, 7), 0.0);

			assertEquals((double) countBoth(txn, 2, LmdbValue.UNKNOWN_ID, LmdbValue.UNKNOWN_ID, LmdbValue.UNKNOWN_ID),
					tripleStore.cardinality(2, LmdbValue.UNKNOWN_ID, LmdbValue.UNKNOWN_ID, LmdbValue.UNKNOWN_ID), 0.0);

			assertEquals((double) countBoth(txn, LmdbValue.UNKNOWN_ID, 2, 3, LmdbValue.UNKNOWN_ID),
					tripleStore.cardinality(LmdbValue.UNKNOWN_ID, 2, 3, LmdbValue.UNKNOWN_ID), 0.0);
		}
	}

	@AfterEach
	public void after() throws Exception {
		tripleStore.close();
	}
}
