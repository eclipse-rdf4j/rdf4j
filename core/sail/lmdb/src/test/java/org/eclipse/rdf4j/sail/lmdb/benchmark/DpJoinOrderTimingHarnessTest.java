/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.sail.lmdb.benchmark;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Duration;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.LongAdder;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.eclipse.rdf4j.benchmark.common.ThemeQueryCatalog;
import org.eclipse.rdf4j.benchmark.rio.util.ThemeDataSetGenerator;
import org.eclipse.rdf4j.benchmark.rio.util.ThemeDataSetGenerator.Theme;
import org.eclipse.rdf4j.common.transaction.IsolationLevels;
import org.eclipse.rdf4j.query.TupleQuery;
import org.eclipse.rdf4j.query.TupleQueryResult;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.LearningEvaluationStrategyFactory;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.JoinStatsProvider;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.MemoryJoinStats;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.MemoryJoinStats.InvalidationSettings;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.PatternKey;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned.LearnedJoinConfig;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractQueryModelVisitor;
import org.eclipse.rdf4j.query.algebra.helpers.collectors.StatementPatternCollector;
import org.eclipse.rdf4j.query.explanation.Explanation;
import org.eclipse.rdf4j.queryrender.sparql.TupleExprIRRenderer;
import org.eclipse.rdf4j.repository.sail.SailRepository;
import org.eclipse.rdf4j.repository.sail.SailRepositoryConnection;
import org.eclipse.rdf4j.repository.util.RDFInserter;
import org.eclipse.rdf4j.sail.lmdb.LmdbStore;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

class DpJoinOrderTimingHarnessTest {

	private static final String EXPECTED_PLAN_DIR = "expected-plans";
	private static final String EXPECTED_PLAN_THEME_PROPERTY = "rdf4j.expectedPlans.theme";
	private static final String UPDATE_EXPECTED_PLANS_PROPERTY = "rdf4j.expectedPlans.update";
	private static final Duration CAPTURE_MAX_DURATION = Duration.ofSeconds(30);
	private static final Duration VERIFY_MIN_DURATION = Duration.ofSeconds(10);
	private static final Duration VERIFY_MAX_DURATION = Duration.ofSeconds(60);
	private static final int ITERATIONS = 100;
	private static final int AVERAGE_WINDOW = 20;
	private static final int EXPLAIN_TIMEOUT_SECONDS = 10;
	private static final int HIGHLY_CONNECTED_EXPLAIN_ITERATIONS = 20;
	private static final int STABILITY_ITERATIONS = 6;
	private static final String ANSI_RESET = "\u001B[0m";
	private static final String ANSI_GREEN = "\u001B[32m";
	private static final String ANSI_RED = "\u001B[31m";
	private static final String ANSI_YELLOW = "\u001B[33m";
	private static final Pattern VAR_NAME_PATTERN = Pattern.compile("name=([^,\\)]+)");
	private static final Pattern ANON_SUFFIX_PATTERN = Pattern.compile("^(.*_)([0-9A-Za-z]+)$");
	private static final Pattern ANON_TOKEN_PATTERN = Pattern.compile("(_anon_[A-Za-z0-9_]+)");
	private static final Pattern TIME_PATTERN = Pattern
			.compile("(totalTimeActual|selfTimeActual)=([0-9]+(?:\\.[0-9]+)?)(ms)");
	private static final Pattern ESTIMATE_PATTERN = Pattern
			.compile("(costEstimate|resultSizeEstimate)=([0-9]+(?:\\.[0-9]+)?)([KMBG]?)");
	private static final double ESTIMATE_TOLERANCE = 0.05d;

	@TempDir
	File dataDir;

	@Test
	void electricalGridQuery4() throws IOException {
		runScenario(Theme.ELECTRICAL_GRID, 4, "ELECTRICAL_GRID #4");
	}

	@Test
	void electricalGridQuery4PlanStable() throws IOException {
		assertPlanStable(Theme.ELECTRICAL_GRID, 4, STABILITY_ITERATIONS);
	}

	@Test
	void pharmaQuery6() throws IOException {
		runScenario(Theme.PHARMA, 6, "PHARMA #6");
	}

	@Test
	void highlyConnectedQuery10ExplainEvolution() throws IOException {
		runExplainEvolution(Theme.HIGHLY_CONNECTED, 10, "HIGHLY_CONNECTED #10", true);
	}

	@Test
	void test1() throws IOException {
		runExplainEvolution(Theme.LIBRARY, 10, "LIBRARY #1", true);
	}

	@Test
	void expectedPlansMatch() throws IOException {
		verifyExpectedPlans(VERIFY_MIN_DURATION, VERIFY_MAX_DURATION);
	}

	@Test
	void updateEngineeringExpectedPlans() throws IOException {
		if (!Boolean.getBoolean(UPDATE_EXPECTED_PLANS_PROPERTY)) {
			return;
		}
		updateExpectedPlans(Theme.ENGINEERING, CAPTURE_MAX_DURATION, index -> index != 4);
	}

	public static void main(String[] args) throws Exception {
		DpJoinOrderTimingHarnessTest harness = new DpJoinOrderTimingHarnessTest();
		harness.dataDir = Files.createTempDirectory("rdf4j-dp-plans").toFile();
		harness.captureExpectedPlans(CAPTURE_MAX_DURATION);
	}

	private void runScenario(Theme theme, int queryIndex, String label) throws IOException {
		runWithDpSetting(theme, queryIndex, label, true);
		runWithDpSetting(theme, queryIndex, label, false);
	}

	private void assertPlanStable(Theme theme, int queryIndex, int iterations) throws IOException {
		File scenarioDir = new File(dataDir, theme.name() + "_stability");
		SailRepository repository = createRepository(scenarioDir, true);
		try {
			loadData(repository, theme);
			String query = ThemeQueryCatalog.queryFor(theme, queryIndex);
			long expected = ThemeQueryCatalog.expectedCountFor(theme, queryIndex);
			List<String> baseline = null;
			try (SailRepositoryConnection connection = repository.getConnection()) {
				for (int i = 0; i < iterations; i++) {
					TupleQuery tupleQuery = connection.prepareTupleQuery(query);
					long count = executeCount(tupleQuery);
					if (count != expected) {
						throw new IllegalStateException(
								"Unexpected count for " + theme + " #" + queryIndex + ": expected " + expected
										+ " but got " + count);
					}
					TupleQuery explainQuery = connection.prepareTupleQuery(query);
					explainQuery.setMaxExecutionTime(EXPLAIN_TIMEOUT_SECONDS);
					Explanation explanation = explainQuery.explain(Explanation.Level.Executed);
					List<String> signature = joinOrderSignature(explanation);
					if (baseline == null) {
						baseline = signature;
					} else if (!baseline.equals(signature)) {
						throw new AssertionError("Join order drift for " + theme + " #" + queryIndex + " at iteration "
								+ (i + 1) + ": expected " + baseline + " but got " + signature);
					}
				}
			}
		} finally {
			repository.shutDown();
		}
	}

	private void runExplainEvolution(Theme theme, int queryIndex, String label, boolean enableDp) throws IOException {
		File scenarioDir = new File(dataDir, label.replace(' ', '_') + "_evolution_" + modeLabel(enableDp));
		long expected = ThemeQueryCatalog.expectedCountFor(theme, queryIndex);
		MemoryJoinStats learnedStats = new MemoryJoinStats(InvalidationSettings.disabled());
		RecordingJoinStatsProvider statsProvider = new RecordingJoinStatsProvider(learnedStats);
		LearnedJoinConfig config = new LearnedJoinConfig(LearnedJoinConfig.DEFAULT_DP_THRESHOLD, enableDp);
		LearningEvaluationStrategyFactory factory = new LearningEvaluationStrategyFactory(statsProvider, null, config);
		LmdbStore store = new LmdbStore(scenarioDir, ConfigUtil.createConfig());
		store.setEvaluationStrategyFactory(factory);

		SailRepository repository = new SailRepository(store);
		repository.init();
		try {
			loadData(repository, theme);
			String query = ThemeQueryCatalog.queryFor(theme, queryIndex);
			System.out.println("Original query:");
			System.out.println(query);
			System.out.println();
			runExplainLoop(repository, query, expected, label, enableDp, HIGHLY_CONNECTED_EXPLAIN_ITERATIONS);
		} finally {
			repository.shutDown();
		}
	}

	private void captureExpectedPlans(Duration maxDuration) throws IOException {
		Objects.requireNonNull(maxDuration, "maxDuration");
		Theme onlyTheme = selectedTheme();
		Path resourcesRoot = expectedPlansRoot();
		Files.createDirectories(resourcesRoot);
		for (Theme theme : Theme.values()) {
			if (onlyTheme != null && theme != onlyTheme) {
				continue;
			}
			Path themeDir = resourcesRoot.resolve(theme.name());
			Files.createDirectories(themeDir);
			File scenarioDir = new File(dataDir, theme.name() + "_expected");
			SailRepository repository = createRepository(scenarioDir, true);
			try {
				loadData(repository, theme);
				for (int index = 0; index < ThemeQueryCatalog.QUERY_COUNT; index++) {
					String query = ThemeQueryCatalog.queryFor(theme, index);
					long expected = ThemeQueryCatalog.expectedCountFor(theme, index);
					String plan = captureFinalExplanation(repository, query, expected, maxDuration);
					Path output = themeDir.resolve("query-" + index + ".txt");
					Files.writeString(output, plan + System.lineSeparator(), StandardCharsets.UTF_8);
					System.out.println("Wrote " + output);
				}
			} finally {
				repository.shutDown();
			}
		}
	}

	private void verifyExpectedPlans(Duration minDuration, Duration maxDuration) throws IOException {
		Objects.requireNonNull(minDuration, "minDuration");
		Objects.requireNonNull(maxDuration, "maxDuration");
		Theme onlyTheme = selectedTheme();
		Path resourcesRoot = expectedPlansRoot();
		for (Theme theme : Theme.values()) {
			if (onlyTheme != null && theme != onlyTheme) {
				continue;
			}
			File scenarioDir = new File(dataDir, theme.name() + "_verify");
			SailRepository repository = createRepository(scenarioDir, true);
			try {
				loadData(repository, theme);
				for (int index = 0; index < ThemeQueryCatalog.QUERY_COUNT; index++) {
					Path expectedPath = resourcesRoot.resolve(theme.name()).resolve("query-" + index + ".txt");
					if (!Files.exists(expectedPath)) {
						throw new IllegalStateException(
								"Missing expected plan: " + expectedPath + " (run main to generate)");
					}
					String expected = Files.readString(expectedPath, StandardCharsets.UTF_8).stripTrailing();
					String drift = verifyPlanWithTimeout(repository,
							ThemeQueryCatalog.queryFor(theme, index),
							ThemeQueryCatalog.expectedCountFor(theme, index),
							expected,
							minDuration,
							maxDuration,
							theme,
							index);
					if (drift != null) {
						System.out.println("Plan drift for " + theme + " #" + index);
						printDiff(expected, drift);
						throw new AssertionError("Plan drift for " + theme + " #" + index);
					}
				}
			} finally {
				repository.shutDown();
			}
		}
	}

	private void updateExpectedPlans(Theme theme, Duration maxDuration, java.util.function.IntPredicate includeIndex)
			throws IOException {
		Objects.requireNonNull(theme, "theme");
		Objects.requireNonNull(maxDuration, "maxDuration");
		Objects.requireNonNull(includeIndex, "includeIndex");
		Path themeDir = expectedPlansRoot().resolve(theme.name());
		Files.createDirectories(themeDir);
		File scenarioDir = new File(dataDir, theme.name() + "_expected_update");
		SailRepository repository = createRepository(scenarioDir, true);
		try {
			loadData(repository, theme);
			for (int index = 0; index < ThemeQueryCatalog.QUERY_COUNT; index++) {
				if (!includeIndex.test(index)) {
					continue;
				}
				String query = ThemeQueryCatalog.queryFor(theme, index);
				long expected = ThemeQueryCatalog.expectedCountFor(theme, index);
				String plan = captureFinalExplanation(repository, query, expected, maxDuration);
				Path output = themeDir.resolve("query-" + index + ".txt");
				Files.writeString(output, plan + System.lineSeparator(), StandardCharsets.UTF_8);
				System.out.println("Wrote " + output);
			}
		} finally {
			repository.shutDown();
		}
	}

	private Theme selectedTheme() {
		String value = System.getProperty(EXPECTED_PLAN_THEME_PROPERTY);
		if (value == null || value.isBlank()) {
			return null;
		}
		return Theme.valueOf(value.trim());
	}

	private SailRepository createRepository(File storeDir, boolean enableDp) {
		MemoryJoinStats learnedStats = new MemoryJoinStats(InvalidationSettings.disabled());
		RecordingJoinStatsProvider statsProvider = new RecordingJoinStatsProvider(learnedStats);
		LearnedJoinConfig config = new LearnedJoinConfig(LearnedJoinConfig.DEFAULT_DP_THRESHOLD, enableDp);
		LearningEvaluationStrategyFactory factory = new LearningEvaluationStrategyFactory(statsProvider, null, config);
		LmdbStore store = new LmdbStore(storeDir, ConfigUtil.createConfig());
		store.setEvaluationStrategyFactory(factory);
		SailRepository repository = new SailRepository(store);
		repository.init();
		return repository;
	}

	private String captureFinalExplanation(SailRepository repository, String query, long expected,
			Duration maxDuration) {
		long start = System.nanoTime();
		String plan = null;
		List<String> lastLines = null;
		while (Duration.ofNanos(System.nanoTime() - start).compareTo(maxDuration) < 0) {
			plan = executeAndExplain(repository, query, expected, lastLines, null);
			lastLines = plan == null ? lastLines : List.of(plan.split("\\R", -1));
		}
		return plan == null ? "<no-plan>" : plan;
	}

	private String verifyPlanWithTimeout(SailRepository repository, String query, long expected, String expectedPlan,
			Duration minDuration, Duration maxDuration, Theme theme, int index) {
		long start = System.nanoTime();
		List<String> expectedLines = List.of(expectedPlan.split("\\R", -1));
		List<String> lastLines = expectedLines;
		String actualPlan = null;
		while (true) {
			actualPlan = executeAndExplain(repository, query, expected, lastLines, expectedLines);
			Duration elapsed = Duration.ofNanos(System.nanoTime() - start);
			if (elapsed.compareTo(minDuration) >= 0 && expectedPlan.equals(actualPlan)) {
				return null;
			}
			if (elapsed.compareTo(maxDuration) >= 0) {
				return actualPlan;
			}
			System.out.println("Waiting for plan match " + theme + " #" + index + " elapsed=" + elapsed.toSeconds()
					+ "s");
		}
	}

	private String executeAndExplain(SailRepository repository, String query, long expected, List<String> previousLines,
			List<String> expectedLines) {
		Map<String, String> normalizedNames = new LinkedHashMap<>();
		Map<String, Integer> prefixCounters = new LinkedHashMap<>();
		try (SailRepositoryConnection connection = repository.getConnection()) {
			TupleQuery tupleQuery = connection.prepareTupleQuery(query);
			long count = executeCount(tupleQuery);
			if (count != expected) {
				throw new IllegalStateException("Unexpected count: expected " + expected + " but got " + count);
			}
			TupleQuery explainQuery = connection.prepareTupleQuery(query);
			explainQuery.setMaxExecutionTime(EXPLAIN_TIMEOUT_SECONDS);
			Explanation explanation = explainQuery.explain(Explanation.Level.Executed);
			List<String> normalized = normalizeExplainLines(explanation.toString(), normalizedNames, prefixCounters,
					expectedLines != null ? expectedLines : previousLines);
			return joinLines(normalized).stripTrailing();
		}
	}

	private void runWithDpSetting(Theme theme, int queryIndex, String label, boolean enableDp) throws IOException {
		File scenarioDir = new File(dataDir, label.replace(' ', '_') + (enableDp ? "_dp" : "_greedy"));
		long expected = ThemeQueryCatalog.expectedCountFor(theme, queryIndex);
		MemoryJoinStats learnedStats = new MemoryJoinStats(InvalidationSettings.disabled());
		RecordingJoinStatsProvider statsProvider = new RecordingJoinStatsProvider(learnedStats);
		LearnedJoinConfig config = new LearnedJoinConfig(LearnedJoinConfig.DEFAULT_DP_THRESHOLD, enableDp);
		LearningEvaluationStrategyFactory factory = new LearningEvaluationStrategyFactory(statsProvider, null, config);
		LmdbStore store = new LmdbStore(scenarioDir, ConfigUtil.createConfig());
		store.setEvaluationStrategyFactory(factory);

		SailRepository repository = new SailRepository(store);
		repository.init();
		try {
			loadData(repository, theme);
			String query = ThemeQueryCatalog.queryFor(theme, queryIndex);
			runLoop(repository, query, expected, label, enableDp, learnedStats, statsProvider);
		} finally {
			repository.shutDown();
		}
	}

	private void loadData(SailRepository repository, Theme theme) throws IOException {
		try (SailRepositoryConnection connection = repository.getConnection()) {
			connection.begin(IsolationLevels.NONE);
			RDFInserter inserter = new RDFInserter(connection);
			ThemeDataSetGenerator.generate(theme, inserter);
			connection.commit();
		}
	}

	private void runLoop(SailRepository repository, String query, long expected, String label, boolean enableDp,
			MemoryJoinStats learnedStats, RecordingJoinStatsProvider statsProvider) {
		long[] durations = new long[ITERATIONS];
		List<String> lastSignature = null;
		try (SailRepositoryConnection connection = repository.getConnection()) {
			for (int i = 0; i < ITERATIONS; i++) {
				TupleQuery tupleQuery = connection.prepareTupleQuery(query);
				long start = System.nanoTime();
				long count = executeCount(tupleQuery);
				long elapsed = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);
				durations[i] = elapsed;
				if (count != expected) {
					throw new IllegalStateException(
							"Unexpected count for " + label + ": expected " + expected + " but got " + count);
				}
				TupleQuery explainQuery = connection.prepareTupleQuery(query);
				explainQuery.setMaxExecutionTime(EXPLAIN_TIMEOUT_SECONDS);
				Explanation explanation = explainQuery.explain(Explanation.Level.Timed);
				List<String> signature = joinOrderSignature(explanation);
				if (lastSignature == null || !lastSignature.equals(signature)) {
					System.out.println(label + " " + modeLabel(enableDp) + " iteration " + (i + 1)
							+ " joinOrder=" + signature);
					Map<String, String> normalizedNames = new LinkedHashMap<>();
					Map<String, Integer> prefixCounters = new LinkedHashMap<>();
					List<String> explainLines = normalizeExplainLines(explanation.toString(), normalizedNames,
							prefixCounters, null);
					System.out.println(joinLines(explainLines));
				}
				lastSignature = signature;
			}
		}
		long average = averageLast(durations, AVERAGE_WINDOW);
		System.out.println(label + " " + modeLabel(enableDp) + " average last " + AVERAGE_WINDOW + " = " + average
				+ " ms");
		statsProvider.logStats(label, enableDp, learnedStats);
	}

	private void runExplainLoop(SailRepository repository, String query, long expected, String label, boolean enableDp,
			int iterations) {
		String lastExplainText = null;
		List<String> lastExplainLines = null;
		List<String> lastSignature = null;
		String lastRenderedQuery = null;
		TupleExprIRRenderer renderer = new TupleExprIRRenderer();
		try (SailRepositoryConnection connection = repository.getConnection()) {
			for (int i = 0; i < iterations; i++) {
				TupleQuery tupleQuery = connection.prepareTupleQuery(query);
				long count = executeCount(tupleQuery);
				if (count != expected) {
					throw new IllegalStateException(
							"Unexpected count for " + label + ": expected " + expected + " but got " + count);
				}
				TupleQuery explainQuery = connection.prepareTupleQuery(query);
				explainQuery.setMaxExecutionTime(EXPLAIN_TIMEOUT_SECONDS);
				Explanation explanation = explainQuery.explain(Explanation.Level.Executed);
				Map<String, String> normalizedNames = new LinkedHashMap<>();
				Map<String, Integer> prefixCounters = new LinkedHashMap<>();
				List<String> explainLines = normalizeExplainLines(explanation.toString(), normalizedNames,
						prefixCounters,
						lastExplainLines);
				String explainText = joinLines(explainLines);
				String renderedQuery = normalizeAnonTokensInText(renderOptimizedQuery(explanation, renderer),
						normalizedNames, prefixCounters);
				boolean explainChanged = lastExplainText == null || !lastExplainText.equals(explainText);
				boolean queryChanged = lastRenderedQuery == null || !lastRenderedQuery.equals(renderedQuery);
				List<String> signature = joinOrderSignature(explanation);
				if (explainChanged || queryChanged || lastSignature == null || !lastSignature.equals(signature)) {
					System.out.println(label + " " + modeLabel(enableDp) + " iteration " + (i + 1)
							+ " joinOrder=" + signature);
					if (explainChanged) {
						System.out.println("Executed plan (normalized):");
						if (lastExplainText == null) {
							System.out.println(explainText);
						} else {
							printDiff(lastExplainText, explainText);
						}
					}
					if (queryChanged) {
						System.out.println("Optimized SPARQL (TupleExprIRRenderer):");
						if (lastRenderedQuery == null) {
							System.out.println(renderedQuery);
						} else {
							printDiff(lastRenderedQuery, renderedQuery);
						}
					}
				} else if (lastSignature == null || !lastSignature.equals(signature)) {
					System.out.println(label + " " + modeLabel(enableDp) + " iteration " + (i + 1)
							+ " joinOrder=" + signature);
				}
				lastSignature = signature;
				lastExplainLines = explainLines;
				lastExplainText = explainText;
				lastRenderedQuery = renderedQuery;
			}
		}
	}

	private long executeCount(TupleQuery tupleQuery) {
		long count = 0L;
		try (TupleQueryResult result = tupleQuery.evaluate()) {
			while (result.hasNext()) {
				result.next();
				count++;
			}
		}
		return count;
	}

	private List<String> joinOrderSignature(Explanation explanation) {
		Object tupleExpr = explanation.tupleExpr();
		if (!(tupleExpr instanceof TupleExpr)) {
			return List.of("<no-tuple-expr>");
		}
		Join join = findLargestJoin((TupleExpr) tupleExpr);
		if (join == null) {
			return List.of("<no-join>");
		}
		List<TupleExpr> operands = flattenJoin(join);
		List<String> order = new ArrayList<>(operands.size());
		for (TupleExpr expr : operands) {
			List<StatementPattern> patterns = StatementPatternCollector.process(expr);
			if (patterns.isEmpty()) {
				order.add(expr.getClass().getSimpleName());
				continue;
			}
			Var predicate = patterns.get(0).getPredicateVar();
			order.add(predicateLabel(predicate));
		}
		return order;
	}

	private Join findLargestJoin(TupleExpr expr) {
		Join[] best = new Join[1];
		int[] bestSize = new int[1];
		expr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			public void meet(Join node) {
				int size = flattenJoin(node).size();
				if (size > bestSize[0]) {
					bestSize[0] = size;
					best[0] = node;
				}
				super.meet(node);
			}
		});
		return best[0];
	}

	private List<TupleExpr> flattenJoin(TupleExpr expr) {
		List<TupleExpr> operands = new ArrayList<>();
		Deque<TupleExpr> stack = new ArrayDeque<>();
		stack.push(expr);
		while (!stack.isEmpty()) {
			TupleExpr current = stack.pop();
			if (current instanceof Join) {
				Join join = (Join) current;
				stack.push(join.getRightArg());
				stack.push(join.getLeftArg());
			} else {
				operands.add(current);
			}
		}
		return operands;
	}

	private String predicateLabel(Var predicate) {
		if (predicate == null || !predicate.hasValue()) {
			return "<var>";
		}
		return predicate.getValue().stringValue();
	}

	private long averageLast(long[] values, int window) {
		int start = Math.max(0, values.length - window);
		long total = 0L;
		int count = 0;
		for (int i = start; i < values.length; i++) {
			total += values[i];
			count++;
		}
		return count == 0 ? 0L : total / count;
	}

	private Path expectedPlansRoot() {
		return repoRoot().resolve("core")
				.resolve("sail")
				.resolve("lmdb")
				.resolve("src")
				.resolve("test")
				.resolve("resources")
				.resolve(EXPECTED_PLAN_DIR);
	}

	private Path repoRoot() {
		String multiModuleRoot = System.getProperty("maven.multiModuleProjectDirectory");
		if (multiModuleRoot != null && !multiModuleRoot.isBlank()) {
			return Path.of(multiModuleRoot);
		}
		Path current = Path.of("").toAbsolutePath();
		for (Path candidate = current; candidate != null; candidate = candidate.getParent()) {
			if (Files.exists(candidate.resolve(".git"))) {
				return candidate;
			}
		}
		return current;
	}

	private List<String> normalizeExplainLines(String text, Map<String, String> normalizedNames,
			Map<String, Integer> prefixCounters, List<String> previousLines) {
		String[] lines = text.split("\\R", -1);
		List<String> normalized = new ArrayList<>(lines.length);
		for (int i = 0; i < lines.length; i++) {
			String line = lines[i];
			line = normalizeTiming(line);
			boolean normalizedVar = false;
			if (line.contains("Var (name=")) {
				line = normalizeVarLine(line, normalizedNames, prefixCounters);
				normalizedVar = true;
			}
			if (!normalizedVar && line.contains("_anon_")) {
				line = normalizeAnonTokensInText(line, normalizedNames, prefixCounters);
			}
			if (previousLines != null && i < previousLines.size()) {
				line = normalizeEstimates(line, previousLines.get(i));
			}
			normalized.add(line);
		}
		return normalized;
	}

	private String joinLines(List<String> lines) {
		if (lines.isEmpty()) {
			return "";
		}
		StringBuilder joined = new StringBuilder();
		for (int i = 0; i < lines.size(); i++) {
			joined.append(lines.get(i));
			if (i < lines.size() - 1) {
				joined.append(System.lineSeparator());
			}
		}
		return joined.toString();
	}

	private String normalizeTiming(String line) {
		Matcher matcher = TIME_PATTERN.matcher(line);
		StringBuilder normalized = new StringBuilder(line.length());
		int last = 0;
		while (matcher.find()) {
			normalized.append(line, last, matcher.start(2));
			normalized.append("<t>");
			normalized.append(matcher.group(3));
			last = matcher.end(3);
		}
		if (last == 0) {
			return line;
		}
		normalized.append(line, last, line.length());
		return normalized.toString();
	}

	private String normalizeEstimates(String line, String previousLine) {
		Map<String, EstimateValue> previous = extractEstimates(previousLine);
		if (previous.isEmpty()) {
			return line;
		}
		Matcher matcher = ESTIMATE_PATTERN.matcher(line);
		StringBuilder normalized = new StringBuilder(line.length());
		int last = 0;
		while (matcher.find()) {
			String key = matcher.group(1);
			EstimateValue previousValue = previous.get(key);
			String replacement = matcher.group(2) + matcher.group(3);
			if (previousValue != null) {
				double currentValue = parseEstimate(matcher.group(2), matcher.group(3));
				if (Double.isFinite(currentValue) && Double.isFinite(previousValue.value)) {
					double denom = Math.max(previousValue.value, 1.0e-12d);
					if (Math.abs(currentValue - previousValue.value) / denom <= ESTIMATE_TOLERANCE) {
						replacement = previousValue.original;
					}
				}
			}
			normalized.append(line, last, matcher.start(2));
			normalized.append(replacement);
			last = matcher.end(3);
		}
		normalized.append(line, last, line.length());
		return normalized.toString();
	}

	private Map<String, EstimateValue> extractEstimates(String line) {
		Matcher matcher = ESTIMATE_PATTERN.matcher(line);
		Map<String, EstimateValue> values = new LinkedHashMap<>();
		while (matcher.find()) {
			String key = matcher.group(1);
			String original = matcher.group(2) + matcher.group(3);
			double value = parseEstimate(matcher.group(2), matcher.group(3));
			values.put(key, new EstimateValue(value, original));
		}
		return values;
	}

	private double parseEstimate(String number, String suffix) {
		double base;
		try {
			base = Double.parseDouble(number);
		} catch (NumberFormatException e) {
			return Double.NaN;
		}
		if (suffix == null || suffix.isEmpty()) {
			return base;
		}
		switch (suffix.charAt(0)) {
		case 'K':
		case 'k':
			return base * 1.0e3d;
		case 'M':
		case 'm':
			return base * 1.0e6d;
		case 'B':
		case 'b':
			return base * 1.0e9d;
		case 'G':
		case 'g':
			return base * 1.0e9d;
		default:
			return Double.NaN;
		}
	}

	private String renderOptimizedQuery(Explanation explanation, TupleExprIRRenderer renderer) {
		Object tupleExpr = explanation.tupleExpr();
		if (!(tupleExpr instanceof TupleExpr)) {
			return "<no-tuple-expr>";
		}

		return renderer.render((TupleExpr) tupleExpr).trim();
	}

	private String normalizeVarLine(String line, Map<String, String> normalizedNames,
			Map<String, Integer> prefixCounters) {
		Matcher matcher = VAR_NAME_PATTERN.matcher(line);
		if (!matcher.find()) {
			return line;
		}
		String name = matcher.group(1);
		if (!name.startsWith("_anon_")) {
			return line;
		}
		String normalized = normalizedNames.get(name);
		if (normalized == null) {
			String base = normalizedPrefix(name);
			int next = prefixCounters.merge(base, 1, Integer::sum);
			normalized = base + next;
			normalizedNames.put(name, normalized);
		}
		return line.substring(0, matcher.start(1)) + normalized + line.substring(matcher.end(1));
	}

	private String normalizedPrefix(String name) {
		Matcher matcher = ANON_SUFFIX_PATTERN.matcher(name);
		String base = name;
		if (matcher.matches()) {
			base = matcher.group(1);
		}
		if (!base.endsWith("_")) {
			base = base + "_";
		}
		return base;
	}

	private String normalizeAnonTokensInText(String text, Map<String, String> normalizedNames,
			Map<String, Integer> prefixCounters) {
		if (!text.contains("_anon_")) {
			return text;
		}
		Matcher matcher = ANON_TOKEN_PATTERN.matcher(text);
		StringBuilder normalized = new StringBuilder(text.length());
		int last = 0;
		while (matcher.find()) {
			String token = matcher.group(1);
			String normalizedToken = normalizedNames.get(token);
			if (normalizedToken == null) {
				String prefix = normalizedPrefix(token);
				int next = prefixCounters.merge(prefix, 1, Integer::sum);
				normalizedToken = prefix + next;
				normalizedNames.put(token, normalizedToken);
			}
			normalized.append(text, last, matcher.start(1));
			normalized.append(normalizedToken);
			last = matcher.end(1);
		}
		normalized.append(text, last, text.length());
		return normalized.toString();
	}

	private static final class EstimateValue {
		private final double value;
		private final String original;

		private EstimateValue(double value, String original) {
			this.value = value;
			this.original = original;
		}
	}

	private void printDiff(String before, String after) {
		List<String> diff = diffLines(before, after);
		int unchangedRun = 0;
		for (int i = 0; i < diff.size(); i++) {
			String line = diff.get(i);
			boolean unchanged = line.startsWith("  ");
			if (unchanged) {
				unchangedRun++;
				continue;
			}
			flushUnchanged(diff, i - unchangedRun, unchangedRun);
			unchangedRun = 0;
			System.out.println(line);
		}
		flushUnchanged(diff, diff.size() - unchangedRun, unchangedRun);
	}

	private void flushUnchanged(List<String> diff, int start, int count) {
		if (count == 0) {
			return;
		}
		int keep = 3;
		if (count <= keep * 2) {
			for (int i = start; i < start + count; i++) {
				System.out.println(diff.get(i));
			}
			return;
		}
		for (int i = start; i < start + keep; i++) {
			System.out.println(diff.get(i));
		}
		System.out.println(ANSI_YELLOW + "  ... " + (count - keep * 2) + " lines unchanged ..." + ANSI_RESET);
		for (int i = start + count - keep; i < start + count; i++) {
			System.out.println(diff.get(i));
		}
	}

	private List<String> diffLines(String before, String after) {
		List<String> left = List.of(before.split("\\R", -1));
		List<String> right = List.of(after.split("\\R", -1));
		int n = left.size();
		int m = right.size();
		int[][] lcs = new int[n + 1][m + 1];
		for (int i = n - 1; i >= 0; i--) {
			for (int j = m - 1; j >= 0; j--) {
				if (left.get(i).equals(right.get(j))) {
					lcs[i][j] = lcs[i + 1][j + 1] + 1;
				} else {
					lcs[i][j] = Math.max(lcs[i + 1][j], lcs[i][j + 1]);
				}
			}
		}
		List<String> diff = new ArrayList<>();
		int i = 0;
		int j = 0;
		while (i < n && j < m) {
			String leftLine = left.get(i);
			String rightLine = right.get(j);
			if (leftLine.equals(rightLine)) {
				diff.add("  " + leftLine);
				i++;
				j++;
				continue;
			}
			if (lcs[i + 1][j] >= lcs[i][j + 1]) {
				diff.add(ANSI_RED + "- " + leftLine + ANSI_RESET);
				i++;
			} else {
				diff.add(ANSI_GREEN + "+ " + rightLine + ANSI_RESET);
				j++;
			}
		}
		while (i < n) {
			diff.add(ANSI_RED + "- " + left.get(i++) + ANSI_RESET);
		}
		while (j < m) {
			diff.add(ANSI_GREEN + "+ " + right.get(j++) + ANSI_RESET);
		}
		return diff;
	}

	private String modeLabel(boolean enableDp) {
		return enableDp ? "DP" : "Greedy";
	}

	private static final class RecordingJoinStatsProvider implements JoinStatsProvider {

		private static final class Entry {
			private final LongAdder calls = new LongAdder();
			private final LongAdder results = new LongAdder();
		}

		private final JoinStatsProvider delegate;
		private final Map<PatternKey, Entry> entries = new ConcurrentHashMap<>();

		private RecordingJoinStatsProvider(JoinStatsProvider delegate) {
			this.delegate = delegate;
		}

		@Override
		public void reset() {
			delegate.reset();
			entries.clear();
		}

		@Override
		public void recordCall(PatternKey key) {
			entries.computeIfAbsent(key, ignored -> new Entry()).calls.increment();
			delegate.recordCall(key);
		}

		@Override
		public void recordResults(PatternKey key, long resultCount) {
			entries.computeIfAbsent(key, ignored -> new Entry()).results.add(Math.max(0L, resultCount));
			delegate.recordResults(key, resultCount);
		}

		@Override
		public void seedIfAbsent(PatternKey key, double defaultCardinality, long priorCalls) {
			delegate.seedIfAbsent(key, defaultCardinality, priorCalls);
		}

		@Override
		public double getAverageResults(PatternKey key) {
			return delegate.getAverageResults(key);
		}

		@Override
		public double getMaxResults(PatternKey key) {
			return delegate.getMaxResults(key);
		}

		@Override
		public boolean hasStats(PatternKey key) {
			return delegate.hasStats(key);
		}

		@Override
		public long getTotalCalls() {
			return delegate.getTotalCalls();
		}

		@Override
		public void recordStatementsAdded(long statementCount) {
			delegate.recordStatementsAdded(statementCount);
		}

		private void logStats(String label, boolean enableDp, MemoryJoinStats learnedStats) {
			String header = label + " " + (enableDp ? "DP" : "Greedy") + " learned stats";
			System.out.println(header + " entries=" + entries.size());
			entries.entrySet()
					.stream()
					.sorted(Map.Entry.comparingByKey((a, b) -> a.toString().compareTo(b.toString())))
					.forEach(entry -> {
						PatternKey key = entry.getKey();
						Entry stats = entry.getValue();
						long calls = stats.calls.sum();
						double avg = calls == 0 ? 0.0d : stats.results.sum() / (double) calls;
						double learnedAvg = learnedStats.getAverageResults(key);
						System.out.println("  " + key + " calls=" + calls + " avg=" + avg + " learnedAvg="
								+ learnedAvg);
					});
		}
	}
}
