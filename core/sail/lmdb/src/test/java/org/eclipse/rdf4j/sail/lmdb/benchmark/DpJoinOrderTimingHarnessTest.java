/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.sail.lmdb.benchmark;

import static org.junit.jupiter.api.Assumptions.assumeTrue;

import java.io.File;
import java.io.IOException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;
import java.util.concurrent.TimeUnit;

import org.eclipse.rdf4j.benchmark.common.ThemeQueryCatalog;
import org.eclipse.rdf4j.benchmark.rio.util.ThemeDataSetGenerator;
import org.eclipse.rdf4j.benchmark.rio.util.ThemeDataSetGenerator.Theme;
import org.eclipse.rdf4j.common.transaction.IsolationLevels;
import org.eclipse.rdf4j.query.TupleQuery;
import org.eclipse.rdf4j.query.TupleQueryResult;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.LearningEvaluationStrategyFactory;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.MemoryJoinStats;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.MemoryJoinStats.InvalidationSettings;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned.LearnedJoinConfig;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractQueryModelVisitor;
import org.eclipse.rdf4j.query.algebra.helpers.collectors.StatementPatternCollector;
import org.eclipse.rdf4j.query.explanation.Explanation;
import org.eclipse.rdf4j.repository.sail.SailRepository;
import org.eclipse.rdf4j.repository.sail.SailRepositoryConnection;
import org.eclipse.rdf4j.repository.util.RDFInserter;
import org.eclipse.rdf4j.sail.lmdb.LmdbStore;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

class DpJoinOrderTimingHarnessTest {

	private static final String ENABLE_PROPERTY = "rdf4j.dp.timing.harness";
	private static final int ITERATIONS = 100;
	private static final int AVERAGE_WINDOW = 20;

	@TempDir
	File dataDir;

	@Test
	void electricalGridQuery4() throws IOException {
		assumeEnabled();
		runScenario(Theme.ELECTRICAL_GRID, 4, "ELECTRICAL_GRID #4");
	}

	@Test
	void pharmaQuery6() throws IOException {
		assumeEnabled();
		runScenario(Theme.PHARMA, 6, "PHARMA #6");
	}

	private void runScenario(Theme theme, int queryIndex, String label) throws IOException {
		runWithDpSetting(theme, queryIndex, label, true);
		runWithDpSetting(theme, queryIndex, label, false);
	}

	private void runWithDpSetting(Theme theme, int queryIndex, String label, boolean enableDp) throws IOException {
		File scenarioDir = new File(dataDir, label.replace(' ', '_') + (enableDp ? "_dp" : "_greedy"));
		long expected = ThemeQueryCatalog.expectedCountFor(theme, queryIndex);
		MemoryJoinStats statsProvider = new MemoryJoinStats(InvalidationSettings.disabled());
		LearnedJoinConfig config = new LearnedJoinConfig(LearnedJoinConfig.DEFAULT_DP_THRESHOLD, enableDp);
		LearningEvaluationStrategyFactory factory = new LearningEvaluationStrategyFactory(statsProvider, null, config);
		LmdbStore store = new LmdbStore(scenarioDir, ConfigUtil.createConfig());
		store.setEvaluationStrategyFactory(factory);

		SailRepository repository = new SailRepository(store);
		repository.init();
		try {
			loadData(repository, theme);
			String query = ThemeQueryCatalog.queryFor(theme, queryIndex);
			runLoop(repository, query, expected, label, enableDp);
		} finally {
			repository.shutDown();
		}
	}

	private void loadData(SailRepository repository, Theme theme) throws IOException {
		try (SailRepositoryConnection connection = repository.getConnection()) {
			connection.begin(IsolationLevels.NONE);
			RDFInserter inserter = new RDFInserter(connection);
			ThemeDataSetGenerator.generate(theme, inserter);
			connection.commit();
		}
	}

	private void runLoop(SailRepository repository, String query, long expected, String label, boolean enableDp) {
		long[] durations = new long[ITERATIONS];
		List<String> lastSignature = null;
		try (SailRepositoryConnection connection = repository.getConnection()) {
			TupleQuery tupleQuery = connection.prepareTupleQuery(query);
			for (int i = 0; i < ITERATIONS; i++) {
				long start = System.nanoTime();
				long count = executeCount(tupleQuery);
				long elapsed = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);
				durations[i] = elapsed;
				if (count != expected) {
					throw new IllegalStateException(
							"Unexpected count for " + label + ": expected " + expected + " but got " + count);
				}
				Explanation explanation = connection.prepareTupleQuery(query).explain(Explanation.Level.Optimized);
				List<String> signature = joinOrderSignature(explanation);
				if (lastSignature == null || !lastSignature.equals(signature)) {
					System.out.println(label + " " + modeLabel(enableDp) + " iteration " + (i + 1)
							+ " joinOrder=" + signature);
					System.out.println(explanation);
				}
				lastSignature = signature;
			}
		}
		long average = averageLast(durations, AVERAGE_WINDOW);
		System.out.println(label + " " + modeLabel(enableDp) + " average last " + AVERAGE_WINDOW + " = " + average
				+ " ms");
	}

	private long executeCount(TupleQuery tupleQuery) {
		long count = 0L;
		try (TupleQueryResult result = tupleQuery.evaluate()) {
			while (result.hasNext()) {
				result.next();
				count++;
			}
		}
		return count;
	}

	private List<String> joinOrderSignature(Explanation explanation) {
		Object tupleExpr = explanation.tupleExpr();
		if (!(tupleExpr instanceof TupleExpr)) {
			return List.of("<no-tuple-expr>");
		}
		Join join = findLargestJoin((TupleExpr) tupleExpr);
		if (join == null) {
			return List.of("<no-join>");
		}
		List<TupleExpr> operands = flattenJoin(join);
		List<String> order = new ArrayList<>(operands.size());
		for (TupleExpr expr : operands) {
			List<StatementPattern> patterns = StatementPatternCollector.process(expr);
			if (patterns.isEmpty()) {
				order.add(expr.getClass().getSimpleName());
				continue;
			}
			Var predicate = patterns.get(0).getPredicateVar();
			order.add(predicateLabel(predicate));
		}
		return order;
	}

	private Join findLargestJoin(TupleExpr expr) {
		Join[] best = new Join[1];
		int[] bestSize = new int[1];
		expr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			public void meet(Join node) {
				int size = flattenJoin(node).size();
				if (size > bestSize[0]) {
					bestSize[0] = size;
					best[0] = node;
				}
				super.meet(node);
			}
		});
		return best[0];
	}

	private List<TupleExpr> flattenJoin(TupleExpr expr) {
		List<TupleExpr> operands = new ArrayList<>();
		Deque<TupleExpr> stack = new ArrayDeque<>();
		stack.push(expr);
		while (!stack.isEmpty()) {
			TupleExpr current = stack.pop();
			if (current instanceof Join) {
				Join join = (Join) current;
				stack.push(join.getRightArg());
				stack.push(join.getLeftArg());
			} else {
				operands.add(current);
			}
		}
		return operands;
	}

	private String predicateLabel(Var predicate) {
		if (predicate == null || !predicate.hasValue()) {
			return "<var>";
		}
		return predicate.getValue().stringValue();
	}

	private long averageLast(long[] values, int window) {
		int start = Math.max(0, values.length - window);
		long total = 0L;
		int count = 0;
		for (int i = start; i < values.length; i++) {
			total += values[i];
			count++;
		}
		return count == 0 ? 0L : total / count;
	}

	private void assumeEnabled() {
		assumeTrue(Boolean.getBoolean(ENABLE_PROPERTY),
				() -> "Set -D" + ENABLE_PROPERTY + "=true to run the timing harness");
	}

	private String modeLabel(boolean enableDp) {
		return enableDp ? "DP" : "Greedy";
	}
}
