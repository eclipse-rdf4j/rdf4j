/*******************************************************************************
 * Copyright (c) 2023 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.sail.elasticsearchstore;

import java.io.IOException;
import java.lang.reflect.Type;
import java.util.Map;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.testcontainers.containers.GenericContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

import com.fasterxml.jackson.core.type.TypeReference;

import co.elastic.clients.elasticsearch.core.SearchResponse;
import co.elastic.clients.elasticsearch.core.search.Hit;

@Testcontainers
public abstract class AbstractElasticsearchStoreIT {

	private static final Logger logger = LoggerFactory.getLogger(AbstractElasticsearchStoreIT.class);
	private static final Type MAP_TYPE = new TypeReference<Map<String, Object>>() {
	}.getType();

	@Container
	private static final GenericContainer<?> elasticsearchContainer = ElasticsearchStoreTestContainerSupport
			.getContainer();

	@BeforeAll
	public static void beforeClass() {
		TestHelpers.openClient();
	}

	@AfterAll
	public static void afterClass() throws IOException {
		TestHelpers.closeClient();
	}

	@AfterEach
	public void after() throws IOException {
		TestHelpers.getClient().indices().refresh(r -> r.index("*"));
		printAllDocs();
		deleteAllIndexes();
	}

	protected void printAllDocs() throws IOException {
		for (String index : getIndexes()) {
			if (!index.equals(".geoip_databases")) {
				logger.info("INDEX: " + index);
				SearchResponse<Map<String, Object>> res = TestHelpers.getClient()
						.search(s -> s.index(index).query(q -> q.matchAll(m -> m)), MAP_TYPE);
				for (Hit<Map<String, Object>> hit : res.hits().hits()) {
					logger.info(" doc " + hit.source());
				}
			}
		}
	}

	protected void deleteAllIndexes() throws IOException {
		for (String index : getIndexes()) {
			if (!index.equals(".geoip_databases")) {
				logger.info("deleting index: " + index);
				TestHelpers.getClient().indices().delete(d -> d.index(index));
			}
		}
	}

	protected String[] getIndexes() {
		try {
			return TestHelpers.getClient()
					.indices()
					.get(g -> g.index("*"))
					.indices()
					.keySet()
					.toArray(new String[0]);
		} catch (IOException e) {
			throw new IllegalStateException(e);
		}
	}

	protected static String elasticsearchHost() {
		return ElasticsearchStoreTestContainerSupport.getHost();
	}

	protected static int elasticsearchPort() {
		return ElasticsearchStoreTestContainerSupport.getHttpPort();
	}

	protected static String elasticsearchCluster() {
		return ElasticsearchStoreTestContainerSupport.getClusterName();
	}
}
