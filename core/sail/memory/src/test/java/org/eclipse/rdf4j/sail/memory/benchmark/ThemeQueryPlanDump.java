/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.sail.memory.benchmark;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;

import org.eclipse.rdf4j.benchmark.common.ThemeQueryCatalog;
import org.eclipse.rdf4j.benchmark.rio.util.ThemeDataSetGenerator;
import org.eclipse.rdf4j.benchmark.rio.util.ThemeDataSetGenerator.Theme;
import org.eclipse.rdf4j.common.transaction.IsolationLevels;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.evaluation.EvaluationStrategy;
import org.eclipse.rdf4j.query.algebra.evaluation.EvaluationStrategyFactory;
import org.eclipse.rdf4j.query.algebra.evaluation.TripleSource;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.DefaultEvaluationStrategyFactory;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.StandardQueryOptimizerPipeline;
import org.eclipse.rdf4j.query.explanation.Explanation;
import org.eclipse.rdf4j.repository.sail.SailRepository;
import org.eclipse.rdf4j.repository.sail.SailRepositoryConnection;
import org.eclipse.rdf4j.repository.util.RDFInserter;
import org.eclipse.rdf4j.sail.memory.MemoryStore;

public final class ThemeQueryPlanDump {

	private static final String[] THEMES = {
			"MEDICAL_RECORDS",
			"SOCIAL_MEDIA",
			"LIBRARY",
			"ENGINEERING",
			"HIGHLY_CONNECTED",
			"TRAIN",
			"ELECTRICAL_GRID",
			"PHARMA"
	};

	private static final int[] QUERY_INDEXES = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	public static void main(String[] args) throws Exception {
		Config config = Config.parse(args);
		List<String> themeNames = config.themeNames;
		List<Integer> queryIndexes = config.queryIndexes;
		boolean[] useSparqlUoValues = config.useSparqlUoValues;
		Path outputRoot = config.outputRoot;

		for (String themeName : themeNames) {
			Theme theme = Theme.valueOf(themeName);
			for (boolean useSparqlUo : useSparqlUoValues) {
				SailRepository repository = createRepository(useSparqlUo);
				try {
					loadData(repository, theme);
					for (int queryIndex : queryIndexes) {
						writeExplanation(repository, theme, queryIndex, useSparqlUo, outputRoot);
					}
				} finally {
					repository.shutDown();
				}
			}
		}
	}

	private static void writeExplanation(SailRepository repository, Theme theme, int queryIndex, boolean useSparqlUo,
			Path outputRoot) throws IOException {
		System.out.println("Generating plan explanation for Theme=" + theme.name() + ", QueryIndex=" + queryIndex
				+ ", UseSparqlUo=" + useSparqlUo);
		String query = ThemeQueryCatalog.queryFor(theme, queryIndex);
		long expected = ThemeQueryCatalog.expectedCountFor(theme, queryIndex);
		String explanation = explain(repository, query);
		Path outputPath = outputRoot
				.resolve(useSparqlUo ? "sparqluo" : "standard")
				.resolve(theme.name())
				.resolve(String.format(Locale.ROOT, "q%02d.txt", queryIndex));
		Files.createDirectories(outputPath.getParent());
		StringBuilder builder = new StringBuilder();
		builder.append("Theme: ").append(theme.name()).append('\n');
		builder.append("QueryIndex: ").append(queryIndex).append('\n');
		builder.append("UseSparqlUo: ").append(useSparqlUo).append('\n');
		builder.append("ExpectedCount: ").append(expected).append('\n');
		builder.append("Query:\n").append(query).append('\n');
		builder.append("Explanation:\n").append(explanation).append('\n');
		Files.writeString(outputPath, builder.toString(), StandardCharsets.UTF_8);
	}

	private static String explain(SailRepository repository, String query) {
		try (SailRepositoryConnection connection = repository.getConnection()) {
			return connection.prepareTupleQuery(query).explain(Explanation.Level.Executed).toString();
		}
	}

	private static void loadData(SailRepository repository, Theme theme) throws IOException {
		try (SailRepositoryConnection connection = repository.getConnection()) {
			connection.begin(IsolationLevels.NONE);
			RDFInserter inserter = new RDFInserter(connection);
			ThemeDataSetGenerator.generate(theme, inserter);
			connection.commit();
		}
	}

	private static SailRepository createRepository(boolean useSparqlUo) {
		MemoryStore store = new MemoryStore();
		if (!useSparqlUo) {
			store.setEvaluationStrategyFactory(createStandardPipelineFactory(store));
		}
		return new SailRepository(store);
	}

	private static EvaluationStrategyFactory createStandardPipelineFactory(MemoryStore store) {
		DefaultEvaluationStrategyFactory factory = new DefaultEvaluationStrategyFactory(
				store.getFederatedServiceResolver()) {
			@Override
			public EvaluationStrategy createEvaluationStrategy(Dataset dataset, TripleSource tripleSource,
					EvaluationStatistics evaluationStatistics) {
				EvaluationStrategy strategy = super.createEvaluationStrategy(dataset, tripleSource,
						evaluationStatistics);
				strategy.setOptimizerPipeline(
						new StandardQueryOptimizerPipeline(strategy, tripleSource, evaluationStatistics));
				return strategy;
			}
		};
		factory.setQuerySolutionCacheThreshold(store.getIterationCacheSyncThreshold());
		factory.setTrackResultSize(store.isTrackResultSize());
		return factory;
	}

	private static final class Config {
		private final List<String> themeNames;
		private final List<Integer> queryIndexes;
		private final boolean[] useSparqlUoValues;
		private final Path outputRoot;

		private Config(List<String> themeNames, List<Integer> queryIndexes, boolean[] useSparqlUoValues,
				Path outputRoot) {
			this.themeNames = themeNames;
			this.queryIndexes = queryIndexes;
			this.useSparqlUoValues = useSparqlUoValues;
			this.outputRoot = outputRoot;
		}

		private static Config parse(String[] args) {
			List<String> themeNames = new ArrayList<>(Arrays.asList(THEMES));
			List<Integer> queryIndexes = new ArrayList<>();
			for (int queryIndex : QUERY_INDEXES) {
				queryIndexes.add(queryIndex);
			}
			String useSparqlUo = "both";
			Path outputRoot = Paths.get("target", "theme-query-plans");

			if (args != null && args.length >= 1) {
				themeNames = List.of(args[0].toUpperCase(Locale.ROOT));
			}
			if (args != null && args.length >= 2) {
				queryIndexes = List.of(Integer.parseInt(args[1]));
			}
			if (args != null && args.length >= 3) {
				useSparqlUo = args[2];
			}
			if (args != null && args.length >= 4) {
				outputRoot = Paths.get(args[3]);
			}

			return new Config(themeNames, queryIndexes, parseUseSparqlUo(useSparqlUo), outputRoot);
		}
	}

	private static boolean[] parseUseSparqlUo(String value) {
		if (value == null || value.isBlank() || "both".equalsIgnoreCase(value)) {
			return new boolean[] { true, false };
		}
		if ("true".equalsIgnoreCase(value)) {
			return new boolean[] { true };
		}
		if ("false".equalsIgnoreCase(value)) {
			return new boolean[] { false };
		}
		throw new IllegalArgumentException("Unexpected z_useSparqlUo value: " + value);
	}
}
