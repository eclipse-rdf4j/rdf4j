/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.sail.memory.benchmark;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.List;

import org.eclipse.rdf4j.benchmark.common.ThemeQueryCatalog;
import org.eclipse.rdf4j.benchmark.rio.util.ThemeDataSetGenerator;
import org.eclipse.rdf4j.benchmark.rio.util.ThemeDataSetGenerator.Theme;
import org.eclipse.rdf4j.common.transaction.IsolationLevels;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.evaluation.EvaluationStrategy;
import org.eclipse.rdf4j.query.algebra.evaluation.EvaluationStrategyFactory;
import org.eclipse.rdf4j.query.algebra.evaluation.TripleSource;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.DefaultEvaluationStrategyFactory;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.StandardQueryOptimizerPipeline;
import org.eclipse.rdf4j.query.explanation.Explanation;
import org.eclipse.rdf4j.query.explanation.GenericPlanNode;
import org.eclipse.rdf4j.repository.sail.SailRepository;
import org.eclipse.rdf4j.repository.sail.SailRepositoryConnection;
import org.eclipse.rdf4j.repository.util.RDFInserter;
import org.eclipse.rdf4j.sail.memory.MemoryStore;
import org.junit.jupiter.api.Assumptions;
import org.junit.jupiter.api.Test;

class ThemeQueryPlanComparisonTest {

	private static final int QUERY_COUNT = ThemeQueryCatalog.QUERY_COUNT;
	private static final boolean VERIFY_COUNTS = Boolean.getBoolean("theme.plan.compare.verifyCounts");

	@Test
	void compareExecutedPlansForAllThemes() throws IOException {
		Assumptions.assumeTrue(Boolean.getBoolean("theme.plan.compare"),
				"Set -Dtheme.plan.compare=true to run plan comparison");

		Path reportDir = Paths.get("target", "surefire-reports");
		Files.createDirectories(reportDir);

		for (Theme theme : Theme.values()) {
			try (RepoContext uoRepo = RepoContext.create(theme, true);
					RepoContext stdRepo = RepoContext.create(theme, false)) {
				for (int index = 0; index < QUERY_COUNT; index++) {
					String query = ThemeQueryCatalog.queryFor(theme, index);
					long expected = ThemeQueryCatalog.expectedCountFor(theme, index);

					PlanResult uoPlan = uoRepo.explain(query, expected);
					PlanResult stdPlan = stdRepo.explain(query, expected);

					String base = "Theme_" + theme + "_Q" + index;
					write(reportDir.resolve(base + "_UO.txt"), uoPlan.planText);
					write(reportDir.resolve(base + "_STD.txt"), stdPlan.planText);
					write(reportDir.resolve(base + "_DIFF.txt"), diff(uoPlan.planText, stdPlan.planText));
					write(reportDir.resolve(base + "_SUMMARY.txt"), summaryLine(theme, index, uoPlan, stdPlan));
					System.out.println(summaryLine(theme, index, uoPlan, stdPlan));
				}
			}
		}
	}

	private static String summaryLine(Theme theme, int index, PlanResult uoPlan, PlanResult stdPlan) {
		return String.format(
				"SUMMARY theme=%s query=%d uoType=%s uoCost=%s uoTimeMs=%s uoNodes=%d uoJoins=%d uoLeftJoins=%d uoUnions=%d"
						+ " stdType=%s stdCost=%s stdTimeMs=%s stdNodes=%d stdJoins=%d stdLeftJoins=%d stdUnions=%d",
				theme,
				index,
				uoPlan.summary.rootType,
				value(uoPlan.summary.rootCostEstimate),
				value(uoPlan.summary.rootTotalTimeMs),
				uoPlan.summary.nodeCount,
				uoPlan.summary.joinCount,
				uoPlan.summary.leftJoinCount,
				uoPlan.summary.unionCount,
				stdPlan.summary.rootType,
				value(stdPlan.summary.rootCostEstimate),
				value(stdPlan.summary.rootTotalTimeMs),
				stdPlan.summary.nodeCount,
				stdPlan.summary.joinCount,
				stdPlan.summary.leftJoinCount,
				stdPlan.summary.unionCount);
	}

	private static String value(Double value) {
		return value == null ? "n/a" : String.format("%.3f", value);
	}

	private static String diff(String left, String right) {
		String[] leftLines = left.split("\\R", -1);
		String[] rightLines = right.split("\\R", -1);
		StringBuilder diff = new StringBuilder();
		int max = Math.max(leftLines.length, rightLines.length);
		for (int i = 0; i < max; i++) {
			String l = i < leftLines.length ? leftLines[i] : "";
			String r = i < rightLines.length ? rightLines[i] : "";
			if (l.equals(r)) {
				diff.append("  ").append(l).append('\n');
			} else {
				diff.append("- ").append(l).append('\n');
				diff.append("+ ").append(r).append('\n');
			}
		}
		return diff.toString();
	}

	private static void write(Path path, String content) throws IOException {
		Files.writeString(path, content == null ? "" : content, StandardCharsets.UTF_8);
	}

	private static final class RepoContext implements AutoCloseable {
		private final SailRepository repository;
		private final Theme theme;
		private final boolean useSparqlUo;

		private RepoContext(SailRepository repository, Theme theme, boolean useSparqlUo) {
			this.repository = repository;
			this.theme = theme;
			this.useSparqlUo = useSparqlUo;
		}

		static RepoContext create(Theme theme, boolean useSparqlUo) throws IOException {
			MemoryStore store = new MemoryStore();
			if (!useSparqlUo) {
				store.setEvaluationStrategyFactory(createStandardPipelineFactory(store));
			}
			SailRepository repository = new SailRepository(store);
			RepoContext context = new RepoContext(repository, theme, useSparqlUo);
			context.loadData();
			return context;
		}

		private void loadData() throws IOException {
			try (SailRepositoryConnection connection = repository.getConnection()) {
				connection.begin(IsolationLevels.NONE);
				RDFInserter inserter = new RDFInserter(connection);
				ThemeDataSetGenerator.generate(theme, inserter);
				connection.commit();
			}
		}

		PlanResult explain(String query, long expectedCount) {
			try (SailRepositoryConnection connection = repository.getConnection()) {
				Explanation explanation = connection.prepareTupleQuery(query).explain(Explanation.Level.Executed);
				long count = -1L;
				if (VERIFY_COUNTS) {
					count = connection.prepareTupleQuery(query).evaluate().stream().count();
					assertEquals(expectedCount, count,
							"Unexpected count for theme " + theme + " with UO=" + useSparqlUo);
				}
				String planText = explanation.toString();
				PlanSummary summary = summarize(explanation);
				return new PlanResult(planText, summary, count);
			}
		}

		@Override
		public void close() {
			repository.shutDown();
		}
	}

	private static PlanSummary summarize(Explanation explanation) {
		GenericPlanNode root = explanation.toGenericPlanNode();
		PlanStats stats = new PlanStats();
		Deque<GenericPlanNode> stack = new ArrayDeque<>();
		stack.push(root);
		while (!stack.isEmpty()) {
			GenericPlanNode node = stack.pop();
			stats.nodeCount++;
			countType(stats, node.getType());
			List<GenericPlanNode> plans = node.getPlans();
			if (plans != null) {
				for (GenericPlanNode child : plans) {
					stack.push(child);
				}
			}
		}
		return new PlanSummary(root.getType(), root.getCostEstimate(), root.getTotalTimeActual(), stats.nodeCount,
				stats.joinCount, stats.leftJoinCount, stats.unionCount);
	}

	private static void countType(PlanStats stats, String type) {
		if (type == null) {
			return;
		}
		if (type.startsWith("Join")) {
			stats.joinCount++;
			return;
		}
		if (type.startsWith("LeftJoin")) {
			stats.leftJoinCount++;
			return;
		}
		if (type.startsWith("Union")) {
			stats.unionCount++;
		}
	}

	private static EvaluationStrategyFactory createStandardPipelineFactory(MemoryStore store) {
		DefaultEvaluationStrategyFactory factory = new DefaultEvaluationStrategyFactory(
				store.getFederatedServiceResolver()) {
			@Override
			public EvaluationStrategy createEvaluationStrategy(Dataset dataset, TripleSource tripleSource,
					EvaluationStatistics evaluationStatistics) {
				EvaluationStrategy strategy = super.createEvaluationStrategy(dataset, tripleSource,
						evaluationStatistics);
				strategy.setOptimizerPipeline(
						new StandardQueryOptimizerPipeline(strategy, tripleSource, evaluationStatistics));
				return strategy;
			}
		};
		factory.setQuerySolutionCacheThreshold(store.getIterationCacheSyncThreshold());
		factory.setTrackResultSize(store.isTrackResultSize());
		return factory;
	}

	private static final class PlanResult {
		private final String planText;
		private final PlanSummary summary;
		@SuppressWarnings("unused")
		private final long count;

		private PlanResult(String planText, PlanSummary summary, long count) {
			this.planText = planText;
			this.summary = summary;
			this.count = count;
		}
	}

	private static final class PlanSummary {
		private final String rootType;
		private final Double rootCostEstimate;
		private final Double rootTotalTimeMs;
		private final int nodeCount;
		private final int joinCount;
		private final int leftJoinCount;
		private final int unionCount;

		private PlanSummary(String rootType, Double rootCostEstimate, Double rootTotalTimeMs, int nodeCount,
				int joinCount, int leftJoinCount, int unionCount) {
			this.rootType = rootType;
			this.rootCostEstimate = rootCostEstimate;
			this.rootTotalTimeMs = rootTotalTimeMs;
			this.nodeCount = nodeCount;
			this.joinCount = joinCount;
			this.leftJoinCount = leftJoinCount;
			this.unionCount = unionCount;
		}
	}

	private static final class PlanStats {
		private int nodeCount;
		private int joinCount;
		private int leftJoinCount;
		private int unionCount;
	}
}
