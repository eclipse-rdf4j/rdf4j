/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.sail.memory;

import static org.assertj.core.api.Assertions.assertThat;

import java.util.HashMap;
import java.util.Map;

import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Value;
import org.eclipse.rdf4j.model.ValueFactory;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.QueryLanguage;
import org.eclipse.rdf4j.query.TupleQuery;
import org.eclipse.rdf4j.query.TupleQueryResult;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryBindingSet;
import org.eclipse.rdf4j.repository.RepositoryConnection;
import org.eclipse.rdf4j.repository.sail.SailRepository;
import org.junit.jupiter.api.Test;

class MemoryStoreSparqlUoOptimizerTest {

	private static final ValueFactory VF = SimpleValueFactory.getInstance();
	private static final IRI P1 = VF.createIRI("urn:p1");
	private static final IRI P2 = VF.createIRI("urn:p2");

	@Test
	void unionAndOptionalQueriesEvaluateCorrectly() {
		SailRepository repo = new SailRepository(new MemoryStore());
		repo.init();
		try (RepositoryConnection connection = repo.getConnection()) {
			seedData(connection);
			assertUnionDuplicates(connection);
			assertOptionalResults(connection);
		} finally {
			repo.shutDown();
		}
	}

	private void seedData(RepositoryConnection connection) {
		connection.add(VF.createIRI("urn:a"), P1, VF.createIRI("urn:o1"));
		connection.add(VF.createIRI("urn:a"), P2, VF.createIRI("urn:o2"));
		connection.add(VF.createIRI("urn:b"), P1, VF.createIRI("urn:o3"));
		connection.add(VF.createIRI("urn:c"), P1, VF.createIRI("urn:o4"));
	}

	private void assertUnionDuplicates(RepositoryConnection connection) {
		Map<BindingSet, Long> actual = evaluateCounts(connection,
				"SELECT ?s WHERE { { ?s <urn:p1> ?o } UNION { ?s <urn:p1> ?o } }");

		Map<BindingSet, Long> expected = new HashMap<>();
		expected.put(bindingSet(VF.createIRI("urn:a"), null), 2L);
		expected.put(bindingSet(VF.createIRI("urn:b"), null), 2L);
		expected.put(bindingSet(VF.createIRI("urn:c"), null), 2L);

		assertThat(actual).isEqualTo(expected);
	}

	private void assertOptionalResults(RepositoryConnection connection) {
		Map<BindingSet, Long> actual = evaluateCounts(connection,
				"SELECT ?s ?o2 WHERE { ?s <urn:p1> ?o OPTIONAL { ?s <urn:p2> ?o2 } }");

		Map<BindingSet, Long> expected = new HashMap<>();
		expected.put(bindingSet(VF.createIRI("urn:a"), VF.createIRI("urn:o2")), 1L);
		expected.put(bindingSet(VF.createIRI("urn:b"), null), 1L);
		expected.put(bindingSet(VF.createIRI("urn:c"), null), 1L);

		assertThat(actual).isEqualTo(expected);
	}

	private Map<BindingSet, Long> evaluateCounts(RepositoryConnection connection, String sparql) {
		TupleQuery query = connection.prepareTupleQuery(QueryLanguage.SPARQL, sparql);
		Map<BindingSet, Long> counts = new HashMap<>();
		try (TupleQueryResult result = query.evaluate()) {
			while (result.hasNext()) {
				QueryBindingSet copy = new QueryBindingSet(result.next());
				counts.merge(copy, 1L, Long::sum);
			}
		}
		return counts;
	}

	private QueryBindingSet bindingSet(Value sValue, Value o2Value) {
		QueryBindingSet bindings = new QueryBindingSet();
		if (sValue != null) {
			bindings.addBinding("s", sValue);
		}
		if (o2Value != null) {
			bindings.addBinding("o2", o2Value);
		}
		return bindings;
	}
}
