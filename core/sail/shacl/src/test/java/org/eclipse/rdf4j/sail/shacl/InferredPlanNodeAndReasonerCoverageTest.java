/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex

package org.eclipse.rdf4j.sail.shacl;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.NoSuchElementException;
import java.util.Set;

import org.eclipse.rdf4j.common.iteration.CloseableIteration;
import org.eclipse.rdf4j.common.transaction.IsolationLevels;
import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Resource;
import org.eclipse.rdf4j.model.Statement;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.model.vocabulary.RDFS;
import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.sail.NotifyingSail;
import org.eclipse.rdf4j.sail.SailConnection;
import org.eclipse.rdf4j.sail.inferencer.fc.SchemaCachingRDFSInferencer;
import org.eclipse.rdf4j.sail.memory.MemoryStore;
import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.ConstraintComponent;
import org.eclipse.rdf4j.sail.shacl.ast.planNodes.FilterByPredicate;
import org.eclipse.rdf4j.sail.shacl.ast.planNodes.PlanNode;
import org.eclipse.rdf4j.sail.shacl.ast.planNodes.Select;
import org.eclipse.rdf4j.sail.shacl.ast.planNodes.ValidationExecutionLogger;
import org.eclipse.rdf4j.sail.shacl.ast.planNodes.ValidationTuple;
import org.eclipse.rdf4j.sail.shacl.wrapper.data.ConnectionsGroup;
import org.eclipse.rdf4j.sail.shacl.wrapper.data.VerySimpleRdfsBackwardsChainingConnection;
import org.junit.jupiter.api.Test;

class InferredPlanNodeAndReasonerCoverageTest {

	private static final SimpleValueFactory VF = SimpleValueFactory.getInstance();

	private static final Resource[] ALL_CONTEXTS = { null };

	private static final IRI TARGET = VF.createIRI("urn:target");
	private static final IRI P = VF.createIRI("urn:p");
	private static final IRI P_SUB = VF.createIRI("urn:pSub");
	private static final IRI O = VF.createIRI("urn:o");
	private static final IRI CLASS_SUB = VF.createIRI("urn:ClassSub");
	private static final IRI CLASS_SUPER = VF.createIRI("urn:ClassSuper");

	@Test
	void verySimpleRdfsBackwardsChainingConnectionShouldGateBaseInferredStatementsByConstructorFlag() {
		try (TestSailContext context = TestSailContext.withInferredStatement()) {
			VerySimpleRdfsBackwardsChainingConnection wrappedWithoutBaseInferred = new VerySimpleRdfsBackwardsChainingConnection(
					context.connection, null, false);

			assertFalse(wrappedWithoutBaseInferred.hasStatement(TARGET, P, O, true, ALL_CONTEXTS),
					"Expected constructor includeInferredStatements=false to hide base inferred statements");
			assertFalse(wrappedWithoutBaseInferred.hasStatement(TARGET, P, O, false, ALL_CONTEXTS),
					"Expected includeInferred=false to hide base inferred statements");

			try (CloseableIteration<? extends Statement> statements = wrappedWithoutBaseInferred.getStatements(TARGET,
					P, O,
					true, ALL_CONTEXTS)) {
				assertFalse(statements.hasNext(),
						"Expected getStatements() to hide base inferred statements when constructor flag is false");
			}

			VerySimpleRdfsBackwardsChainingConnection wrappedWithBaseInferred = new VerySimpleRdfsBackwardsChainingConnection(
					context.connection, null, true);

			assertTrue(wrappedWithBaseInferred.hasStatement(TARGET, P, O, true, ALL_CONTEXTS),
					"Expected constructor includeInferredStatements=true to expose base inferred statements");
			assertFalse(wrappedWithBaseInferred.hasStatement(TARGET, P, O, false, ALL_CONTEXTS),
					"Expected includeInferred=false to hide base inferred statements even when constructor flag is true");

			try (CloseableIteration<? extends Statement> statements = wrappedWithBaseInferred.getStatements(TARGET, P,
					O,
					true, ALL_CONTEXTS)) {
				assertTrue(statements.hasNext(),
						"Expected getStatements() to expose base inferred statements when constructor flag is true");
			}
		}
	}

	@Test
	void filterByPredicateShouldRespectConnectionsGroupIncludeInferredSetting() {
		try (TestSailContext context = TestSailContext.withInferredStatement()) {
			PlanNode parent = new SingletonPlanNode(
					new ValidationTuple(TARGET, ConstraintComponent.Scope.nodeShape, false, ALL_CONTEXTS));

			try (ConnectionsGroup withoutInferred = context.connectionsGroup(false)) {
				FilterByPredicate filterByPredicate = new FilterByPredicate(
						withoutInferred.getBaseConnection(),
						Set.of(P),
						parent,
						FilterByPredicate.On.Subject,
						ALL_CONTEXTS,
						withoutInferred);
				assertEquals(0, countTuples(filterByPredicate),
						"Expected inferred statements to be excluded when includeInferredStatements=false");
			}

			try (ConnectionsGroup withInferred = context.connectionsGroup(true)) {
				FilterByPredicate filterByPredicate = new FilterByPredicate(
						withInferred.getBaseConnection(),
						Set.of(P),
						parent,
						FilterByPredicate.On.Subject,
						ALL_CONTEXTS,
						withInferred);
				assertEquals(1, countTuples(filterByPredicate),
						"Expected inferred statements to be included when includeInferredStatements=true");
			}
		}
	}

	@Test
	void selectShouldRespectIncludeInferredArgument() {
		try (TestSailContext context = TestSailContext.withInferredStatement()) {
			String query = "select * where { ?this <urn:p> <urn:o> . }";

			Select withoutInferred = new Select(
					context.connection,
					query,
					InferredPlanNodeAndReasonerCoverageTest::mapBindingSet,
					ALL_CONTEXTS,
					false);
			assertEquals(0, countTuples(withoutInferred),
					"Expected Select to hide inferred statements when includeInferred=false");

			Select withInferred = new Select(
					context.connection,
					query,
					InferredPlanNodeAndReasonerCoverageTest::mapBindingSet,
					ALL_CONTEXTS,
					true);
			assertEquals(1, countTuples(withInferred),
					"Expected Select to include inferred statements when includeInferred=true");
		}
	}

	private static ValidationTuple mapBindingSet(BindingSet bindingSet) {
		return new ValidationTuple((Resource) bindingSet.getValue("this"), ConstraintComponent.Scope.nodeShape, false,
				ALL_CONTEXTS);
	}

	private static int countTuples(PlanNode planNode) {
		planNode.receiveLogger(ValidationExecutionLogger.getInstance(false));
		try (CloseableIteration<? extends ValidationTuple> iterator = planNode.iterator()) {
			int count = 0;
			while (iterator.hasNext()) {
				iterator.next();
				count++;
			}
			return count;
		}
	}

	private static final class SingletonPlanNode implements PlanNode {

		private final ValidationTuple tuple;

		private SingletonPlanNode(ValidationTuple tuple) {
			this.tuple = tuple;
		}

		@Override
		public CloseableIteration<? extends ValidationTuple> iterator() {
			return new CloseableIteration<>() {
				private boolean available = true;

				@Override
				public void close() {
					available = false;
				}

				@Override
				public boolean hasNext() {
					return available;
				}

				@Override
				public ValidationTuple next() {
					if (!available) {
						throw new NoSuchElementException();
					}
					available = false;
					return tuple;
				}

				@Override
				public void remove() {
					throw new UnsupportedOperationException();
				}
			};
		}

		@Override
		public int depth() {
			return 0;
		}

		@Override
		public void getPlanAsGraphvizDot(StringBuilder stringBuilder) {
			// no-op
		}

		@Override
		public String getId() {
			return Integer.toString(System.identityHashCode(this));
		}

		@Override
		public void receiveLogger(ValidationExecutionLogger validationExecutionLogger) {
			// no-op
		}

		@Override
		public boolean producesSorted() {
			return false;
		}

		@Override
		public boolean requiresSorted() {
			return false;
		}
	}

	private static final class TestSailContext implements AutoCloseable {
		private final NotifyingSail sail;
		private final SailConnection connection;

		private TestSailContext(NotifyingSail sail, SailConnection connection) {
			this.sail = sail;
			this.connection = connection;
		}

		static TestSailContext withInferredStatement() {
			MemoryStore memoryStore = new MemoryStore();
			NotifyingSail sail = new SchemaCachingRDFSInferencer(memoryStore, false);
			sail.init();

			SailConnection connection = sail.getConnection();
			connection.begin(IsolationLevels.NONE);
			connection.addStatement(P_SUB, RDFS.SUBPROPERTYOF, P);
			connection.addStatement(TARGET, P_SUB, O);
			connection.commit();

			connection.begin(IsolationLevels.NONE);
			assertTrue(connection.hasStatement(TARGET, P, O, true, ALL_CONTEXTS),
					"Sanity check: expected inferred statement to exist");
			assertFalse(connection.hasStatement(TARGET, P, O, false, ALL_CONTEXTS),
					"Sanity check: expected inferred statement to be hidden when includeInferred=false");

			return new TestSailContext(sail, connection);
		}

		ConnectionsGroup connectionsGroup(boolean includeInferredStatements) {
			ShaclSailConnection.Settings transactionSettings = new ShaclSailConnection.Settings(false, true, false,
					IsolationLevels.NONE);
			return new ConnectionsGroup(connection, null, null, null, new Stats(), null, includeInferredStatements,
					transactionSettings, true);
		}

		@Override
		public void close() {
			try {
				try {
					try {
						connection.rollback();
					} catch (Exception ignored) {
						// ignore
					}
					connection.close();
				} finally {
					sail.shutDown();
				}
			} catch (Exception e) {
				throw new RuntimeException(e);
			}
		}
	}
}
