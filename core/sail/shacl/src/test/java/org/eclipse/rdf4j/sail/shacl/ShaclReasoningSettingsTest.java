/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex

package org.eclipse.rdf4j.sail.shacl;

import java.io.StringReader;
import java.util.List;
import java.util.Set;
import java.util.stream.Stream;

import org.eclipse.rdf4j.common.transaction.IsolationLevels;
import org.eclipse.rdf4j.common.transaction.QueryEvaluationMode;
import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.util.Values;
import org.eclipse.rdf4j.model.vocabulary.RDF4J;
import org.eclipse.rdf4j.query.QueryLanguage;
import org.eclipse.rdf4j.repository.RepositoryConnection;
import org.eclipse.rdf4j.repository.RepositoryException;
import org.eclipse.rdf4j.repository.sail.SailRepository;
import org.eclipse.rdf4j.rio.RDFFormat;
import org.eclipse.rdf4j.sail.NotifyingSail;
import org.eclipse.rdf4j.sail.inferencer.fc.SchemaCachingRDFSInferencer;
import org.eclipse.rdf4j.sail.memory.MemoryStore;
import org.eclipse.rdf4j.sail.shacl.ShaclSail.TransactionSettings.ValidationApproach;
import org.eclipse.rdf4j.sail.shacl.results.ValidationReport;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

public class ShaclReasoningSettingsTest {

	private static final IRI DATA_GRAPH = Values.iri("urn:data");
	private static final IRI ONTOLOGY_GRAPH = Values.iri("urn:ontology");

	enum Scenario {
		RDFS,
		INCLUDE_INFERRED
	}

	enum InferencerMode {
		NONE,
		SCHEMA_CACHING
	}

	static final class ReasoningCase {
		final String name;
		final Scenario scenario;
		final InferencerMode inferencerMode;
		final boolean globalRdfs;
		final boolean globalInclude;
		final Boolean shapeRdfsOverride;
		final Boolean shapeIncludeOverride;

		ReasoningCase(String name, Scenario scenario, InferencerMode inferencerMode, boolean globalRdfs,
				boolean globalInclude, Boolean shapeRdfsOverride, Boolean shapeIncludeOverride) {
			this.name = name;
			this.scenario = scenario;
			this.inferencerMode = inferencerMode;
			this.globalRdfs = globalRdfs;
			this.globalInclude = globalInclude;
			this.shapeRdfsOverride = shapeRdfsOverride;
			this.shapeIncludeOverride = shapeIncludeOverride;
		}

		@Override
		public String toString() {
			return name;
		}
	}

	static Stream<Arguments> rdfsCases() {
		List<ReasoningCase> cases = List.of(
				new ReasoningCase("rdfs-globals-off", Scenario.RDFS, InferencerMode.NONE, false, false, null, null),
				new ReasoningCase("rdfs-globals-on", Scenario.RDFS, InferencerMode.NONE, true, false, null, null),
				new ReasoningCase("rdfs-shape-on", Scenario.RDFS, InferencerMode.NONE, false, false, true, null),
				new ReasoningCase("rdfs-override-off", Scenario.RDFS, InferencerMode.NONE, true, false, false, null)
		);
		return cases.stream().map(Arguments::of);
	}

	static Stream<Arguments> includeCases() {
		List<ReasoningCase> cases = List.of(
				new ReasoningCase("include-globals-off", Scenario.INCLUDE_INFERRED, InferencerMode.SCHEMA_CACHING,
						false, false, false, null),
				new ReasoningCase("include-globals-on", Scenario.INCLUDE_INFERRED, InferencerMode.SCHEMA_CACHING,
						false, true, false, null),
				new ReasoningCase("include-shape-on", Scenario.INCLUDE_INFERRED, InferencerMode.SCHEMA_CACHING,
						false, false, false, true),
				new ReasoningCase("include-override-off", Scenario.INCLUDE_INFERRED, InferencerMode.SCHEMA_CACHING,
						false, true, false, false)
		);
		return cases.stream().map(Arguments::of);
	}

	@ParameterizedTest(name = "{0}")
	@MethodSource("rdfsCases")
	void rdfsSubClassReasoningAcrossValidationModes(ReasoningCase testCase) {
		runAllModes(testCase);
	}

	@ParameterizedTest(name = "{0}")
	@MethodSource("includeCases")
	void includeInferredStatementsAcrossValidationModes(ReasoningCase testCase) {
		runAllModes(testCase);
	}

	private static void runAllModes(ReasoningCase testCase) {
		assertSingleTransaction(testCase);
		assertBulkValidation(testCase);
		assertMultiUpdateTransaction(testCase);
		assertShaclValidator(testCase);
	}

	private static void assertSingleTransaction(ReasoningCase testCase) {
		SailRepository repository = createRepository(testCase);
		try {
			try (RepositoryConnection connection = repository.getConnection()) {
				connection.begin(IsolationLevels.NONE);
				addTurtle(connection, dataTurtle(testCase), DATA_GRAPH);
				commitExpecting(testCase, connection, "single transaction");
			}
		} finally {
			repository.shutDown();
		}
	}

	private static void assertBulkValidation(ReasoningCase testCase) {
		SailRepository repository = createRepository(testCase);
		try {
			loadDataWithoutValidation(repository, testCase);
			try (RepositoryConnection connection = repository.getConnection()) {
				connection.begin(ValidationApproach.Bulk);
				try {
					connection.commit();
					Assertions.assertTrue(expectedConforms(testCase), "bulk validation should have failed");
				} catch (RepositoryException e) {
					connection.rollback();
					Throwable cause = e.getCause();
					if (!(cause instanceof ShaclSailValidationException)) {
						throw e;
					}
					ValidationReport report = ((ShaclSailValidationException) cause).getValidationReport();
					Assertions.assertFalse(expectedConforms(testCase), "bulk validation unexpectedly failed");
					Assertions.assertFalse(report.conforms(), "bulk validation report should not conform");
				}
			}
		} finally {
			repository.shutDown();
		}
	}

	private static void assertMultiUpdateTransaction(ReasoningCase testCase) {
		SailRepository repository = createRepository(testCase);
		try {
			try (RepositoryConnection connection = repository.getConnection()) {
				connection.begin(IsolationLevels.NONE);
				connection.prepareUpdate(QueryLanguage.SPARQL, updatePart1(testCase)).execute();
				connection.prepareUpdate(QueryLanguage.SPARQL, updatePart2(testCase)).execute();
				commitExpecting(testCase, connection, "multi-update transaction");
			}
		} finally {
			repository.shutDown();
		}
	}

	private static void assertShaclValidator(ReasoningCase testCase) {
		SailRepository shapesRepo = new SailRepository(new MemoryStore());
		SailRepository dataRepo = new SailRepository(createDataSail(testCase));
		try {
			shapesRepo.init();
			dataRepo.init();
			loadShapes(shapesRepo, testCase);
			loadOntology(dataRepo, testCase);
			loadData(dataRepo, testCase);

			ValidationReport report = ShaclValidator.builder()
					.setRdfsSubClassReasoning(testCase.globalRdfs)
					.setIncludeInferredStatements(testCase.globalInclude)
					.setEclipseRdf4jShaclExtensions(true)
					.setCacheSelectNodes(true)
					.setParallelValidation(false)
					.withShapes(shapesRepo.getSail())
					.build()
					.validate(dataRepo.getSail());

			Assertions.assertEquals(expectedConforms(testCase), report.conforms(), "ShaclValidator result mismatch");
		} finally {
			try {
				shapesRepo.shutDown();
			} finally {
				dataRepo.shutDown();
			}
		}
	}

	private static void commitExpecting(ReasoningCase testCase, RepositoryConnection connection, String label) {
		boolean expectedConforms = expectedConforms(testCase);
		try {
			connection.commit();
			Assertions.assertTrue(expectedConforms, label + " should have failed");
		} catch (RepositoryException e) {
			connection.rollback();
			Throwable cause = e.getCause();
			if (!(cause instanceof ShaclSailValidationException)) {
				throw e;
			}
			Assertions.assertFalse(expectedConforms, label + " should have conformed");
		}
	}

	private static SailRepository createRepository(ReasoningCase testCase) {
		SailRepository repository = new SailRepository(createShaclSail(testCase));
		repository.init();
		loadShapes(repository, testCase);
		loadOntology(repository, testCase);
		return repository;
	}

	private static ShaclSail createShaclSail(ReasoningCase testCase) {
		NotifyingSail baseSail = createDataSail(testCase);
		ShaclSail shaclSail = new ShaclSail(baseSail);
		shaclSail.setLogValidationPlans(false);
		shaclSail.setCacheSelectNodes(true);
		shaclSail.setParallelValidation(false);
		shaclSail.setLogValidationViolations(false);
		shaclSail.setGlobalLogValidationExecution(false);
		shaclSail.setEclipseRdf4jShaclExtensions(true);
		shaclSail.setDashDataShapes(false);
		shaclSail.setPerformanceLogging(false);
		shaclSail.setRdfsSubClassReasoning(testCase.globalRdfs);
		shaclSail.setIncludeInferredStatements(testCase.globalInclude);
		shaclSail.setSerializableValidation(false);
		shaclSail.setShapesGraphs(Set.of(RDF4J.SHACL_SHAPE_GRAPH));
		return shaclSail;
	}

	private static NotifyingSail createDataSail(ReasoningCase testCase) {
		MemoryStore memoryStore = new MemoryStore();
		memoryStore.setDefaultQueryEvaluationMode(QueryEvaluationMode.STRICT);
		if (testCase.inferencerMode == InferencerMode.SCHEMA_CACHING) {
			return new SchemaCachingRDFSInferencer(memoryStore, false);
		}
		return memoryStore;
	}

	private static void loadShapes(SailRepository repository, ReasoningCase testCase) {
		try (RepositoryConnection connection = repository.getConnection()) {
			connection.begin(IsolationLevels.NONE, ValidationApproach.Disabled);
			addTurtle(connection, shapesTurtle(testCase), RDF4J.SHACL_SHAPE_GRAPH);
			connection.commit();
		}
	}

	private static void loadOntology(SailRepository repository, ReasoningCase testCase) {
		try (RepositoryConnection connection = repository.getConnection()) {
			connection.begin(IsolationLevels.NONE, ValidationApproach.Disabled);
			addTurtle(connection, ontologyTurtle(testCase), ONTOLOGY_GRAPH);
			connection.commit();
		}
	}

	private static void loadDataWithoutValidation(SailRepository repository, ReasoningCase testCase) {
		try (RepositoryConnection connection = repository.getConnection()) {
			connection.begin(IsolationLevels.NONE, ValidationApproach.Disabled);
			addTurtle(connection, dataTurtle(testCase), DATA_GRAPH);
			connection.commit();
		}
	}

	private static void loadData(SailRepository repository, ReasoningCase testCase) {
		try (RepositoryConnection connection = repository.getConnection()) {
			connection.begin(IsolationLevels.NONE, ValidationApproach.Disabled);
			addTurtle(connection, dataTurtle(testCase), DATA_GRAPH);
			connection.commit();
		}
	}

	private static void addTurtle(RepositoryConnection connection, String turtle, IRI context) {
		try {
			connection.add(new StringReader(turtle), "", RDFFormat.TURTLE, context);
		} catch (java.io.IOException e) {
			throw new RuntimeException(e);
		}
	}

	private static boolean expectedConforms(ReasoningCase testCase) {
		if (testCase.scenario == Scenario.RDFS) {
			boolean effectiveRdfs = testCase.shapeRdfsOverride != null
					? testCase.shapeRdfsOverride
					: testCase.globalRdfs;
			return !effectiveRdfs;
		}
		boolean effectiveInclude = testCase.shapeIncludeOverride != null
				? testCase.shapeIncludeOverride
				: testCase.globalInclude;
		return effectiveInclude;
	}

	private static String shapesTurtle(ReasoningCase testCase) {
		StringBuilder builder = new StringBuilder();
		builder.append("@prefix tr: <https://example.com/trains/> .\n");
		builder.append("@prefix sh: <http://www.w3.org/ns/shacl#> .\n");
		builder.append("@prefix rsx: <http://rdf4j.org/shacl-extensions#> .\n");
		builder.append("\n");

		if (testCase.scenario == Scenario.RDFS) {
			builder.append("tr:RailcarBrakeShape a sh:NodeShape ;\n");
			builder.append("  sh:targetClass tr:Railcar ;\n");
			if (testCase.shapeRdfsOverride != null) {
				builder.append("  rsx:rdfsSubClassReasoning " + testCase.shapeRdfsOverride + " ;\n");
			}
			builder.append("  sh:property [\n");
			builder.append("    sh:path tr:hasBrake ;\n");
			builder.append("    sh:minCount 1\n");
			builder.append("  ] .\n");
			return builder.toString();
		}

		builder.append("tr:TrainShape a sh:NodeShape ;\n");
		builder.append("  sh:targetClass tr:Train ;\n");
		builder.append("  rsx:rdfsSubClassReasoning false ;\n");
		if (testCase.shapeIncludeOverride != null) {
			builder.append("  rsx:includeInferredStatements " + testCase.shapeIncludeOverride + " ;\n");
		}
		builder.append("  sh:property [\n");
		builder.append("    sh:path [ sh:inversePath tr:isRailcarOf ] ;\n");
		builder.append("    sh:class tr:Railcar ;\n");
		builder.append("    sh:minCount 1\n");
		builder.append("  ] .\n");
		return builder.toString();
	}

	private static String ontologyTurtle(ReasoningCase testCase) {
		return String.join("\n",
				"@prefix tr: <https://example.com/trains/> .",
				"@prefix owl: <http://www.w3.org/2002/07/owl#> .",
				"@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .",
				"",
				"tr:Train a owl:Class .",
				"tr:Railcar a owl:Class .",
				"tr:FreightWagon a owl:Class ;",
				"  rdfs:subClassOf tr:Railcar .",
				"tr:hasRailcar a owl:ObjectProperty .",
				"tr:isRailcarOf a owl:ObjectProperty ;",
				"  owl:inverseOf tr:hasRailcar .",
				"tr:hasBrake a owl:ObjectProperty .",
				""
		);
	}

	private static String dataTurtle(ReasoningCase testCase) {
		if (testCase.scenario == Scenario.RDFS) {
			return String.join("\n",
					"@prefix tr: <https://example.com/trains/> .",
					"",
					"<urn:train1> a tr:Train ;",
					"  tr:hasRailcar <urn:wagon1> , <urn:wagon2> .",
					"<urn:wagon1> a tr:FreightWagon ;",
					"  tr:hasBrake <urn:brake1> .",
					"<urn:wagon2> a tr:FreightWagon .",
					""
			);
		}

		return String.join("\n",
				"@prefix tr: <https://example.com/trains/> .",
				"",
				"<urn:train1> a tr:Train .",
				"<urn:wagon1> a tr:FreightWagon ;",
				"  tr:isRailcarOf <urn:train1> .",
				""
		);
	}

	private static String updatePart1(ReasoningCase testCase) {
		if (testCase.scenario == Scenario.RDFS) {
			return String.join("\n",
					"PREFIX tr: <https://example.com/trains/>",
					"INSERT DATA {",
					"  GRAPH <urn:data> {",
					"    <urn:train1> a tr:Train ;",
					"      tr:hasRailcar <urn:wagon1> .",
					"    <urn:wagon1> a tr:FreightWagon ;",
					"      tr:hasBrake <urn:brake1> .",
					"  }",
					"}"
			);
		}

		return String.join("\n",
				"PREFIX tr: <https://example.com/trains/>",
				"INSERT DATA {",
				"  GRAPH <urn:data> {",
				"    <urn:train1> a tr:Train .",
				"    <urn:wagon1> a tr:FreightWagon .",
				"  }",
				"}"
		);
	}

	private static String updatePart2(ReasoningCase testCase) {
		if (testCase.scenario == Scenario.RDFS) {
			return String.join("\n",
					"PREFIX tr: <https://example.com/trains/>",
					"INSERT DATA {",
					"  GRAPH <urn:data> {",
					"    <urn:train1> tr:hasRailcar <urn:wagon2> .",
					"    <urn:wagon2> a tr:FreightWagon .",
					"  }",
					"}"
			);
		}

		return String.join("\n",
				"PREFIX tr: <https://example.com/trains/>",
				"INSERT DATA {",
				"  GRAPH <urn:data> {",
				"    <urn:wagon1> tr:isRailcarOf <urn:train1> .",
				"  }",
				"}"
		);
	}
}
