/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex

package org.eclipse.rdf4j.sail.shacl;

import java.io.StringReader;
import java.util.Set;

import org.eclipse.rdf4j.common.transaction.IsolationLevels;
import org.eclipse.rdf4j.common.transaction.QueryEvaluationMode;
import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.util.Values;
import org.eclipse.rdf4j.model.vocabulary.RDF4J;
import org.eclipse.rdf4j.query.QueryLanguage;
import org.eclipse.rdf4j.repository.RepositoryConnection;
import org.eclipse.rdf4j.repository.RepositoryException;
import org.eclipse.rdf4j.repository.sail.SailRepository;
import org.eclipse.rdf4j.rio.RDFFormat;
import org.eclipse.rdf4j.sail.NotifyingSail;
import org.eclipse.rdf4j.sail.inferencer.fc.SchemaCachingRDFSInferencer;
import org.eclipse.rdf4j.sail.memory.MemoryStore;
import org.eclipse.rdf4j.sail.shacl.results.ValidationReport;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class ShaclReasoningDefaultsTest {

	private static final IRI DATA_GRAPH = Values.iri("urn:data");
	private static final IRI ONTOLOGY_GRAPH = Values.iri("urn:ontology");

	@Test
	void defaultsEnableRdfsSubClassReasoningInShaclSail() {
		SailRepository repository = new SailRepository(createShaclSail(new MemoryStore()));
		try {
			repository.init();
			loadShapes(repository, rdfsShapesTurtle());
			loadOntology(repository);

			try (RepositoryConnection connection = repository.getConnection()) {
				connection.begin(IsolationLevels.NONE);
				addTurtle(connection, rdfsDataTurtle(), DATA_GRAPH);
				commitExpectingViolation(connection, "default rdfs reasoning should flag missing brake");
			}
		} finally {
			repository.shutDown();
		}
	}

	@Test
	void defaultsEnableRdfsSubClassReasoningInShaclValidator() {
		SailRepository shapesRepo = new SailRepository(new MemoryStore());
		SailRepository dataRepo = new SailRepository(new MemoryStore());
		try {
			shapesRepo.init();
			dataRepo.init();

			loadShapes(shapesRepo, rdfsShapesTurtle());
			loadOntology(dataRepo);
			try (RepositoryConnection connection = dataRepo.getConnection()) {
				connection.begin(IsolationLevels.NONE);
				addTurtle(connection, rdfsDataTurtle(), DATA_GRAPH);
				connection.commit();
			}

			ValidationReport report = ShaclValidator.builder()
					.setEclipseRdf4jShaclExtensions(true)
					.setCacheSelectNodes(true)
					.setParallelValidation(false)
					.withShapes(shapesRepo.getSail())
					.build()
					.validate(dataRepo.getSail());

			Assertions.assertFalse(report.conforms(), "default rdfs reasoning should detect violation");
		} finally {
			try {
				shapesRepo.shutDown();
			} finally {
				dataRepo.shutDown();
			}
		}
	}

	@Test
	void defaultsEnableIncludeInferredInShaclSail() {
		SailRepository repository = new SailRepository(createShaclSail(createInferencingSail()));
		try {
			repository.init();
			loadShapes(repository, includeShapesTurtle());
			loadOntology(repository);

			try (RepositoryConnection connection = repository.getConnection()) {
				connection.begin(IsolationLevels.NONE);
				connection.prepareUpdate(QueryLanguage.SPARQL, includeDataUpdate()).execute();
				commitExpectingConformance(connection, "default includeInferred should accept inferred type");
			}
		} finally {
			repository.shutDown();
		}
	}

	@Test
	void defaultsEnableIncludeInferredInShaclValidator() {
		SailRepository shapesRepo = new SailRepository(new MemoryStore());
		SailRepository dataRepo = new SailRepository(createInferencingSail());
		try {
			shapesRepo.init();
			dataRepo.init();

			loadShapes(shapesRepo, includeShapesTurtle());
			loadOntology(dataRepo);
			try (RepositoryConnection connection = dataRepo.getConnection()) {
				connection.begin(IsolationLevels.NONE);
				connection.prepareUpdate(QueryLanguage.SPARQL, includeDataUpdate()).execute();
				connection.commit();
			}

			ValidationReport report = ShaclValidator.builder()
					.setEclipseRdf4jShaclExtensions(true)
					.setCacheSelectNodes(true)
					.setParallelValidation(false)
					.withShapes(shapesRepo.getSail())
					.build()
					.validate(dataRepo.getSail());

			Assertions.assertTrue(report.conforms(), "default includeInferred should permit inferred type");
		} finally {
			try {
				shapesRepo.shutDown();
			} finally {
				dataRepo.shutDown();
			}
		}
	}

	private static ShaclSail createShaclSail(NotifyingSail baseSail) {
		ShaclSail shaclSail = new ShaclSail(baseSail);
		shaclSail.setLogValidationPlans(false);
		shaclSail.setCacheSelectNodes(true);
		shaclSail.setParallelValidation(false);
		shaclSail.setLogValidationViolations(false);
		shaclSail.setGlobalLogValidationExecution(false);
		shaclSail.setEclipseRdf4jShaclExtensions(true);
		shaclSail.setDashDataShapes(false);
		shaclSail.setPerformanceLogging(false);
		shaclSail.setSerializableValidation(false);
		shaclSail.setShapesGraphs(Set.of(RDF4J.SHACL_SHAPE_GRAPH));
		return shaclSail;
	}

	private static NotifyingSail createInferencingSail() {
		MemoryStore memoryStore = new MemoryStore();
		memoryStore.setDefaultQueryEvaluationMode(QueryEvaluationMode.STRICT);
		return new SchemaCachingRDFSInferencer(memoryStore, false);
	}

	private static void loadShapes(SailRepository repository, String turtle) {
		try (RepositoryConnection connection = repository.getConnection()) {
			connection.begin(IsolationLevels.NONE, ShaclSail.TransactionSettings.ValidationApproach.Disabled);
			addTurtle(connection, turtle, RDF4J.SHACL_SHAPE_GRAPH);
			connection.commit();
		}
	}

	private static void loadOntology(SailRepository repository) {
		try (RepositoryConnection connection = repository.getConnection()) {
			connection.begin(IsolationLevels.NONE, ShaclSail.TransactionSettings.ValidationApproach.Disabled);
			addTurtle(connection, ontologyTurtle(), ONTOLOGY_GRAPH);
			connection.commit();
		}
	}

	private static void addTurtle(RepositoryConnection connection, String turtle, IRI context) {
		try {
			connection.add(new StringReader(turtle), "", RDFFormat.TURTLE, context);
		} catch (java.io.IOException e) {
			throw new RuntimeException(e);
		}
	}

	private static void commitExpectingViolation(RepositoryConnection connection, String label) {
		try {
			connection.commit();
			Assertions.fail(label);
		} catch (RepositoryException e) {
			connection.rollback();
			Throwable cause = e.getCause();
			if (!(cause instanceof ShaclSailValidationException)) {
				throw e;
			}
		}
	}

	private static void commitExpectingConformance(RepositoryConnection connection, String label) {
		try {
			connection.commit();
		} catch (RepositoryException e) {
			connection.rollback();
			Throwable cause = e.getCause();
			if (cause instanceof ShaclSailValidationException) {
				Assertions.fail(label);
			}
			throw e;
		}
	}

	private static String rdfsShapesTurtle() {
		return String.join("\n",
				"@prefix tr: <https://example.com/trains/> .",
				"@prefix sh: <http://www.w3.org/ns/shacl#> .",
				"",
				"tr:RailcarBrakeShape a sh:NodeShape ;",
				"  sh:targetClass tr:Railcar ;",
				"  sh:property [",
				"    sh:path tr:hasBrake ;",
				"    sh:minCount 1",
				"  ] .",
				""
		);
	}

	private static String includeShapesTurtle() {
		return String.join("\n",
				"@prefix tr: <https://example.com/trains/> .",
				"@prefix sh: <http://www.w3.org/ns/shacl#> .",
				"@prefix rsx: <http://rdf4j.org/shacl-extensions#> .",
				"",
				"tr:TrainShape a sh:NodeShape ;",
				"  sh:targetClass tr:Train ;",
				"  rsx:rdfsSubClassReasoning false ;",
				"  sh:property [",
				"    sh:path [ sh:inversePath tr:isRailcarOf ] ;",
				"    sh:class tr:Railcar ;",
				"    sh:minCount 1",
				"  ] .",
				""
		);
	}

	private static String ontologyTurtle() {
		return String.join("\n",
				"@prefix tr: <https://example.com/trains/> .",
				"@prefix owl: <http://www.w3.org/2002/07/owl#> .",
				"@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .",
				"",
				"tr:Train a owl:Class .",
				"tr:Railcar a owl:Class .",
				"tr:FreightWagon a owl:Class ;",
				"  rdfs:subClassOf tr:Railcar .",
				"tr:hasRailcar a owl:ObjectProperty .",
				"tr:isRailcarOf a owl:ObjectProperty ;",
				"  owl:inverseOf tr:hasRailcar .",
				"tr:hasBrake a owl:ObjectProperty .",
				""
		);
	}

	private static String rdfsDataTurtle() {
		return String.join("\n",
				"@prefix tr: <https://example.com/trains/> .",
				"",
				"<urn:train1> a tr:Train ;",
				"  tr:hasRailcar <urn:wagon1> , <urn:wagon2> .",
				"<urn:wagon1> a tr:FreightWagon ;",
				"  tr:hasBrake <urn:brake1> .",
				"<urn:wagon2> a tr:FreightWagon .",
				""
		);
	}

	private static String includeDataUpdate() {
		return String.join("\n",
				"PREFIX tr: <https://example.com/trains/>",
				"INSERT DATA {",
				"  GRAPH <urn:data> {",
				"    <urn:train1> a tr:Train .",
				"    <urn:wagon1> a tr:FreightWagon ;",
				"      tr:isRailcarOf <urn:train1> .",
				"  }",
				"}"
		);
	}
}
