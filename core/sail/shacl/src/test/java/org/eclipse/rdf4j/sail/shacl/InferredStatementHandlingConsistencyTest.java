/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex

package org.eclipse.rdf4j.sail.shacl;

import java.util.List;
import java.util.NoSuchElementException;

import org.eclipse.rdf4j.common.iteration.CloseableIteration;
import org.eclipse.rdf4j.common.transaction.IsolationLevels;
import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Resource;
import org.eclipse.rdf4j.model.util.Values;
import org.eclipse.rdf4j.model.vocabulary.RDFS;
import org.eclipse.rdf4j.sail.NotifyingSail;
import org.eclipse.rdf4j.sail.SailConnection;
import org.eclipse.rdf4j.sail.inferencer.fc.SchemaCachingRDFSInferencer;
import org.eclipse.rdf4j.sail.memory.MemoryStore;
import org.eclipse.rdf4j.sail.shacl.ast.SparqlFragment;
import org.eclipse.rdf4j.sail.shacl.ast.StatementMatcher;
import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.ConstraintComponent;
import org.eclipse.rdf4j.sail.shacl.ast.planNodes.BindSelect;
import org.eclipse.rdf4j.sail.shacl.ast.planNodes.ExternalFilterByQuery;
import org.eclipse.rdf4j.sail.shacl.ast.planNodes.PlanNode;
import org.eclipse.rdf4j.sail.shacl.ast.planNodes.UnBufferedPlanNode;
import org.eclipse.rdf4j.sail.shacl.ast.planNodes.ValidationExecutionLogger;
import org.eclipse.rdf4j.sail.shacl.ast.planNodes.ValidationTuple;
import org.eclipse.rdf4j.sail.shacl.ast.targets.EffectiveTarget;
import org.eclipse.rdf4j.sail.shacl.wrapper.data.ConnectionsGroup;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

class InferredStatementHandlingConsistencyTest {

	private static final Resource[] ALL_CONTEXTS = {};

	private static final IRI TARGET = Values.iri("urn:target");
	private static final IRI P = Values.iri("urn:p");
	private static final IRI P_SUB = Values.iri("urn:pSub");
	private static final IRI O = Values.iri("urn:o");

	@Test
	void externalFilterByQueryShouldUseConnectionsGroupIncludeInferredStatements() {
		try (TestSailContext context = TestSailContext.withInferredStatement()) {
			try (ConnectionsGroup connectionsGroup = context.connectionsGroup(true)) {
				PlanNode parent = new SingletonPlanNode(
						new ValidationTuple(TARGET, ConstraintComponent.Scope.nodeShape, false, ALL_CONTEXTS));

				SparqlFragment query = SparqlFragment.bgp(List.of(),
						StatementMatcher.Variable.THIS.asSparqlVariable() + " <urn:p> <urn:o> .",
						false);

				PlanNode accepted = new ExternalFilterByQuery(
						connectionsGroup.getBaseConnection(),
						ALL_CONTEXTS,
						parent,
						query,
						StatementMatcher.Variable.THIS,
						ValidationTuple::getActiveTarget,
						null,
						connectionsGroup
				).getTrueNode(UnBufferedPlanNode.class);

				Assertions.assertEquals(1, countTuples(accepted),
						"Expected inferred statements to be visible when includeInferredStatements is enabled");
			}
		}
	}

	@Test
	void bindSelectShouldUseConnectionsGroupIncludeInferredStatements() {
		try (TestSailContext context = TestSailContext.withInferredStatement()) {
			try (ConnectionsGroup connectionsGroup = context.connectionsGroup(false)) {
				PlanNode source = new SingletonPlanNode(
						new ValidationTuple(TARGET, ConstraintComponent.Scope.nodeShape, false, ALL_CONTEXTS));

				SparqlFragment query = SparqlFragment.bgp(List.of(),
						"?x <urn:p> ?o .",
						false);

				BindSelect bindSelect = new BindSelect(
						connectionsGroup.getBaseConnection(),
						ALL_CONTEXTS,
						query,
						List.of(new StatementMatcher.Variable<>("x")),
						source,
						List.of("x", "o"),
						ConstraintComponent.Scope.nodeShape,
						10,
						EffectiveTarget.Extend.right,
						false,
						connectionsGroup
				);

				Assertions.assertEquals(0, countTuples(bindSelect),
						"Expected inferred statements to be hidden when includeInferredStatements is disabled");
			}
		}
	}

	private static int countTuples(PlanNode planNode) {
		planNode.receiveLogger(ValidationExecutionLogger.getInstance(false));
		try (CloseableIteration<? extends ValidationTuple> iterator = planNode.iterator()) {
			int count = 0;
			while (iterator.hasNext()) {
				iterator.next();
				count++;
			}
			return count;
		}
	}

	private static final class SingletonPlanNode implements PlanNode {

		private final ValidationTuple tuple;

		private SingletonPlanNode(ValidationTuple tuple) {
			this.tuple = tuple;
		}

		@Override
		public CloseableIteration<? extends ValidationTuple> iterator() {
			return new CloseableIteration<>() {
				private boolean available = true;

				@Override
				public void close() {
					available = false;
				}

				@Override
				public boolean hasNext() {
					return available;
				}

				@Override
				public ValidationTuple next() {
					if (!available) {
						throw new NoSuchElementException();
					}
					available = false;
					return tuple;
				}

				@Override
				public void remove() {
					throw new UnsupportedOperationException();
				}
			};
		}

		@Override
		public int depth() {
			return 0;
		}

		@Override
		public void getPlanAsGraphvizDot(StringBuilder stringBuilder) {
			// no-op
		}

		@Override
		public String getId() {
			return Integer.toString(System.identityHashCode(this));
		}

		@Override
		public void receiveLogger(ValidationExecutionLogger validationExecutionLogger) {
			// no-op
		}

		@Override
		public boolean producesSorted() {
			return false;
		}

		@Override
		public boolean requiresSorted() {
			return false;
		}
	}

	private static final class TestSailContext implements AutoCloseable {
		private final NotifyingSail sail;
		private final SailConnection connection;

		private TestSailContext(NotifyingSail sail, SailConnection connection) {
			this.sail = sail;
			this.connection = connection;
		}

		static TestSailContext withInferredStatement() {
			MemoryStore memoryStore = new MemoryStore();
			NotifyingSail sail = new SchemaCachingRDFSInferencer(memoryStore, false);
			sail.init();

			SailConnection connection = sail.getConnection();
			connection.begin(IsolationLevels.NONE);
			connection.addStatement(P_SUB, RDFS.SUBPROPERTYOF, P);
			connection.addStatement(TARGET, P_SUB, O);
			connection.commit();

			connection.begin(IsolationLevels.NONE);
			Assertions.assertTrue(connection.hasStatement(TARGET, P, O, true),
					"Sanity check: expected inferred statement to exist");
			Assertions.assertFalse(connection.hasStatement(TARGET, P, O, false),
					"Sanity check: expected inferred statement to be hidden when includeInferred=false");

			return new TestSailContext(sail, connection);
		}

		ConnectionsGroup connectionsGroup(boolean includeInferredStatements) {
			ShaclSailConnection.Settings transactionSettings = new ShaclSailConnection.Settings(false, true, false,
					IsolationLevels.NONE);
			return new ConnectionsGroup(connection, null, null, null, new Stats(), null, includeInferredStatements,
					transactionSettings, true);
		}

		@Override
		public void close() {
			try {
				try {
					try {
						connection.rollback();
					} catch (Exception ignored) {
						// ignore
					}
					connection.close();
				} finally {
					sail.shutDown();
				}
			} catch (Exception e) {
				throw new RuntimeException(e);
			}
		}
	}
}
