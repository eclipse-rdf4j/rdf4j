/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex

package org.eclipse.rdf4j.sail.shacl;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.rdf4j.common.transaction.IsolationLevels;
import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Statement;
import org.eclipse.rdf4j.model.vocabulary.RDF;
import org.eclipse.rdf4j.model.vocabulary.RDF4J;
import org.eclipse.rdf4j.query.QueryLanguage;
import org.eclipse.rdf4j.repository.RepositoryConnection;
import org.eclipse.rdf4j.repository.RepositoryException;
import org.eclipse.rdf4j.repository.sail.SailRepository;
import org.eclipse.rdf4j.repository.sail.SailRepositoryConnection;
import org.eclipse.rdf4j.rio.RDFFormat;
import org.eclipse.rdf4j.sail.NotifyingSail;
import org.eclipse.rdf4j.sail.NotifyingSailConnection;
import org.eclipse.rdf4j.sail.SailConnectionListener;
import org.eclipse.rdf4j.sail.SailException;
import org.eclipse.rdf4j.sail.helpers.NotifyingSailWrapper;
import org.eclipse.rdf4j.sail.inferencer.InferencerConnection;
import org.eclipse.rdf4j.sail.inferencer.InferencerConnectionWrapper;
import org.eclipse.rdf4j.sail.inferencer.fc.SchemaCachingRDFSInferencer;
import org.eclipse.rdf4j.sail.memory.MemoryStore;
import org.eclipse.rdf4j.sail.shacl.results.ValidationReport;
import org.junit.jupiter.api.Test;

public class RdfsReasoningShaclSailTest {

	@Test
	public void inversePathClassConstraintFailsWithoutIncludeInferredStatements() throws Exception {
		SailRepository repo = createRepository(false, false);

		IRI ontologyGraph = repo.getValueFactory().createIRI("urn:ontology");
		IRI dataGraph = repo.getValueFactory().createIRI("urn:data");

		loadTurtle(repo, ontologyTurtle(), ontologyGraph);
		loadTurtle(repo, trainShapeTurtle(null, null), RDF4J.SHACL_SHAPE_GRAPH);
		loadTurtle(repo, dataTurtle(), dataGraph);

		try (RepositoryConnection conn = repo.getConnection()) {
			conn.begin();
			conn.prepareUpdate(QueryLanguage.SPARQL, insertUpdate()).execute();
			assertThrows(ShaclSailValidationException.class, () -> commitAndRethrow(conn));
		} finally {
			repo.shutDown();
		}
	}

	@Test
	public void inversePathClassConstraintPassesWithIncludeInferredStatements() throws Exception {
		SailRepository repo = createRepository(true, false);

		IRI ontologyGraph = repo.getValueFactory().createIRI("urn:ontology");
		IRI dataGraph = repo.getValueFactory().createIRI("urn:data");

		loadTurtle(repo, ontologyTurtle(), ontologyGraph);
		loadTurtle(repo, trainShapeTurtle(null, null), RDF4J.SHACL_SHAPE_GRAPH);
		loadTurtle(repo, dataTurtle(), dataGraph);

		try (RepositoryConnection conn = repo.getConnection()) {
			conn.begin();
			conn.prepareUpdate(QueryLanguage.SPARQL, insertUpdate()).execute();
			assertDoesNotThrow(() -> commitAndRethrow(conn));
		} finally {
			repo.shutDown();
		}
	}

	@Test
	public void inversePathClassConstraintPassesWithPerShapeIncludeInferredStatements() throws Exception {
		SailRepository repo = createRepository(false, false);

		IRI ontologyGraph = repo.getValueFactory().createIRI("urn:ontology");
		IRI dataGraph = repo.getValueFactory().createIRI("urn:data");

		loadTurtle(repo, ontologyTurtle(), ontologyGraph);
		loadTurtle(repo, trainShapeTurtle(null, true), RDF4J.SHACL_SHAPE_GRAPH);
		loadTurtle(repo, dataTurtle(), dataGraph);

		try (RepositoryConnection conn = repo.getConnection()) {
			conn.begin();
			conn.prepareUpdate(QueryLanguage.SPARQL, insertUpdate()).execute();
			assertDoesNotThrow(() -> commitAndRethrow(conn));
		} finally {
			repo.shutDown();
		}
	}

	@Test
	public void inferredTargetClassChangeIsDetectedWhenInferredStatementsReported() throws Exception {
		SailRepository repo = createRepository(true, false);

		IRI ontologyGraph = repo.getValueFactory().createIRI("urn:ontology");
		IRI dataGraph = repo.getValueFactory().createIRI("urn:data");

		loadTurtle(repo, ontologyTurtle(), ontologyGraph);
		loadTurtle(repo, railcarBrakeShapeTurtle(null, null), RDF4J.SHACL_SHAPE_GRAPH);

		IRI wagon1 = repo.getValueFactory().createIRI("urn:wagon1");
		IRI freightWagon = repo.getValueFactory().createIRI("https://example.com/trains/FreightWagon");

		try (RepositoryConnection conn = repo.getConnection()) {
			conn.begin();
			conn.add(wagon1, RDF.TYPE, freightWagon, dataGraph);
			assertThrows(ShaclSailValidationException.class, () -> commitAndRethrow(conn));
		} finally {
			repo.shutDown();
		}
	}

	@Test
	public void targetClassUsesPerShapeRdfsSubClassReasoning() throws Exception {
		SailRepository repo = createRepository(false, false, false);

		IRI ontologyGraph = repo.getValueFactory().createIRI("urn:ontology");
		IRI dataGraph = repo.getValueFactory().createIRI("urn:data");

		loadTurtle(repo, ontologyTurtle(), ontologyGraph);
		loadTurtle(repo, railcarBrakeShapeTurtle(true, null), RDF4J.SHACL_SHAPE_GRAPH);

		IRI wagon1 = repo.getValueFactory().createIRI("urn:wagon1");
		IRI freightWagon = repo.getValueFactory().createIRI("https://example.com/trains/FreightWagon");

		try (RepositoryConnection conn = repo.getConnection()) {
			conn.begin();
			conn.add(wagon1, RDF.TYPE, freightWagon, dataGraph);
			assertThrows(ShaclSailValidationException.class, () -> commitAndRethrow(conn));
		} finally {
			repo.shutDown();
		}
	}

	@Test
	public void inferredTargetClassChangeIsMissedWhenInferredStatementsNotReported() throws Exception {
		SailRepository repo = createRepository(true, true);

		IRI ontologyGraph = repo.getValueFactory().createIRI("urn:ontology");
		IRI dataGraph = repo.getValueFactory().createIRI("urn:data");

		loadTurtle(repo, ontologyTurtle(), ontologyGraph);
		loadTurtle(repo, railcarBrakeShapeTurtle(null, null), RDF4J.SHACL_SHAPE_GRAPH);

		IRI wagon1 = repo.getValueFactory().createIRI("urn:wagon1");
		IRI freightWagon = repo.getValueFactory().createIRI("https://example.com/trains/FreightWagon");

		try (RepositoryConnection conn = repo.getConnection()) {
			conn.begin();
			conn.add(wagon1, RDF.TYPE, freightWagon, dataGraph);
			assertDoesNotThrow(() -> commitAndRethrow(conn));
		}

		try (SailRepositoryConnection conn = repo.getConnection()) {
			conn.begin();
			ValidationReport report = ((ShaclSailConnection) conn.getSailConnection()).revalidate();
			assertFalse(report.conforms());
			conn.rollback();
		} finally {
			repo.shutDown();
		}
	}

	@Test
	public void legacyCallbacksWithoutInferenceMetadataFailWhenAShapeDisablesInferredStatements()
			throws Exception {
		SailRepository repo = createRepositoryWithLegacyCallbackForwarding(true);

		IRI ontologyGraph = repo.getValueFactory().createIRI("urn:ontology");
		IRI dataGraph = repo.getValueFactory().createIRI("urn:data");

		loadTurtle(repo, ontologyTurtle(), ontologyGraph);
		loadTurtle(repo, railcarBrakeShapeTurtle(null, false), RDF4J.SHACL_SHAPE_GRAPH);

		IRI wagon1 = repo.getValueFactory().createIRI("urn:wagon1");
		IRI freightWagon = repo.getValueFactory().createIRI("https://example.com/trains/FreightWagon");

		try (RepositoryConnection conn = repo.getConnection()) {
			conn.begin();
			conn.add(wagon1, RDF.TYPE, freightWagon, dataGraph);
			ShaclSailValidationException exception = assertThrows(ShaclSailValidationException.class,
					() -> commitAndRethrow(conn));
			assertTrue(exception.getMessage().contains("does not support shapes that explicitly set"));
			assertTrue(exception.getMessage().contains("statementAdded(Statement, boolean inferred)"));
			assertTrue(exception.getMessage().contains("statementRemoved(Statement, boolean inferred)"));
		} finally {
			repo.shutDown();
		}
	}

	@Test
	public void legacyCallbacksWithoutInferenceMetadataFailWhenGlobalIncludeInferredStatementsIsDisabled()
			throws Exception {
		SailRepository repo = createRepositoryWithLegacyCallbackForwarding(false);

		IRI ontologyGraph = repo.getValueFactory().createIRI("urn:ontology");
		IRI dataGraph = repo.getValueFactory().createIRI("urn:data");

		loadTurtle(repo, ontologyTurtle(), ontologyGraph);
		loadTurtle(repo, railcarBrakeShapeTurtle(null, null), RDF4J.SHACL_SHAPE_GRAPH);

		IRI wagon1 = repo.getValueFactory().createIRI("urn:wagon1");
		IRI freightWagon = repo.getValueFactory().createIRI("https://example.com/trains/FreightWagon");

		try (RepositoryConnection conn = repo.getConnection()) {
			conn.begin();
			conn.add(wagon1, RDF.TYPE, freightWagon, dataGraph);
			ShaclSailValidationException exception = assertThrows(ShaclSailValidationException.class,
					() -> commitAndRethrow(conn));
			assertTrue(exception.getMessage()
					.contains("deprecated SailConnectionListener callbacks without inferred flags"));
			assertTrue(exception.getMessage().contains("statementAdded(Statement, boolean inferred)"));
			assertTrue(exception.getMessage().contains("statementRemoved(Statement, boolean inferred)"));
		} finally {
			repo.shutDown();
		}
	}

	@Test
	public void legacyCallbacksWithoutInferenceMetadataAreAcceptedWhenAllShapesIncludeInferredStatements()
			throws Exception {
		SailRepository repo = createRepositoryWithLegacyCallbackForwarding(true);

		IRI ontologyGraph = repo.getValueFactory().createIRI("urn:ontology");
		IRI dataGraph = repo.getValueFactory().createIRI("urn:data");

		loadTurtle(repo, ontologyTurtle(), ontologyGraph);
		loadTurtle(repo, railcarBrakeShapeTurtle(null, null), RDF4J.SHACL_SHAPE_GRAPH);

		IRI wagon1 = repo.getValueFactory().createIRI("urn:wagon1");
		IRI freightWagon = repo.getValueFactory().createIRI("https://example.com/trains/FreightWagon");

		try (RepositoryConnection conn = repo.getConnection()) {
			conn.begin();
			assertDoesNotThrow(() -> conn.add(wagon1, RDF.TYPE, freightWagon, dataGraph));
			conn.rollback();
		} finally {
			repo.shutDown();
		}
	}

	private static SailRepository createRepository(boolean includeInferredStatements,
			boolean filterInferredNotifications) {
		return createRepository(includeInferredStatements, filterInferredNotifications, true);
	}

	private static SailRepository createRepositoryWithLegacyCallbackForwarding(boolean includeInferredStatements) {
		NotifyingSail baseSail = new LegacyCallbackForwardingSail(new MemoryStore());
		NotifyingSail shaclBase = new SchemaCachingRDFSInferencer(baseSail);
		ShaclSail shaclSail = new ShaclSail(shaclBase);
		shaclSail.setRdfsSubClassReasoning(false);
		shaclSail.setIncludeInferredStatements(includeInferredStatements);
		shaclSail.setEclipseRdf4jShaclExtensions(true);
		shaclSail.setSerializableValidation(false);

		SailRepository repo = new SailRepository(shaclSail);
		repo.init();
		return repo;
	}

	private static SailRepository createRepository(boolean includeInferredStatements,
			boolean filterInferredNotifications,
			boolean useSchemaCachingInferencer) {
		NotifyingSail baseSail = new MemoryStore();
		if (filterInferredNotifications) {
			baseSail = new InferredStatementFilteringSail(baseSail);
		}
		NotifyingSail shaclBase = baseSail;
		if (useSchemaCachingInferencer) {
			shaclBase = new SchemaCachingRDFSInferencer(baseSail);
		}
		ShaclSail shaclSail = new ShaclSail(shaclBase);
		shaclSail.setRdfsSubClassReasoning(false);
		shaclSail.setIncludeInferredStatements(includeInferredStatements);
		shaclSail.setEclipseRdf4jShaclExtensions(true);
		shaclSail.setSerializableValidation(false);

		SailRepository repo = new SailRepository(shaclSail);
		repo.init();
		return repo;
	}

	private static void loadTurtle(SailRepository repo, String resource, IRI context) throws IOException {
		try (RepositoryConnection conn = repo.getConnection()) {
			conn.begin(IsolationLevels.NONE, ShaclSail.TransactionSettings.ValidationApproach.Disabled);
			conn.add(new StringReader(resource), "", RDFFormat.TURTLE, context);
			conn.commit();
		}
	}

	private static void commitAndRethrow(RepositoryConnection conn) throws Throwable {
		try {
			conn.commit();
		} catch (RepositoryException e) {
			conn.rollback();
			throw e.getCause() == null ? e : e.getCause();
		}
	}

	private static String ontologyTurtle() {
		return String.join("\n",
				"@prefix tr: <https://example.com/trains/> .",
				"@prefix owl: <http://www.w3.org/2002/07/owl#> .",
				"@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .",
				"",
				"tr:Train a owl:Class .",
				"tr:Railcar a owl:Class .",
				"tr:FreightWagon a owl:Class ;",
				"    rdfs:subClassOf tr:Railcar .",
				"tr:hasRailcar a owl:ObjectProperty .",
				"tr:hasBrake a owl:ObjectProperty .",
				"tr:isRailcarOf owl:inverseOf tr:hasRailcar .",
				""
		);
	}

	private static String trainShapeTurtle(Boolean rdfsSubClassReasoning, Boolean includeInferredStatements) {
		List<String> lines = new ArrayList<>();
		lines.add("@prefix tr: <https://example.com/trains/> .");
		lines.add("@prefix owl: <http://www.w3.org/2002/07/owl#> .");
		lines.add("@prefix sh: <http://www.w3.org/ns/shacl#> .");
		if (rdfsSubClassReasoning != null || includeInferredStatements != null) {
			lines.add("@prefix rsx: <http://rdf4j.org/shacl-extensions#> .");
		}
		lines.add("");
		lines.add("tr:TrainShape a owl:NamedIndividual, sh:NodeShape ;");
		lines.add("    sh:property [");
		lines.add("            sh:class tr:Railcar ;");
		lines.add("            sh:path [ sh:inversePath tr:isRailcarOf ]");
		lines.add("    ] ;");
		if (rdfsSubClassReasoning != null) {
			lines.add("    rsx:rdfsSubClassReasoning " + rdfsSubClassReasoning + " ;");
		}
		if (includeInferredStatements != null) {
			lines.add("    rsx:includeInferredStatements " + includeInferredStatements + " ;");
		}
		lines.add("    sh:targetClass tr:Train .");
		lines.add("");
		return String.join("\n", lines);
	}

	private static String railcarBrakeShapeTurtle(Boolean rdfsSubClassReasoning, Boolean includeInferredStatements) {
		List<String> lines = new ArrayList<>();
		lines.add("@prefix tr: <https://example.com/trains/> .");
		lines.add("@prefix owl: <http://www.w3.org/2002/07/owl#> .");
		lines.add("@prefix sh: <http://www.w3.org/ns/shacl#> .");
		if (rdfsSubClassReasoning != null || includeInferredStatements != null) {
			lines.add("@prefix rsx: <http://rdf4j.org/shacl-extensions#> .");
		}
		lines.add("");
		lines.add("tr:RailcarBrakeShape a owl:NamedIndividual, sh:NodeShape ;");
		lines.add("    sh:targetClass tr:Railcar ;");
		if (rdfsSubClassReasoning != null) {
			lines.add("    rsx:rdfsSubClassReasoning " + rdfsSubClassReasoning + " ;");
		}
		if (includeInferredStatements != null) {
			lines.add("    rsx:includeInferredStatements " + includeInferredStatements + " ;");
		}
		lines.add("    sh:property [");
		lines.add("            sh:path tr:hasBrake ;");
		lines.add("            sh:minCount 1");
		lines.add("    ] .");
		lines.add("");
		return String.join("\n", lines);
	}

	private static String dataTurtle() {
		return String.join("\n",
				"@prefix tr: <https://example.com/trains/> .",
				"",
				"<urn:train1> a tr:Train .",
				"<urn:wagon1> a tr:FreightWagon .",
				""
		);
	}

	private static String insertUpdate() {
		return String.join("\n",
				"PREFIX tr: <https://example.com/trains/>",
				"INSERT DATA {",
				"  GRAPH <urn:data> {",
				"    <urn:wagon1> tr:isRailcarOf <urn:train1> .",
				"  }",
				"}",
				""
		);
	}

	// Test helper: hide inferred change notifications from listeners.
	private static final class InferredStatementFilteringSail extends NotifyingSailWrapper {
		InferredStatementFilteringSail(NotifyingSail baseSail) {
			super(baseSail);
		}

		@Override
		public NotifyingSailConnection getConnection() throws SailException {
			InferencerConnection connection = (InferencerConnection) super.getConnection();
			return new InferredStatementFilteringConnection(connection);
		}
	}

	private static final class InferredStatementFilteringConnection extends InferencerConnectionWrapper {
		private final Map<SailConnectionListener, SailConnectionListener> listenerMap = new IdentityHashMap<>();

		InferredStatementFilteringConnection(InferencerConnection wrappedCon) {
			super(wrappedCon);
		}

		@Override
		public void addConnectionListener(SailConnectionListener listener) {
			SailConnectionListener filteringListener = new SailConnectionListener() {
				@Override
				public void statementAdded(Statement st) {
					statementAdded(st, false);
				}

				@Override
				public void statementRemoved(Statement st) {
					statementRemoved(st, false);
				}

				@Override
				public void statementAdded(Statement st, boolean inferred) {
					if (!inferred) {
						listener.statementAdded(st, false);
					}
				}

				@Override
				public void statementRemoved(Statement st, boolean inferred) {
					if (!inferred) {
						listener.statementRemoved(st, false);
					}
				}
			};
			listenerMap.put(listener, filteringListener);
			super.addConnectionListener(filteringListener);
		}

		@Override
		public void removeConnectionListener(SailConnectionListener listener) {
			SailConnectionListener filteringListener = listenerMap.remove(listener);
			if (filteringListener != null) {
				super.removeConnectionListener(filteringListener);
			} else {
				super.removeConnectionListener(listener);
			}
		}
	}

	// Test helper: force all notifications through deprecated no-flag listener methods.
	private static final class LegacyCallbackForwardingSail extends NotifyingSailWrapper {
		LegacyCallbackForwardingSail(NotifyingSail baseSail) {
			super(baseSail);
		}

		@Override
		public NotifyingSailConnection getConnection() throws SailException {
			InferencerConnection connection = (InferencerConnection) super.getConnection();
			return new LegacyCallbackForwardingConnection(connection);
		}
	}

	private static final class LegacyCallbackForwardingConnection extends InferencerConnectionWrapper {
		private final Map<SailConnectionListener, SailConnectionListener> listenerMap = new IdentityHashMap<>();

		LegacyCallbackForwardingConnection(InferencerConnection wrappedCon) {
			super(wrappedCon);
		}

		@Override
		public void addConnectionListener(SailConnectionListener listener) {
			SailConnectionListener legacyForwardingListener = new SailConnectionListener() {
				@Override
				public void statementAdded(Statement st) {
					listener.statementAdded(st);
				}

				@Override
				public void statementRemoved(Statement st) {
					listener.statementRemoved(st);
				}

				@Override
				public void statementAdded(Statement st, boolean inferred) {
					listener.statementAdded(st);
				}

				@Override
				public void statementRemoved(Statement st, boolean inferred) {
					listener.statementRemoved(st);
				}
			};
			listenerMap.put(listener, legacyForwardingListener);
			super.addConnectionListener(legacyForwardingListener);
		}

		@Override
		public void removeConnectionListener(SailConnectionListener listener) {
			SailConnectionListener filteringListener = listenerMap.remove(listener);
			if (filteringListener != null) {
				super.removeConnectionListener(filteringListener);
			} else {
				super.removeConnectionListener(listener);
			}
		}
	}

}
