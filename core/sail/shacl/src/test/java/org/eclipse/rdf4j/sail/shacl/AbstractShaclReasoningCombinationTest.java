/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex

package org.eclipse.rdf4j.sail.shacl;

import java.io.StringReader;
import java.util.Set;

import org.eclipse.rdf4j.common.transaction.IsolationLevels;
import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.util.Values;
import org.eclipse.rdf4j.model.vocabulary.RDF4J;
import org.eclipse.rdf4j.query.QueryLanguage;
import org.eclipse.rdf4j.repository.RepositoryConnection;
import org.eclipse.rdf4j.repository.RepositoryException;
import org.eclipse.rdf4j.repository.sail.SailRepository;
import org.eclipse.rdf4j.rio.RDFFormat;
import org.eclipse.rdf4j.sail.NotifyingSail;
import org.eclipse.rdf4j.sail.memory.MemoryStore;
import org.eclipse.rdf4j.sail.shacl.ShaclSail.TransactionSettings.ValidationApproach;
import org.eclipse.rdf4j.sail.shacl.results.ValidationReport;
import org.junit.jupiter.api.Assertions;

abstract class AbstractShaclReasoningCombinationTest {

	protected static final IRI DATA_GRAPH = Values.iri("urn:data");
	protected static final IRI ONTOLOGY_GRAPH = Values.iri("urn:ontology");

	protected static final class ReasoningCase {
		final String name;
		final String shapesTurtle;
		final String dataTurtle;
		final String updatePart1;
		final String updatePart2;
		final boolean conformsWhenEnabled;
		final boolean conformsWhenDisabled;

		ReasoningCase(String name, String shapesTurtle, String dataTurtle, String updatePart1, String updatePart2,
				boolean conformsWhenEnabled, boolean conformsWhenDisabled) {
			this.name = name;
			this.shapesTurtle = shapesTurtle;
			this.dataTurtle = dataTurtle;
			this.updatePart1 = updatePart1;
			this.updatePart2 = updatePart2;
			this.conformsWhenEnabled = conformsWhenEnabled;
			this.conformsWhenDisabled = conformsWhenDisabled;
		}

		boolean expectedConforms(boolean enabled) {
			return enabled ? conformsWhenEnabled : conformsWhenDisabled;
		}

		@Override
		public String toString() {
			return name;
		}
	}

	protected void runAllModes(ReasoningCase testCase, boolean expectedEnabled, boolean rdfsSubClassReasoning,
			boolean includeInferredStatements) {
		assertSingleTransaction(testCase, expectedEnabled, rdfsSubClassReasoning, includeInferredStatements);
		assertBulkValidation(testCase, expectedEnabled, rdfsSubClassReasoning, includeInferredStatements);
		assertMultiUpdateTransaction(testCase, expectedEnabled, rdfsSubClassReasoning, includeInferredStatements);
		assertShaclValidator(testCase, expectedEnabled, rdfsSubClassReasoning, includeInferredStatements);
	}

	protected abstract NotifyingSail createDataSail();

	protected abstract String ontologyTurtle();

	private void assertSingleTransaction(ReasoningCase testCase, boolean expectedEnabled, boolean rdfsSubClassReasoning,
			boolean includeInferredStatements) {
		SailRepository repository = createRepository(testCase, rdfsSubClassReasoning, includeInferredStatements);
		try {
			try (RepositoryConnection connection = repository.getConnection()) {
				connection.begin(IsolationLevels.NONE);
				addTurtle(connection, testCase.dataTurtle, DATA_GRAPH);
				commitExpecting(testCase, expectedEnabled, connection, "single transaction");
			}
		} finally {
			repository.shutDown();
		}
	}

	private void assertBulkValidation(ReasoningCase testCase, boolean expectedEnabled, boolean rdfsSubClassReasoning,
			boolean includeInferredStatements) {
		SailRepository repository = createRepository(testCase, rdfsSubClassReasoning, includeInferredStatements);
		try {
			loadDataWithoutValidation(repository, testCase.dataTurtle);
			try (RepositoryConnection connection = repository.getConnection()) {
				connection.begin(ValidationApproach.Bulk);
				try {
					connection.commit();
					Assertions.assertTrue(testCase.expectedConforms(expectedEnabled),
							"bulk validation should have failed");
				} catch (RepositoryException e) {
					connection.rollback();
					Throwable cause = e.getCause();
					if (!(cause instanceof ShaclSailValidationException)) {
						throw e;
					}
					Assertions.assertFalse(testCase.expectedConforms(expectedEnabled),
							"bulk validation unexpectedly failed");
				}
			}
		} finally {
			repository.shutDown();
		}
	}

	private void assertMultiUpdateTransaction(ReasoningCase testCase, boolean expectedEnabled,
			boolean rdfsSubClassReasoning,
			boolean includeInferredStatements) {
		SailRepository repository = createRepository(testCase, rdfsSubClassReasoning, includeInferredStatements);
		try {
			try (RepositoryConnection connection = repository.getConnection()) {
				connection.begin(IsolationLevels.NONE);
				connection.prepareUpdate(QueryLanguage.SPARQL, testCase.updatePart1).execute();
				connection.prepareUpdate(QueryLanguage.SPARQL, testCase.updatePart2).execute();
				commitExpecting(testCase, expectedEnabled, connection, "multi-update transaction");
			}
		} finally {
			repository.shutDown();
		}
	}

	private void assertShaclValidator(ReasoningCase testCase, boolean expectedEnabled, boolean rdfsSubClassReasoning,
			boolean includeInferredStatements) {
		SailRepository shapesRepo = new SailRepository(new MemoryStore());
		SailRepository dataRepo = new SailRepository(createDataSail());
		try {
			shapesRepo.init();
			dataRepo.init();
			loadShapes(shapesRepo, testCase.shapesTurtle);
			loadOntology(dataRepo);
			loadDataWithoutValidation(dataRepo, testCase.dataTurtle);

			ValidationReport report = ShaclValidator.builder()
					.setEclipseRdf4jShaclExtensions(true)
					.setCacheSelectNodes(true)
					.setParallelValidation(false)
					.setRdfsSubClassReasoning(rdfsSubClassReasoning)
					.setIncludeInferredStatements(includeInferredStatements)
					.withShapes(shapesRepo.getSail())
					.build()
					.validate(dataRepo.getSail());

			Assertions.assertEquals(testCase.expectedConforms(expectedEnabled), report.conforms(),
					"ShaclValidator result mismatch");
		} finally {
			try {
				shapesRepo.shutDown();
			} finally {
				dataRepo.shutDown();
			}
		}
	}

	private void commitExpecting(ReasoningCase testCase, boolean expectedEnabled, RepositoryConnection connection,
			String label) {
		boolean expectedConforms = testCase.expectedConforms(expectedEnabled);
		try {
			connection.commit();
			Assertions.assertTrue(expectedConforms, label + " should have failed");
		} catch (RepositoryException e) {
			connection.rollback();
			Throwable cause = e.getCause();
			if (!(cause instanceof ShaclSailValidationException)) {
				throw e;
			}
			Assertions.assertFalse(expectedConforms, label + " should have conformed");
		}
	}

	private SailRepository createRepository(ReasoningCase testCase, boolean rdfsSubClassReasoning,
			boolean includeInferredStatements) {
		SailRepository repository = new SailRepository(
				createShaclSail(rdfsSubClassReasoning, includeInferredStatements));
		repository.init();
		loadShapes(repository, testCase.shapesTurtle);
		loadOntology(repository);
		return repository;
	}

	private ShaclSail createShaclSail(boolean rdfsSubClassReasoning, boolean includeInferredStatements) {
		NotifyingSail baseSail = createDataSail();
		ShaclSail shaclSail = new ShaclSail(baseSail);
		shaclSail.setLogValidationPlans(false);
		shaclSail.setCacheSelectNodes(true);
		shaclSail.setParallelValidation(false);
		shaclSail.setLogValidationViolations(false);
		shaclSail.setGlobalLogValidationExecution(false);
		shaclSail.setEclipseRdf4jShaclExtensions(true);
		shaclSail.setDashDataShapes(false);
		shaclSail.setPerformanceLogging(false);
		shaclSail.setSerializableValidation(false);
		shaclSail.setShapesGraphs(Set.of(RDF4J.SHACL_SHAPE_GRAPH));
		shaclSail.setRdfsSubClassReasoning(rdfsSubClassReasoning);
		shaclSail.setIncludeInferredStatements(includeInferredStatements);
		return shaclSail;
	}

	private void loadShapes(SailRepository repository, String turtle) {
		try (RepositoryConnection connection = repository.getConnection()) {
			connection.begin(IsolationLevels.NONE, ValidationApproach.Disabled);
			addTurtle(connection, turtle, RDF4J.SHACL_SHAPE_GRAPH);
			connection.commit();
		}
	}

	private void loadOntology(SailRepository repository) {
		try (RepositoryConnection connection = repository.getConnection()) {
			connection.begin(IsolationLevels.NONE, ValidationApproach.Disabled);
			addTurtle(connection, ontologyTurtle(), ONTOLOGY_GRAPH);
			connection.commit();
		}
	}

	private void loadDataWithoutValidation(SailRepository repository, String turtle) {
		try (RepositoryConnection connection = repository.getConnection()) {
			connection.begin(IsolationLevels.NONE, ValidationApproach.Disabled);
			addTurtle(connection, turtle, DATA_GRAPH);
			connection.commit();
		}
	}

	private static void addTurtle(RepositoryConnection connection, String turtle, IRI context) {
		try {
			connection.add(new StringReader(turtle), "", RDFFormat.TURTLE, context);
		} catch (java.io.IOException e) {
			throw new RuntimeException(e);
		}
	}
}
