/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex

package org.eclipse.rdf4j.sail.shacl;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

import org.eclipse.rdf4j.common.transaction.IsolationLevels;
import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Resource;
import org.eclipse.rdf4j.model.Statement;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.model.vocabulary.RDF;
import org.eclipse.rdf4j.model.vocabulary.RDFS;
import org.eclipse.rdf4j.repository.sail.SailRepository;
import org.eclipse.rdf4j.repository.sail.SailRepositoryConnection;
import org.eclipse.rdf4j.sail.SailConnection;
import org.eclipse.rdf4j.sail.memory.MemoryStore;
import org.eclipse.rdf4j.sail.shacl.wrapper.data.ConnectionsGroup;
import org.eclipse.rdf4j.sail.shacl.wrapper.data.RdfsSubClassOfReasoner;
import org.junit.jupiter.api.Test;

class ShaclSailInferredDeltaInternalsTest {

	private static final SimpleValueFactory VF = SimpleValueFactory.getInstance();

	private static final Resource[] ALL_CONTEXTS = { null };

	private static final IRI TARGET = VF.createIRI("urn:target");
	private static final IRI BASE_P = VF.createIRI("urn:baseP");
	private static final IRI BASE_O = VF.createIRI("urn:baseO");
	private static final IRI CLASS_SUB = VF.createIRI("urn:ClassSub");
	private static final IRI CLASS_SUPER = VF.createIRI("urn:ClassSuper");

	@Test
	void fillAddedAndRemovedRepositoriesShouldCombineExplicitAndInferredStoresBySettings() throws Exception {
		try (ShaclConnectionHarness harness = new ShaclConnectionHarness()) {
			harness.shaclConnection.rdfsSubClassOfReasoner = createReasoner(CLASS_SUB, CLASS_SUPER);

			Statement explicitType = VF.createStatement(TARGET, RDF.TYPE, CLASS_SUB);
			Statement baseInferred = VF.createStatement(TARGET, BASE_P, BASE_O);

			harness.shaclConnection.statementAdded(explicitType, false);
			harness.shaclConnection.statementAdded(baseInferred, true);
			harness.shaclConnection.fillAddedAndRemovedStatementRepositories();

			assertAddedVisibility(harness.shaclConnection, false, false, true, false, false);
			assertAddedVisibility(harness.shaclConnection, true, false, true, true, false);
			assertAddedVisibility(harness.shaclConnection, false, true, true, false, true);
			assertAddedVisibility(harness.shaclConnection, true, true, true, true, true);
		}
	}

	@Test
	void fillInferredRepositoryShouldFilterStatementsPresentInBothAddedAndRemovedInferredSets() throws Exception {
		try (ShaclConnectionHarness harness = new ShaclConnectionHarness()) {
			Statement inferredStatement = VF.createStatement(TARGET, BASE_P, BASE_O);

			harness.shaclConnection.statementAdded(inferredStatement, true);
			harness.shaclConnection.statementRemoved(inferredStatement, true);
			harness.shaclConnection.fillAddedAndRemovedStatementRepositories();

			try (ConnectionsGroup connectionsGroup = harness.shaclConnection.getConnectionsGroup(
					harness.shaclConnection.getWrappedConnection(), null, true, false)) {
				assertNotNull(connectionsGroup.getAddedStatements(),
						"Expected inferred added-store to be created when inferred additions are tracked");
				assertNotNull(connectionsGroup.getRemovedStatements(),
						"Expected inferred removed-store to be created when inferred removals are tracked");
				assertFalse(
						connectionsGroup.getAddedStatements().hasStatement(TARGET, BASE_P, BASE_O, true, ALL_CONTEXTS),
						"Expected overlapping inferred statement to be filtered from added-store");
				assertFalse(
						connectionsGroup.getRemovedStatements()
								.hasStatement(TARGET, BASE_P, BASE_O, true, ALL_CONTEXTS),
						"Expected overlapping inferred statement to be filtered from removed-store");
			}
		}
	}

	private static void assertAddedVisibility(ShaclSailConnection shaclConnection, boolean includeInferred,
			boolean useRdfsSubClassReasoning, boolean expectExplicitType, boolean expectBaseInferred,
			boolean expectRdfsInferredType) {
		try (ConnectionsGroup connectionsGroup = shaclConnection.getConnectionsGroup(
				shaclConnection.getWrappedConnection(),
				null, includeInferred, useRdfsSubClassReasoning)) {
			SailConnection addedStatements = connectionsGroup.getAddedStatements();
			assertNotNull(addedStatements, "Expected added-statement store to be available");
			assertEquals(expectExplicitType,
					addedStatements.hasStatement(TARGET, RDF.TYPE, CLASS_SUB, true, ALL_CONTEXTS),
					"Explicit type statement visibility mismatch");
			assertEquals(expectBaseInferred,
					addedStatements.hasStatement(TARGET, BASE_P, BASE_O, true, ALL_CONTEXTS),
					"Base inferred statement visibility mismatch");
			assertEquals(expectRdfsInferredType,
					addedStatements.hasStatement(TARGET, RDF.TYPE, CLASS_SUPER, true, ALL_CONTEXTS),
					"RDFS inferred type statement visibility mismatch");
		}
	}

	private static void assertEquals(boolean expected, boolean actual, String message) {
		if (expected) {
			assertTrue(actual, message);
		} else {
			assertFalse(actual, message);
		}
	}

	private static RdfsSubClassOfReasoner createReasoner(IRI subClass, IRI superClass) {
		MemoryStore memoryStore = new MemoryStore();
		memoryStore.init();
		try (SailConnection connection = memoryStore.getConnection()) {
			connection.begin(IsolationLevels.NONE);
			connection.addStatement(subClass, RDFS.SUBCLASSOF, superClass);
			connection.commit();

			connection.begin(IsolationLevels.NONE);
			return RdfsSubClassOfReasoner.createReasoner(connection, new ValidationSettings());
		} finally {
			memoryStore.shutDown();
		}
	}

	private static final class ShaclConnectionHarness implements AutoCloseable {
		private final SailRepository repository;
		private final SailRepositoryConnection repositoryConnection;
		private final ShaclSailConnection shaclConnection;

		private ShaclConnectionHarness() {
			ShaclSail shaclSail = new ShaclSail(new MemoryStore());
			shaclSail.setSerializableValidation(false);
			repository = new SailRepository(shaclSail);
			repository.init();

			try (SailRepositoryConnection seedConnection = repository.getConnection()) {
				seedConnection.begin(IsolationLevels.NONE, ShaclSail.TransactionSettings.ValidationApproach.Disabled);
				seedConnection.add(VF.createIRI("urn:seed"), VF.createIRI("urn:seedPredicate"),
						VF.createIRI("urn:seedObject"));
				seedConnection.commit();
			}

			repositoryConnection = repository.getConnection();
			repositoryConnection.begin(IsolationLevels.NONE);
			shaclConnection = (ShaclSailConnection) repositoryConnection.getSailConnection();
		}

		@Override
		public void close() {
			try {
				try {
					repositoryConnection.rollback();
				} catch (Exception ignored) {
					// ignore
				}
				repositoryConnection.close();
			} finally {
				repository.shutDown();
			}
		}
	}
}
