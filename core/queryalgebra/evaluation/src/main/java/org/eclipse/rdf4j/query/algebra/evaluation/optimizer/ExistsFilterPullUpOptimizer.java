/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.BinaryValueOperator;
import org.eclipse.rdf4j.query.algebra.Exists;
import org.eclipse.rdf4j.query.algebra.Filter;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.NAryValueOperator;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.UnaryValueOperator;
import org.eclipse.rdf4j.query.algebra.ValueExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryOptimizer;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractSimpleQueryModelVisitor;

/**
 * Pulls up Filters containing {@link Exists} over joins where the right operand does not introduce new bindings.
 * <p>
 * This reduces the number of EXISTS evaluations when the join can act as a pre-filter.
 */
public class ExistsFilterPullUpOptimizer implements QueryOptimizer {

	@Override
	public void optimize(TupleExpr tupleExpr, Dataset dataset, BindingSet bindings) {
		tupleExpr.visit(new ExistsFilterPullUpVisitor());
	}

	private static final class ExistsFilterPullUpVisitor extends AbstractSimpleQueryModelVisitor<RuntimeException> {
		@Override
		public void meet(Join join) throws RuntimeException {
			super.meet(join);

			if (!(join.getLeftArg() instanceof Filter)) {
				return;
			}

			Filter filter = (Filter) join.getLeftArg();
			ValueExpr condition = filter.getCondition();
			if (!containsExists(condition)) {
				return;
			}

			TupleExpr filterArg = filter.getArg();
			if (filterArg == null) {
				return;
			}

			TupleExpr rightArg = join.getRightArg();
			if (rightArg == null) {
				return;
			}

			if (!(rightArg instanceof StatementPattern)) {
				return;
			}

			if (!introducesNoNewBindings(filterArg, (StatementPattern) rightArg)) {
				return;
			}

			Join rewrittenJoin = new Join(filterArg, rightArg);
			rewrittenJoin.setMergeJoin(join.isMergeJoin());
			Filter pulledUp = new Filter(rewrittenJoin, condition);
			join.replaceWith(pulledUp);
		}

		private static boolean introducesNoNewBindings(TupleExpr leftArg, StatementPattern rightArg) {
			for (Var var : new Var[] { rightArg.getSubjectVar(), rightArg.getPredicateVar(), rightArg.getObjectVar(),
					rightArg.getContextVar() }) {
				if (var == null || var.hasValue()) {
					continue;
				}
				if (!leftArg.getBindingNames().contains(var.getName())) {
					return false;
				}
			}
			return true;
		}

		private static boolean containsExists(ValueExpr expr) {
			if (expr == null) {
				return false;
			}
			if (expr instanceof Exists) {
				return true;
			}
			if (expr instanceof UnaryValueOperator) {
				return containsExists(((UnaryValueOperator) expr).getArg());
			}
			if (expr instanceof BinaryValueOperator) {
				BinaryValueOperator binary = (BinaryValueOperator) expr;
				return containsExists(binary.getLeftArg()) || containsExists(binary.getRightArg());
			}
			if (expr instanceof NAryValueOperator) {
				for (ValueExpr arg : ((NAryValueOperator) expr).getArguments()) {
					if (containsExists(arg)) {
						return true;
					}
				}
				return false;
			}
			return false;
		}
	}
}
