/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.eclipse.rdf4j.model.Literal;
import org.eclipse.rdf4j.model.Value;
import org.eclipse.rdf4j.model.vocabulary.RDF;
import org.eclipse.rdf4j.model.vocabulary.XMLSchema;
import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.And;
import org.eclipse.rdf4j.query.algebra.BinaryTupleOperator;
import org.eclipse.rdf4j.query.algebra.BinaryValueOperator;
import org.eclipse.rdf4j.query.algebra.Compare;
import org.eclipse.rdf4j.query.algebra.Compare.CompareOp;
import org.eclipse.rdf4j.query.algebra.Extension;
import org.eclipse.rdf4j.query.algebra.ExtensionElem;
import org.eclipse.rdf4j.query.algebra.Filter;
import org.eclipse.rdf4j.query.algebra.NAryValueOperator;
import org.eclipse.rdf4j.query.algebra.SameTerm;
import org.eclipse.rdf4j.query.algebra.SubQueryValueOperator;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.UnaryTupleOperator;
import org.eclipse.rdf4j.query.algebra.UnaryValueOperator;
import org.eclipse.rdf4j.query.algebra.ValueConstant;
import org.eclipse.rdf4j.query.algebra.ValueExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryOptimizer;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractSimpleQueryModelVisitor;

/**
 * Inlines FILTER equality constraints into the query tree when the bound variable is assured.
 */
public class FilterEqualityOptimizer implements QueryOptimizer {

	@Override
	public void optimize(TupleExpr tupleExpr, Dataset dataset, BindingSet bindings) {
		tupleExpr.visit(new FilterEqualityVisitor());
	}

	private static final class FilterEqualityVisitor extends AbstractSimpleQueryModelVisitor<RuntimeException> {
		@Override
		public void meet(Filter filter) {
			super.meet(filter);
			TupleExpr arg = filter.getArg();
			if (arg == null) {
				return;
			}
			Map<String, Value> bindings = extractLiteralBindings(filter.getCondition(), arg);
			if (bindings.isEmpty()) {
				return;
			}
			for (Map.Entry<String, Value> entry : bindings.entrySet()) {
				arg.visit(new VarBinder(entry.getKey(), entry.getValue()));
			}
		}
	}

	private static Map<String, Value> extractLiteralBindings(ValueExpr condition, TupleExpr arg) {
		if (condition == null || arg == null) {
			return Map.of();
		}
		Set<String> assuredBindings = arg.getAssuredBindingNames();
		if (assuredBindings.isEmpty()) {
			return Map.of();
		}
		Map<String, String> aliasMap = collectAliasMap(arg);
		Set<String> bindableNames = new HashSet<>(assuredBindings);
		bindableNames.addAll(aliasMap.keySet());
		Map<String, Value> bindings = new HashMap<>();
		if (!collectLiteralBindings(condition, bindings, bindableNames)) {
			return Map.of();
		}
		if (bindings.isEmpty()) {
			return Map.of();
		}
		Map<String, Value> resolved = new HashMap<>();
		for (Map.Entry<String, Value> entry : bindings.entrySet()) {
			String name = entry.getKey();
			Value value = entry.getValue();
			if (assuredBindings.contains(name) && !mergeBinding(resolved, name, value)) {
				return Map.of();
			}
			String source = aliasMap.get(name);
			if (source != null && assuredBindings.contains(source) && !mergeBinding(resolved, source, value)) {
				return Map.of();
			}
		}
		return resolved;
	}

	private static boolean mergeBinding(Map<String, Value> bindings, String name, Value value) {
		Value existing = bindings.get(name);
		if (existing != null && !existing.equals(value)) {
			return false;
		}
		bindings.put(name, value);
		return true;
	}

	private static boolean collectLiteralBindings(ValueExpr expr, Map<String, Value> bindings,
			Collection<String> bindableNames) {
		if (expr instanceof And) {
			And and = (And) expr;
			return collectLiteralBindings(and.getLeftArg(), bindings, bindableNames)
					&& collectLiteralBindings(and.getRightArg(), bindings, bindableNames);
		}
		if (expr instanceof Compare) {
			Compare compare = (Compare) expr;
			if (compare.getOperator() != CompareOp.EQ) {
				return false;
			}
			return extractBinding(compare.getLeftArg(), compare.getRightArg(), bindings, bindableNames,
					LiteralInliningPolicy.STRING_LIKE_ONLY)
					|| extractBinding(compare.getRightArg(), compare.getLeftArg(), bindings, bindableNames,
							LiteralInliningPolicy.STRING_LIKE_ONLY);
		}
		if (expr instanceof SameTerm) {
			SameTerm sameTerm = (SameTerm) expr;
			return extractBinding(sameTerm.getLeftArg(), sameTerm.getRightArg(), bindings, bindableNames,
					LiteralInliningPolicy.ALL)
					|| extractBinding(sameTerm.getRightArg(), sameTerm.getLeftArg(), bindings, bindableNames,
							LiteralInliningPolicy.ALL);
		}
		return false;
	}

	private static boolean extractBinding(ValueExpr varExpr, ValueExpr valueExpr, Map<String, Value> bindings,
			Collection<String> bindableNames, LiteralInliningPolicy literalPolicy) {
		Var var = asUnboundVar(varExpr);
		Value value = asValue(valueExpr);
		if (var == null || value == null) {
			return false;
		}
		if (value instanceof Literal && !isAllowedLiteral((Literal) value, literalPolicy)) {
			return false;
		}
		if (!bindableNames.contains(var.getName())) {
			return false;
		}
		Value existing = bindings.get(var.getName());
		if (existing != null && !existing.equals(value)) {
			return false;
		}
		bindings.put(var.getName(), value);
		return true;
	}

	private static Var asUnboundVar(ValueExpr expr) {
		if (expr instanceof Var) {
			Var var = (Var) expr;
			return var.hasValue() ? null : var;
		}
		return null;
	}

	private static Value asValue(ValueExpr expr) {
		if (expr instanceof ValueConstant) {
			return ((ValueConstant) expr).getValue();
		}
		if (expr instanceof Var) {
			Var var = (Var) expr;
			return var.hasValue() ? var.getValue() : null;
		}
		return null;
	}

	private static boolean isAllowedLiteral(Literal literal, LiteralInliningPolicy policy) {
		switch (policy) {
		case ALL:
			return true;
		case STRING_LIKE_ONLY:
			return isStringLikeLiteral(literal);
		case NONE:
		default:
			return false;
		}
	}

	private static boolean isStringLikeLiteral(Literal literal) {
		return XMLSchema.STRING.equals(literal.getDatatype()) || RDF.LANGSTRING.equals(literal.getDatatype());
	}

	private static Map<String, String> collectAliasMap(TupleExpr arg) {
		Map<String, String> aliasMap = new HashMap<>();
		arg.visit(new AliasCollector(aliasMap));
		return aliasMap;
	}

	private static class AliasCollector extends StopAtScopeChange {
		private final Map<String, String> aliasMap;

		AliasCollector(Map<String, String> aliasMap) {
			super(true);
			this.aliasMap = aliasMap;
		}

		@Override
		public void meet(Extension node) {
			for (ExtensionElem elem : node.getElements()) {
				if (elem.getExpr() instanceof Var) {
					String alias = elem.getName();
					String source = ((Var) elem.getExpr()).getName();
					String existing = aliasMap.get(alias);
					if (existing == null) {
						aliasMap.put(alias, source);
					} else if (!existing.equals(source)) {
						aliasMap.remove(alias);
					}
				}
			}
			super.meet(node);
		}
	}

	private enum LiteralInliningPolicy {
		NONE,
		STRING_LIKE_ONLY,
		ALL
	}

	private static class StopAtScopeChange extends AbstractSimpleQueryModelVisitor<RuntimeException> {

		StopAtScopeChange(boolean meetStatementPatternChildren) {
			super(meetStatementPatternChildren);
		}

		@Override
		public void meetUnaryTupleOperator(UnaryTupleOperator node) {
			if (!node.isVariableScopeChange()) {
				super.meetUnaryTupleOperator(node);
			}
		}

		@Override
		public void meetBinaryTupleOperator(BinaryTupleOperator node) {
			if (!node.isVariableScopeChange()) {
				super.meetBinaryTupleOperator(node);
			}
		}

		@Override
		protected void meetBinaryValueOperator(BinaryValueOperator node) throws RuntimeException {
			if (!node.isVariableScopeChange()) {
				super.meetBinaryValueOperator(node);
			}
		}

		@Override
		protected void meetNAryValueOperator(NAryValueOperator node) throws RuntimeException {
			if (!node.isVariableScopeChange()) {
				super.meetNAryValueOperator(node);
			}
		}

		@Override
		protected void meetSubQueryValueOperator(SubQueryValueOperator node) throws RuntimeException {
			if (!node.isVariableScopeChange()) {
				super.meetSubQueryValueOperator(node);
			}
		}

		@Override
		protected void meetUnaryValueOperator(UnaryValueOperator node) throws RuntimeException {
			if (!node.isVariableScopeChange()) {
				super.meetUnaryValueOperator(node);
			}
		}
	}

	private static class VarBinder extends StopAtScopeChange {
		private final String varName;
		private final Value value;

		VarBinder(String varName, Value value) {
			super(true);
			this.varName = varName;
			this.value = value;
		}

		@Override
		public void meet(Var var) {
			if (var.getName().equals(varName)) {
				var.replaceWith(Var.of(varName, value, var.isAnonymous(), var.isConstant()));
			}
		}
	}
}
