/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;

import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.And;
import org.eclipse.rdf4j.query.algebra.BinaryTupleOperator;
import org.eclipse.rdf4j.query.algebra.BinaryValueOperator;
import org.eclipse.rdf4j.query.algebra.BindingSetAssignment;
import org.eclipse.rdf4j.query.algebra.Distinct;
import org.eclipse.rdf4j.query.algebra.Exists;
import org.eclipse.rdf4j.query.algebra.Extension;
import org.eclipse.rdf4j.query.algebra.ExtensionElem;
import org.eclipse.rdf4j.query.algebra.Filter;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.NAryValueOperator;
import org.eclipse.rdf4j.query.algebra.Projection;
import org.eclipse.rdf4j.query.algebra.ProjectionElem;
import org.eclipse.rdf4j.query.algebra.ProjectionElemList;
import org.eclipse.rdf4j.query.algebra.Service;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.SubQueryValueOperator;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.UnaryTupleOperator;
import org.eclipse.rdf4j.query.algebra.UnaryValueOperator;
import org.eclipse.rdf4j.query.algebra.ValueExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryOptimizer;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractQueryModelVisitor;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractSimpleQueryModelVisitor;

/**
 * Rewrites top-level Filter(EXISTS ...) into a safe semi-join when correlated variables are assuredly bound.
 */
public class ExistsSemiJoinOptimizer implements QueryOptimizer {

	private static final double MAX_RIGHT_TO_LEFT_RATIO = 8.0;
	private static final double MIN_LEFT_TO_RIGHT_RATIO_FOR_SINGLE_STATEMENT_PATTERN = 8.0;

	private final EvaluationStatistics evaluationStatistics;
	private final boolean allowNonImprovingTransforms;

	public ExistsSemiJoinOptimizer() {
		this(new EvaluationStatistics(), true);
	}

	public ExistsSemiJoinOptimizer(EvaluationStatistics evaluationStatistics, boolean allowNonImprovingTransforms) {
		this.evaluationStatistics = evaluationStatistics == null ? new EvaluationStatistics() : evaluationStatistics;
		this.allowNonImprovingTransforms = allowNonImprovingTransforms;
	}

	@Override
	public void optimize(TupleExpr tupleExpr, Dataset dataset, BindingSet bindings) {
		tupleExpr.visit(new ExistsSemiJoinVisitor(evaluationStatistics, allowNonImprovingTransforms));
	}

	private static final class ExistsSemiJoinVisitor extends AbstractSimpleQueryModelVisitor<RuntimeException> {
		private final EvaluationStatistics evaluationStatistics;
		private final boolean allowNonImprovingTransforms;

		private ExistsSemiJoinVisitor(EvaluationStatistics evaluationStatistics, boolean allowNonImprovingTransforms) {
			this.evaluationStatistics = evaluationStatistics;
			this.allowNonImprovingTransforms = allowNonImprovingTransforms;
		}

		@Override
		public void meet(Filter filter) {
			super.meet(filter);
			ExistsExtraction extraction = ExistsExtraction.from(filter.getCondition());
			if (extraction == null) {
				return;
			}
			TupleExpr arg = filter.getArg();
			if (arg == null) {
				return;
			}
			TupleExpr subQuery = extraction.exists.getSubQuery();
			if (subQuery == null) {
				return;
			}
			if (containsService(subQuery)) {
				return;
			}
			Set<String> leftAssured = assuredBindingsWithAliases(arg);
			Set<String> rightAssured = assuredBindingsWithAliases(subQuery);
			Set<String> shared = collectSharedUnboundNames(arg, subQuery);
			if (shared.isEmpty()) {
				return;
			}
			if (!leftAssured.containsAll(shared) || !rightAssured.containsAll(shared)) {
				return;
			}
			if (!hasStatementPatternCoveringVars(subQuery, shared)) {
				return;
			}
			if (shouldKeepExistsAsFilter(arg, subQuery, shared)) {
				return;
			}
			TupleExpr right = buildDistinctProjection(subQuery.clone(), shared);
			if (!shouldRewrite(arg, right)) {
				return;
			}
			Join join = new Join(arg, right);
			if (extraction.remainingCondition == null) {
				filter.replaceWith(join);
				return;
			}
			filter.setArg(join);
			filter.setCondition(extraction.remainingCondition);
		}

		private boolean shouldKeepExistsAsFilter(TupleExpr leftArg, TupleExpr subQuery, Set<String> joinVars) {
			StatementPattern statementPattern = singleStatementPatternOrNull(subQuery);
			if (statementPattern == null) {
				return false;
			}
			Map<String, String> aliases = collectAliasMap(leftArg);
			if (!aliases.isEmpty() && joinVars.stream().anyMatch(aliases::containsKey)) {
				return false;
			}

			int localVarCount = countUnboundNonJoinVars(statementPattern, joinVars);
			if (localVarCount == 0) {
				return true;
			}

			double leftCardinality = estimateLeftArgCardinality(leftArg, joinVars);
			double rightCardinality = evaluationStatistics.getCardinality(subQuery);
			if (!Double.isFinite(leftCardinality) || !Double.isFinite(rightCardinality) || rightCardinality <= 0.0) {
				return true;
			}
			return leftCardinality < rightCardinality * MIN_LEFT_TO_RIGHT_RATIO_FOR_SINGLE_STATEMENT_PATTERN;
		}

		private double estimateLeftArgCardinality(TupleExpr leftArg, Set<String> joinVars) {
			if (joinVars.isEmpty()) {
				return evaluationStatistics.getCardinality(leftArg);
			}
			double[] min = { Double.POSITIVE_INFINITY };
			leftArg.visit(new StopAtScopeChange(true) {
				@Override
				public void meet(BindingSetAssignment node) {
					if (node.getBindingNames().containsAll(joinVars)) {
						min[0] = Math.min(min[0], estimateBindingSetSize(node.getBindingSets()));
					}
					super.meet(node);
				}

				@Override
				public void meet(StatementPattern node) {
					if (!statementPatternContainsAllNames(node, joinVars)) {
						return;
					}
					double cardinality = evaluationStatistics.getCardinality(node);
					if (Double.isFinite(cardinality)) {
						min[0] = Math.min(min[0], cardinality);
					}
				}
			});
			if (Double.isFinite(min[0]) && min[0] != Double.POSITIVE_INFINITY) {
				return min[0];
			}
			return evaluationStatistics.getCardinality(leftArg);
		}

		private int estimateBindingSetSize(Iterable<BindingSet> bindingSets) {
			if (bindingSets == null) {
				return 0;
			}
			if (bindingSets instanceof Collection<?>) {
				return ((Collection<?>) bindingSets).size();
			}
			return 1;
		}

		private boolean statementPatternContainsAllNames(StatementPattern pattern, Set<String> requiredNames) {
			for (String name : requiredNames) {
				if (!statementPatternContainsName(pattern, name)) {
					return false;
				}
			}
			return true;
		}

		private boolean statementPatternContainsName(StatementPattern pattern, String name) {
			return varHasName(pattern.getSubjectVar(), name) || varHasName(pattern.getPredicateVar(), name)
					|| varHasName(pattern.getObjectVar(), name) || varHasName(pattern.getContextVar(), name);
		}

		private boolean varHasName(Var var, String name) {
			return var != null && name.equals(var.getName());
		}

		private boolean shouldRewrite(TupleExpr left, TupleExpr right) {
			if (allowNonImprovingTransforms) {
				return true;
			}
			double leftCardinality = evaluationStatistics.getCardinality(left);
			double rightCardinality = evaluationStatistics.getCardinality(right);
			if (!Double.isFinite(leftCardinality) || !Double.isFinite(rightCardinality) || leftCardinality <= 0.0) {
				return false;
			}
			return rightCardinality <= leftCardinality * MAX_RIGHT_TO_LEFT_RATIO;
		}
	}

	private static TupleExpr buildDistinctProjection(TupleExpr subQuery, Set<String> joinVars) {
		List<String> ordered = new ArrayList<>(joinVars);
		Collections.sort(ordered);
		ProjectionElemList projectionElemList = new ProjectionElemList();
		for (String name : ordered) {
			projectionElemList.addElement(new ProjectionElem(name));
		}
		Projection projection = new Projection(subQuery, projectionElemList, false);
		Distinct distinct = new Distinct(projection);
		distinct.setVariableScopeChange(true);
		return distinct;
	}

	private static boolean containsService(TupleExpr subQuery) {
		AtomicBoolean found = new AtomicBoolean(false);
		subQuery.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			public void meet(Service node) {
				found.set(true);
			}
		});
		return found.get();
	}

	private static Set<String> assuredBindingsWithAliases(TupleExpr expr) {
		Set<String> assured = new LinkedHashSet<>(expr.getAssuredBindingNames());
		Map<String, String> aliases = collectAliasMap(expr);
		if (aliases.isEmpty()) {
			return assured;
		}
		boolean changed;
		do {
			changed = false;
			for (Map.Entry<String, String> entry : aliases.entrySet()) {
				if (assured.contains(entry.getValue()) && assured.add(entry.getKey())) {
					changed = true;
				}
			}
		} while (changed);
		return assured;
	}

	private static Set<String> collectSharedUnboundNames(TupleExpr left, TupleExpr right) {
		Set<String> leftUnbound = collectUnboundVarNames(left);
		leftUnbound.addAll(left.getBindingNames());
		Set<String> rightUnbound = collectUnboundVarNames(right);
		if (rightUnbound.isEmpty()) {
			return Set.of();
		}
		leftUnbound.retainAll(rightUnbound);
		return leftUnbound;
	}

	private static Set<String> collectUnboundVarNames(TupleExpr expr) {
		Set<String> names = new LinkedHashSet<>();
		expr.visit(new StopAtScopeChange(true) {
			@Override
			public void meet(Var node) {
				if (!node.hasValue()) {
					names.add(node.getName());
				}
			}
		});
		Map<String, String> aliases = collectAliasMap(expr);
		if (!aliases.isEmpty()) {
			names.addAll(aliases.keySet());
		}
		return names;
	}

	private static Map<String, String> collectAliasMap(TupleExpr expr) {
		Map<String, String> aliasMap = new HashMap<>();
		expr.visit(new AliasCollector(aliasMap));
		return aliasMap;
	}

	private static StatementPattern singleStatementPatternOrNull(TupleExpr expr) {
		StatementPattern[] match = { null };
		int[] count = { 0 };
		expr.visit(new StopAtScopeChange(true) {
			@Override
			public void meet(StatementPattern node) {
				count[0]++;
				match[0] = node;
			}
		});
		return count[0] == 1 ? match[0] : null;
	}

	private static int countUnboundNonJoinVars(StatementPattern statementPattern, Set<String> joinVars) {
		int count = 0;
		count += isUnboundNonJoinVar(statementPattern.getSubjectVar(), joinVars) ? 1 : 0;
		count += isUnboundNonJoinVar(statementPattern.getPredicateVar(), joinVars) ? 1 : 0;
		count += isUnboundNonJoinVar(statementPattern.getObjectVar(), joinVars) ? 1 : 0;
		count += isUnboundNonJoinVar(statementPattern.getContextVar(), joinVars) ? 1 : 0;
		return count;
	}

	private static boolean isUnboundNonJoinVar(Var var, Set<String> joinVars) {
		return var != null && !var.hasValue() && !joinVars.contains(var.getName());
	}

	private static boolean hasStatementPatternCoveringVars(TupleExpr expr, Set<String> joinVars) {
		if (joinVars.isEmpty()) {
			return false;
		}
		AtomicBoolean found = new AtomicBoolean(false);
		expr.visit(new StopAtScopeChange(true) {
			@Override
			public void meet(StatementPattern node) {
				if (found.get()) {
					return;
				}
				Set<String> vars = new HashSet<>();
				addVarName(node.getSubjectVar(), vars);
				addVarName(node.getPredicateVar(), vars);
				addVarName(node.getObjectVar(), vars);
				addVarName(node.getContextVar(), vars);
				if (vars.containsAll(joinVars)) {
					found.set(true);
				}
			}
		});
		return found.get();
	}

	private static void addVarName(Var var, Set<String> vars) {
		if (var != null) {
			vars.add(var.getName());
		}
	}

	private static final class AliasCollector extends StopAtScopeChange {
		private final Map<String, String> aliasMap;

		private AliasCollector(Map<String, String> aliasMap) {
			super(true);
			this.aliasMap = aliasMap;
		}

		@Override
		public void meet(Extension node) {
			for (ExtensionElem elem : node.getElements()) {
				if (!(elem.getExpr() instanceof Var)) {
					continue;
				}
				String alias = elem.getName();
				String source = ((Var) elem.getExpr()).getName();
				String existing = aliasMap.get(alias);
				if (existing == null) {
					aliasMap.put(alias, source);
				} else if (!existing.equals(source)) {
					aliasMap.remove(alias);
				}
			}
			super.meet(node);
		}
	}

	private static class StopAtScopeChange extends AbstractSimpleQueryModelVisitor<RuntimeException> {

		private StopAtScopeChange(boolean meetStatementPatternChildren) {
			super(meetStatementPatternChildren);
		}

		@Override
		public void meetUnaryTupleOperator(UnaryTupleOperator node) {
			if (!node.isVariableScopeChange()) {
				super.meetUnaryTupleOperator(node);
			}
		}

		@Override
		public void meetBinaryTupleOperator(BinaryTupleOperator node) {
			if (!node.isVariableScopeChange()) {
				super.meetBinaryTupleOperator(node);
			}
		}

		@Override
		protected void meetBinaryValueOperator(BinaryValueOperator node) throws RuntimeException {
			if (!node.isVariableScopeChange()) {
				super.meetBinaryValueOperator(node);
			}
		}

		@Override
		protected void meetNAryValueOperator(NAryValueOperator node) throws RuntimeException {
			if (!node.isVariableScopeChange()) {
				super.meetNAryValueOperator(node);
			}
		}

		@Override
		protected void meetSubQueryValueOperator(SubQueryValueOperator node) throws RuntimeException {
			if (!node.isVariableScopeChange()) {
				super.meetSubQueryValueOperator(node);
			}
		}

		@Override
		protected void meetUnaryValueOperator(UnaryValueOperator node) throws RuntimeException {
			if (!node.isVariableScopeChange()) {
				super.meetUnaryValueOperator(node);
			}
		}
	}

	private static final class ExistsExtraction {
		private final Exists exists;
		private final ValueExpr remainingCondition;

		private ExistsExtraction(Exists exists, ValueExpr remainingCondition) {
			this.exists = exists;
			this.remainingCondition = remainingCondition;
		}

		private static ExistsExtraction from(ValueExpr condition) {
			if (condition == null) {
				return null;
			}
			if (condition instanceof Exists) {
				return new ExistsExtraction((Exists) condition, null);
			}
			if (!(condition instanceof And)) {
				return null;
			}
			List<ValueExpr> conjuncts = new ArrayList<>();
			collectConjuncts(condition, conjuncts);
			Exists exists = null;
			List<ValueExpr> remaining = new ArrayList<>();
			for (ValueExpr expr : conjuncts) {
				if (expr instanceof Exists) {
					if (exists != null) {
						return null;
					}
					exists = (Exists) expr;
					continue;
				}
				if (containsExists(expr)) {
					return null;
				}
				remaining.add(expr);
			}
			if (exists == null) {
				return null;
			}
			ValueExpr remainingCondition = rebuildAndChain(remaining);
			return new ExistsExtraction(exists, remainingCondition);
		}

		private static void collectConjuncts(ValueExpr expr, List<ValueExpr> conjuncts) {
			if (expr instanceof And) {
				And and = (And) expr;
				collectConjuncts(and.getLeftArg(), conjuncts);
				collectConjuncts(and.getRightArg(), conjuncts);
				return;
			}
			conjuncts.add(expr);
		}

		private static ValueExpr rebuildAndChain(List<ValueExpr> conjuncts) {
			if (conjuncts.isEmpty()) {
				return null;
			}
			ValueExpr current = conjuncts.get(0);
			for (int i = 1; i < conjuncts.size(); i++) {
				current = new And(current, conjuncts.get(i));
			}
			return current;
		}

		private static boolean containsExists(ValueExpr expr) {
			AtomicBoolean found = new AtomicBoolean(false);
			expr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
				@Override
				public void meet(Exists node) {
					found.set(true);
				}
			});
			return found.get();
		}
	}
}
