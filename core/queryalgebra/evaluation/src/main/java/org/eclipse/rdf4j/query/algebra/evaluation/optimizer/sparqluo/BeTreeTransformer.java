/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer.sparqluo;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.Var;

public class BeTreeTransformer {
	private final BeCostEstimator costEstimator;
	private final BeBgpCoalescer coalescer = new BeBgpCoalescer();
	private final boolean allowNonImprovingTransforms;

	public BeTreeTransformer(BeCostEstimator costEstimator) {
		this(costEstimator, false);
	}

	public BeTreeTransformer(BeCostEstimator costEstimator, boolean allowNonImprovingTransforms) {
		this.costEstimator = costEstimator;
		this.allowNonImprovingTransforms = allowNonImprovingTransforms;
	}

	public void transform(BeGroupNode root) {
		postOrderTransform(root);
	}

	private void postOrderTransform(BeGroupNode group) {
		for (BeNode child : group.getChildren()) {
			if (child instanceof BeGroupNode) {
				postOrderTransform((BeGroupNode) child);
			} else if (child instanceof BeUnionNode) {
				for (BeGroupNode branch : ((BeUnionNode) child).getBranches()) {
					postOrderTransform(branch);
				}
			} else if (child instanceof BeOptionalNode) {
				postOrderTransform(((BeOptionalNode) child).getRight());
			}
		}
		singleLevelTransform(group);
	}

	private void singleLevelTransform(BeGroupNode group) {
		int index = 0;
		while (index < group.size()) {
			BeNode node = group.getChild(index);
			if (!(node instanceof BeBgpNode)) {
				index++;
				continue;
			}

			BeBgpNode bgp = (BeBgpNode) node;
			Segment segment = segmentForIndex(group, index);
			MergeCandidate bestMerge = decideMerge(group, index, bgp, segment);
			if (bestMerge != null && (bestMerge.deltaCost < 0.0 || allowNonImprovingTransforms)) {
				performMerge(group, index, bgp, bestMerge.union);
				continue;
			}

			applyInjects(group, index, bgp, segment);
			index++;
		}
	}

	private void applyInjects(BeGroupNode group, int bgpIndex, BeBgpNode bgp, Segment segment) {
		for (int i = bgpIndex + 1; i <= segment.end; i++) {
			BeNode node = group.getChild(i);
			if (!(node instanceof BeOptionalNode)) {
				continue;
			}
			BeOptionalNode optional = (BeOptionalNode) node;
			if (!canInject(bgp, optional)) {
				continue;
			}
			double baseCost = costEstimator.estimateGroupCost(group);
			BeUndoToken undo = performInject(optional, bgp);
			double newCost = costEstimator.estimateGroupCost(group);
			double delta = newCost - baseCost;
			if (delta >= 0.0 && !allowNonImprovingTransforms) {
				undo.undo();
			}
		}
	}

	private MergeCandidate decideMerge(BeGroupNode group, int bgpIndex, BeBgpNode bgp, Segment segment) {
		double baseCost = costEstimator.estimateGroupCost(group);
		MergeCandidate best = null;
		for (int i = segment.start; i <= segment.end; i++) {
			BeNode node = group.getChild(i);
			if (!(node instanceof BeUnionNode)) {
				continue;
			}
			BeUnionNode union = (BeUnionNode) node;
			if (!canMerge(bgp, union)) {
				continue;
			}
			BeUndoToken undo = performMerge(group, bgpIndex, bgp, union);
			double newCost = costEstimator.estimateGroupCost(group);
			double delta = newCost - baseCost;
			undo.undo();
			if (best == null || delta < best.deltaCost) {
				best = new MergeCandidate(union, delta);
			}
		}
		return best;
	}

	private Segment segmentForIndex(BeGroupNode group, int index) {
		int start = index;
		while (start > 0 && isTransformable(group.getChild(start - 1))) {
			start--;
		}
		int end = index;
		while (end + 1 < group.size() && isTransformable(group.getChild(end + 1))) {
			end++;
		}
		return new Segment(start, end);
	}

	private boolean isTransformable(BeNode node) {
		return node instanceof BeBgpNode || node instanceof BeUnionNode || node instanceof BeOptionalNode;
	}

	private boolean canMerge(BeBgpNode bgp, BeUnionNode union) {
		for (BeGroupNode branch : union.getBranches()) {
			if (containsCoalescableBgp(bgp, branch)) {
				return true;
			}
		}
		return false;
	}

	private boolean canInject(BeBgpNode bgp, BeOptionalNode optional) {
		return containsCoalescableBgp(bgp, optional.getRight());
	}

	private boolean containsCoalescableBgp(BeBgpNode source, BeGroupNode group) {
		for (BeNode child : group.getChildren()) {
			if (child instanceof BeBgpNode && coalescable(source, (BeBgpNode) child)) {
				return true;
			}
			if (child instanceof BeGroupNode && containsCoalescableBgp(source, (BeGroupNode) child)) {
				return true;
			}
			if (child instanceof BeUnionNode) {
				for (BeGroupNode branch : ((BeUnionNode) child).getBranches()) {
					if (containsCoalescableBgp(source, branch)) {
						return true;
					}
				}
			}
			if (child instanceof BeOptionalNode
					&& containsCoalescableBgp(source, ((BeOptionalNode) child).getRight())) {
				return true;
			}
		}
		return false;
	}

	private BeUndoToken performMerge(BeGroupNode parent, int bgpIndex, BeBgpNode bgp, BeUnionNode union) {
		BeUndoToken undo = new BeUndoToken();
		undo.capture(parent);
		for (BeGroupNode branch : union.getBranches()) {
			undo.capture(branch);
			branch.addChild(0, cloneBgp(bgp));
			coalescer.coalesce(branch);
		}
		parent.removeChild(bgpIndex);
		return undo;
	}

	private BeUndoToken performInject(BeOptionalNode optional, BeBgpNode bgp) {
		BeUndoToken undo = new BeUndoToken();
		BeGroupNode right = optional.getRight();
		undo.capture(right);
		right.addChild(0, cloneBgp(bgp));
		coalescer.coalesce(right);
		return undo;
	}

	private BeBgpNode cloneBgp(BeBgpNode bgp) {
		List<StatementPattern> clones = new ArrayList<>(bgp.getStatementPatterns().size());
		for (StatementPattern pattern : bgp.getStatementPatterns()) {
			clones.add(pattern.clone());
		}
		return new BeBgpNode(clones);
	}

	private boolean coalescable(BeBgpNode left, BeBgpNode right) {
		for (StatementPattern leftPattern : left.getStatementPatterns()) {
			for (StatementPattern rightPattern : right.getStatementPatterns()) {
				if (coalescable(leftPattern, rightPattern)) {
					return true;
				}
			}
		}
		return false;
	}

	private boolean coalescable(StatementPattern left, StatementPattern right) {
		List<String> leftVars = subjectObjectVars(left);
		if (leftVars.isEmpty()) {
			return false;
		}
		List<String> rightVars = subjectObjectVars(right);
		if (rightVars.isEmpty()) {
			return false;
		}
		for (String leftVar : leftVars) {
			if (rightVars.contains(leftVar)) {
				return true;
			}
		}
		return false;
	}

	private List<String> subjectObjectVars(StatementPattern pattern) {
		List<String> vars = new ArrayList<>(2);
		collectVar(vars, pattern.getSubjectVar());
		collectVar(vars, pattern.getObjectVar());
		return vars;
	}

	private void collectVar(List<String> target, Var var) {
		if (var != null && !var.hasValue()) {
			target.add(var.getName());
		}
	}

	private static final class Segment {
		private final int start;
		private final int end;

		private Segment(int start, int end) {
			this.start = start;
			this.end = end;
		}
	}

	private static final class MergeCandidate {
		private final BeUnionNode union;
		private final double deltaCost;

		private MergeCandidate(BeUnionNode union, double deltaCost) {
			this.union = union;
			this.deltaCost = deltaCost;
		}
	}

	private static final class BeUndoToken {
		private final Map<BeGroupNode, List<BeNode>> snapshots = new HashMap<>();

		private void capture(BeGroupNode group) {
			snapshots.putIfAbsent(group, new ArrayList<>(group.getChildren()));
		}

		private void undo() {
			for (Map.Entry<BeGroupNode, List<BeNode>> entry : snapshots.entrySet()) {
				entry.getKey().replaceChildren(entry.getValue());
			}
		}
	}
}
