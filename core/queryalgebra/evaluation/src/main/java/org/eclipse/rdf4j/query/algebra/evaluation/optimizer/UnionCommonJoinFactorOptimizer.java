/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.Filter;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.LeftJoin;
import org.eclipse.rdf4j.query.algebra.SingletonSet;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.Union;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryOptimizer;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractSimpleQueryModelVisitor;
import org.eclipse.rdf4j.query.algebra.helpers.collectors.VarNameCollector;

/**
 * Pulls a common join prefix out of UNION branches when the shared factors are safe to extract.
 */
public class UnionCommonJoinFactorOptimizer implements QueryOptimizer {

	private final EvaluationStatistics evaluationStatistics;
	private final boolean allowNonImprovingTransforms;

	public UnionCommonJoinFactorOptimizer(EvaluationStatistics evaluationStatistics) {
		this(evaluationStatistics, false);
	}

	public UnionCommonJoinFactorOptimizer(EvaluationStatistics evaluationStatistics,
			boolean allowNonImprovingTransforms) {
		this.evaluationStatistics = Objects.requireNonNull(evaluationStatistics, "evaluationStatistics");
		this.allowNonImprovingTransforms = allowNonImprovingTransforms;
	}

	@Override
	public void optimize(TupleExpr tupleExpr, Dataset dataset, BindingSet bindings) {
		tupleExpr.visit(new UnionVisitor());
	}

	private final class UnionVisitor extends AbstractSimpleQueryModelVisitor<RuntimeException> {
		@Override
		public void meet(Union union) {
			super.meet(union);
			TupleExpr replacement = pullUpCommonJoinFactors(union);
			if (replacement != union) {
				union.replaceWith(replacement);
				replacement.visit(this);
			}
		}
	}

	private TupleExpr pullUpCommonJoinFactors(Union union) {
		if (union.isVariableScopeChange()) {
			return union;
		}
		List<TupleExpr> branches = new ArrayList<>();
		collectUnionArgs(union, branches);
		if (branches.size() < 2) {
			return union;
		}

		List<BranchAnalysis> analyses = new ArrayList<>();
		for (TupleExpr branch : branches) {
			BranchAnalysis analysis = BranchAnalysis.analyze(branch);
			if (analysis == null) {
				return union;
			}
			analyses.add(analysis);
		}

		List<List<TupleExpr>> eligibleLists = new ArrayList<>();
		for (BranchAnalysis analysis : analyses) {
			eligibleLists.add(analysis.eligibleFactors);
		}
		List<TupleExpr> common = commonFactors(eligibleLists);
		if (common.isEmpty()) {
			return union;
		}
		List<List<TupleExpr>> remainingFactorLists = new ArrayList<>();
		for (BranchAnalysis analysis : analyses) {
			remainingFactorLists.add(removeCommon(analysis.factors, new HashMap<>(countFactors(common))));
		}
		if (!shouldPullUp(common, remainingFactorLists)) {
			return union;
		}

		List<TupleExpr> rebuiltBranches = new ArrayList<>();
		for (int i = 0; i < analyses.size(); i++) {
			BranchAnalysis analysis = analyses.get(i);
			List<TupleExpr> remainingFactors = remainingFactorLists.get(i);
			if (analysis.hasOptionalRight && remainingFactors.isEmpty()) {
				return union;
			}
			TupleExpr remainingLeft = joinFactors(remainingFactors);
			if (analysis.hasOptionalRight) {
				LeftJoin rewritten = new LeftJoin(remainingLeft, analysis.optionalRight.clone());
				rebuiltBranches.add(rewritten);
			} else {
				rebuiltBranches.add(remainingLeft);
			}
		}

		TupleExpr newUnion = buildUnion(rebuiltBranches, union.isVariableScopeChange());
		TupleExpr pulled = joinFactors(common);
		return new Join(pulled, newUnion);
	}

	private static void collectUnionArgs(Union union, List<TupleExpr> branches) {
		TupleExpr left = union.getLeftArg();
		TupleExpr right = union.getRightArg();
		if (left instanceof Union) {
			collectUnionArgs((Union) left, branches);
		} else {
			branches.add(left);
		}
		if (right instanceof Union) {
			collectUnionArgs((Union) right, branches);
		} else {
			branches.add(right);
		}
	}

	private static TupleExpr buildUnion(List<TupleExpr> branches, boolean scopeChange) {
		TupleExpr unionExpr = null;
		for (TupleExpr branch : branches) {
			if (unionExpr == null) {
				unionExpr = branch;
			} else {
				Union newUnion = new Union(unionExpr, branch);
				newUnion.setVariableScopeChange(scopeChange);
				unionExpr = newUnion;
			}
		}
		if (unionExpr == null) {
			return new SingletonSet();
		}
		if (unionExpr instanceof Union) {
			((Union) unionExpr).setVariableScopeChange(scopeChange);
		}
		return unionExpr;
	}

	private boolean shouldPullUp(List<TupleExpr> common, List<List<TupleExpr>> remainingFactorLists) {
		if (allowNonImprovingTransforms) {
			return true;
		}
		double commonCardinality = estimateCardinality(common);
		for (List<TupleExpr> remaining : remainingFactorLists) {
			if (remaining.isEmpty()) {
				continue;
			}
			double remainingCardinality = estimateCardinality(remaining);
			if (commonCardinality > remainingCardinality) {
				return false;
			}
		}
		return true;
	}

	private double estimateCardinality(List<TupleExpr> factors) {
		return evaluationStatistics.getCardinality(joinFactors(factors));
	}

	private static TupleExpr joinFactors(List<TupleExpr> factors) {
		if (factors.isEmpty()) {
			return new SingletonSet();
		}
		TupleExpr expr = null;
		for (TupleExpr factor : factors) {
			TupleExpr clone = factor.clone();
			if (expr == null) {
				expr = clone;
			} else {
				expr = new Join(expr, clone);
			}
		}
		return expr != null ? expr : new SingletonSet();
	}

	private static Map<TupleExpr, Integer> countFactors(List<TupleExpr> factors) {
		Map<TupleExpr, Integer> counts = new HashMap<>();
		for (TupleExpr factor : factors) {
			counts.merge(factor, 1, Integer::sum);
		}
		return counts;
	}

	private static List<TupleExpr> commonFactors(List<List<TupleExpr>> eligibleLists) {
		List<TupleExpr> first = eligibleLists.get(0);
		Map<TupleExpr, Integer> minCounts = countFactors(first);
		for (int i = 1; i < eligibleLists.size(); i++) {
			Map<TupleExpr, Integer> branchCounts = countFactors(eligibleLists.get(i));
			for (TupleExpr key : new HashSet<>(minCounts.keySet())) {
				Integer count = branchCounts.get(key);
				if (count == null || count == 0) {
					minCounts.remove(key);
				} else {
					minCounts.put(key, Math.min(minCounts.get(key), count));
				}
			}
			if (minCounts.isEmpty()) {
				return List.of();
			}
		}
		List<TupleExpr> common = new ArrayList<>();
		Map<TupleExpr, Integer> remaining = new HashMap<>(minCounts);
		for (TupleExpr factor : first) {
			Integer count = remaining.get(factor);
			if (count != null && count > 0) {
				common.add(factor);
				remaining.put(factor, count - 1);
			}
		}
		return common;
	}

	private static List<TupleExpr> removeCommon(List<TupleExpr> factors, Map<TupleExpr, Integer> removalCounts) {
		List<TupleExpr> remaining = new ArrayList<>();
		for (TupleExpr factor : factors) {
			Integer count = removalCounts.get(factor);
			if (count != null && count > 0) {
				removalCounts.put(factor, count - 1);
				continue;
			}
			remaining.add(factor);
		}
		return remaining;
	}

	private static final class BranchAnalysis {
		private final List<TupleExpr> factors;
		private final List<TupleExpr> eligibleFactors;
		private final TupleExpr optionalRight;
		private final boolean hasOptionalRight;

		private BranchAnalysis(List<TupleExpr> factors, List<TupleExpr> eligibleFactors, TupleExpr optionalRight) {
			this.factors = factors;
			this.eligibleFactors = eligibleFactors;
			this.optionalRight = optionalRight;
			this.hasOptionalRight = optionalRight != null;
		}

		private static BranchAnalysis analyze(TupleExpr branch) {
			TupleExpr mandatory = branch;
			TupleExpr optionalRight = null;
			if (branch instanceof LeftJoin) {
				LeftJoin leftJoin = (LeftJoin) branch;
				if (leftJoin.getCondition() != null) {
					return null;
				}
				mandatory = leftJoin.getLeftArg();
				optionalRight = leftJoin.getRightArg();
			}

			List<TupleExpr> factors = new ArrayList<>();
			collectJoinFactors(mandatory, factors);
			if (factors.isEmpty()) {
				return null;
			}

			Set<String> rightVars = collectLeftJoinRightVars(branch);
			List<TupleExpr> eligible = new ArrayList<>();
			for (TupleExpr factor : factors) {
				if (!isEligibleFactor(factor)) {
					return null;
				}
				if (!hasSharedBindings(factor, rightVars)) {
					eligible.add(factor);
				}
			}

			if (eligible.isEmpty()) {
				return null;
			}

			return new BranchAnalysis(factors, eligible, optionalRight);
		}
	}

	private static void collectJoinFactors(TupleExpr expr, List<TupleExpr> factors) {
		if (expr instanceof Join) {
			Join join = (Join) expr;
			collectJoinFactors(join.getLeftArg(), factors);
			collectJoinFactors(join.getRightArg(), factors);
			return;
		}
		factors.add(expr);
	}

	private static Set<String> collectLeftJoinRightVars(TupleExpr expr) {
		Set<String> vars = new HashSet<>();
		expr.visit(new AbstractSimpleQueryModelVisitor<RuntimeException>() {
			@Override
			public void meet(LeftJoin node) {
				vars.addAll(VarNameCollector.process(node.getRightArg()));
				super.meet(node);
			}
		});
		return vars;
	}

	private static boolean isEligibleFactor(TupleExpr factor) {
		if (factor instanceof StatementPattern) {
			return true;
		}
		if (factor instanceof Filter) {
			return isSelfContainedFilter((Filter) factor);
		}
		return false;
	}

	private static boolean isSelfContainedFilter(Filter filter) {
		Set<String> conditionVars = VarNameCollector.process(filter.getCondition());
		Set<String> argBindings = filter.getArg().getBindingNames();
		return argBindings.containsAll(conditionVars);
	}

	private static boolean hasSharedBindings(TupleExpr factor, Set<String> rightVars) {
		if (rightVars.isEmpty()) {
			return false;
		}
		for (String name : factor.getBindingNames()) {
			if (rightVars.contains(name)) {
				return true;
			}
		}
		return false;
	}
}
