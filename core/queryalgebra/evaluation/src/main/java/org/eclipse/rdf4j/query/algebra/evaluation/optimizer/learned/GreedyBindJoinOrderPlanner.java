/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;

import org.eclipse.rdf4j.query.algebra.TupleExpr;

/**
 * Greedy join order planner based on estimated fanout.
 */
public class GreedyBindJoinOrderPlanner implements JoinOrderPlanner {

	private static final double DISCONNECTED_PENALTY = 1.0e9d;

	private final BindJoinCostModel costModel;

	public GreedyBindJoinOrderPlanner(BindJoinCostModel costModel) {
		this.costModel = Objects.requireNonNull(costModel, "costModel");
	}

	@Override
	public List<TupleExpr> order(List<TupleExpr> operands, Set<String> initiallyBoundVars) {
		if (operands.isEmpty()) {
			return List.of();
		}

		List<TupleExpr> remaining = new ArrayList<>(operands);
		List<TupleExpr> ordered = new ArrayList<>(operands.size());
		Set<String> bound = new HashSet<>(initiallyBoundVars);

		TupleExpr first = selectFirst(remaining, bound);
		remaining.remove(first);
		ordered.add(first);
		bound.addAll(filteredBindingNames(first));

		while (!remaining.isEmpty()) {
			TupleExpr next = selectNext(remaining, bound);
			remaining.remove(next);
			ordered.add(next);
			bound.addAll(filteredBindingNames(next));
		}

		return ordered;
	}

	private TupleExpr selectFirst(List<TupleExpr> remaining, Set<String> bound) {
		TupleExpr best = remaining.get(0);
		double bestCardinality = firstScore(best, remaining, bound);
		for (int i = 1; i < remaining.size(); i++) {
			TupleExpr candidate = remaining.get(i);
			double cardinality = firstScore(candidate, remaining, bound);
			if (cardinality < bestCardinality) {
				bestCardinality = cardinality;
				best = candidate;
			}
		}
		return best;
	}

	private TupleExpr selectNext(List<TupleExpr> remaining, Set<String> bound) {
		TupleExpr best = remaining.get(0);
		double bestScore = score(best, bound);
		for (int i = 1; i < remaining.size(); i++) {
			TupleExpr candidate = remaining.get(i);
			double score = score(candidate, bound);
			if (score < bestScore) {
				bestScore = score;
				best = candidate;
			}
		}
		return best;
	}

	private double score(TupleExpr expr, Set<String> bound) {
		double fanout = costModel.estimateFanout(expr, bound);
		if (fanout < 0.0d) {
			fanout = 0.0d;
		}
		Set<String> names = filteredBindingNames(expr);
		if (names.isEmpty() || bound.isEmpty() || disjoint(names, bound)) {
			if (fanout <= 0.0d) {
				fanout = 1.0d;
			}
			return fanout * DISCONNECTED_PENALTY;
		}
		return fanout;
	}

	private double firstScore(TupleExpr expr, List<TupleExpr> remaining, Set<String> bound) {
		double cardinality = costModel.estimateScanCardinality(expr, bound);
		if (isIsolated(expr, remaining)) {
			return cardinality * DISCONNECTED_PENALTY;
		}
		return cardinality;
	}

	private boolean isIsolated(TupleExpr expr, List<TupleExpr> remaining) {
		Set<String> names = filteredBindingNames(expr);
		if (names.isEmpty()) {
			return true;
		}
		for (TupleExpr candidate : remaining) {
			if (candidate == expr) {
				continue;
			}
			if (!disjoint(names, filteredBindingNames(candidate))) {
				return false;
			}
		}
		return true;
	}

	private Set<String> filteredBindingNames(TupleExpr expr) {
		Set<String> names = new HashSet<>(costModel.bindingNames(expr));
		names.removeIf(name -> name.startsWith("_const_"));
		return names;
	}

	private boolean disjoint(Set<String> left, Set<String> right) {
		for (String name : left) {
			if (right.contains(name)) {
				return false;
			}
		}
		return true;
	}
}
