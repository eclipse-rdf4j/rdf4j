/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.BindingSetAssignment;
import org.eclipse.rdf4j.query.algebra.Filter;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.Union;
import org.eclipse.rdf4j.query.algebra.ValueExpr;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryOptimizer;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractSimpleQueryModelVisitor;

/**
 * Pulls common Filters and VALUES (BindingSetAssignment) out of Union branches when possible.
 */
public class UnionCommonFilterBindingSetOptimizer implements QueryOptimizer {

	@Override
	public void optimize(TupleExpr tupleExpr, Dataset dataset, BindingSet bindings) {
		tupleExpr.visit(new UnionVisitor());
	}

	private static final class BranchFilters {
		private final TupleExpr core;
		private final List<ValueExpr> conditions;

		private BranchFilters(TupleExpr core, List<ValueExpr> conditions) {
			this.core = core;
			this.conditions = conditions;
		}
	}

	private static final class UnionVisitor extends AbstractSimpleQueryModelVisitor<RuntimeException> {
		@Override
		public void meet(Union union) {
			super.meet(union);

			TupleExpr replacement = pullUpCommonFilter(union);
			if (replacement != union) {
				union.replaceWith(replacement);
				replacement.visit(this);
				return;
			}

			replacement = pullUpCommonBindingSetAssignment(union);
			if (replacement != union) {
				union.replaceWith(replacement);
				replacement.visit(this);
			}
		}
	}

	private static TupleExpr pullUpCommonFilter(Union union) {
		List<TupleExpr> branches = new ArrayList<>();
		collectUnionBranches(union, union.isVariableScopeChange(), branches);
		if (branches.size() < 2) {
			return union;
		}

		List<BranchFilters> branchFilters = new ArrayList<>(branches.size());
		Map<ValueExpr, Integer> commonCounts = null;
		for (TupleExpr branch : branches) {
			BranchFilters filters = collectLeadingFilters(branch);
			if (filters.conditions.isEmpty()) {
				return union;
			}
			Map<ValueExpr, Integer> counts = countConditions(filters.conditions);
			if (commonCounts == null) {
				commonCounts = new LinkedHashMap<>(counts);
			} else {
				intersectCounts(commonCounts, counts);
			}
			if (commonCounts.isEmpty()) {
				return union;
			}
			branchFilters.add(filters);
		}

		List<ValueExpr> hoisted = orderedCommonFilters(branchFilters.get(0).conditions, commonCounts);
		if (hoisted.isEmpty()) {
			return union;
		}

		List<TupleExpr> rewrittenBranches = new ArrayList<>(branchFilters.size());
		for (BranchFilters filters : branchFilters) {
			List<ValueExpr> remaining = removeCommonFilters(filters.conditions, commonCounts);
			TupleExpr rebuilt = filters.core;
			for (int i = remaining.size() - 1; i >= 0; i--) {
				rebuilt = new Filter(rebuilt, remaining.get(i).clone());
			}
			rewrittenBranches.add(rebuilt);
		}

		TupleExpr rebuiltUnion = rebuildUnion(rewrittenBranches, union.isVariableScopeChange());
		TupleExpr wrapped = rebuiltUnion;
		for (int i = hoisted.size() - 1; i >= 0; i--) {
			wrapped = new Filter(wrapped, hoisted.get(i).clone());
		}
		return wrapped;
	}

	private static TupleExpr pullUpCommonBindingSetAssignment(Union union) {
		if (!(union.getLeftArg() instanceof Join) || !(union.getRightArg() instanceof Join)) {
			return union;
		}
		Join leftJoin = (Join) union.getLeftArg();
		Join rightJoin = (Join) union.getRightArg();

		BindingSetAssignment leftBsa = bindingSetAssignment(leftJoin.getLeftArg());
		BindingSetAssignment rightBsa = bindingSetAssignment(rightJoin.getLeftArg());
		if (sameBindingSetAssignment(leftBsa, rightBsa)) {
			Union newUnion = new Union(leftJoin.getRightArg(), rightJoin.getRightArg());
			newUnion.setVariableScopeChange(union.isVariableScopeChange());
			return new Join(leftBsa.clone(), newUnion);
		}

		leftBsa = bindingSetAssignment(leftJoin.getRightArg());
		rightBsa = bindingSetAssignment(rightJoin.getRightArg());
		if (sameBindingSetAssignment(leftBsa, rightBsa)) {
			Union newUnion = new Union(leftJoin.getLeftArg(), rightJoin.getLeftArg());
			newUnion.setVariableScopeChange(union.isVariableScopeChange());
			return new Join(newUnion, leftBsa.clone());
		}

		return union;
	}

	private static BindingSetAssignment bindingSetAssignment(TupleExpr expr) {
		if (expr instanceof BindingSetAssignment) {
			return (BindingSetAssignment) expr;
		}
		return null;
	}

	private static boolean sameBindingSetAssignment(BindingSetAssignment left, BindingSetAssignment right) {
		if (left == right) {
			return left != null;
		}
		if (left == null || right == null) {
			return false;
		}
		left.getAssuredBindingNames();
		right.getAssuredBindingNames();
		return left.equals(right);
	}

	private static void collectUnionBranches(TupleExpr expr, boolean variableScopeChange, List<TupleExpr> branches) {
		if (expr instanceof Union && ((Union) expr).isVariableScopeChange() == variableScopeChange) {
			Union union = (Union) expr;
			collectUnionBranches(union.getLeftArg(), variableScopeChange, branches);
			collectUnionBranches(union.getRightArg(), variableScopeChange, branches);
		} else {
			branches.add(expr);
		}
	}

	private static BranchFilters collectLeadingFilters(TupleExpr expr) {
		List<ValueExpr> conditions = new ArrayList<>();
		TupleExpr current = expr;
		while (current instanceof Filter) {
			Filter filter = (Filter) current;
			conditions.add(filter.getCondition());
			current = filter.getArg();
		}
		return new BranchFilters(current, conditions);
	}

	private static Map<ValueExpr, Integer> countConditions(List<ValueExpr> conditions) {
		Map<ValueExpr, Integer> counts = new LinkedHashMap<>();
		for (ValueExpr condition : conditions) {
			counts.merge(condition, 1, Integer::sum);
		}
		return counts;
	}

	private static void intersectCounts(Map<ValueExpr, Integer> commonCounts, Map<ValueExpr, Integer> counts) {
		Iterator<Map.Entry<ValueExpr, Integer>> iterator = commonCounts.entrySet().iterator();
		while (iterator.hasNext()) {
			Map.Entry<ValueExpr, Integer> entry = iterator.next();
			Integer count = counts.get(entry.getKey());
			if (count == null) {
				iterator.remove();
				continue;
			}
			int min = Math.min(entry.getValue(), count);
			if (min == 0) {
				iterator.remove();
			} else {
				entry.setValue(min);
			}
		}
	}

	private static List<ValueExpr> orderedCommonFilters(List<ValueExpr> conditions,
			Map<ValueExpr, Integer> commonCounts) {
		List<ValueExpr> ordered = new ArrayList<>();
		Map<ValueExpr, Integer> remaining = new HashMap<>(commonCounts);
		for (ValueExpr condition : conditions) {
			Integer count = remaining.get(condition);
			if (count == null || count == 0) {
				continue;
			}
			ordered.add(condition);
			if (count == 1) {
				remaining.remove(condition);
			} else {
				remaining.put(condition, count - 1);
			}
		}
		return ordered;
	}

	private static List<ValueExpr> removeCommonFilters(List<ValueExpr> conditions,
			Map<ValueExpr, Integer> commonCounts) {
		List<ValueExpr> remaining = new ArrayList<>();
		Map<ValueExpr, Integer> toRemove = new HashMap<>(commonCounts);
		for (ValueExpr condition : conditions) {
			Integer count = toRemove.get(condition);
			if (count == null || count == 0) {
				remaining.add(condition);
				continue;
			}
			if (count == 1) {
				toRemove.remove(condition);
			} else {
				toRemove.put(condition, count - 1);
			}
		}
		return remaining;
	}

	private static TupleExpr rebuildUnion(List<TupleExpr> branches, boolean variableScopeChange) {
		TupleExpr current = branches.get(0);
		for (int i = 1; i < branches.size(); i++) {
			Union union = new Union(current, branches.get(i));
			union.setVariableScopeChange(variableScopeChange);
			current = union;
		}
		return current;
	}
}
