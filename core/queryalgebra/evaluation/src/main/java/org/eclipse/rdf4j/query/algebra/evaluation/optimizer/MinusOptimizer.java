/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;

import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.BinaryTupleOperator;
import org.eclipse.rdf4j.query.algebra.BinaryValueOperator;
import org.eclipse.rdf4j.query.algebra.Difference;
import org.eclipse.rdf4j.query.algebra.EmptySet;
import org.eclipse.rdf4j.query.algebra.Extension;
import org.eclipse.rdf4j.query.algebra.ExtensionElem;
import org.eclipse.rdf4j.query.algebra.LeftJoin;
import org.eclipse.rdf4j.query.algebra.NAryValueOperator;
import org.eclipse.rdf4j.query.algebra.Projection;
import org.eclipse.rdf4j.query.algebra.ProjectionElem;
import org.eclipse.rdf4j.query.algebra.ProjectionElemList;
import org.eclipse.rdf4j.query.algebra.QueryModelNode;
import org.eclipse.rdf4j.query.algebra.Service;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.SubQueryValueOperator;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.UnaryTupleOperator;
import org.eclipse.rdf4j.query.algebra.UnaryValueOperator;
import org.eclipse.rdf4j.query.algebra.Union;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.VariableScopeChange;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryOptimizer;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractSimpleQueryModelVisitor;

/**
 * Simplifies MINUS (Difference) nodes when they cannot affect results.
 */
public class MinusOptimizer implements QueryOptimizer {

	private final boolean enableUnionSplit;

	public MinusOptimizer() {
		this(true);
	}

	public MinusOptimizer(boolean enableUnionSplit) {
		this.enableUnionSplit = enableUnionSplit;
	}

	@Override
	public void optimize(TupleExpr tupleExpr, Dataset dataset, BindingSet bindings) {
		MinusVisitor visitor = new MinusVisitor(enableUnionSplit);
		Set<String> rootScope = new HashSet<>();
		if (bindings != null) {
			rootScope.addAll(bindings.getBindingNames());
		}
		visitor.visitWithScope(tupleExpr, rootScope);
	}

	private static final class MinusVisitor extends AbstractSimpleQueryModelVisitor<RuntimeException> {
		private final boolean enableUnionSplit;
		private final Deque<Set<String>> scopeStack = new ArrayDeque<>();

		private MinusVisitor(boolean enableUnionSplit) {
			this.enableUnionSplit = enableUnionSplit;
		}

		private void visitWithScope(TupleExpr expr, Set<String> scope) {
			scopeStack.push(scope);
			expr.visit(this);
			scopeStack.pop();
		}

		private Set<String> currentScope() {
			return scopeStack.peek();
		}

		@Override
		public void meet(LeftJoin leftJoin) {
			Set<String> scope = currentScope();
			visitWithScope(leftJoin.getLeftArg(), scope);
			Set<String> rightScope = new HashSet<>(scope);
			rightScope.addAll(leftJoin.getLeftArg().getBindingNames());
			visitWithScope(leftJoin.getRightArg(), rightScope);
			if (leftJoin.getCondition() != null) {
				leftJoin.getCondition().visit(this);
			}
		}

		@Override
		public void meet(Difference difference) {
			super.meet(difference);

			Set<String> scope = currentScope();
			TupleExpr leftArg = difference.getLeftArg();
			TupleExpr rightArg = difference.getRightArg();

			if (leftArg instanceof EmptySet) {
				return;
			}
			if (rightArg instanceof EmptySet) {
				difference.replaceWith(leftArg);
				return;
			}
			if (scope.isEmpty()
					&& Collections.disjoint(leftArg.getBindingNames(), rightArg.getBindingNames())) {
				difference.replaceWith(leftArg);
				return;
			}
			if (enableUnionSplit && rightArg instanceof Union) {
				Union union = (Union) rightArg;
				List<TupleExpr> branches = new ArrayList<>();
				collectUnionBranches(union, union.isVariableScopeChange(), branches);
				if (branches.size() > 1) {
					TupleExpr current = leftArg;
					for (TupleExpr branch : branches) {
						current = new Difference(current, branch);
					}
					difference.replaceWith(current);
					return;
				}
			}

			applyJoinKeyProjection(difference);
		}
	}

	private static void collectUnionBranches(TupleExpr expr, boolean variableScopeChange, List<TupleExpr> branches) {
		if (expr instanceof Union && ((Union) expr).isVariableScopeChange() == variableScopeChange) {
			Union union = (Union) expr;
			collectUnionBranches(union.getLeftArg(), variableScopeChange, branches);
			collectUnionBranches(union.getRightArg(), variableScopeChange, branches);
		} else {
			branches.add(expr);
		}
	}

	private static void applyJoinKeyProjection(Difference difference) {
		TupleExpr leftArg = difference.getLeftArg();
		TupleExpr rightArg = difference.getRightArg();
		if (containsService(rightArg)) {
			return;
		}
		Set<String> shared = collectSharedUnboundNames(leftArg, rightArg);
		if (shared.isEmpty()) {
			return;
		}
		Set<String> leftAssured = assuredBindingsWithAliases(leftArg);
		Set<String> rightAssured = assuredBindingsWithAliases(rightArg);
		if (!leftAssured.containsAll(shared) || !rightAssured.containsAll(shared)) {
			return;
		}
		if (!hasStatementPatternCoveringVars(rightArg, shared)) {
			return;
		}
		TupleExpr projected = buildProjection(rightArg.clone(), shared);
		difference.setRightArg(projected);
	}

	private static TupleExpr buildProjection(TupleExpr subQuery, Set<String> joinVars) {
		List<String> ordered = new ArrayList<>(joinVars);
		Collections.sort(ordered);
		ProjectionElemList projectionElemList = new ProjectionElemList();
		for (String name : ordered) {
			projectionElemList.addElement(new ProjectionElem(name));
		}
		return new Projection(subQuery, projectionElemList);
	}

	private static boolean containsService(TupleExpr subQuery) {
		AtomicBoolean found = new AtomicBoolean(false);
		subQuery.visit(new org.eclipse.rdf4j.query.algebra.helpers.AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			public void meet(Service node) {
				found.set(true);
			}
		});
		return found.get();
	}

	private static Set<String> assuredBindingsWithAliases(TupleExpr expr) {
		Set<String> assured = new HashSet<>(expr.getAssuredBindingNames());
		Map<String, String> aliases = collectAliasMap(expr);
		if (aliases.isEmpty()) {
			return assured;
		}
		boolean changed;
		do {
			changed = false;
			for (Map.Entry<String, String> entry : aliases.entrySet()) {
				if (assured.contains(entry.getValue()) && assured.add(entry.getKey())) {
					changed = true;
				}
			}
		} while (changed);
		return assured;
	}

	private static Set<String> collectSharedUnboundNames(TupleExpr left, TupleExpr right) {
		Set<String> leftUnbound = collectUnboundVarNames(left);
		if (leftUnbound.isEmpty()) {
			return Set.of();
		}
		Set<String> rightUnbound = collectUnboundVarNames(right);
		if (rightUnbound.isEmpty()) {
			return Set.of();
		}
		leftUnbound.retainAll(rightUnbound);
		return leftUnbound;
	}

	private static Set<String> collectUnboundVarNames(TupleExpr expr) {
		Set<String> names = new HashSet<>();
		expr.visit(new StopAtScopeChange(true, expr) {
			@Override
			public void meet(Var node) {
				if (!node.hasValue()) {
					names.add(node.getName());
				}
			}

			@Override
			public void meet(Extension node) {
				for (ExtensionElem elem : node.getElements()) {
					names.add(elem.getName());
				}
				super.meet(node);
			}
		});
		return names;
	}

	private static Map<String, String> collectAliasMap(TupleExpr expr) {
		Map<String, String> aliasMap = new HashMap<>();
		expr.visit(new AliasCollector(aliasMap, expr));
		return aliasMap;
	}

	private static boolean hasStatementPatternCoveringVars(TupleExpr expr, Set<String> joinVars) {
		if (joinVars.isEmpty()) {
			return false;
		}
		AtomicBoolean found = new AtomicBoolean(false);
		expr.visit(new StopAtScopeChange(true, expr) {
			@Override
			public void meet(StatementPattern node) {
				if (found.get()) {
					return;
				}
				Set<String> vars = new HashSet<>();
				addVarName(node.getSubjectVar(), vars);
				addVarName(node.getPredicateVar(), vars);
				addVarName(node.getObjectVar(), vars);
				addVarName(node.getContextVar(), vars);
				if (vars.containsAll(joinVars)) {
					found.set(true);
				}
			}
		});
		return found.get();
	}

	private static void addVarName(Var var, Set<String> vars) {
		if (var != null) {
			vars.add(var.getName());
		}
	}

	private static final class AliasCollector extends StopAtScopeChange {
		private final Map<String, String> aliasMap;

		private AliasCollector(Map<String, String> aliasMap, TupleExpr root) {
			super(true, root);
			this.aliasMap = aliasMap;
		}

		@Override
		public void meet(Extension node) {
			for (ExtensionElem elem : node.getElements()) {
				if (!(elem.getExpr() instanceof Var)) {
					continue;
				}
				String alias = elem.getName();
				String source = ((Var) elem.getExpr()).getName();
				String existing = aliasMap.get(alias);
				if (existing == null) {
					aliasMap.put(alias, source);
				} else if (!existing.equals(source)) {
					aliasMap.remove(alias);
				}
			}
			super.meet(node);
		}
	}

	private static class StopAtScopeChange extends AbstractSimpleQueryModelVisitor<RuntimeException> {
		private final QueryModelNode root;

		private StopAtScopeChange(boolean meetStatementPatternChildren, QueryModelNode root) {
			super(meetStatementPatternChildren);
			this.root = root;
		}

		@Override
		public void meetUnaryTupleOperator(UnaryTupleOperator node) {
			if (!isSkippableScopeChange(node)) {
				super.meetUnaryTupleOperator(node);
			}
		}

		@Override
		public void meetBinaryTupleOperator(BinaryTupleOperator node) {
			if (!isSkippableScopeChange(node)) {
				super.meetBinaryTupleOperator(node);
			}
		}

		@Override
		protected void meetBinaryValueOperator(BinaryValueOperator node) throws RuntimeException {
			if (!isSkippableScopeChange(node)) {
				super.meetBinaryValueOperator(node);
			}
		}

		@Override
		protected void meetNAryValueOperator(NAryValueOperator node) throws RuntimeException {
			if (!isSkippableScopeChange(node)) {
				super.meetNAryValueOperator(node);
			}
		}

		@Override
		protected void meetSubQueryValueOperator(SubQueryValueOperator node) throws RuntimeException {
			if (!isSkippableScopeChange(node)) {
				super.meetSubQueryValueOperator(node);
			}
		}

		@Override
		protected void meetUnaryValueOperator(UnaryValueOperator node) throws RuntimeException {
			if (!isSkippableScopeChange(node)) {
				super.meetUnaryValueOperator(node);
			}
		}

		private boolean isSkippableScopeChange(QueryModelNode node) {
			return node != root && node instanceof VariableScopeChange
					&& ((VariableScopeChange) node).isVariableScopeChange();
		}
	}
}
