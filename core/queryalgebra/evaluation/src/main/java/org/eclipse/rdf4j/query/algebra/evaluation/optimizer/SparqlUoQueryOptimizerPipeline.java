/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.evaluation.EvaluationStrategy;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryOptimizer;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryOptimizerPipeline;
import org.eclipse.rdf4j.query.algebra.evaluation.TripleSource;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.sparqluo.SparqlUoConfig;

public class SparqlUoQueryOptimizerPipeline implements QueryOptimizerPipeline {

	private final QueryOptimizerPipeline delegate;
	private final SparqlUoOptimizer sparqlUoOptimizer;
	private final BindingSetAssignmentUnionOptimizer bindingSetAssignmentUnionOptimizer;
	private final UnionCommonStatementPatternOptimizer unionCommonStatementPatternOptimizer;
	private final UnionCommonJoinFactorOptimizer unionCommonJoinFactorOptimizer;
	private final UnionCommonFilterBindingSetOptimizer unionCommonFilterBindingSetOptimizer;
	private final OptionalFilterJoinOptimizer optionalFilterJoinOptimizer;
	private final OptionalNotBoundFilterOptimizer optionalNotBoundFilterOptimizer;
	private final OptionalBindLeftJoinOptimizer optionalBindLeftJoinOptimizer;
	private final MinusOptimizer minusOptimizer;
	private final ExistsConstantOptimizer existsConstantOptimizer;
	private final ExistsSemiJoinOptimizer existsSemiJoinOptimizer;
	private final NotExistsSemiJoinOptimizer notExistsSemiJoinOptimizer;
	private final QueryJoinOptimizer joinOptimizer;
	private final FilterOptimizer preJoinFilterOptimizer = new LimitAwareFilterOptimizer();
	private final boolean enableOptionalFilterJoin;
	private final boolean enableUnionCommonPullUp;

	public SparqlUoQueryOptimizerPipeline(EvaluationStrategy strategy, TripleSource tripleSource,
			EvaluationStatistics evaluationStatistics) {
		this(strategy, tripleSource, evaluationStatistics, SparqlUoConfig.fromSystemProperties());
	}

	public SparqlUoQueryOptimizerPipeline(EvaluationStrategy strategy, TripleSource tripleSource,
			EvaluationStatistics evaluationStatistics, SparqlUoConfig config) {
		this.delegate = new StandardQueryOptimizerPipeline(strategy, tripleSource, evaluationStatistics);
		this.sparqlUoOptimizer = new SparqlUoOptimizer(evaluationStatistics, disableOptionalFilterJoin(config));
		this.bindingSetAssignmentUnionOptimizer = new BindingSetAssignmentUnionOptimizer(
				config.maxBindingSetAssignmentUnionSize());
		this.unionCommonStatementPatternOptimizer = new UnionCommonStatementPatternOptimizer(evaluationStatistics);
		this.unionCommonJoinFactorOptimizer = new UnionCommonJoinFactorOptimizer(evaluationStatistics,
				config.allowNonImprovingTransforms());
		this.unionCommonFilterBindingSetOptimizer = new UnionCommonFilterBindingSetOptimizer();
		this.optionalFilterJoinOptimizer = new OptionalFilterJoinOptimizer();
		this.optionalNotBoundFilterOptimizer = new OptionalNotBoundFilterOptimizer();
		this.optionalBindLeftJoinOptimizer = new OptionalBindLeftJoinOptimizer();
		this.minusOptimizer = new MinusOptimizer(config.enableMinusUnionSplit());
		this.existsConstantOptimizer = new ExistsConstantOptimizer();
		this.existsSemiJoinOptimizer = new ExistsSemiJoinOptimizer(evaluationStatistics,
				config.allowNonImprovingTransforms());
		this.notExistsSemiJoinOptimizer = new NotExistsSemiJoinOptimizer(evaluationStatistics,
				config.allowNonImprovingTransforms());
		this.joinOptimizer = new QueryJoinOptimizer(evaluationStatistics, strategy.isTrackResultSize(), tripleSource,
				false);
		this.enableOptionalFilterJoin = config.enableOptionalFilterJoin();
		this.enableUnionCommonPullUp = config.allowNonImprovingTransforms();
	}

	@Override
	public Iterable<QueryOptimizer> getOptimizers() {
		List<QueryOptimizer> optimizers = new ArrayList<>();
		boolean inserted = false;
		boolean bindingSetUnionInserted = false;
		boolean statementPatternInserted = false;
		boolean commonFactorInserted = false;
		boolean optionalFilterJoinInserted = false;
		for (QueryOptimizer optimizer : delegate.getOptimizers()) {
			if (optimizer instanceof QueryJoinOptimizer) {
				if (!inserted) {
					optimizers.add(existsConstantOptimizer);
					optimizers.add(minusOptimizer);
					optimizers.add(preJoinFilterOptimizer);
					optimizers.add(sparqlUoOptimizer);
					inserted = true;
				}
				optimizers.add(joinOptimizer);
				if (enableOptionalFilterJoin && !optionalFilterJoinInserted) {
					optimizers.add(optionalFilterJoinOptimizer);
					optimizers.add(optionalNotBoundFilterOptimizer);
					optimizers.add(optionalBindLeftJoinOptimizer);
					optionalFilterJoinInserted = true;
				}
				optimizers.add(existsSemiJoinOptimizer);
				optimizers.add(notExistsSemiJoinOptimizer);
				continue;
			}
			if (optimizer instanceof FilterOptimizer) {
				optimizers.add(optimizer);
				optimizers.add(unionCommonFilterBindingSetOptimizer);
				if (!statementPatternInserted) {
					if (enableUnionCommonPullUp) {
						optimizers.add(unionCommonStatementPatternOptimizer);
						optimizers.add(unionCommonJoinFactorOptimizer);
						statementPatternInserted = true;
						commonFactorInserted = true;
					}
				}
				continue;
			}
			optimizers.add(optimizer);
			if (optimizer instanceof IterativeEvaluationOptimizer) {
				optimizers.add(bindingSetAssignmentUnionOptimizer);
				bindingSetUnionInserted = true;
			}
		}
		if (!inserted) {
			optimizers.add(existsConstantOptimizer);
			optimizers.add(minusOptimizer);
			optimizers.add(preJoinFilterOptimizer);
			optimizers.add(sparqlUoOptimizer);
			optimizers.add(joinOptimizer);
			if (enableOptionalFilterJoin && !optionalFilterJoinInserted) {
				optimizers.add(optionalFilterJoinOptimizer);
				optimizers.add(optionalNotBoundFilterOptimizer);
				optimizers.add(optionalBindLeftJoinOptimizer);
				optionalFilterJoinInserted = true;
			}
			optimizers.add(existsSemiJoinOptimizer);
			optimizers.add(notExistsSemiJoinOptimizer);
		}
		if (!bindingSetUnionInserted) {
			optimizers.add(bindingSetAssignmentUnionOptimizer);
		}
		if (!statementPatternInserted && enableUnionCommonPullUp) {
			optimizers.add(unionCommonStatementPatternOptimizer);
		}
		if (!commonFactorInserted && enableUnionCommonPullUp) {
			optimizers.add(unionCommonJoinFactorOptimizer);
		}
		return optimizers;
	}

	private static SparqlUoConfig disableOptionalFilterJoin(SparqlUoConfig config) {
		if (!config.enableOptionalFilterJoin()) {
			return config;
		}
		return SparqlUoConfig.builder()
				.allowNonImprovingTransforms(config.allowNonImprovingTransforms())
				.assumedVarDomainCardinality(config.assumedVarDomainCardinality())
				.optionalMatchRate(config.optionalMatchRate())
				.optionalMultiplicity(config.optionalMultiplicity())
				.debugLogging(config.debugLogging())
				.simulateJoinOrder(config.simulateJoinOrder())
				.maxBindingSetAssignmentUnionSize(config.maxBindingSetAssignmentUnionSize())
				.enableMinusUnionSplit(config.enableMinusUnionSplit())
				.enableOptionalFilterJoin(false)
				.enableUnionCommonPrefixPullUp(config.enableUnionCommonPrefixPullUp())
				.build();
	}

	private static final class LimitAwareFilterOptimizer extends FilterOptimizer {
		@Override
		public void optimize(TupleExpr tupleExpr, Dataset dataset, BindingSet bindings) {
			if (UnorderedSliceDetector.hasUnorderedSlice(tupleExpr)) {
				return;
			}
			super.optimize(tupleExpr, dataset, bindings);
		}
	}
}
