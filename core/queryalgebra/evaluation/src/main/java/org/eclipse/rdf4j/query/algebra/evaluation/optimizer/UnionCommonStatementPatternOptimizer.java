/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import org.eclipse.rdf4j.model.BNode;
import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Literal;
import org.eclipse.rdf4j.model.Value;
import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.SingletonSet;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.Union;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryOptimizer;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractSimpleQueryModelVisitor;

/**
 * Pulls a common StatementPattern out of Union branches when both branches are simple joins.
 */
public class UnionCommonStatementPatternOptimizer implements QueryOptimizer {

	private final EvaluationStatistics evaluationStatistics;

	public UnionCommonStatementPatternOptimizer(EvaluationStatistics evaluationStatistics) {
		this.evaluationStatistics = Objects.requireNonNull(evaluationStatistics, "evaluationStatistics");
	}

	@Override
	public void optimize(TupleExpr tupleExpr, Dataset dataset, BindingSet bindings) {
		tupleExpr.visit(new UnionVisitor());
	}

	private final class UnionVisitor extends AbstractSimpleQueryModelVisitor<RuntimeException> {
		@Override
		public void meet(Union union) {
			super.meet(union);
			TupleExpr replacement = pullUpCommonStatementPatterns(union);
			if (replacement != union) {
				union.replaceWith(replacement);
				replacement.visit(this);
			}
		}
	}

	private TupleExpr pullUpCommonStatementPatterns(Union union) {
		if (union.isVariableScopeChange()) {
			return union;
		}
		List<TupleExpr> branches = new ArrayList<>();
		collectUnionArgs(union, branches);
		if (branches.size() < 2) {
			return union;
		}
		List<List<StatementPattern>> branchPatterns = new ArrayList<>();
		for (TupleExpr branch : branches) {
			List<StatementPattern> patterns = collectStatementPatterns(branch);
			if (patterns == null || patterns.isEmpty()) {
				return union;
			}
			branchPatterns.add(patterns);
		}
		List<StatementPattern> common = commonPatterns(branchPatterns);
		if (common.isEmpty()) {
			return union;
		}
		Map<StatementPatternKey, Integer> removalCounts = countPatterns(common);
		List<List<StatementPattern>> remainingBranches = new ArrayList<>();
		for (List<StatementPattern> branchPatternsList : branchPatterns) {
			remainingBranches.add(removeCommon(branchPatternsList, new HashMap<>(removalCounts)));
		}
		if (!shouldPullUp(common, remainingBranches)) {
			return union;
		}
		List<TupleExpr> rebuiltBranches = new ArrayList<>();
		for (List<StatementPattern> remaining : remainingBranches) {
			rebuiltBranches.add(joinPatterns(remaining));
		}
		TupleExpr newUnion = buildUnion(rebuiltBranches, union.isVariableScopeChange());
		TupleExpr pulled = joinPatterns(common);
		return new Join(pulled, newUnion);
	}

	private static void collectUnionArgs(Union union, List<TupleExpr> branches) {
		TupleExpr left = union.getLeftArg();
		TupleExpr right = union.getRightArg();
		if (left instanceof Union) {
			collectUnionArgs((Union) left, branches);
		} else {
			branches.add(left);
		}
		if (right instanceof Union) {
			collectUnionArgs((Union) right, branches);
		} else {
			branches.add(right);
		}
	}

	private static List<StatementPattern> collectStatementPatterns(TupleExpr expr) {
		if (expr instanceof StatementPattern) {
			return new ArrayList<>(List.of((StatementPattern) expr));
		}
		if (expr instanceof SingletonSet) {
			return new ArrayList<>();
		}
		if (expr instanceof Join) {
			List<TupleExpr> args = new ArrayList<>();
			collectJoinArgs((Join) expr, args);
			List<StatementPattern> patterns = new ArrayList<>();
			for (TupleExpr arg : args) {
				List<StatementPattern> nested = collectStatementPatterns(arg);
				if (nested == null) {
					return null;
				}
				patterns.addAll(nested);
			}
			return patterns;
		}
		return null;
	}

	private static void collectJoinArgs(Join join, List<TupleExpr> args) {
		TupleExpr left = join.getLeftArg();
		TupleExpr right = join.getRightArg();
		if (left instanceof Join) {
			collectJoinArgs((Join) left, args);
		} else {
			args.add(left);
		}
		if (right instanceof Join) {
			collectJoinArgs((Join) right, args);
		} else {
			args.add(right);
		}
	}

	private static TupleExpr joinPatterns(List<StatementPattern> patterns) {
		if (patterns.isEmpty()) {
			return new SingletonSet();
		}
		TupleExpr expr = null;
		for (StatementPattern pattern : patterns) {
			StatementPattern clone = pattern.clone();
			if (expr == null) {
				expr = clone;
			} else {
				expr = new Join(expr, clone);
			}
		}
		return expr != null ? expr : new SingletonSet();
	}

	private static TupleExpr buildUnion(List<TupleExpr> branches, boolean scopeChange) {
		TupleExpr unionExpr = null;
		for (TupleExpr branch : branches) {
			if (unionExpr == null) {
				unionExpr = branch;
			} else {
				Union newUnion = new Union(unionExpr, branch);
				newUnion.setVariableScopeChange(scopeChange);
				unionExpr = newUnion;
			}
		}
		if (unionExpr == null) {
			return new SingletonSet();
		}
		if (unionExpr instanceof Union) {
			((Union) unionExpr).setVariableScopeChange(scopeChange);
		}
		return unionExpr;
	}

	private static Map<StatementPatternKey, Integer> countPatterns(List<StatementPattern> patterns) {
		Map<StatementPatternKey, Integer> counts = new HashMap<>();
		for (StatementPattern pattern : patterns) {
			StatementPatternKey key = StatementPatternKey.of(pattern);
			counts.merge(key, 1, Integer::sum);
		}
		return counts;
	}

	private static List<StatementPattern> commonPatterns(List<List<StatementPattern>> branchPatterns) {
		List<StatementPattern> first = branchPatterns.get(0);
		Map<StatementPatternKey, Integer> minCounts = countPatterns(first);
		for (int i = 1; i < branchPatterns.size(); i++) {
			Map<StatementPatternKey, Integer> branchCounts = countPatterns(branchPatterns.get(i));
			for (StatementPatternKey key : new HashSet<>(minCounts.keySet())) {
				Integer count = branchCounts.get(key);
				if (count == null || count == 0) {
					minCounts.remove(key);
				} else {
					minCounts.put(key, Math.min(minCounts.get(key), count));
				}
			}
			if (minCounts.isEmpty()) {
				return List.of();
			}
		}
		List<StatementPattern> common = new ArrayList<>();
		Map<StatementPatternKey, Integer> remaining = new HashMap<>(minCounts);
		for (StatementPattern pattern : first) {
			StatementPatternKey key = StatementPatternKey.of(pattern);
			Integer count = remaining.get(key);
			if (count != null && count > 0) {
				common.add(pattern);
				remaining.put(key, count - 1);
			}
		}
		return common;
	}

	private static List<StatementPattern> removeCommon(List<StatementPattern> patterns,
			Map<StatementPatternKey, Integer> removalCounts) {
		List<StatementPattern> remaining = new ArrayList<>();
		for (StatementPattern pattern : patterns) {
			StatementPatternKey key = StatementPatternKey.of(pattern);
			Integer count = removalCounts.get(key);
			if (count != null && count > 0) {
				removalCounts.put(key, count - 1);
				continue;
			}
			remaining.add(pattern);
		}
		return remaining;
	}

	private boolean shouldPullUp(List<StatementPattern> common, List<List<StatementPattern>> remainingBranches) {
		double commonCardinality = estimateCardinality(common);
		for (List<StatementPattern> remaining : remainingBranches) {
			if (remaining.isEmpty()) {
				continue;
			}
			double remainingCardinality = estimateCardinality(remaining);
			if (commonCardinality > remainingCardinality) {
				return false;
			}
		}
		return true;
	}

	private double estimateCardinality(List<StatementPattern> patterns) {
		return evaluationStatistics.getCardinality(joinPatterns(patterns));
	}

	private static final class StatementPatternKey {
		private final String subject;
		private final String predicate;
		private final String object;
		private final String context;

		private StatementPatternKey(String subject, String predicate, String object, String context) {
			this.subject = subject;
			this.predicate = predicate;
			this.object = object;
			this.context = context;
		}

		static StatementPatternKey of(StatementPattern pattern) {
			return new StatementPatternKey(
					varKey(pattern.getSubjectVar()),
					varKey(pattern.getPredicateVar()),
					varKey(pattern.getObjectVar()),
					varKey(pattern.getContextVar()));
		}

		private static String varKey(Var var) {
			if (var == null) {
				return "_";
			}
			if (var.hasValue()) {
				return valueKey(var.getValue());
			}
			String suffix = var.isAnonymous() ? "#anon" : "";
			return "?" + var.getName() + suffix;
		}

		private static String valueKey(Value value) {
			if (value instanceof IRI) {
				return "<" + ((IRI) value).stringValue() + ">";
			}
			if (value instanceof Literal) {
				Literal literal = (Literal) value;
				StringBuilder builder = new StringBuilder();
				builder.append("\"").append(literal.getLabel()).append("\"");
				if (literal.getLanguage().isPresent()) {
					builder.append("@").append(literal.getLanguage().get());
				} else if (literal.getDatatype() != null) {
					builder.append("^^<").append(literal.getDatatype().stringValue()).append(">");
				}
				return builder.toString();
			}
			if (value instanceof BNode) {
				return "_:" + ((BNode) value).getID();
			}
			return value.stringValue();
		}

		@Override
		public boolean equals(Object other) {
			if (this == other) {
				return true;
			}
			if (!(other instanceof StatementPatternKey)) {
				return false;
			}
			StatementPatternKey that = (StatementPatternKey) other;
			return subject.equals(that.subject)
					&& predicate.equals(that.predicate)
					&& object.equals(that.object)
					&& context.equals(that.context);
		}

		@Override
		public int hashCode() {
			int result = subject.hashCode();
			result = 31 * result + predicate.hashCode();
			result = 31 * result + object.hashCode();
			result = 31 * result + context.hashCode();
			return result;
		}
	}
}
