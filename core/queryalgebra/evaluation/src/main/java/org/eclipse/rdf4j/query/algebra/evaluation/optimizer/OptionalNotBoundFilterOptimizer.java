/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import java.util.HashSet;
import java.util.Set;

import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.Bound;
import org.eclipse.rdf4j.query.algebra.Exists;
import org.eclipse.rdf4j.query.algebra.Filter;
import org.eclipse.rdf4j.query.algebra.LeftJoin;
import org.eclipse.rdf4j.query.algebra.Not;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.ValueExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryOptimizer;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractSimpleQueryModelVisitor;

/**
 * Rewrites Filter(!BOUND(?v)) over a LeftJoin into Filter(Not(Exists(right))) on the left argument.
 */
public class OptionalNotBoundFilterOptimizer implements QueryOptimizer {

	@Override
	public void optimize(TupleExpr tupleExpr, Dataset dataset, BindingSet bindings) {
		if (UnorderedSliceDetector.hasUnorderedSlice(tupleExpr)) {
			return;
		}
		tupleExpr.visit(new OptionalNotBoundVisitor());
	}

	private static final class OptionalNotBoundVisitor extends AbstractSimpleQueryModelVisitor<RuntimeException> {
		@Override
		public void meet(Filter filter) {
			super.meet(filter);
			Var notBoundVar = notBoundVar(filter.getCondition());
			if (notBoundVar == null || notBoundVar.hasValue()) {
				return;
			}
			if (!(filter.getArg() instanceof LeftJoin)) {
				return;
			}
			LeftJoin leftJoin = (LeftJoin) filter.getArg();
			if (leftJoin.getCondition() != null) {
				return;
			}
			Set<String> rightOnly = new HashSet<>(leftJoin.getRightArg().getBindingNames());
			rightOnly.removeAll(leftJoin.getLeftArg().getBindingNames());
			if (!rightOnly.contains(notBoundVar.getName())) {
				return;
			}

			TupleExpr left = leftJoin.getLeftArg();
			TupleExpr right = leftJoin.getRightArg();

			filter.setCondition(new Not(new Exists(right.clone())));
			filter.setArg(left);
		}
	}

	private static Var notBoundVar(ValueExpr condition) {
		if (!(condition instanceof Not)) {
			return null;
		}
		ValueExpr inner = ((Not) condition).getArg();
		if (!(inner instanceof Bound)) {
			return null;
		}
		ValueExpr arg = ((Bound) inner).getArg();
		if (arg instanceof Var) {
			return (Var) arg;
		}
		return null;
	}
}
