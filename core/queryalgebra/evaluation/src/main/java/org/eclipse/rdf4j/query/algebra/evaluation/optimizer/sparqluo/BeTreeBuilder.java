/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer.sparqluo;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.LeftJoin;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.Union;
import org.eclipse.rdf4j.query.algebra.helpers.collectors.VarNameCollector;

public class BeTreeBuilder {
	private final BeBgpCoalescer coalescer = new BeBgpCoalescer();

	public BeGroupNode build(TupleExpr expr) {
		BeGroupNode group = new BeGroupNode();
		addGroupChildren(expr, group, new HashSet<>());
		coalescer.coalesce(group);
		return group;
	}

	private void addGroupChildren(TupleExpr expr, BeGroupNode group, Set<String> boundVars) {
		if (expr instanceof Join) {
			List<TupleExpr> args = new ArrayList<>();
			collectJoinArgs((Join) expr, args);
			for (TupleExpr arg : args) {
				addGroupChildren(arg, group, boundVars);
			}
			return;
		}
		if (expr instanceof LeftJoin) {
			LeftJoin leftJoin = (LeftJoin) expr;
			if (leftJoin.getCondition() != null || !canFlattenLeftJoin(leftJoin, boundVars)) {
				group.addChild(new BeBarrierNode(expr));
				boundVars.addAll(expr.getBindingNames());
				return;
			}
			addGroupChildren(leftJoin.getLeftArg(), group, boundVars);
			BeGroupNode rightGroup = build(leftJoin.getRightArg());
			group.addChild(new BeOptionalNode(rightGroup));
			boundVars.addAll(leftJoin.getBindingNames());
			return;
		}
		if (expr instanceof Union) {
			Union union = (Union) expr;
			List<TupleExpr> branches = new ArrayList<>();
			boolean scopeChange = collectUnionArgs(union, branches, union.isVariableScopeChange());
			BeUnionNode unionNode = new BeUnionNode(scopeChange);
			for (TupleExpr branch : branches) {
				unionNode.addBranch(build(branch));
			}
			group.addChild(unionNode);
			boundVars.addAll(union.getBindingNames());
			return;
		}
		if (expr instanceof StatementPattern) {
			group.addChild(new BeBgpNode(List.of((StatementPattern) expr)));
			boundVars.addAll(expr.getBindingNames());
			return;
		}

		group.addChild(new BeBarrierNode(expr));
		boundVars.addAll(expr.getBindingNames());
	}

	private void collectJoinArgs(Join join, List<TupleExpr> args) {
		TupleExpr left = join.getLeftArg();
		TupleExpr right = join.getRightArg();
		if (left instanceof Join) {
			collectJoinArgs((Join) left, args);
		} else {
			args.add(left);
		}
		if (right instanceof Join) {
			collectJoinArgs((Join) right, args);
		} else {
			args.add(right);
		}
	}

	private boolean collectUnionArgs(Union union, List<TupleExpr> branches, boolean scopeChange) {
		TupleExpr left = union.getLeftArg();
		TupleExpr right = union.getRightArg();
		if (left instanceof Union) {
			scopeChange = collectUnionArgs((Union) left, branches,
					scopeChange || ((Union) left).isVariableScopeChange());
		} else {
			branches.add(left);
		}
		if (right instanceof Union) {
			scopeChange = collectUnionArgs((Union) right, branches,
					scopeChange || ((Union) right).isVariableScopeChange());
		} else {
			branches.add(right);
		}
		return scopeChange;
	}

	private boolean canFlattenLeftJoin(LeftJoin leftJoin, Set<String> boundVars) {
		if (boundVars.isEmpty()) {
			return true;
		}
		Set<String> optionalVars = new HashSet<>(VarNameCollector.process(leftJoin.getRightArg()));
		if (leftJoin.hasCondition()) {
			optionalVars.addAll(VarNameCollector.process(leftJoin.getCondition()));
		}
		optionalVars.removeAll(leftJoin.getLeftArg().getBindingNames());
		if (optionalVars.isEmpty()) {
			return true;
		}
		for (String var : optionalVars) {
			if (boundVars.contains(var)) {
				return false;
			}
		}
		return true;
	}
}
