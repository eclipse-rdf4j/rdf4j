/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.impl;

import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.QueryEvaluationException;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.Service;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryEvaluationStep;
import org.eclipse.rdf4j.query.algebra.evaluation.TripleSource;
import org.eclipse.rdf4j.query.algebra.evaluation.federation.FederatedServiceResolver;
import org.eclipse.rdf4j.query.algebra.evaluation.federation.ServiceJoinIterator;
import org.eclipse.rdf4j.query.algebra.evaluation.iterator.AdaptiveJoinIteration;
import org.eclipse.rdf4j.query.algebra.evaluation.iterator.HashJoinIteration;
import org.eclipse.rdf4j.query.algebra.evaluation.iterator.InnerMergeJoinIterator;
import org.eclipse.rdf4j.query.algebra.evaluation.iterator.JoinIterator;
import org.eclipse.rdf4j.query.algebra.helpers.TupleExprs;

/**
 * Evaluation strategy that can switch between nested-loop and hash join at runtime.
 */
public class AdaptiveEvaluationStrategy extends DefaultEvaluationStrategy {

	private final int nestedLoopThreshold;
	private final long hashJoinMaxBuildRows;

	public AdaptiveEvaluationStrategy(TripleSource tripleSource, Dataset dataset,
			FederatedServiceResolver serviceResolver, long iterationCacheSyncTreshold,
			EvaluationStatistics evaluationStatistics, boolean trackResultSize,
			int nestedLoopThreshold, long hashJoinMaxBuildRows) {
		super(tripleSource, dataset, serviceResolver, iterationCacheSyncTreshold, evaluationStatistics,
				trackResultSize);
		this.nestedLoopThreshold = nestedLoopThreshold;
		this.hashJoinMaxBuildRows = hashJoinMaxBuildRows;
	}

	@Override
	protected QueryEvaluationStep prepare(Join node, QueryEvaluationContext context) throws QueryEvaluationException {
		QueryEvaluationStep leftPrepared = precompile(node.getLeftArg(), context);
		QueryEvaluationStep rightPrepared = precompile(node.getRightArg(), context);
		if (node.getRightArg() instanceof Service) {
			return bindings -> {
				node.setAlgorithm(ServiceJoinIterator.class.getSimpleName());
				return new ServiceJoinIterator(leftPrepared.evaluate(bindings), (Service) node.getRightArg(),
						bindings, this);
			};
		}

		if (isOutOfScopeForLeftArgBindings(node.getRightArg())) {
			String[] joinAttributes = HashJoinIteration.hashJoinAttributeNames(node);
			return bindings -> {
				node.setAlgorithm(HashJoinIteration.class.getSimpleName());
				return new HashJoinIteration(leftPrepared, rightPrepared, bindings, false, joinAttributes, context);
			};
		}

		if (node.isMergeJoin() && context.getComparator() != null) {
			return bindings -> {
				node.setAlgorithm(InnerMergeJoinIterator.class.getSimpleName());
				return InnerMergeJoinIterator.getInstance(leftPrepared, rightPrepared, bindings,
						context.getComparator(), context.getValue(node.getOrder().getName()), context);
			};
		}

		String[] joinAttributes = HashJoinIteration.hashJoinAttributeNames(node);
		if (joinAttributes.length == 0) {
			return bindings -> {
				node.setAlgorithm(JoinIterator.class.getSimpleName());
				return JoinIterator.getInstance(leftPrepared, rightPrepared, bindings);
			};
		}

		return bindings -> {
			node.setAlgorithm(AdaptiveJoinIteration.class.getSimpleName());
			return new AdaptiveJoinIteration(leftPrepared, rightPrepared, bindings, joinAttributes,
					nestedLoopThreshold, hashJoinMaxBuildRows, context);
		};
	}

	private static boolean isOutOfScopeForLeftArgBindings(TupleExpr expr) {
		return TupleExprs.isVariableScopeChange(expr) || TupleExprs.containsSubquery(expr);
	}

}
