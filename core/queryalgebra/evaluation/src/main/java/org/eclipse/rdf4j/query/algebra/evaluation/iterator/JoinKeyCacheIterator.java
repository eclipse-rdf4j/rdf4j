/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.iterator;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.rdf4j.common.iteration.CloseableIteration;
import org.eclipse.rdf4j.common.iteration.LookAheadIteration;
import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.MutableBindingSet;
import org.eclipse.rdf4j.query.QueryEvaluationException;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryEvaluationStep;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.QueryEvaluationContext;

public class JoinKeyCacheIterator extends LookAheadIteration<BindingSet> {
	private static final String PROP_ENABLED = "rdf4j.query.joinKeyCache.enabled";
	private static final String PROP_MAX_ENTRIES = "rdf4j.query.joinKeyCache.maxEntries";
	private static final String PROP_MAX_RESULTS = "rdf4j.query.joinKeyCache.maxResultsPerKey";

	private static final boolean CACHE_ENABLED = readEnabled();
	private static final int DEFAULT_MAX_ENTRIES = 1000;
	private static final int DEFAULT_MAX_RESULTS = 1000;

	private final CloseableIteration<BindingSet> leftIter;
	private final QueryEvaluationStep preparedRight;
	private final QueryEvaluationContext context;
	private final String[] joinAttributes;
	private final Set<String> rightBindingNames;
	private final int maxResultsPerKey;
	private final Map<BindingSetHashKey, List<BindingSet>> cache;

	private BindingSet currentLeft;
	private Iterator<BindingSet> currentRightIter;

	public static boolean isEnabled(String[] joinAttributes) {
		return CACHE_ENABLED && joinAttributes.length > 0 && readMaxEntries() > 0;
	}

	public static CloseableIteration<BindingSet> getInstance(QueryEvaluationStep leftPrepared,
			QueryEvaluationStep preparedRight, BindingSet bindings, String[] joinAttributes,
			Set<String> rightBindingNames, QueryEvaluationContext context) {
		CloseableIteration<BindingSet> leftIter = leftPrepared.evaluate(bindings);
		if (leftIter == QueryEvaluationStep.EMPTY_ITERATION) {
			return leftIter;
		}
		return new JoinKeyCacheIterator(leftIter, preparedRight, joinAttributes, rightBindingNames, context);
	}

	private JoinKeyCacheIterator(CloseableIteration<BindingSet> leftIter, QueryEvaluationStep preparedRight,
			String[] joinAttributes, Set<String> rightBindingNames, QueryEvaluationContext context) {
		this.leftIter = leftIter;
		this.preparedRight = preparedRight;
		this.joinAttributes = joinAttributes;
		this.rightBindingNames = rightBindingNames;
		this.context = context;
		this.maxResultsPerKey = readMaxResultsPerKey();
		this.cache = new LinkedHashMap<>(16, 0.75f, true) {
			@Override
			protected boolean removeEldestEntry(Map.Entry<BindingSetHashKey, List<BindingSet>> eldest) {
				return size() > readMaxEntries();
			}
		};
	}

	@Override
	protected BindingSet getNextElement() throws QueryEvaluationException {
		if (currentRightIter != null) {
			if (currentRightIter.hasNext()) {
				return merge(currentLeft, currentRightIter.next());
			}
			currentRightIter = null;
			currentLeft = null;
		}

		while (leftIter.hasNext()) {
			currentLeft = leftIter.next();
			BindingSetHashKey key = BindingSetHashKey.create(joinAttributes, currentLeft);
			List<BindingSet> rightResults = cache.get(key);
			if (rightResults == null) {
				CacheEntry entry = evaluateRight(currentLeft);
				rightResults = entry.results;
				if (entry.cacheable) {
					cache.put(key, rightResults);
				}
			}

			if (!rightResults.isEmpty()) {
				currentRightIter = rightResults.iterator();
				return merge(currentLeft, currentRightIter.next());
			}
		}
		return null;
	}

	private CacheEntry evaluateRight(BindingSet leftBindings) {
		CloseableIteration<BindingSet> iteration = preparedRight.evaluate(leftBindings);
		if (iteration == QueryEvaluationStep.EMPTY_ITERATION) {
			return CacheEntry.empty();
		}
		List<BindingSet> results = new ArrayList<>();
		boolean cacheable = true;
		try {
			while (iteration.hasNext()) {
				BindingSet candidate = iteration.next();
				results.add(stripLeftBindings(candidate));
				if (maxResultsPerKey > 0 && results.size() > maxResultsPerKey) {
					cacheable = false;
				}
			}
		} finally {
			iteration.close();
		}
		return new CacheEntry(results, cacheable);
	}

	private BindingSet stripLeftBindings(BindingSet candidate) {
		MutableBindingSet stripped = context.createBindingSet();
		for (String name : candidate.getBindingNames()) {
			if (rightBindingNames.contains(name)) {
				var value = candidate.getValue(name);
				if (value != null) {
					context.addBinding(name).accept(value, stripped);
				}
			}
		}
		return stripped;
	}

	private BindingSet merge(BindingSet left, BindingSet right) {
		MutableBindingSet result = context.createBindingSet(left);
		for (String name : right.getBindingNames()) {
			if (!result.hasBinding(name)) {
				var value = right.getValue(name);
				if (value != null) {
					context.addBinding(name).accept(value, result);
				}
			}
		}
		return result;
	}

	@Override
	protected void handleClose() throws QueryEvaluationException {
		try {
			leftIter.close();
		} finally {
			if (currentRightIter instanceof CloseableIteration) {
				((CloseableIteration<?>) currentRightIter).close();
			}
		}
	}

	private static boolean readEnabled() {
		String value = System.getProperty(PROP_ENABLED);
		return value == null || Boolean.parseBoolean(value);
	}

	private static int readMaxEntries() {
		return readInt(PROP_MAX_ENTRIES, DEFAULT_MAX_ENTRIES);
	}

	private static int readMaxResultsPerKey() {
		return readInt(PROP_MAX_RESULTS, DEFAULT_MAX_RESULTS);
	}

	private static int readInt(String property, int fallback) {
		String value = System.getProperty(property);
		if (value == null) {
			return fallback;
		}
		try {
			return Integer.parseInt(value);
		} catch (NumberFormatException ignore) {
			return fallback;
		}
	}

	private static final class CacheEntry {
		private final List<BindingSet> results;
		private final boolean cacheable;

		private CacheEntry(List<BindingSet> results, boolean cacheable) {
			this.results = results;
			this.cacheable = cacheable;
		}

		private static CacheEntry empty() {
			return new CacheEntry(List.of(), true);
		}
	}
}
