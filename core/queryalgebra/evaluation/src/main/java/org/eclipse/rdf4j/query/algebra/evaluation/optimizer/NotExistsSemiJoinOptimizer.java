/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;

import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.And;
import org.eclipse.rdf4j.query.algebra.BinaryTupleOperator;
import org.eclipse.rdf4j.query.algebra.BinaryValueOperator;
import org.eclipse.rdf4j.query.algebra.Difference;
import org.eclipse.rdf4j.query.algebra.Distinct;
import org.eclipse.rdf4j.query.algebra.Exists;
import org.eclipse.rdf4j.query.algebra.Extension;
import org.eclipse.rdf4j.query.algebra.ExtensionElem;
import org.eclipse.rdf4j.query.algebra.Filter;
import org.eclipse.rdf4j.query.algebra.NAryValueOperator;
import org.eclipse.rdf4j.query.algebra.Not;
import org.eclipse.rdf4j.query.algebra.Projection;
import org.eclipse.rdf4j.query.algebra.ProjectionElem;
import org.eclipse.rdf4j.query.algebra.ProjectionElemList;
import org.eclipse.rdf4j.query.algebra.Service;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.SubQueryValueOperator;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.UnaryTupleOperator;
import org.eclipse.rdf4j.query.algebra.UnaryValueOperator;
import org.eclipse.rdf4j.query.algebra.ValueExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryOptimizer;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractQueryModelVisitor;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractSimpleQueryModelVisitor;

/**
 * Rewrites Filter(NOT EXISTS ...) into a safe anti-join when correlated variables are assuredly bound.
 */
public class NotExistsSemiJoinOptimizer implements QueryOptimizer {

	private static final double MAX_RIGHT_TO_LEFT_RATIO = 8.0;
	private static final double MAX_RIGHT_CARDINALITY = 100_000.0;

	private final EvaluationStatistics evaluationStatistics;
	private final boolean allowNonImprovingTransforms;

	public NotExistsSemiJoinOptimizer() {
		this(new EvaluationStatistics(), false);
	}

	public NotExistsSemiJoinOptimizer(EvaluationStatistics evaluationStatistics, boolean allowNonImprovingTransforms) {
		this.evaluationStatistics = Objects.requireNonNull(evaluationStatistics, "evaluationStatistics");
		this.allowNonImprovingTransforms = allowNonImprovingTransforms;
	}

	@Override
	public void optimize(TupleExpr tupleExpr, Dataset dataset, BindingSet bindings) {
		tupleExpr.visit(new NotExistsVisitor());
	}

	private final class NotExistsVisitor extends AbstractSimpleQueryModelVisitor<RuntimeException> {
		@Override
		public void meet(Filter filter) {
			super.meet(filter);
			NotExistsExtraction extraction = NotExistsExtraction.from(filter.getCondition());
			if (extraction == null) {
				return;
			}
			TupleExpr arg = filter.getArg();
			if (arg == null) {
				return;
			}
			TupleExpr subQuery = extraction.exists.getSubQuery();
			if (subQuery == null) {
				return;
			}
			if (containsService(subQuery)) {
				return;
			}
			Set<String> shared = collectSharedUnboundNames(arg, subQuery);
			if (shared.isEmpty()) {
				return;
			}
			Set<String> leftAssured = assuredBindingsWithAliases(arg);
			Set<String> rightAssured = assuredBindingsWithAliases(subQuery);
			if (!leftAssured.containsAll(shared) || !rightAssured.containsAll(shared)) {
				return;
			}
			if (!hasStatementPatternCoveringVars(subQuery, shared)) {
				return;
			}
			if (isExactJoinVarMatch(subQuery, shared)) {
				return;
			}
			TupleExpr leftForEstimate = arg;
			if (extraction.remainingCondition != null) {
				leftForEstimate = new Filter(arg.clone(), extraction.remainingCondition.clone());
			}
			TupleExpr right = buildDistinctProjection(subQuery.clone(), shared);
			if (!shouldRewrite(leftForEstimate, right)) {
				return;
			}
			TupleExpr left = arg;
			if (extraction.remainingCondition != null) {
				left = new Filter(arg, extraction.remainingCondition.clone());
			}
			Difference difference = new Difference(left, right);
			filter.replaceWith(difference);
		}
	}

	private boolean shouldRewrite(TupleExpr left, TupleExpr right) {
		if (allowNonImprovingTransforms) {
			return true;
		}
		double leftCardinality = evaluationStatistics.getCardinality(left);
		double rightCardinality = evaluationStatistics.getCardinality(right);
		if (!Double.isFinite(leftCardinality) || !Double.isFinite(rightCardinality) || leftCardinality <= 0.0) {
			return false;
		}
		if (rightCardinality > MAX_RIGHT_CARDINALITY) {
			return false;
		}
		return rightCardinality <= leftCardinality * MAX_RIGHT_TO_LEFT_RATIO;
	}

	private static TupleExpr buildDistinctProjection(TupleExpr subQuery, Set<String> joinVars) {
		List<String> ordered = new ArrayList<>(joinVars);
		Collections.sort(ordered);
		ProjectionElemList projectionElemList = new ProjectionElemList();
		for (String name : ordered) {
			projectionElemList.addElement(new ProjectionElem(name));
		}
		Projection projection = new Projection(subQuery, projectionElemList, false);
		return new Distinct(projection);
	}

	private static boolean containsService(TupleExpr subQuery) {
		AtomicBoolean found = new AtomicBoolean(false);
		subQuery.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			public void meet(Service node) {
				found.set(true);
			}
		});
		return found.get();
	}

	private static Set<String> assuredBindingsWithAliases(TupleExpr expr) {
		Set<String> assured = new LinkedHashSet<>(expr.getAssuredBindingNames());
		Map<String, String> aliases = collectAliasMap(expr);
		if (aliases.isEmpty()) {
			return assured;
		}
		boolean changed;
		do {
			changed = false;
			for (Map.Entry<String, String> entry : aliases.entrySet()) {
				if (assured.contains(entry.getValue()) && assured.add(entry.getKey())) {
					changed = true;
				}
			}
		} while (changed);
		return assured;
	}

	private static Set<String> collectSharedUnboundNames(TupleExpr left, TupleExpr right) {
		Set<String> leftUnbound = collectUnboundVarNames(left);
		leftUnbound.addAll(left.getBindingNames());
		Set<String> rightUnbound = collectUnboundVarNames(right);
		if (rightUnbound.isEmpty()) {
			return Set.of();
		}
		leftUnbound.retainAll(rightUnbound);
		return leftUnbound;
	}

	private static Set<String> collectUnboundVarNames(TupleExpr expr) {
		Set<String> names = new LinkedHashSet<>();
		expr.visit(new StopAtScopeChange(true) {
			@Override
			public void meet(Var node) {
				if (!node.hasValue()) {
					names.add(node.getName());
				}
			}
		});
		Map<String, String> aliases = collectAliasMap(expr);
		if (!aliases.isEmpty()) {
			names.addAll(aliases.keySet());
		}
		return names;
	}

	private static Map<String, String> collectAliasMap(TupleExpr expr) {
		Map<String, String> aliasMap = new HashMap<>();
		expr.visit(new AliasCollector(aliasMap));
		return aliasMap;
	}

	private static boolean isExactJoinVarMatch(TupleExpr expr, Set<String> joinVars) {
		if (joinVars.isEmpty()) {
			return false;
		}
		return collectUnboundVarNames(expr).equals(joinVars);
	}

	private static boolean hasStatementPatternCoveringVars(TupleExpr expr, Set<String> joinVars) {
		if (joinVars.isEmpty()) {
			return false;
		}
		AtomicBoolean found = new AtomicBoolean(false);
		expr.visit(new StopAtScopeChange(true) {
			@Override
			public void meet(StatementPattern node) {
				if (found.get()) {
					return;
				}
				Set<String> vars = new HashSet<>();
				addVarName(node.getSubjectVar(), vars);
				addVarName(node.getPredicateVar(), vars);
				addVarName(node.getObjectVar(), vars);
				addVarName(node.getContextVar(), vars);
				if (vars.containsAll(joinVars)) {
					found.set(true);
				}
			}
		});
		return found.get();
	}

	private static void addVarName(Var var, Set<String> vars) {
		if (var != null) {
			vars.add(var.getName());
		}
	}

	private static final class AliasCollector extends StopAtScopeChange {
		private final Map<String, String> aliasMap;

		private AliasCollector(Map<String, String> aliasMap) {
			super(true);
			this.aliasMap = aliasMap;
		}

		@Override
		public void meet(Extension node) {
			for (ExtensionElem elem : node.getElements()) {
				if (!(elem.getExpr() instanceof Var)) {
					continue;
				}
				String alias = elem.getName();
				String source = ((Var) elem.getExpr()).getName();
				String existing = aliasMap.get(alias);
				if (existing == null) {
					aliasMap.put(alias, source);
				} else if (!existing.equals(source)) {
					aliasMap.remove(alias);
				}
			}
			super.meet(node);
		}
	}

	private static class StopAtScopeChange extends AbstractSimpleQueryModelVisitor<RuntimeException> {

		private StopAtScopeChange(boolean meetStatementPatternChildren) {
			super(meetStatementPatternChildren);
		}

		@Override
		public void meetUnaryTupleOperator(UnaryTupleOperator node) {
			if (!node.isVariableScopeChange()) {
				super.meetUnaryTupleOperator(node);
			}
		}

		@Override
		public void meetBinaryTupleOperator(BinaryTupleOperator node) {
			if (!node.isVariableScopeChange()) {
				super.meetBinaryTupleOperator(node);
			}
		}

		@Override
		protected void meetBinaryValueOperator(BinaryValueOperator node) throws RuntimeException {
			if (!node.isVariableScopeChange()) {
				super.meetBinaryValueOperator(node);
			}
		}

		@Override
		protected void meetNAryValueOperator(NAryValueOperator node) throws RuntimeException {
			if (!node.isVariableScopeChange()) {
				super.meetNAryValueOperator(node);
			}
		}

		@Override
		protected void meetSubQueryValueOperator(SubQueryValueOperator node) throws RuntimeException {
			if (!node.isVariableScopeChange()) {
				super.meetSubQueryValueOperator(node);
			}
		}

		@Override
		protected void meetUnaryValueOperator(UnaryValueOperator node) throws RuntimeException {
			if (!node.isVariableScopeChange()) {
				super.meetUnaryValueOperator(node);
			}
		}
	}

	private static final class NotExistsExtraction {
		private final Exists exists;
		private final ValueExpr remainingCondition;

		private NotExistsExtraction(Exists exists, ValueExpr remainingCondition) {
			this.exists = exists;
			this.remainingCondition = remainingCondition;
		}

		private static NotExistsExtraction from(ValueExpr condition) {
			if (condition == null) {
				return null;
			}
			Exists exists = extractNotExists(condition);
			if (exists != null) {
				return new NotExistsExtraction(exists, null);
			}
			if (!(condition instanceof And)) {
				return null;
			}
			List<ValueExpr> conjuncts = new ArrayList<>();
			collectConjuncts(condition, conjuncts);
			Exists found = null;
			List<ValueExpr> remaining = new ArrayList<>();
			for (ValueExpr expr : conjuncts) {
				Exists candidate = extractNotExists(expr);
				if (candidate != null) {
					if (found != null) {
						return null;
					}
					found = candidate;
					continue;
				}
				if (containsExists(expr)) {
					return null;
				}
				remaining.add(expr);
			}
			if (found == null) {
				return null;
			}
			ValueExpr remainingCondition = rebuildAndChain(remaining);
			return new NotExistsExtraction(found, remainingCondition);
		}

		private static Exists extractNotExists(ValueExpr expr) {
			if (!(expr instanceof Not)) {
				return null;
			}
			ValueExpr inner = ((Not) expr).getArg();
			if (inner instanceof Exists) {
				return (Exists) inner;
			}
			return null;
		}

		private static void collectConjuncts(ValueExpr expr, List<ValueExpr> conjuncts) {
			if (expr instanceof And) {
				And and = (And) expr;
				collectConjuncts(and.getLeftArg(), conjuncts);
				collectConjuncts(and.getRightArg(), conjuncts);
				return;
			}
			conjuncts.add(expr);
		}

		private static ValueExpr rebuildAndChain(List<ValueExpr> conjuncts) {
			if (conjuncts.isEmpty()) {
				return null;
			}
			ValueExpr current = conjuncts.get(0);
			for (int i = 1; i < conjuncts.size(); i++) {
				current = new And(current, conjuncts.get(i));
			}
			return current;
		}

		private static boolean containsExists(ValueExpr expr) {
			AtomicBoolean found = new AtomicBoolean(false);
			expr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
				@Override
				public void meet(Exists node) {
					found.set(true);
				}
			});
			return found.get();
		}
	}
}
