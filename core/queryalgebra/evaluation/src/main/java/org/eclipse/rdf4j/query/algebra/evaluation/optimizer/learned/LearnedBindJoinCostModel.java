/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Value;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.query.algebra.And;
import org.eclipse.rdf4j.query.algebra.Compare;
import org.eclipse.rdf4j.query.algebra.Compare.CompareOp;
import org.eclipse.rdf4j.query.algebra.Extension;
import org.eclipse.rdf4j.query.algebra.Filter;
import org.eclipse.rdf4j.query.algebra.Or;
import org.eclipse.rdf4j.query.algebra.Reduced;
import org.eclipse.rdf4j.query.algebra.SameTerm;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.UnaryTupleOperator;
import org.eclipse.rdf4j.query.algebra.ValueConstant;
import org.eclipse.rdf4j.query.algebra.ValueExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.JoinStatsProvider;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.PatternKey;
import org.eclipse.rdf4j.query.algebra.helpers.TupleExprs;
import org.eclipse.rdf4j.query.algebra.helpers.collectors.VarNameCollector;

/**
 * Cost model based on learned join statistics with an EvaluationStatistics fallback.
 */
public class LearnedBindJoinCostModel implements BindJoinCostModel {

	private static final long DEFAULT_PRIOR_CALLS = 2;
	private static final double FILTER_EXISTS_UNBOUND_PENALTY = 1.0e9d;
	private static final double GENERIC_BOUND_CAP_MULTIPLIER = 10.0d;
	private static final IRI BOUND_VALUE = SimpleValueFactory.getInstance().createIRI("urn:bound");
	private static final EvaluationStatistics GENERIC_STATS = new EvaluationStatistics();

	private final EvaluationStatistics fallbackStats;
	private final JoinStatsProvider learnedStats;
	private final FilterConstraints externalConstraints;

	public LearnedBindJoinCostModel(EvaluationStatistics fallbackStats, JoinStatsProvider learnedStats) {
		this(fallbackStats, learnedStats, List.of());
	}

	public LearnedBindJoinCostModel(EvaluationStatistics fallbackStats, JoinStatsProvider learnedStats,
			List<ValueExpr> externalFilters) {
		this.fallbackStats = Objects.requireNonNull(fallbackStats, "fallbackStats");
		this.learnedStats = Objects.requireNonNull(learnedStats, "learnedStats");
		this.externalConstraints = collectExternalConstraints(externalFilters);
	}

	@Override
	public double estimateFanout(TupleExpr expr, Set<String> boundVars) {
		if (TupleExprs.isFilterExistsFunction(expr)) {
			return estimateFilterExistsCardinality((Filter) expr, boundVars);
		}
		PatternContext context = unwrapPattern(expr);
		if (context == null) {
			return fallbackStats.getCardinality(expr);
		}
		return estimatePattern(context, boundVars);
	}

	@Override
	public double estimateScanCardinality(TupleExpr expr, Set<String> initiallyBoundVars) {
		if (TupleExprs.isFilterExistsFunction(expr)) {
			return estimateFilterExistsCardinality((Filter) expr, initiallyBoundVars);
		}
		PatternContext context = unwrapPattern(expr);
		if (context == null) {
			return fallbackStats.getCardinality(expr);
		}
		return estimatePattern(context, initiallyBoundVars);
	}

	@Override
	public Set<String> bindingNames(TupleExpr expr) {
		return expr.getBindingNames();
	}

	private double estimatePattern(PatternContext context, Set<String> boundVars) {
		FilterApplication filterApplication = applyFilterConstraints(context, boundVars);
		StatementPattern pattern = context.pattern;
		Set<String> effectiveBoundVars = filterApplication.boundVars;
		PatternKey key = buildKey(pattern, effectiveBoundVars);
		StatementPattern boundPattern = applyBoundVars(pattern, effectiveBoundVars);
		double defaultEstimate = fallbackStats.getCardinality(boundPattern);
		if (usesPlaceholder(boundPattern)) {
			defaultEstimate = fallbackEstimateForBoundPlaceholder(pattern, boundPattern, defaultEstimate);
		}
		if (!learnedStats.hasStats(key)) {
			double estimate = applyFilterMultiplier(defaultEstimate, filterApplication, pattern);
			return applyFilterFallbackCap(estimate, context);
		}
		learnedStats.seedIfAbsent(key, defaultEstimate, DEFAULT_PRIOR_CALLS);
		double average = learnedStats.getAverageResults(key);
		double estimate = average > 0.0d ? average : defaultEstimate;
		double max = learnedStats.getMaxResults(key);
		if (max > estimate && estimate > 0.0d) {
			double skewed = Math.sqrt(estimate * max);
			if (skewed > estimate) {
				estimate = skewed;
			}
		}
		double adjusted = estimate > 0.0d ? estimate : defaultEstimate;
		double filtered = applyFilterMultiplier(adjusted, filterApplication, pattern);
		return applyFilterFallbackCap(filtered, context);
	}

	private double estimateFilterExistsCardinality(Filter filter, Set<String> boundVars) {
		double estimate = fallbackStats.getCardinality(filter);
		if (estimate <= 0.0d) {
			estimate = 1.0d;
		}
		Set<String> correlated = correlatedFilterVars(filter);
		if (!correlated.isEmpty() && !boundVars.containsAll(correlated)) {
			estimate *= FILTER_EXISTS_UNBOUND_PENALTY;
		}
		return estimate;
	}

	private Set<String> correlatedFilterVars(Filter filter) {
		Set<String> filterVars = VarNameCollector.process(filter.getCondition());
		if (filterVars.isEmpty()) {
			return filterVars;
		}
		Set<String> bindings = filter.getBindingNames();
		if (bindings.isEmpty()) {
			return Set.of();
		}
		Set<String> correlated = new HashSet<>(filterVars);
		correlated.retainAll(bindings);
		return correlated.isEmpty() ? Set.of() : correlated;
	}

	private double fallbackEstimateForBoundPlaceholder(StatementPattern pattern, StatementPattern boundPattern,
			double fallbackEstimate) {
		double unboundEstimate = fallbackStats.getCardinality(pattern);
		double genericUnbound = GENERIC_STATS.getCardinality(pattern);
		double genericBound = GENERIC_STATS.getCardinality(boundPattern);
		double candidate = fallbackEstimate;
		if (unboundEstimate > 0.0d && genericUnbound > 0.0d && genericBound > 0.0d) {
			double scaled = unboundEstimate * (genericBound / genericUnbound);
			if (scaled > 0.0d) {
				candidate = scaled;
			}
		} else if (fallbackEstimate <= 0.0d) {
			if (genericBound > 0.0d) {
				candidate = genericBound;
			} else if (unboundEstimate > 0.0d) {
				candidate = unboundEstimate;
			} else {
				candidate = 1.0d;
			}
		}
		if (fallbackEstimate > 0.0d && fallbackEstimate < candidate) {
			candidate = fallbackEstimate;
		}
		if (unboundEstimate > 0.0d) {
			boolean fallbackIgnoresBindings = fallbackEstimate <= 0.0d
					|| (fallbackEstimate > 0.0d && fallbackEstimate >= unboundEstimate * 0.95d);
			if (fallbackIgnoresBindings) {
				double cap = Math.sqrt(unboundEstimate);
				if (genericBound > 0.0d) {
					double genericCap = genericBound;
					if (countUnboundVars(boundPattern) > 1) {
						genericCap *= GENERIC_BOUND_CAP_MULTIPLIER;
					}
					if (genericCap > 0.0d && genericCap < cap) {
						cap = genericCap;
					}
				}
				if (cap > 0.0d && candidate > cap) {
					candidate = cap;
				}
			}
		}
		if (isFullyBound(boundPattern)) {
			candidate = Math.min(candidate, 1.0d);
		}
		return candidate > 0.0d ? candidate : 1.0d;
	}

	private boolean isFullyBound(StatementPattern pattern) {
		return hasValue(pattern.getSubjectVar())
				&& hasValue(pattern.getPredicateVar())
				&& hasValue(pattern.getObjectVar())
				&& (pattern.getContextVar() == null || pattern.getContextVar().hasValue());
	}

	private boolean hasValue(Var var) {
		return var != null && var.hasValue();
	}

	private int countUnboundVars(StatementPattern pattern) {
		int count = 0;
		if (isUnbound(pattern.getSubjectVar())) {
			count++;
		}
		if (isUnbound(pattern.getPredicateVar())) {
			count++;
		}
		if (isUnbound(pattern.getObjectVar())) {
			count++;
		}
		Var context = pattern.getContextVar();
		if (context != null && isUnbound(context)) {
			count++;
		}
		return count;
	}

	private boolean isUnbound(Var var) {
		return var != null && !var.hasValue();
	}

	private boolean usesPlaceholder(StatementPattern pattern) {
		return isPlaceholder(pattern.getSubjectVar())
				|| isPlaceholder(pattern.getPredicateVar())
				|| isPlaceholder(pattern.getObjectVar())
				|| isPlaceholder(pattern.getContextVar());
	}

	private boolean isPlaceholder(Var var) {
		return var != null && BOUND_VALUE.equals(var.getValue());
	}

	private double applyFilterFallbackCap(double estimate, PatternContext context) {
		if (context.filters.isEmpty()) {
			return estimate;
		}
		double filterEstimate = fallbackStats.getCardinality(context.filters.get(0));
		if (filterEstimate > 0.0d && filterEstimate < estimate) {
			return filterEstimate;
		}
		return estimate;
	}

	private PatternKey buildKey(StatementPattern node, Set<String> boundVars) {
		int mask = 0;
		if (isBound(node.getSubjectVar(), boundVars)) {
			mask |= PatternKey.SUBJECT_BOUND;
		}
		if (isBound(node.getPredicateVar(), boundVars)) {
			mask |= PatternKey.PREDICATE_BOUND;
		}
		if (isBound(node.getObjectVar(), boundVars)) {
			mask |= PatternKey.OBJECT_BOUND;
		}
		Var predVar = node.getPredicateVar();
		IRI predicateKey = null;
		if (predVar != null && predVar.hasValue() && predVar.getValue() instanceof IRI) {
			predicateKey = (IRI) predVar.getValue();
		}
		return new PatternKey(predicateKey, mask);
	}

	private boolean isBound(Var var, Set<String> boundVars) {
		if (var == null) {
			return false;
		}
		if (var.hasValue()) {
			return true;
		}
		String name = var.getName();
		return name != null && boundVars.contains(name);
	}

	private PatternContext unwrapPattern(TupleExpr expr) {
		TupleExpr current = expr;
		List<Filter> filters = List.of();
		while (true) {
			if (current instanceof Filter) {
				Filter filter = (Filter) current;
				if (filters.isEmpty()) {
					filters = List.of(filter);
				} else {
					if (filters.size() == 1) {
						filters = new java.util.ArrayList<>(filters);
					}
					filters.add(filter);
				}
				current = filter.getArg();
				continue;
			}
			if (current instanceof Extension || current instanceof Reduced) {
				current = ((UnaryTupleOperator) current).getArg();
				continue;
			}
			break;
		}
		if (!(current instanceof StatementPattern)) {
			return null;
		}
		return new PatternContext((StatementPattern) current, filters);
	}

	private FilterApplication applyFilterConstraints(PatternContext context, Set<String> boundVars) {
		FilterConstraints constraints = externalConstraints;
		for (Filter filter : context.filters) {
			constraints = constraints.and(extractFilterConstraints(filter.getCondition()));
		}
		if (constraints.isEmpty()) {
			return new FilterApplication(new HashSet<>(boundVars), 1.0d);
		}
		Set<String> effectiveBound = new HashSet<>(boundVars);
		double multiplier = 1.0d;
		Set<String> patternNames = context.pattern.getBindingNames();
		for (Map.Entry<String, Set<Value>> entry : constraints.bindings.entrySet()) {
			String name = entry.getKey();
			if (!patternNames.contains(name)) {
				continue;
			}
			if (effectiveBound.contains(name)) {
				continue;
			}
			effectiveBound.add(name);
			int count = entry.getValue().size();
			if (count > 1) {
				multiplier *= count;
			}
		}
		return new FilterApplication(effectiveBound, multiplier);
	}

	private FilterConstraints collectExternalConstraints(List<ValueExpr> filters) {
		if (filters == null || filters.isEmpty()) {
			return FilterConstraints.empty();
		}
		FilterConstraints constraints = FilterConstraints.empty();
		for (ValueExpr expr : filters) {
			constraints = constraints.and(extractFilterConstraints(expr));
			if (constraints.isEmpty()) {
				return constraints;
			}
		}
		return constraints;
	}

	private FilterConstraints extractFilterConstraints(ValueExpr expr) {
		if (expr instanceof Compare) {
			return compareConstraints((Compare) expr);
		}
		if (expr instanceof SameTerm) {
			SameTerm sameTerm = (SameTerm) expr;
			return equalityConstraints(sameTerm.getLeftArg(), sameTerm.getRightArg());
		}
		if (expr instanceof And) {
			And and = (And) expr;
			return extractFilterConstraints(and.getLeftArg()).and(extractFilterConstraints(and.getRightArg()));
		}
		if (expr instanceof Or) {
			Or or = (Or) expr;
			return extractFilterConstraints(or.getLeftArg()).or(extractFilterConstraints(or.getRightArg()));
		}
		return FilterConstraints.empty();
	}

	private FilterConstraints compareConstraints(Compare compare) {
		if (compare.getOperator() != CompareOp.EQ) {
			return FilterConstraints.empty();
		}
		return equalityConstraints(compare.getLeftArg(), compare.getRightArg());
	}

	private FilterConstraints equalityConstraints(ValueExpr left, ValueExpr right) {
		Value leftValue = constantValue(left);
		Value rightValue = constantValue(right);
		Var leftVar = unboundVar(left);
		Var rightVar = unboundVar(right);
		if (leftValue != null && rightVar != null) {
			return FilterConstraints.of(rightVar.getName(), leftValue);
		}
		if (rightValue != null && leftVar != null) {
			return FilterConstraints.of(leftVar.getName(), rightValue);
		}
		return FilterConstraints.empty();
	}

	private Value constantValue(ValueExpr expr) {
		if (expr instanceof ValueConstant) {
			return ((ValueConstant) expr).getValue();
		}
		if (expr instanceof Var) {
			Var var = (Var) expr;
			return var.hasValue() ? var.getValue() : null;
		}
		return null;
	}

	private Var unboundVar(ValueExpr expr) {
		if (!(expr instanceof Var)) {
			return null;
		}
		Var var = (Var) expr;
		if (var.hasValue()) {
			return null;
		}
		String name = var.getName();
		return name == null || name.startsWith("_const_") ? null : var;
	}

	private double applyFilterMultiplier(double estimate, FilterApplication filterApplication,
			StatementPattern pattern) {
		if (filterApplication.multiplier <= 1.0d) {
			return estimate;
		}
		double unfiltered = fallbackStats.getCardinality(pattern);
		double adjusted = estimate * filterApplication.multiplier;
		if (unfiltered > 0.0d && adjusted > unfiltered) {
			return unfiltered;
		}
		return adjusted;
	}

	private StatementPattern applyBoundVars(StatementPattern pattern, Set<String> boundVars) {
		if (boundVars.isEmpty()) {
			return pattern;
		}
		if (!needsBinding(pattern.getSubjectVar(), boundVars)
				&& !needsBinding(pattern.getPredicateVar(), boundVars)
				&& !needsBinding(pattern.getObjectVar(), boundVars)
				&& !needsBinding(pattern.getContextVar(), boundVars)) {
			return pattern;
		}
		Var subject = boundVar(pattern.getSubjectVar(), boundVars);
		Var predicate = boundVar(pattern.getPredicateVar(), boundVars);
		Var object = boundVar(pattern.getObjectVar(), boundVars);
		Var context = boundVar(pattern.getContextVar(), boundVars);
		return new StatementPattern(pattern.getScope(), subject, predicate, object, context);
	}

	private boolean needsBinding(Var var, Set<String> boundVars) {
		if (var == null || var.hasValue()) {
			return false;
		}
		String name = var.getName();
		return name != null && boundVars.contains(name);
	}

	private Var boundVar(Var var, Set<String> boundVars) {
		if (var == null) {
			return null;
		}
		Var clone = var.clone();
		if (!needsBinding(clone, boundVars)) {
			return clone;
		}
		Var bound = Var.of(clone.getName(), BOUND_VALUE, clone.isAnonymous(), clone.isConstant());
		bound.setVariableScopeChange(clone.isVariableScopeChange());
		return bound;
	}

	private static final class PatternContext {
		private final StatementPattern pattern;
		private final List<Filter> filters;

		private PatternContext(StatementPattern pattern, List<Filter> filters) {
			this.pattern = pattern;
			this.filters = filters;
		}
	}

	private static final class FilterApplication {
		private final Set<String> boundVars;
		private final double multiplier;

		private FilterApplication(Set<String> boundVars, double multiplier) {
			this.boundVars = boundVars;
			this.multiplier = multiplier;
		}
	}

	private static final class FilterConstraints {
		private static final FilterConstraints EMPTY = new FilterConstraints(Map.of());

		private final Map<String, Set<Value>> bindings;

		private FilterConstraints(Map<String, Set<Value>> bindings) {
			this.bindings = bindings;
		}

		private static FilterConstraints empty() {
			return EMPTY;
		}

		private static FilterConstraints of(String name, Value value) {
			if (name == null || value == null) {
				return EMPTY;
			}
			Map<String, Set<Value>> map = new HashMap<>();
			Set<Value> values = new HashSet<>();
			values.add(value);
			map.put(name, values);
			return new FilterConstraints(map);
		}

		private boolean isEmpty() {
			return bindings.isEmpty();
		}

		private FilterConstraints and(FilterConstraints other) {
			if (this.isEmpty()) {
				return other;
			}
			if (other.isEmpty()) {
				return this;
			}
			Map<String, Set<Value>> merged = new HashMap<>();
			Set<String> names = new HashSet<>(bindings.keySet());
			names.addAll(other.bindings.keySet());
			for (String name : names) {
				Set<Value> left = bindings.get(name);
				Set<Value> right = other.bindings.get(name);
				if (left != null && right != null) {
					Set<Value> intersection = new HashSet<>(left);
					intersection.retainAll(right);
					if (intersection.isEmpty()) {
						return EMPTY;
					}
					merged.put(name, intersection);
				} else if (left != null) {
					merged.put(name, left);
				} else if (right != null) {
					merged.put(name, right);
				}
			}
			return new FilterConstraints(merged);
		}

		private FilterConstraints or(FilterConstraints other) {
			if (this.isEmpty() || other.isEmpty()) {
				return EMPTY;
			}
			if (!bindings.keySet().equals(other.bindings.keySet())) {
				return EMPTY;
			}
			Map<String, Set<Value>> merged = new HashMap<>();
			for (Map.Entry<String, Set<Value>> entry : bindings.entrySet()) {
				Set<Value> values = new HashSet<>(entry.getValue());
				values.addAll(other.bindings.get(entry.getKey()));
				merged.put(entry.getKey(), values);
			}
			return new FilterConstraints(merged);
		}
	}
}
