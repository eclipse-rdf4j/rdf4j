/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned;

import java.util.Objects;
import java.util.Set;

import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.query.algebra.Extension;
import org.eclipse.rdf4j.query.algebra.Filter;
import org.eclipse.rdf4j.query.algebra.Reduced;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.UnaryTupleOperator;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.JoinStatsProvider;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.PatternKey;

/**
 * Cost model based on learned join statistics with an EvaluationStatistics fallback.
 */
public class LearnedBindJoinCostModel implements BindJoinCostModel {

	private static final long DEFAULT_PRIOR_CALLS = 2;
	private static final IRI BOUND_VALUE = SimpleValueFactory.getInstance().createIRI("urn:bound");

	private final EvaluationStatistics fallbackStats;
	private final JoinStatsProvider learnedStats;

	public LearnedBindJoinCostModel(EvaluationStatistics fallbackStats, JoinStatsProvider learnedStats) {
		this.fallbackStats = Objects.requireNonNull(fallbackStats, "fallbackStats");
		this.learnedStats = Objects.requireNonNull(learnedStats, "learnedStats");
	}

	@Override
	public double estimateFanout(TupleExpr expr, Set<String> boundVars) {
		StatementPattern pattern = unwrapToStatementPattern(expr);
		if (pattern == null) {
			return fallbackStats.getCardinality(expr);
		}
		return estimatePattern(pattern, boundVars);
	}

	@Override
	public double estimateScanCardinality(TupleExpr expr, Set<String> initiallyBoundVars) {
		StatementPattern pattern = unwrapToStatementPattern(expr);
		if (pattern == null) {
			return fallbackStats.getCardinality(expr);
		}
		return estimatePattern(pattern, initiallyBoundVars);
	}

	@Override
	public Set<String> bindingNames(TupleExpr expr) {
		return expr.getBindingNames();
	}

	private double estimatePattern(StatementPattern pattern, Set<String> boundVars) {
		PatternKey key = buildKey(pattern, boundVars);
		StatementPattern boundPattern = applyBoundVars(pattern, boundVars);
		double defaultEstimate = fallbackStats.getCardinality(boundPattern);
		if (!learnedStats.hasStats(key)) {
			return defaultEstimate;
		}
		learnedStats.seedIfAbsent(key, defaultEstimate, DEFAULT_PRIOR_CALLS);
		double estimate = learnedStats.getAverageResults(key);
		return estimate > 0.0d ? estimate : defaultEstimate;
	}

	private PatternKey buildKey(StatementPattern node, Set<String> boundVars) {
		int mask = 0;
		if (isBound(node.getSubjectVar(), boundVars)) {
			mask |= PatternKey.SUBJECT_BOUND;
		}
		if (isBound(node.getPredicateVar(), boundVars)) {
			mask |= PatternKey.PREDICATE_BOUND;
		}
		if (isBound(node.getObjectVar(), boundVars)) {
			mask |= PatternKey.OBJECT_BOUND;
		}
		Var predVar = node.getPredicateVar();
		IRI predicateKey = null;
		if (predVar != null && predVar.hasValue() && predVar.getValue() instanceof IRI) {
			predicateKey = (IRI) predVar.getValue();
		}
		return new PatternKey(predicateKey, mask);
	}

	private boolean isBound(Var var, Set<String> boundVars) {
		if (var == null) {
			return false;
		}
		if (var.hasValue()) {
			return true;
		}
		String name = var.getName();
		return name != null && boundVars.contains(name);
	}

	private StatementPattern unwrapToStatementPattern(TupleExpr expr) {
		TupleExpr current = expr;
		while (current instanceof Filter || current instanceof Extension || current instanceof Reduced) {
			current = ((UnaryTupleOperator) current).getArg();
		}
		return current instanceof StatementPattern ? (StatementPattern) current : null;
	}

	private StatementPattern applyBoundVars(StatementPattern pattern, Set<String> boundVars) {
		if (boundVars.isEmpty()) {
			return pattern;
		}
		if (!needsBinding(pattern.getSubjectVar(), boundVars)
				&& !needsBinding(pattern.getPredicateVar(), boundVars)
				&& !needsBinding(pattern.getObjectVar(), boundVars)
				&& !needsBinding(pattern.getContextVar(), boundVars)) {
			return pattern;
		}
		Var subject = boundVar(pattern.getSubjectVar(), boundVars);
		Var predicate = boundVar(pattern.getPredicateVar(), boundVars);
		Var object = boundVar(pattern.getObjectVar(), boundVars);
		Var context = boundVar(pattern.getContextVar(), boundVars);
		return new StatementPattern(pattern.getScope(), subject, predicate, object, context);
	}

	private boolean needsBinding(Var var, Set<String> boundVars) {
		if (var == null || var.hasValue()) {
			return false;
		}
		String name = var.getName();
		return name != null && boundVars.contains(name);
	}

	private Var boundVar(Var var, Set<String> boundVars) {
		if (var == null) {
			return null;
		}
		Var clone = var.clone();
		if (!needsBinding(clone, boundVars)) {
			return clone;
		}
		Var bound = Var.of(clone.getName(), BOUND_VALUE, clone.isAnonymous(), clone.isConstant());
		bound.setVariableScopeChange(clone.isVariableScopeChange());
		return bound;
	}
}
