/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Literal;
import org.eclipse.rdf4j.model.Value;
import org.eclipse.rdf4j.model.datatypes.XMLDatatypeUtil;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.model.vocabulary.RDF;
import org.eclipse.rdf4j.query.algebra.And;
import org.eclipse.rdf4j.query.algebra.Compare;
import org.eclipse.rdf4j.query.algebra.Compare.CompareOp;
import org.eclipse.rdf4j.query.algebra.Extension;
import org.eclipse.rdf4j.query.algebra.Filter;
import org.eclipse.rdf4j.query.algebra.ListMemberOperator;
import org.eclipse.rdf4j.query.algebra.Or;
import org.eclipse.rdf4j.query.algebra.Reduced;
import org.eclipse.rdf4j.query.algebra.SameTerm;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.UnaryTupleOperator;
import org.eclipse.rdf4j.query.algebra.ValueConstant;
import org.eclipse.rdf4j.query.algebra.ValueExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.JoinStatsProvider;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.PatternKey;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.PatternKeys;
import org.eclipse.rdf4j.query.algebra.helpers.TupleExprs;
import org.eclipse.rdf4j.query.algebra.helpers.collectors.VarNameCollector;

/**
 * Cost model based on learned join statistics with an EvaluationStatistics fallback.
 */
public class LearnedBindJoinCostModel implements BindJoinCostModel {

	private static final long DEFAULT_PRIOR_CALLS = 2;
	private static final double FILTER_EXISTS_UNBOUND_PENALTY = 1.0e9d;
	private static final double GENERIC_BOUND_CAP_MULTIPLIER = 10.0d;
	private static final double FILTER_VALUE_CARDINALITY = 40.0d;
	private static final double MIN_FILTER_MULTIPLIER = 0.05d;
	private static final IRI BOUND_VALUE = SimpleValueFactory.getInstance().createIRI("urn:bound");
	private static final EvaluationStatistics GENERIC_STATS = new EvaluationStatistics();

	private final EvaluationStatistics fallbackStats;
	private final JoinStatsProvider learnedStats;
	private final FilterConstraints externalConstraints;
	private final Set<String> typeSubjectNames;

	public LearnedBindJoinCostModel(EvaluationStatistics fallbackStats, JoinStatsProvider learnedStats) {
		this(fallbackStats, learnedStats, List.of());
	}

	public LearnedBindJoinCostModel(EvaluationStatistics fallbackStats, JoinStatsProvider learnedStats,
			List<ValueExpr> externalFilters) {
		this(fallbackStats, learnedStats, externalFilters, List.of());
	}

	public LearnedBindJoinCostModel(EvaluationStatistics fallbackStats, JoinStatsProvider learnedStats,
			List<ValueExpr> externalFilters, List<StatementPattern> contextPatterns) {
		this.fallbackStats = Objects.requireNonNull(fallbackStats, "fallbackStats");
		this.learnedStats = Objects.requireNonNull(learnedStats, "learnedStats");
		this.typeSubjectNames = collectTypeSubjects(contextPatterns);
		FilterConstraints constraints = collectExternalConstraints(externalFilters);
		constraints = constraints.and(derivePatternConstraints(contextPatterns, constraints));
		this.externalConstraints = constraints;
	}

	@Override
	public double estimateFanout(TupleExpr expr, Set<String> boundVars) {
		if (TupleExprs.isFilterExistsFunction(expr)) {
			return estimateFilterExistsCardinality((Filter) expr, boundVars);
		}
		PatternContext context = unwrapPattern(expr);
		if (context == null) {
			return fallbackStats.getCardinality(expr);
		}
		return estimatePattern(context, boundVars);
	}

	@Override
	public double estimateScanCardinality(TupleExpr expr, Set<String> initiallyBoundVars) {
		if (TupleExprs.isFilterExistsFunction(expr)) {
			return estimateFilterExistsCardinality((Filter) expr, initiallyBoundVars);
		}
		PatternContext context = unwrapPattern(expr);
		if (context == null) {
			return fallbackStats.getCardinality(expr);
		}
		return estimateScanPattern(context, initiallyBoundVars);
	}

	private double estimateScanPattern(PatternContext context, Set<String> boundVars) {
		FilterApplication filterApplication = applyScanConstraints(context, boundVars);
		StatementPattern pattern = context.pattern;
		Set<String> effectiveBoundVars = filterApplication.boundVars;
		StatementPattern boundPattern = applyBoundVars(pattern, effectiveBoundVars);
		double defaultEstimate = fallbackStats.getCardinality(boundPattern);
		if (usesPlaceholder(boundPattern)) {
			defaultEstimate = fallbackEstimateForBoundPlaceholder(pattern, boundPattern, defaultEstimate);
		}
		PatternKey key = buildKey(pattern, effectiveBoundVars);
		if (!learnedStats.hasStats(key)) {
			double estimate = defaultEstimate > 0.0d ? defaultEstimate : 1.0d;
			double filtered = applyFilterMultiplier(estimate, filterApplication, pattern);
			return applyFilterFallbackCap(filtered, context);
		}
		learnedStats.seedIfAbsent(key, defaultEstimate, DEFAULT_PRIOR_CALLS);
		double average = learnedStats.getAverageResults(key);
		double estimate = average > 0.0d ? average : defaultEstimate;
		double max = learnedStats.getMaxResults(key);
		if (max > estimate && estimate > 0.0d) {
			double skewed = Math.sqrt(estimate * max);
			if (skewed > estimate) {
				estimate = skewed;
			}
		}
		double adjusted = estimate > 0.0d ? estimate : defaultEstimate;
		double filtered = applyFilterMultiplier(adjusted, filterApplication, pattern);
		filtered = capFilteredToFallback(filtered, defaultEstimate, filterApplication, pattern);
		return applyFilterFallbackCap(filtered, context);
	}

	@Override
	public Set<String> bindingNames(TupleExpr expr) {
		return expr.getBindingNames();
	}

	private double estimatePattern(PatternContext context, Set<String> boundVars) {
		FilterApplication filterApplication = applyFilterConstraints(context, boundVars);
		StatementPattern pattern = context.pattern;
		Set<String> effectiveBoundVars = filterApplication.boundVars;
		PatternKey key = buildKey(pattern, effectiveBoundVars);
		StatementPattern boundPattern = applyBoundVars(pattern, effectiveBoundVars);
		double defaultEstimate = fallbackStats.getCardinality(boundPattern);
		if (usesPlaceholder(boundPattern)) {
			defaultEstimate = fallbackEstimateForBoundPlaceholder(pattern, boundPattern, defaultEstimate);
		}
		if (!learnedStats.hasStats(key)) {
			double estimate = applyFilterMultiplier(defaultEstimate, filterApplication, pattern);
			return applyFilterFallbackCap(estimate, context);
		}
		learnedStats.seedIfAbsent(key, defaultEstimate, DEFAULT_PRIOR_CALLS);
		double average = learnedStats.getAverageResults(key);
		double estimate = average > 0.0d ? average : defaultEstimate;
		double max = learnedStats.getMaxResults(key);
		if (max > estimate && estimate > 0.0d) {
			double skewed = Math.sqrt(estimate * max);
			if (skewed > estimate) {
				estimate = skewed;
			}
		}
		double adjusted = estimate > 0.0d ? estimate : defaultEstimate;
		double filtered = applyFilterMultiplier(adjusted, filterApplication, pattern);
		filtered = capFilteredToFallback(filtered, defaultEstimate, filterApplication, pattern);
		return applyFilterFallbackCap(filtered, context);
	}

	private double capFilteredToFallback(double filteredEstimate, double defaultEstimate,
			FilterApplication filterApplication, StatementPattern pattern) {
		if (filterApplication.multiplier >= 1.0d) {
			return filteredEstimate;
		}
		if (defaultEstimate <= 0.0d) {
			return filteredEstimate;
		}
		double filteredDefault = applyFilterMultiplier(defaultEstimate, filterApplication, pattern);
		if (filteredDefault > 0.0d && filteredEstimate > filteredDefault) {
			return filteredDefault;
		}
		return filteredEstimate;
	}

	private double estimateFilterExistsCardinality(Filter filter, Set<String> boundVars) {
		double estimate = fallbackStats.getCardinality(filter);
		if (estimate <= 0.0d) {
			estimate = 1.0d;
		}
		Set<String> correlated = correlatedFilterVars(filter);
		if (!correlated.isEmpty() && !boundVars.containsAll(correlated)) {
			estimate *= FILTER_EXISTS_UNBOUND_PENALTY;
		}
		return estimate;
	}

	private Set<String> correlatedFilterVars(Filter filter) {
		Set<String> filterVars = VarNameCollector.process(filter.getCondition());
		if (filterVars.isEmpty()) {
			return filterVars;
		}
		Set<String> bindings = filter.getBindingNames();
		if (bindings.isEmpty()) {
			return Set.of();
		}
		Set<String> correlated = new HashSet<>(filterVars);
		correlated.retainAll(bindings);
		return correlated.isEmpty() ? Set.of() : correlated;
	}

	private double fallbackEstimateForBoundPlaceholder(StatementPattern pattern, StatementPattern boundPattern,
			double fallbackEstimate) {
		double unboundEstimate = fallbackStats.getCardinality(pattern);
		double genericUnbound = GENERIC_STATS.getCardinality(pattern);
		double genericBound = GENERIC_STATS.getCardinality(boundPattern);
		double candidate = fallbackEstimate;
		if (unboundEstimate > 0.0d && genericUnbound > 0.0d && genericBound > 0.0d) {
			double scaled = unboundEstimate * (genericBound / genericUnbound);
			if (scaled > 0.0d) {
				candidate = scaled;
			}
		} else if (fallbackEstimate <= 0.0d) {
			if (genericBound > 0.0d) {
				candidate = genericBound;
			} else if (unboundEstimate > 0.0d) {
				candidate = unboundEstimate;
			} else {
				candidate = 1.0d;
			}
		}
		if (fallbackEstimate > 0.0d && fallbackEstimate < candidate) {
			candidate = fallbackEstimate;
		}
		if (unboundEstimate > 0.0d) {
			boolean fallbackIgnoresBindings = fallbackEstimate <= 0.0d
					|| (fallbackEstimate > 0.0d && fallbackEstimate >= unboundEstimate * 0.95d);
			if (fallbackIgnoresBindings) {
				double cap = Math.sqrt(unboundEstimate);
				if (genericBound > 0.0d) {
					double genericCap = genericBound;
					if (countUnboundVars(boundPattern) > 1) {
						genericCap *= GENERIC_BOUND_CAP_MULTIPLIER;
					}
					if (genericCap > 0.0d && genericCap < cap) {
						cap = genericCap;
					}
				}
				if (cap > 0.0d && candidate > cap) {
					candidate = cap;
				}
			}
		}
		if (isFullyBound(boundPattern)) {
			candidate = Math.min(candidate, 1.0d);
		}
		return candidate > 0.0d ? candidate : 1.0d;
	}

	private boolean isFullyBound(StatementPattern pattern) {
		return hasValue(pattern.getSubjectVar())
				&& hasValue(pattern.getPredicateVar())
				&& hasValue(pattern.getObjectVar())
				&& (pattern.getContextVar() == null || pattern.getContextVar().hasValue());
	}

	private boolean hasValue(Var var) {
		return var != null && var.hasValue();
	}

	private int countUnboundVars(StatementPattern pattern) {
		int count = 0;
		if (isUnbound(pattern.getSubjectVar())) {
			count++;
		}
		if (isUnbound(pattern.getPredicateVar())) {
			count++;
		}
		if (isUnbound(pattern.getObjectVar())) {
			count++;
		}
		Var context = pattern.getContextVar();
		if (context != null && isUnbound(context)) {
			count++;
		}
		return count;
	}

	private boolean isUnbound(Var var) {
		return var != null && !var.hasValue();
	}

	private boolean usesPlaceholder(StatementPattern pattern) {
		return isPlaceholder(pattern.getSubjectVar())
				|| isPlaceholder(pattern.getPredicateVar())
				|| isPlaceholder(pattern.getObjectVar())
				|| isPlaceholder(pattern.getContextVar());
	}

	private boolean isPlaceholder(Var var) {
		return var != null && BOUND_VALUE.equals(var.getValue());
	}

	private double applyFilterFallbackCap(double estimate, PatternContext context) {
		if (context.filters.isEmpty()) {
			return estimate;
		}
		Set<String> patternNames = context.pattern.getBindingNames();
		if (patternNames.isEmpty()) {
			return estimate;
		}
		double capped = estimate;
		for (Filter filter : context.filters) {
			Set<String> filterVars = VarNameCollector.process(filter.getCondition());
			if (filterVars.isEmpty()) {
				continue;
			}
			boolean intersects = false;
			for (String name : filterVars) {
				if (patternNames.contains(name)) {
					intersects = true;
					break;
				}
			}
			if (!intersects) {
				continue;
			}
			double filterEstimate = fallbackStats.getCardinality(filter);
			if (filterEstimate > 0.0d && filterEstimate < capped) {
				capped = filterEstimate;
			}
		}
		return capped;
	}

	private PatternKey buildKey(StatementPattern node, Set<String> boundVars) {
		int mask = 0;
		if (isBound(node.getSubjectVar(), boundVars)) {
			mask |= PatternKey.SUBJECT_BOUND;
		}
		if (isBound(node.getPredicateVar(), boundVars)) {
			mask |= PatternKey.PREDICATE_BOUND;
		}
		if (isBound(node.getObjectVar(), boundVars)) {
			mask |= PatternKey.OBJECT_BOUND;
		}
		Var predVar = node.getPredicateVar();
		IRI predicateKey = null;
		if (predVar != null && predVar.hasValue() && predVar.getValue() instanceof IRI) {
			predicateKey = (IRI) predVar.getValue();
		}
		Var objVar = node.getObjectVar();
		Value objectValue = objVar != null && objVar.hasValue() ? objVar.getValue() : null;
		IRI statsPredicate = PatternKeys.predicateKey(predicateKey, objectValue);
		return new PatternKey(statsPredicate, mask);
	}

	private boolean isBound(Var var, Set<String> boundVars) {
		if (var == null) {
			return false;
		}
		if (var.hasValue()) {
			return true;
		}
		String name = var.getName();
		return name != null && boundVars.contains(name);
	}

	private PatternContext unwrapPattern(TupleExpr expr) {
		TupleExpr current = expr;
		List<Filter> filters = List.of();
		while (true) {
			if (current instanceof Filter) {
				Filter filter = (Filter) current;
				if (filters.isEmpty()) {
					filters = List.of(filter);
				} else {
					if (filters.size() == 1) {
						filters = new java.util.ArrayList<>(filters);
					}
					filters.add(filter);
				}
				current = filter.getArg();
				continue;
			}
			if (current instanceof Extension || current instanceof Reduced) {
				current = ((UnaryTupleOperator) current).getArg();
				continue;
			}
			break;
		}
		if (!(current instanceof StatementPattern)) {
			return null;
		}
		return new PatternContext((StatementPattern) current, filters);
	}

	private FilterApplication applyFilterConstraints(PatternContext context, Set<String> boundVars) {
		FilterConstraints constraints = externalConstraints;
		for (Filter filter : context.filters) {
			constraints = constraints.and(extractFilterConstraints(filter.getCondition()));
		}
		if (constraints.isEmpty()) {
			return new FilterApplication(new HashSet<>(boundVars), 1.0d);
		}
		Set<String> effectiveBound = new HashSet<>(boundVars);
		Set<String> patternNames = context.pattern.getBindingNames();
		double multiplier = 1.0d;
		for (Map.Entry<String, Set<Value>> entry : constraints.bindings.entrySet()) {
			String name = entry.getKey();
			if (!patternNames.contains(name)) {
				continue;
			}
			Set<Value> values = entry.getValue();
			if (values != null && !values.isEmpty() && !boundVars.contains(name)) {
				double ratio = values.size() / FILTER_VALUE_CARDINALITY;
				double selectivity = Math.min(1.0d, Math.max(MIN_FILTER_MULTIPLIER, ratio));
				if (selectivity < multiplier) {
					multiplier = selectivity;
				}
			}
		}
		for (String name : constraints.constrained) {
			if (!patternNames.contains(name)) {
				continue;
			}
			if (!boundVars.contains(name) && MIN_FILTER_MULTIPLIER < multiplier) {
				multiplier = MIN_FILTER_MULTIPLIER;
			}
		}
		return new FilterApplication(effectiveBound, multiplier);
	}

	private FilterApplication applyScanConstraints(PatternContext context, Set<String> boundVars) {
		FilterConstraints constraints = externalConstraints;
		for (Filter filter : context.filters) {
			constraints = constraints.and(extractFilterConstraints(filter.getCondition()));
		}
		if (constraints.isEmpty() || constraints.bindings.isEmpty()) {
			return new FilterApplication(new HashSet<>(boundVars), 1.0d);
		}
		Set<String> effectiveBound = new HashSet<>(boundVars);
		Set<String> patternNames = context.pattern.getBindingNames();
		double multiplier = 1.0d;
		for (Map.Entry<String, Set<Value>> entry : constraints.bindings.entrySet()) {
			String name = entry.getKey();
			if (!patternNames.contains(name)) {
				continue;
			}
			Set<Value> values = entry.getValue();
			if (values != null && !values.isEmpty() && !boundVars.contains(name)) {
				double ratio = values.size() / FILTER_VALUE_CARDINALITY;
				double selectivity = Math.min(1.0d, Math.max(MIN_FILTER_MULTIPLIER, ratio));
				if (selectivity < multiplier) {
					multiplier = selectivity;
				}
			}
		}
		return new FilterApplication(effectiveBound, multiplier);
	}

	private FilterConstraints derivePatternConstraints(List<StatementPattern> patterns, FilterConstraints constraints) {
		if (patterns == null || patterns.isEmpty() || constraints.isEmpty()) {
			return FilterConstraints.empty();
		}
		if (constraints.bindings.isEmpty()) {
			return FilterConstraints.empty();
		}
		Set<String> constrainedNames = constraints.bindings.keySet();
		Set<String> derived = new HashSet<>();
		for (StatementPattern pattern : patterns) {
			Var object = pattern.getObjectVar();
			if (object == null || object.hasValue()) {
				continue;
			}
			String objectName = object.getName();
			if (objectName == null || !constrainedNames.contains(objectName)) {
				continue;
			}
			Var subject = pattern.getSubjectVar();
			if (subject == null || subject.hasValue()) {
				continue;
			}
			String subjectName = subject.getName();
			if (subjectName != null && typeSubjectNames.contains(subjectName)) {
				Set<Value> values = constraints.bindings.get(objectName);
				if (isNonNumericLiteralConstraint(values)) {
					continue;
				}
			}
			if (subjectName != null && !subjectName.startsWith("_const_")) {
				derived.add(subjectName);
			}
		}
		return derived.isEmpty() ? FilterConstraints.empty() : FilterConstraints.constrained(derived);
	}

	private FilterConstraints collectExternalConstraints(List<ValueExpr> filters) {
		if (filters == null || filters.isEmpty()) {
			return FilterConstraints.empty();
		}
		FilterConstraints constraints = FilterConstraints.empty();
		for (ValueExpr expr : filters) {
			constraints = constraints.and(extractFilterConstraints(expr));
		}
		return constraints;
	}

	private FilterConstraints extractFilterConstraints(ValueExpr expr) {
		if (expr instanceof Compare) {
			return compareConstraints((Compare) expr);
		}
		if (expr instanceof ListMemberOperator) {
			return listMemberConstraints((ListMemberOperator) expr);
		}
		if (expr instanceof SameTerm) {
			SameTerm sameTerm = (SameTerm) expr;
			return equalityConstraints(sameTerm.getLeftArg(), sameTerm.getRightArg());
		}
		if (expr instanceof And) {
			And and = (And) expr;
			return extractFilterConstraints(and.getLeftArg()).and(extractFilterConstraints(and.getRightArg()));
		}
		if (expr instanceof Or) {
			Or or = (Or) expr;
			return extractFilterConstraints(or.getLeftArg()).or(extractFilterConstraints(or.getRightArg()));
		}
		return FilterConstraints.empty();
	}

	private FilterConstraints listMemberConstraints(ListMemberOperator operator) {
		List<ValueExpr> args = operator.getArguments();
		if (args == null || args.size() < 2) {
			return FilterConstraints.empty();
		}
		ValueExpr target = args.get(0);
		if (!(target instanceof Var)) {
			return FilterConstraints.empty();
		}
		String name = ((Var) target).getName();
		if (name == null) {
			return FilterConstraints.empty();
		}
		Set<Value> values = new HashSet<>();
		for (int i = 1; i < args.size(); i++) {
			ValueExpr candidate = args.get(i);
			if (candidate instanceof ValueConstant) {
				values.add(((ValueConstant) candidate).getValue());
			} else if (candidate instanceof Var) {
				Var var = (Var) candidate;
				if (var.hasValue()) {
					values.add(var.getValue());
				}
			}
		}
		if (!areNumericValues(values)) {
			return FilterConstraints.empty();
		}
		return FilterConstraints.ofValues(name, values);
	}

	private boolean areNumericValues(Set<Value> values) {
		if (values.isEmpty()) {
			return false;
		}
		for (Value value : values) {
			if (!(value instanceof Literal)) {
				return false;
			}
			Literal literal = (Literal) value;
			IRI datatype = literal.getDatatype();
			if (datatype == null || !XMLDatatypeUtil.isNumericDatatype(datatype)) {
				return false;
			}
		}
		return true;
	}

	private boolean isNonNumericLiteralConstraint(Set<Value> values) {
		if (values == null || values.isEmpty()) {
			return false;
		}
		for (Value value : values) {
			if (!(value instanceof Literal)) {
				return false;
			}
			Literal literal = (Literal) value;
			IRI datatype = literal.getDatatype();
			if (datatype != null && XMLDatatypeUtil.isNumericDatatype(datatype)) {
				return false;
			}
		}
		return true;
	}

	private Set<String> collectTypeSubjects(List<StatementPattern> patterns) {
		if (patterns == null || patterns.isEmpty()) {
			return Set.of();
		}
		Set<String> subjects = new HashSet<>();
		for (StatementPattern pattern : patterns) {
			Var predicate = pattern.getPredicateVar();
			if (predicate == null || !predicate.hasValue() || !(predicate.getValue() instanceof IRI)) {
				continue;
			}
			if (!RDF.TYPE.equals(predicate.getValue())) {
				continue;
			}
			Var subject = pattern.getSubjectVar();
			if (subject == null || subject.hasValue()) {
				continue;
			}
			String name = subject.getName();
			if (name != null && !name.startsWith("_const_")) {
				subjects.add(name);
			}
		}
		return subjects.isEmpty() ? Set.of() : subjects;
	}

	private FilterConstraints compareConstraints(Compare compare) {
		if (compare.getOperator() != CompareOp.EQ) {
			return FilterConstraints.empty();
		}
		return equalityConstraints(compare.getLeftArg(), compare.getRightArg());
	}

	private FilterConstraints equalityConstraints(ValueExpr left, ValueExpr right) {
		Value leftValue = constantValue(left);
		Value rightValue = constantValue(right);
		Var leftVar = unboundVar(left);
		Var rightVar = unboundVar(right);
		if (leftValue != null && rightVar != null) {
			return FilterConstraints.of(rightVar.getName(), leftValue);
		}
		if (rightValue != null && leftVar != null) {
			return FilterConstraints.of(leftVar.getName(), rightValue);
		}
		if (leftVar != null && rightVar != null) {
			return FilterConstraints.ofVars(leftVar.getName(), rightVar.getName());
		}
		return FilterConstraints.empty();
	}

	private Value constantValue(ValueExpr expr) {
		if (expr instanceof ValueConstant) {
			return ((ValueConstant) expr).getValue();
		}
		if (expr instanceof Var) {
			Var var = (Var) expr;
			return var.hasValue() ? var.getValue() : null;
		}
		return null;
	}

	private Var unboundVar(ValueExpr expr) {
		if (!(expr instanceof Var)) {
			return null;
		}
		Var var = (Var) expr;
		if (var.hasValue()) {
			return null;
		}
		String name = var.getName();
		return name == null || name.startsWith("_const_") ? null : var;
	}

	private double applyFilterMultiplier(double estimate, FilterApplication filterApplication,
			StatementPattern pattern) {
		if (filterApplication.multiplier == 1.0d) {
			return estimate;
		}
		double adjusted = estimate * filterApplication.multiplier;
		if (filterApplication.multiplier < 1.0d) {
			return Math.max(1.0d, adjusted);
		}
		double unfiltered = fallbackStats.getCardinality(pattern);
		if (unfiltered > 0.0d && adjusted > unfiltered) {
			return unfiltered;
		}
		return adjusted;
	}

	private StatementPattern applyBoundVars(StatementPattern pattern, Set<String> boundVars) {
		if (boundVars.isEmpty()) {
			return pattern;
		}
		if (!needsBinding(pattern.getSubjectVar(), boundVars)
				&& !needsBinding(pattern.getPredicateVar(), boundVars)
				&& !needsBinding(pattern.getObjectVar(), boundVars)
				&& !needsBinding(pattern.getContextVar(), boundVars)) {
			return pattern;
		}
		Var subject = boundVar(pattern.getSubjectVar(), boundVars);
		Var predicate = boundVar(pattern.getPredicateVar(), boundVars);
		Var object = boundVar(pattern.getObjectVar(), boundVars);
		Var context = boundVar(pattern.getContextVar(), boundVars);
		return new StatementPattern(pattern.getScope(), subject, predicate, object, context);
	}

	private boolean needsBinding(Var var, Set<String> boundVars) {
		if (var == null || var.hasValue()) {
			return false;
		}
		String name = var.getName();
		return name != null && boundVars.contains(name);
	}

	private Var boundVar(Var var, Set<String> boundVars) {
		if (var == null) {
			return null;
		}
		Var clone = var.clone();
		if (!needsBinding(clone, boundVars)) {
			return clone;
		}
		Var bound = Var.of(clone.getName(), BOUND_VALUE, clone.isAnonymous(), clone.isConstant());
		bound.setVariableScopeChange(clone.isVariableScopeChange());
		return bound;
	}

	private static final class PatternContext {
		private final StatementPattern pattern;
		private final List<Filter> filters;

		private PatternContext(StatementPattern pattern, List<Filter> filters) {
			this.pattern = pattern;
			this.filters = filters;
		}
	}

	private static final class FilterApplication {
		private final Set<String> boundVars;
		private final double multiplier;

		private FilterApplication(Set<String> boundVars, double multiplier) {
			this.boundVars = boundVars;
			this.multiplier = multiplier;
		}
	}

	private static final class FilterConstraints {
		private static final FilterConstraints EMPTY = new FilterConstraints(Map.of(), Set.of());

		private final Map<String, Set<Value>> bindings;
		private final Set<String> constrained;

		private FilterConstraints(Map<String, Set<Value>> bindings, Set<String> constrained) {
			this.bindings = bindings;
			this.constrained = constrained;
		}

		private static FilterConstraints empty() {
			return EMPTY;
		}

		private static FilterConstraints of(String name, Value value) {
			if (name == null || value == null) {
				return EMPTY;
			}
			Map<String, Set<Value>> map = new HashMap<>();
			Set<Value> values = new HashSet<>();
			values.add(value);
			map.put(name, values);
			Set<String> constrained = new HashSet<>();
			constrained.add(name);
			return new FilterConstraints(map, constrained);
		}

		private static FilterConstraints ofValues(String name, Set<Value> values) {
			if (name == null || values == null || values.isEmpty()) {
				return EMPTY;
			}
			Map<String, Set<Value>> map = new HashMap<>();
			map.put(name, new HashSet<>(values));
			Set<String> constrained = new HashSet<>();
			constrained.add(name);
			return new FilterConstraints(map, constrained);
		}

		private static FilterConstraints ofVars(String left, String right) {
			if (left == null || right == null) {
				return EMPTY;
			}
			Set<String> constrained = new HashSet<>();
			constrained.add(left);
			constrained.add(right);
			return new FilterConstraints(Map.of(), constrained);
		}

		private static FilterConstraints constrained(Set<String> names) {
			if (names == null || names.isEmpty()) {
				return EMPTY;
			}
			Set<String> constrained = new HashSet<>(names);
			return new FilterConstraints(Map.of(), constrained);
		}

		private Set<String> constrainedNames() {
			if (bindings.isEmpty()) {
				return constrained;
			}
			Set<String> names = new HashSet<>(constrained);
			names.addAll(bindings.keySet());
			return names;
		}

		private boolean isEmpty() {
			return bindings.isEmpty() && constrained.isEmpty();
		}

		private FilterConstraints and(FilterConstraints other) {
			if (this.isEmpty()) {
				return other;
			}
			if (other.isEmpty()) {
				return this;
			}
			Map<String, Set<Value>> merged = new HashMap<>();
			Set<String> mergedConstrained = new HashSet<>(constrained);
			mergedConstrained.addAll(other.constrained);
			Set<String> names = new HashSet<>(bindings.keySet());
			names.addAll(other.bindings.keySet());
			for (String name : names) {
				Set<Value> left = bindings.get(name);
				Set<Value> right = other.bindings.get(name);
				if (left != null && right != null) {
					Set<Value> intersection = new HashSet<>(left);
					intersection.retainAll(right);
					if (intersection.isEmpty()) {
						return EMPTY;
					}
					merged.put(name, intersection);
				} else if (left != null) {
					merged.put(name, left);
				} else if (right != null) {
					merged.put(name, right);
				}
			}
			return new FilterConstraints(merged, mergedConstrained);
		}

		private FilterConstraints or(FilterConstraints other) {
			if (this.isEmpty() || other.isEmpty()) {
				return EMPTY;
			}
			Set<String> common = new HashSet<>(constrained);
			common.retainAll(other.constrained);
			if (common.isEmpty()) {
				return EMPTY;
			}
			Map<String, Set<Value>> merged = new HashMap<>();
			for (String name : common) {
				Set<Value> left = bindings.get(name);
				Set<Value> right = other.bindings.get(name);
				if (left != null && right != null) {
					Set<Value> values = new HashSet<>(left);
					values.addAll(right);
					merged.put(name, values);
				}
			}
			return new FilterConstraints(merged, common);
		}
	}
}
