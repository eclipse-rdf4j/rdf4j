/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import java.util.ArrayDeque;
import java.util.Deque;

import org.eclipse.rdf4j.query.algebra.Order;
import org.eclipse.rdf4j.query.algebra.QueryModelNode;
import org.eclipse.rdf4j.query.algebra.Slice;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractQueryModelVisitor;

final class UnorderedSliceDetector extends AbstractQueryModelVisitor<RuntimeException> {

	private final Deque<Boolean> sliceOrderStack = new ArrayDeque<>();
	private boolean unorderedSliceFound;

	static boolean hasUnorderedSlice(QueryModelNode node) {
		UnorderedSliceDetector detector = new UnorderedSliceDetector();
		node.visit(detector);
		return detector.unorderedSliceFound;
	}

	@Override
	public void meet(Slice node) {
		if (unorderedSliceFound) {
			return;
		}
		if (node.hasLimit() || node.hasOffset()) {
			sliceOrderStack.push(false);
			node.getArg().visit(this);
			boolean ordered = sliceOrderStack.pop();
			if (!ordered) {
				unorderedSliceFound = true;
			}
			return;
		}
		super.meet(node);
	}

	@Override
	public void meet(Order node) {
		if (!sliceOrderStack.isEmpty()) {
			sliceOrderStack.pop();
			sliceOrderStack.push(true);
		}
		if (unorderedSliceFound) {
			return;
		}
		super.meet(node);
	}

	@Override
	protected void meetNode(QueryModelNode node) throws RuntimeException {
		if (unorderedSliceFound) {
			return;
		}
		super.meetNode(node);
	}
}
