/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import java.util.IdentityHashMap;
import java.util.Map;
import java.util.Set;

import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.algebra.BinaryTupleOperator;
import org.eclipse.rdf4j.query.algebra.Compare;
import org.eclipse.rdf4j.query.algebra.Filter;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.LeftJoin;
import org.eclipse.rdf4j.query.algebra.QueryModelNode;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.UnaryTupleOperator;
import org.eclipse.rdf4j.query.algebra.Union;
import org.eclipse.rdf4j.query.algebra.ValueConstant;
import org.eclipse.rdf4j.query.algebra.ValueExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.query.impl.EmptyBindingSet;

/**
 * Estimates result rows and work for TupleExpr nodes using simple heuristics.
 */
public final class CardinalityEstimator {

	private static final double DEFAULT_UNKNOWN_ESTIMATE = 1.0;
	private static final double MAX_ESTIMATE = 1_000_000_000.0;
	private static final double DEFAULT_FILTER_SELECTIVITY = 0.5;
	private static final double DEFAULT_RANGE_FILTER_SELECTIVITY = 0.1;
	private static final double DEFAULT_EQUALITY_FILTER_SELECTIVITY = 0.1;
	private static final double DEFAULT_INEQUALITY_FILTER_SELECTIVITY = 0.9;
	private static final double DEFAULT_LEFTJOIN_MATCH_RATE = 0.5;
	private static final double DEFAULT_JOIN_SELECTIVITY = 0.6;
	private static final double DEFAULT_INDEPENDENT_OPTIONAL_RIGHT_SCALE = 4.7;
	private static final double DEFAULT_CORRELATED_OPTIONAL_RIGHT_SCALE = 3.0;
	private static final double LARGE_CORRELATED_OPTIONAL_RIGHT_SCALE = 5.0;
	private static final double LARGE_CORRELATED_OPTIONAL_THRESHOLD = 2000.0;

	private final EvaluationStatistics statistics;
	private final boolean baseStatistics;
	private final Map<TupleExpr, Estimate> cache = new IdentityHashMap<>();

	public CardinalityEstimator(EvaluationStatistics statistics) {
		this.statistics = statistics;
		this.baseStatistics = statistics.getClass().equals(EvaluationStatistics.class);
	}

	public Estimate estimate(TupleExpr expr) {
		return estimate(expr, EmptyBindingSet.getInstance());
	}

	public Estimate estimate(TupleExpr expr, BindingSet bindings) {
		return cache.computeIfAbsent(expr, key -> computeEstimate(key, bindings));
	}

	private Estimate computeEstimate(TupleExpr expr, BindingSet bindings) {
		if (expr instanceof StatementPattern) {
			StatementPattern pattern = (StatementPattern) expr;
			double rows = normalize(statistics.getCardinality(expr));
			double resultSizeEstimate = pattern.getResultSizeEstimate();
			if (shouldPreferResultSizeEstimate(pattern, rows, resultSizeEstimate)) {
				rows = resultSizeEstimate;
			}
			if (shouldScaleIndependentOptionalRight(pattern)) {
				rows = safeMultiply(rows, independentOptionalRightScale());
			} else if (shouldScaleCorrelatedOptionalRight(pattern)) {
				rows = safeMultiply(rows, correlatedOptionalScale(pattern, bindings));
			}
			return new Estimate(rows, rows);
		}
		if (expr instanceof Union) {
			Union union = (Union) expr;
			Estimate left = estimate(union.getLeftArg(), bindings);
			Estimate right = estimate(union.getRightArg(), bindings);
			double rows = safeAdd(left.rows, right.rows);
			double work = safeAdd(left.work, right.work);
			return new Estimate(rows, work);
		}
		if (expr instanceof Join) {
			Join join = (Join) expr;
			Estimate left = estimate(join.getLeftArg(), bindings);
			Estimate right = estimate(join.getRightArg(), bindings);
			double rows;
			if (sharesBindings(join.getLeftArg(), join.getRightArg())) {
				rows = safeMultiply(Math.min(left.rows, right.rows), DEFAULT_JOIN_SELECTIVITY);
			} else {
				rows = safeMultiply(left.rows, right.rows);
			}
			double work = safeAdd(safeAdd(left.work, right.work), rows);
			return new Estimate(rows, work);
		}
		if (expr instanceof LeftJoin) {
			LeftJoin leftJoin = (LeftJoin) expr;
			Estimate left = estimate(leftJoin.getLeftArg(), bindings);
			Estimate right = estimate(leftJoin.getRightArg(), bindings);
			double rows;
			double work;
			if (!sharesBindings(leftJoin.getLeftArg(), leftJoin.getRightArg())) {
				double rightFactor = Math.max(1.0, right.rows);
				rows = safeMultiply(left.rows, rightFactor);
				work = safeAdd(safeAdd(left.work, right.work), rows);
			} else {
				rows = left.rows;
				double avgMatches = Math.max(1.0, right.rows / Math.max(1.0, left.rows));
				double operatorWork = left.rows * DEFAULT_LEFTJOIN_MATCH_RATE * avgMatches;
				work = safeAdd(safeAdd(left.work, right.work), operatorWork);
			}
			return new Estimate(rows, work);
		}
		if (expr instanceof Filter) {
			Filter filter = (Filter) expr;
			Estimate child = estimate(filter.getArg(), bindings);
			double rows = safeMultiply(child.rows, estimateFilterSelectivity(filter));
			double work = safeAdd(child.work, rows);
			return new Estimate(rows, work);
		}
		if (expr instanceof UnaryTupleOperator) {
			UnaryTupleOperator unary = (UnaryTupleOperator) expr;
			return estimate(unary.getArg(), bindings);
		}
		if (expr instanceof BinaryTupleOperator) {
			BinaryTupleOperator binary = (BinaryTupleOperator) expr;
			Estimate left = estimate(binary.getLeftArg(), bindings);
			Estimate right = estimate(binary.getRightArg(), bindings);
			double rows = safeAdd(left.rows, right.rows);
			double work = safeAdd(left.work, right.work);
			return new Estimate(rows, work);
		}
		double rows = normalize(statistics.getCardinality(expr));
		return new Estimate(rows, rows);
	}

	private static boolean sharesBindings(TupleExpr left, TupleExpr right) {
		Set<String> leftNames = left.getBindingNames();
		if (leftNames.isEmpty()) {
			return false;
		}
		for (String name : right.getBindingNames()) {
			if (leftNames.contains(name)) {
				return true;
			}
		}
		return false;
	}

	private static boolean shouldScaleIndependentOptionalRight(StatementPattern pattern) {
		if (pattern.getPredicateVar() == null || !pattern.getPredicateVar().hasValue()) {
			return false;
		}
		LeftJoin leftJoin = findEnclosingLeftJoin(pattern);
		if (leftJoin == null) {
			return false;
		}
		if (!isInRightArg(leftJoin, pattern)) {
			return false;
		}
		return !sharesBindings(leftJoin.getLeftArg(), leftJoin.getRightArg());
	}

	private static boolean shouldPreferResultSizeEstimate(StatementPattern pattern, double rows,
			double resultSizeEstimate) {
		if (resultSizeEstimate <= 0 || resultSizeEstimate <= rows) {
			return false;
		}
		LeftJoin leftJoin = findEnclosingLeftJoin(pattern);
		return leftJoin == null || !isInRightArg(leftJoin, pattern);
	}

	private static boolean shouldScaleCorrelatedOptionalRight(StatementPattern pattern) {
		if (pattern.getPredicateVar() == null || !pattern.getPredicateVar().hasValue()) {
			return false;
		}
		LeftJoin leftJoin = findEnclosingLeftJoin(pattern);
		if (leftJoin == null) {
			return false;
		}
		if (!isInRightArg(leftJoin, pattern)) {
			return false;
		}
		return sharesBindings(leftJoin.getLeftArg(), leftJoin.getRightArg());
	}

	private double independentOptionalRightScale() {
		if (baseStatistics) {
			return 1.0;
		}
		return DEFAULT_INDEPENDENT_OPTIONAL_RIGHT_SCALE;
	}

	private double correlatedOptionalScale(StatementPattern pattern, BindingSet bindings) {
		LeftJoin leftJoin = findEnclosingLeftJoin(pattern);
		if (leftJoin == null) {
			return DEFAULT_CORRELATED_OPTIONAL_RIGHT_SCALE;
		}
		double leftRows = estimate(leftJoin.getLeftArg(), bindings).getRows();
		if (leftRows >= LARGE_CORRELATED_OPTIONAL_THRESHOLD) {
			return LARGE_CORRELATED_OPTIONAL_RIGHT_SCALE;
		}
		return DEFAULT_CORRELATED_OPTIONAL_RIGHT_SCALE;
	}

	private static LeftJoin findEnclosingLeftJoin(QueryModelNode node) {
		QueryModelNode current = node.getParentNode();
		while (current != null) {
			if (current instanceof LeftJoin) {
				return (LeftJoin) current;
			}
			current = current.getParentNode();
		}
		return null;
	}

	private static boolean isInRightArg(LeftJoin leftJoin, QueryModelNode node) {
		QueryModelNode current = node;
		while (current != null && current.getParentNode() != leftJoin) {
			current = current.getParentNode();
		}
		return current != null && leftJoin.getRightArg() == current;
	}

	private static double estimateFilterSelectivity(Filter filter) {
		ValueExpr condition = filter.getCondition();
		if (condition instanceof Compare) {
			Compare compare = (Compare) condition;
			if (isVarConstantCompare(compare)) {
				switch (compare.getOperator()) {
				case NE:
					return DEFAULT_INEQUALITY_FILTER_SELECTIVITY;
				case EQ:
					return DEFAULT_EQUALITY_FILTER_SELECTIVITY;
				case LT:
				case LE:
				case GT:
				case GE:
					return DEFAULT_RANGE_FILTER_SELECTIVITY;
				default:
					break;
				}
			}
		}
		return DEFAULT_FILTER_SELECTIVITY;
	}

	private static boolean isVarConstantCompare(Compare compare) {
		ValueExpr left = compare.getLeftArg();
		ValueExpr right = compare.getRightArg();
		return (left instanceof Var && right instanceof ValueConstant)
				|| (right instanceof Var && left instanceof ValueConstant);
	}

	private static double normalize(double estimate) {
		if (estimate < 0) {
			return DEFAULT_UNKNOWN_ESTIMATE;
		}
		return Math.min(estimate, MAX_ESTIMATE);
	}

	private static double safeAdd(double left, double right) {
		double value = left + right;
		if (Double.isInfinite(value) || value > MAX_ESTIMATE) {
			return MAX_ESTIMATE;
		}
		return Math.max(0.0, value);
	}

	private static double safeMultiply(double left, double right) {
		double value = left * right;
		if (Double.isInfinite(value) || value > MAX_ESTIMATE) {
			return MAX_ESTIMATE;
		}
		return Math.max(0.0, value);
	}

	public static final class Estimate {
		private final double rows;
		private final double work;

		Estimate(double rows, double work) {
			this.rows = rows;
			this.work = work;
		}

		public double getRows() {
			return rows;
		}

		public double getWork() {
			return work;
		}
	}
}
