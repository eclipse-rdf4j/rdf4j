/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import java.util.HashSet;
import java.util.Set;

import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.And;
import org.eclipse.rdf4j.query.algebra.BinaryValueOperator;
import org.eclipse.rdf4j.query.algebra.Bound;
import org.eclipse.rdf4j.query.algebra.Coalesce;
import org.eclipse.rdf4j.query.algebra.Exists;
import org.eclipse.rdf4j.query.algebra.Filter;
import org.eclipse.rdf4j.query.algebra.FunctionCall;
import org.eclipse.rdf4j.query.algebra.If;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.LeftJoin;
import org.eclipse.rdf4j.query.algebra.NAryValueOperator;
import org.eclipse.rdf4j.query.algebra.Not;
import org.eclipse.rdf4j.query.algebra.Or;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.UnaryValueOperator;
import org.eclipse.rdf4j.query.algebra.ValueConstant;
import org.eclipse.rdf4j.query.algebra.ValueExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryOptimizer;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractSimpleQueryModelVisitor;

/**
 * Rewrites Filter(LeftJoin(...)) into Filter(Join(...)) when the filter condition depends on optional-only variables in
 * a strict way, making the OPTIONAL mandatory.
 */
public class OptionalFilterJoinOptimizer implements QueryOptimizer {

	@Override
	public void optimize(TupleExpr tupleExpr, Dataset dataset, BindingSet bindings) {
		tupleExpr.visit(new OptionalFilterVisitor());
	}

	private static final class OptionalFilterVisitor extends AbstractSimpleQueryModelVisitor<RuntimeException> {
		@Override
		public void meet(Filter filter) {
			super.meet(filter);
			if (!(filter.getArg() instanceof LeftJoin)) {
				return;
			}
			LeftJoin leftJoin = (LeftJoin) filter.getArg();
			if (leftJoin.getCondition() != null) {
				return;
			}
			Set<String> rightOnly = new HashSet<>(leftJoin.getRightArg().getBindingNames());
			rightOnly.removeAll(leftJoin.getLeftArg().getBindingNames());
			if (rightOnly.isEmpty()) {
				return;
			}
			if (!requiresRightVars(filter.getCondition(), rightOnly)) {
				return;
			}
			Join join = new Join(leftJoin.getLeftArg(), leftJoin.getRightArg());
			filter.setArg(join);
		}
	}

	private static boolean requiresRightVars(ValueExpr expr, Set<String> rightOnly) {
		if (expr == null || rightOnly.isEmpty()) {
			return false;
		}
		if (expr instanceof Var) {
			return rightOnly.contains(((Var) expr).getName());
		}
		if (expr instanceof ValueConstant) {
			return false;
		}
		if (expr instanceof Bound) {
			return rightOnly.contains(((Bound) expr).getArg().getName());
		}
		if (expr instanceof If || expr instanceof Coalesce || expr instanceof Exists) {
			return false;
		}
		if (expr instanceof FunctionCall) {
			for (ValueExpr arg : ((FunctionCall) expr).getArgs()) {
				if (requiresRightVars(arg, rightOnly)) {
					return true;
				}
			}
			return false;
		}
		if (expr instanceof Or) {
			Or or = (Or) expr;
			return requiresRightVars(or.getLeftArg(), rightOnly) && requiresRightVars(or.getRightArg(), rightOnly);
		}
		if (expr instanceof And) {
			And and = (And) expr;
			return requiresRightVars(and.getLeftArg(), rightOnly) || requiresRightVars(and.getRightArg(), rightOnly);
		}
		if (expr instanceof Not) {
			ValueExpr arg = ((Not) expr).getArg();
			if (arg instanceof Bound && rightOnly.contains(((Bound) arg).getArg().getName())) {
				return false;
			}
			return requiresRightVars(arg, rightOnly);
		}
		if (expr instanceof UnaryValueOperator) {
			return requiresRightVars(((UnaryValueOperator) expr).getArg(), rightOnly);
		}
		if (expr instanceof BinaryValueOperator) {
			BinaryValueOperator binary = (BinaryValueOperator) expr;
			return requiresRightVars(binary.getLeftArg(), rightOnly)
					|| requiresRightVars(binary.getRightArg(), rightOnly);
		}
		if (expr instanceof NAryValueOperator) {
			for (ValueExpr arg : ((NAryValueOperator) expr).getArguments()) {
				if (requiresRightVars(arg, rightOnly)) {
					return true;
				}
			}
			return false;
		}
		return false;
	}
}
