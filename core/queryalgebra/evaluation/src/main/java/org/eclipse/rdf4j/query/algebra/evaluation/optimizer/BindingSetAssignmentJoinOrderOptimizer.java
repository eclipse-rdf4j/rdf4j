/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import java.util.Set;

import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.BindingSetAssignment;
import org.eclipse.rdf4j.query.algebra.Filter;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryOptimizer;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractSimpleQueryModelVisitor;
import org.eclipse.rdf4j.query.algebra.helpers.collectors.VarNameCollector;

/**
 * Rewrites specific VALUES cross-products so the {@link StatementPattern} is evaluated with both sides bound without
 * materializing an explicit cartesian join between two {@link BindingSetAssignment}s.
 */
public class BindingSetAssignmentJoinOrderOptimizer implements QueryOptimizer {

	@Override
	public void optimize(TupleExpr tupleExpr, Dataset dataset, BindingSet bindings) {
		if (UnorderedSliceDetector.hasUnorderedSlice(tupleExpr)) {
			return;
		}
		tupleExpr.visit(new BindingSetAssignmentJoinOrderVisitor());
	}

	private static final class BindingSetAssignmentJoinOrderVisitor
			extends AbstractSimpleQueryModelVisitor<RuntimeException> {

		@Override
		public void meet(Filter filter) throws RuntimeException {
			super.meet(filter);

			if (!(filter.getArg() instanceof Join)) {
				return;
			}

			Join join = (Join) filter.getArg();
			StatementPattern statementPattern = statementPattern(join);
			if (statementPattern == null) {
				return;
			}

			Join valuesJoin = valuesJoin(join);
			if (valuesJoin == null) {
				return;
			}

			BindingSetAssignment leftValues = (BindingSetAssignment) valuesJoin.getLeftArg();
			BindingSetAssignment rightValues = (BindingSetAssignment) valuesJoin.getRightArg();
			if (!areDisjoint(leftValues.getBindingNames(), rightValues.getBindingNames())) {
				return;
			}

			if (!statementPatternUsesAny(statementPattern, leftValues.getBindingNames())
					|| !statementPatternUsesAny(statementPattern, rightValues.getBindingNames())) {
				return;
			}

			Set<String> filterVars = VarNameCollector.process(filter.getCondition());
			if (!join.getBindingNames().containsAll(filterVars)) {
				return;
			}

			BindingSetAssignment subjectValues = subjectValues(statementPattern, leftValues, rightValues);
			if (subjectValues == null) {
				return;
			}
			BindingSetAssignment objectValues = subjectValues == leftValues ? rightValues : leftValues;

			Filter statementPatternFilter = new Filter(statementPattern.clone(), filter.getCondition().clone());
			Join inner = new Join((TupleExpr) objectValues.clone(), statementPatternFilter);
			Join outer = new Join((TupleExpr) subjectValues.clone(), inner);

			filter.replaceWith(outer);
			outer.visit(this);
		}

		private static StatementPattern statementPattern(Join join) {
			if (join.getLeftArg() instanceof StatementPattern) {
				return (StatementPattern) join.getLeftArg();
			}
			if (join.getRightArg() instanceof StatementPattern) {
				return (StatementPattern) join.getRightArg();
			}
			return null;
		}

		private static Join valuesJoin(Join join) {
			if (join.getLeftArg() instanceof Join) {
				Join candidate = (Join) join.getLeftArg();
				if (candidate.getLeftArg() instanceof BindingSetAssignment
						&& candidate.getRightArg() instanceof BindingSetAssignment) {
					return candidate;
				}
			}
			if (join.getRightArg() instanceof Join) {
				Join candidate = (Join) join.getRightArg();
				if (candidate.getLeftArg() instanceof BindingSetAssignment
						&& candidate.getRightArg() instanceof BindingSetAssignment) {
					return candidate;
				}
			}
			return null;
		}

		private static boolean areDisjoint(Set<String> left, Set<String> right) {
			for (String name : left) {
				if (right.contains(name)) {
					return false;
				}
			}
			return true;
		}

		private static boolean statementPatternUsesAny(StatementPattern statementPattern, Set<String> bindingNames) {
			for (Var var : new Var[] { statementPattern.getSubjectVar(), statementPattern.getPredicateVar(),
					statementPattern.getObjectVar(), statementPattern.getContextVar() }) {
				if (var == null || var.hasValue()) {
					continue;
				}
				if (bindingNames.contains(var.getName())) {
					return true;
				}
			}
			return false;
		}

		private static BindingSetAssignment subjectValues(StatementPattern statementPattern, BindingSetAssignment left,
				BindingSetAssignment right) {
			Var subject = statementPattern.getSubjectVar();
			if (subject == null || subject.hasValue()) {
				return null;
			}
			String subjectName = subject.getName();
			if (left.getBindingNames().contains(subjectName)) {
				return left;
			}
			if (right.getBindingNames().contains(subjectName)) {
				return right;
			}
			return null;
		}
	}
}
