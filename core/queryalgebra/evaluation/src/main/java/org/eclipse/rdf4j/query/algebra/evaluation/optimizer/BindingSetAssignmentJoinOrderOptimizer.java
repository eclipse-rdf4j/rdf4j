/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import java.util.Collection;
import java.util.Set;

import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.BindingSetAssignment;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryOptimizer;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractSimpleQueryModelVisitor;

/**
 * Reorders joins to avoid an early cartesian product between two {@link BindingSetAssignment}s (VALUES) when the result
 * is immediately joined with a {@link StatementPattern} that can be evaluated efficiently with a single bound side.
 */
public class BindingSetAssignmentJoinOrderOptimizer implements QueryOptimizer {

	@Override
	public void optimize(TupleExpr tupleExpr, Dataset dataset, BindingSet bindings) {
		if (UnorderedSliceDetector.hasUnorderedSlice(tupleExpr)) {
			return;
		}
		tupleExpr.visit(new BindingSetAssignmentJoinOrderVisitor());
	}

	private static final class BindingSetAssignmentJoinOrderVisitor
			extends AbstractSimpleQueryModelVisitor<RuntimeException> {

		@Override
		public void meet(Join join) throws RuntimeException {
			super.meet(join);

			StatementPattern statementPattern;
			Join bindingSetJoin;
			if (join.getLeftArg() instanceof Join && join.getRightArg() instanceof StatementPattern) {
				bindingSetJoin = (Join) join.getLeftArg();
				statementPattern = (StatementPattern) join.getRightArg();
			} else if (join.getRightArg() instanceof Join && join.getLeftArg() instanceof StatementPattern) {
				bindingSetJoin = (Join) join.getRightArg();
				statementPattern = (StatementPattern) join.getLeftArg();
			} else {
				return;
			}

			if (!(bindingSetJoin.getLeftArg() instanceof BindingSetAssignment)
					|| !(bindingSetJoin.getRightArg() instanceof BindingSetAssignment)) {
				return;
			}

			BindingSetAssignment leftValues = (BindingSetAssignment) bindingSetJoin.getLeftArg();
			BindingSetAssignment rightValues = (BindingSetAssignment) bindingSetJoin.getRightArg();
			if (!areDisjoint(leftValues.getBindingNames(), rightValues.getBindingNames())) {
				return;
			}

			if (!statementPatternUsesAny(statementPattern, leftValues.getBindingNames())
					|| !statementPatternUsesAny(statementPattern, rightValues.getBindingNames())) {
				return;
			}

			BindingSetAssignment firstValues = chooseFirst(statementPattern, leftValues, rightValues);
			BindingSetAssignment secondValues = firstValues == leftValues ? rightValues : leftValues;

			StatementPattern statementPatternClone = statementPattern.clone();
			Join inner = new Join((TupleExpr) firstValues.clone(), statementPatternClone);
			Join outer = new Join(inner, (TupleExpr) secondValues.clone());

			join.replaceWith(outer);
			outer.visit(this);
		}

		private static boolean areDisjoint(Set<String> left, Set<String> right) {
			for (String name : left) {
				if (right.contains(name)) {
					return false;
				}
			}
			return true;
		}

		private static boolean statementPatternUsesAny(StatementPattern statementPattern, Set<String> bindingNames) {
			for (Var var : new Var[] { statementPattern.getSubjectVar(), statementPattern.getPredicateVar(),
					statementPattern.getObjectVar(), statementPattern.getContextVar() }) {
				if (var == null || var.hasValue()) {
					continue;
				}
				if (bindingNames.contains(var.getName())) {
					return true;
				}
			}
			return false;
		}

		private static BindingSetAssignment chooseFirst(StatementPattern statementPattern, BindingSetAssignment left,
				BindingSetAssignment right) {
			int leftScore = positionScore(statementPattern, left.getBindingNames());
			int rightScore = positionScore(statementPattern, right.getBindingNames());
			if (leftScore != rightScore) {
				return leftScore < rightScore ? left : right;
			}

			int leftSize = estimateSize(left);
			int rightSize = estimateSize(right);
			if (leftSize != rightSize) {
				return leftSize <= rightSize ? left : right;
			}

			return left;
		}

		private static int positionScore(StatementPattern statementPattern, Set<String> names) {
			Var subject = statementPattern.getSubjectVar();
			if (subject != null && !subject.hasValue() && names.contains(subject.getName())) {
				return 0;
			}
			Var object = statementPattern.getObjectVar();
			if (object != null && !object.hasValue() && names.contains(object.getName())) {
				return 1;
			}
			Var predicate = statementPattern.getPredicateVar();
			if (predicate != null && !predicate.hasValue() && names.contains(predicate.getName())) {
				return 2;
			}
			Var context = statementPattern.getContextVar();
			if (context != null && !context.hasValue() && names.contains(context.getName())) {
				return 3;
			}
			return Integer.MAX_VALUE;
		}

		private static int estimateSize(BindingSetAssignment assignment) {
			Iterable<BindingSet> bindingSets = assignment.getBindingSets();
			if (bindingSets instanceof Collection<?>) {
				return ((Collection<?>) bindingSets).size();
			}
			return Integer.MAX_VALUE;
		}
	}
}
