/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.iterator;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import org.eclipse.rdf4j.common.iteration.CloseableIteration;
import org.eclipse.rdf4j.common.iteration.LookAheadIteration;
import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.QueryEvaluationException;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryEvaluationStep;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.QueryEvaluationContext;

/**
 * Adaptive join that switches from nested-loop to hash join based on observed left size.
 */
public class AdaptiveJoinIteration extends LookAheadIteration<BindingSet> {

	private final QueryEvaluationStep leftPrepared;
	private final QueryEvaluationStep rightPrepared;
	private final BindingSet bindings;
	private final QueryEvaluationContext context;
	private final int nestedLoopThreshold;
	private final long hashJoinMaxBuildRows;
	private final String[] joinAttributes;

	private CloseableIteration<BindingSet> delegate;
	private boolean initialized;

	public AdaptiveJoinIteration(QueryEvaluationStep leftPrepared,
			QueryEvaluationStep rightPrepared,
			BindingSet bindings,
			String[] joinAttributes,
			int nestedLoopThreshold,
			long hashJoinMaxBuildRows,
			QueryEvaluationContext context) {
		this.leftPrepared = leftPrepared;
		this.rightPrepared = rightPrepared;
		this.bindings = bindings;
		this.joinAttributes = joinAttributes;
		this.nestedLoopThreshold = nestedLoopThreshold;
		this.hashJoinMaxBuildRows = hashJoinMaxBuildRows;
		this.context = context;
	}

	@Override
	protected BindingSet getNextElement() throws QueryEvaluationException {
		ensureInitialized();
		while (delegate != null) {
			try {
				if (delegate.hasNext()) {
					return delegate.next();
				}
				delegate.close();
				delegate = null;
				return null;
			} catch (HashJoinSizeLimitExceededException e) {
				switchToNestedLoop();
			}
		}
		return null;
	}

	@Override
	protected void handleClose() throws QueryEvaluationException {
		if (delegate != null) {
			delegate.close();
			delegate = null;
		}
	}

	private void ensureInitialized() throws QueryEvaluationException {
		if (initialized) {
			return;
		}
		initialized = true;
		delegate = chooseDelegate();
	}

	private CloseableIteration<BindingSet> chooseDelegate() throws QueryEvaluationException {
		CloseableIteration<BindingSet> leftIter = leftPrepared.evaluate(bindings);
		if (leftIter == QueryEvaluationStep.EMPTY_ITERATION) {
			return leftIter;
		}

		List<BindingSet> buffer = new ArrayList<>(Math.min(nestedLoopThreshold + 1, 16));
		while (leftIter.hasNext() && buffer.size() <= nestedLoopThreshold) {
			buffer.add(leftIter.next());
		}

		if (!leftIter.hasNext()) {
			leftIter.close();
			if (buffer.isEmpty()) {
				return QueryEvaluationStep.EMPTY_ITERATION;
			}
			return new BufferedJoinIterator(buffer, rightPrepared);
		}

		leftIter.close();
		return new LimitedSizeHashJoinIteration(leftPrepared, rightPrepared, bindings, joinAttributes, context,
				hashJoinMaxBuildRows);
	}

	private void switchToNestedLoop() throws QueryEvaluationException {
		if (delegate != null) {
			delegate.close();
		}
		delegate = JoinIterator.getInstance(leftPrepared, rightPrepared, bindings);
	}

	private static final class BufferedJoinIterator extends LookAheadIteration<BindingSet> {

		private final Iterator<BindingSet> leftIter;
		private final QueryEvaluationStep rightPrepared;
		private CloseableIteration<BindingSet> rightIter;

		private BufferedJoinIterator(List<BindingSet> leftBindings, QueryEvaluationStep rightPrepared) {
			this.leftIter = leftBindings.iterator();
			this.rightPrepared = rightPrepared;
		}

		@Override
		protected BindingSet getNextElement() throws QueryEvaluationException {
			if (rightIter != null) {
				if (rightIter.hasNext()) {
					return rightIter.next();
				}
				rightIter.close();
				rightIter = null;
			}

			while (leftIter.hasNext()) {
				rightIter = rightPrepared.evaluate(leftIter.next());
				if (rightIter.hasNext()) {
					return rightIter.next();
				}
				rightIter.close();
				rightIter = null;
			}

			return null;
		}

		@Override
		protected void handleClose() throws QueryEvaluationException {
			if (rightIter != null) {
				rightIter.close();
				rightIter = null;
			}
		}
	}

	private static final class LimitedSizeHashJoinIteration extends HashJoinIteration {

		private final long maxBuildRows;

		private LimitedSizeHashJoinIteration(QueryEvaluationStep left,
				QueryEvaluationStep right,
				BindingSet bindings,
				String[] joinAttributes,
				QueryEvaluationContext context,
				long maxBuildRows) throws QueryEvaluationException {
			super(left, right, bindings, false, joinAttributes, context);
			this.maxBuildRows = maxBuildRows;
		}

		@Override
		protected Collection<BindingSet> makeIterationCache(CloseableIteration<BindingSet> iter) {
			return new LimitedSizeCollection<>(maxBuildRows);
		}
	}

	private static final class LimitedSizeCollection<E> extends ArrayList<E> {

		private static final long serialVersionUID = 1L;
		private final long maxSize;

		private LimitedSizeCollection(long maxSize) {
			this.maxSize = maxSize;
		}

		@Override
		public boolean add(E value) {
			if (maxSize > 0 && size() >= maxSize) {
				throw new HashJoinSizeLimitExceededException(maxSize);
			}
			return super.add(value);
		}
	}

	private static final class HashJoinSizeLimitExceededException extends QueryEvaluationException {

		private static final long serialVersionUID = 1L;

		private HashJoinSizeLimitExceededException(long maxBuildRows) {
			super("Hash join build side exceeded " + maxBuildRows + " rows");
		}
	}
}
