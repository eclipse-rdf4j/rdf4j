/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;

import org.eclipse.rdf4j.common.iteration.CloseableIteration;
import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Resource;
import org.eclipse.rdf4j.model.Statement;
import org.eclipse.rdf4j.model.Value;
import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.Extension;
import org.eclipse.rdf4j.query.algebra.Filter;
import org.eclipse.rdf4j.query.algebra.Reduced;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.UnaryTupleOperator;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.TripleSource;

/**
 * Runtime sampling refinement for join operand ordering.
 */
public class RuntimeSamplingRefiner {

	private final TripleSource tripleSource;
	private final LearnedJoinConfig config;

	public RuntimeSamplingRefiner(TripleSource tripleSource, LearnedJoinConfig config) {
		this.tripleSource = Objects.requireNonNull(tripleSource, "tripleSource");
		this.config = Objects.requireNonNull(config, "config");
	}

	public Optional<List<TupleExpr>> refine(List<TupleExpr> orderedOperands, Dataset dataset,
			BindingSet initialBindings) {
		if (!config.isEnableRuntimeSampling()) {
			return Optional.empty();
		}
		if (orderedOperands.size() > config.getRuntimeSamplingMaxOperands()) {
			return Optional.empty();
		}

		List<SampleCandidate> candidates = new ArrayList<>(orderedOperands.size());
		for (TupleExpr operand : orderedOperands) {
			StatementPattern pattern = unwrapToStatementPattern(operand);
			if (pattern == null) {
				return Optional.empty();
			}
			candidates.add(new SampleCandidate(operand, pattern));
		}

		Resource[] contexts = contextsFrom(dataset);
		List<SampledOperand> sampled = new ArrayList<>(candidates.size());
		for (SampleCandidate candidate : candidates) {
			long count = sampleCount(candidate.pattern, contexts, initialBindings);
			sampled.add(new SampledOperand(candidate.operand, count));
		}

		sampled.sort(Comparator.comparingLong(SampledOperand::count));
		List<TupleExpr> reordered = new ArrayList<>(sampled.size());
		for (SampledOperand operand : sampled) {
			reordered.add(operand.operand());
		}

		return reordered.equals(orderedOperands) ? Optional.empty() : Optional.of(reordered);
	}

	private long sampleCount(StatementPattern pattern, Resource[] contexts, BindingSet initialBindings) {
		Resource subj = resolveResource(pattern.getSubjectVar(), initialBindings);
		IRI pred = resolveIri(pattern.getPredicateVar(), initialBindings);
		Value obj = resolveValue(pattern.getObjectVar(), initialBindings);
		long max = config.getRuntimeSamplingMaxStatementsPerPattern();
		long count = 0;
		try (CloseableIteration<? extends Statement> iter = tripleSource.getStatements(subj, pred, obj, contexts)) {
			while (iter.hasNext() && count < max) {
				iter.next();
				count++;
			}
		} catch (RuntimeException e) {
			return 0;
		}
		return count;
	}

	private Resource resolveResource(Var var, BindingSet initialBindings) {
		Value value = resolveValue(var, initialBindings);
		return value instanceof Resource ? (Resource) value : null;
	}

	private IRI resolveIri(Var var, BindingSet initialBindings) {
		Value value = resolveValue(var, initialBindings);
		return value instanceof IRI ? (IRI) value : null;
	}

	private Value resolveValue(Var var, BindingSet initialBindings) {
		if (var == null) {
			return null;
		}
		if (var.hasValue()) {
			return var.getValue();
		}
		if (initialBindings == null || var.getName() == null) {
			return null;
		}
		return initialBindings.getValue(var.getName());
	}

	private Resource[] contextsFrom(Dataset dataset) {
		if (dataset == null) {
			return new Resource[0];
		}
		Set<IRI> graphs = dataset.getDefaultGraphs();
		if (graphs == null || graphs.isEmpty()) {
			return new Resource[0];
		}
		return graphs.toArray(new Resource[0]);
	}

	private StatementPattern unwrapToStatementPattern(TupleExpr expr) {
		TupleExpr current = expr;
		while (current instanceof Filter || current instanceof Extension || current instanceof Reduced) {
			current = ((UnaryTupleOperator) current).getArg();
		}
		return current instanceof StatementPattern ? (StatementPattern) current : null;
	}

	private static final class SampleCandidate {
		private final TupleExpr operand;
		private final StatementPattern pattern;

		private SampleCandidate(TupleExpr operand, StatementPattern pattern) {
			this.operand = operand;
			this.pattern = pattern;
		}
	}

	private static final class SampledOperand {
		private final TupleExpr operand;
		private final long count;

		private SampledOperand(TupleExpr operand, long count) {
			this.operand = operand;
			this.count = count;
		}

		private TupleExpr operand() {
			return operand;
		}

		private long count() {
			return count;
		}
	}
}
