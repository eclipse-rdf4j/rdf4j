/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.Exists;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.LeftJoin;
import org.eclipse.rdf4j.query.algebra.Not;
import org.eclipse.rdf4j.query.algebra.Projection;
import org.eclipse.rdf4j.query.algebra.QueryRoot;
import org.eclipse.rdf4j.query.algebra.Service;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.Union;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryOptimizer;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.sparqluo.BeCostEstimator;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.sparqluo.BeGroupNode;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.sparqluo.BeTreeBuilder;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.sparqluo.BeTreeSerializer;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.sparqluo.BeTreeTransformer;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractQueryModelVisitor;

public class SparqlUoOptimizer implements QueryOptimizer {

	private static final ParentReferenceCleaner PARENT_REFERENCE_CLEANER = new ParentReferenceCleaner();

	private final BeTreeBuilder builder = new BeTreeBuilder();
	private final BeTreeSerializer serializer = new BeTreeSerializer();
	private final BeTreeTransformer transformer;

	public SparqlUoOptimizer(EvaluationStatistics evaluationStatistics) {
		this(evaluationStatistics, false);
	}

	public SparqlUoOptimizer(EvaluationStatistics evaluationStatistics, boolean allowNonImprovingTransforms) {
		this.transformer = new BeTreeTransformer(new BeCostEstimator(evaluationStatistics),
				allowNonImprovingTransforms);
	}

	@Override
	public void optimize(TupleExpr tupleExpr, Dataset dataset, BindingSet bindings) {
		PARENT_REFERENCE_CLEANER.optimize(tupleExpr, dataset, bindings);
		tupleExpr.visit(new SparqlUoVisitor());
	}

	private class SparqlUoVisitor extends AbstractQueryModelVisitor<RuntimeException> {

		@Override
		public void meet(Join node) {
			if (isGroupRoot(node)) {
				rewrite(node);
				return;
			}
			super.meet(node);
		}

		@Override
		public void meet(LeftJoin node) {
			if (node.getCondition() == null && isGroupRoot(node)) {
				rewrite(node);
				return;
			}
			super.meet(node);
		}

		@Override
		public void meet(Union node) {
			if (isGroupRoot(node)) {
				rewrite(node);
				return;
			}
			super.meet(node);
		}

		@Override
		public void meet(StatementPattern node) {
			if (isGroupRoot(node)) {
				rewrite(node);
			}
		}

		@Override
		public void meet(Service node) {
			// Skip SERVICE subtrees to avoid changing remote semantics.
		}

		@Override
		public void meet(Projection node) {
			if (node.isSubquery() && !(node.getParentNode() instanceof QueryRoot)) {
				return;
			}
			super.meet(node);
		}

		@Override
		public void meet(Exists node) {
			// Skip EXISTS subqueries.
		}

		@Override
		public void meet(Not node) {
			// Skip NOT EXISTS subqueries.
		}

		private boolean isGroupRoot(TupleExpr node) {
			if (node.getParentNode() == null) {
				return false;
			}
			return !(node.getParentNode() instanceof Join
					|| node.getParentNode() instanceof LeftJoin
					|| node.getParentNode() instanceof Union);
		}

		private void rewrite(TupleExpr node) {
			BeGroupNode group = builder.build(node);
			transformer.transform(group);
			TupleExpr replacement = serializer.serialize(group);
			node.replaceWith(replacement);
		}
	}
}
