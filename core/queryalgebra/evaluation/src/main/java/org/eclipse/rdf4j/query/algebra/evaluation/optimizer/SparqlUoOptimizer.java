/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.Exists;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.LeftJoin;
import org.eclipse.rdf4j.query.algebra.Not;
import org.eclipse.rdf4j.query.algebra.Projection;
import org.eclipse.rdf4j.query.algebra.QueryRoot;
import org.eclipse.rdf4j.query.algebra.Service;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.Union;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryOptimizer;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.sparqluo.BeCostEstimator;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.sparqluo.BeGroupNode;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.sparqluo.BeTreeBuilder;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.sparqluo.BeTreeSerializer;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.sparqluo.BeTreeTransformer;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.sparqluo.SparqlUoConfig;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractQueryModelVisitor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class SparqlUoOptimizer implements QueryOptimizer {

	private static final ParentReferenceCleaner PARENT_REFERENCE_CLEANER = new ParentReferenceCleaner();
	private static final Logger LOGGER = LoggerFactory.getLogger(SparqlUoOptimizer.class);

	private final SparqlUoConfig config;
	private final BeTreeBuilder builder;
	private final BeTreeSerializer serializer = new BeTreeSerializer();
	private final BeTreeTransformer transformer;
	private final OptionalFilterJoinOptimizer optionalFilterJoinOptimizer = new OptionalFilterJoinOptimizer();
	private final OptionalNotBoundFilterOptimizer optionalNotBoundFilterOptimizer = new OptionalNotBoundFilterOptimizer();
	private final OptionalBindLeftJoinOptimizer optionalBindLeftJoinOptimizer = new OptionalBindLeftJoinOptimizer();

	public SparqlUoOptimizer(EvaluationStatistics evaluationStatistics) {
		this(evaluationStatistics, SparqlUoConfig.fromSystemProperties());
	}

	public SparqlUoOptimizer(EvaluationStatistics evaluationStatistics, boolean allowNonImprovingTransforms) {
		this(evaluationStatistics, SparqlUoConfig.builder()
				.allowNonImprovingTransforms(allowNonImprovingTransforms)
				.build());
	}

	public SparqlUoOptimizer(EvaluationStatistics evaluationStatistics, SparqlUoConfig config) {
		this.config = config;
		this.builder = new BeTreeBuilder(config);
		this.transformer = new BeTreeTransformer(new BeCostEstimator(evaluationStatistics, config), config);
	}

	@Override
	public void optimize(TupleExpr tupleExpr, Dataset dataset, BindingSet bindings) {
		if (UnorderedSliceDetector.hasUnorderedSlice(tupleExpr)) {
			// Avoid plan rewrites that can change LIMIT/OFFSET truncation order.
			return;
		}
		PARENT_REFERENCE_CLEANER.optimize(tupleExpr, dataset, bindings);
		if (config.enableOptionalFilterJoin()) {
			optionalFilterJoinOptimizer.optimize(tupleExpr, dataset, bindings);
			optionalNotBoundFilterOptimizer.optimize(tupleExpr, dataset, bindings);
			optionalBindLeftJoinOptimizer.optimize(tupleExpr, dataset, bindings);
		}
		tupleExpr.visit(new SparqlUoVisitor());
		if (config.enableOptionalFilterJoin()) {
			optionalFilterJoinOptimizer.optimize(tupleExpr, dataset, bindings);
			optionalNotBoundFilterOptimizer.optimize(tupleExpr, dataset, bindings);
			optionalBindLeftJoinOptimizer.optimize(tupleExpr, dataset, bindings);
		}
	}

	private class SparqlUoVisitor extends AbstractQueryModelVisitor<RuntimeException> {

		@Override
		public void meet(Join node) {
			if (isGroupRoot(node)) {
				rewrite(node);
				return;
			}
			super.meet(node);
		}

		@Override
		public void meet(LeftJoin node) {
			if (isGroupRoot(node)) {
				rewrite(node);
				return;
			}
			super.meet(node);
		}

		@Override
		public void meet(Union node) {
			if (isGroupRoot(node)) {
				rewrite(node);
				return;
			}
			super.meet(node);
		}

		@Override
		public void meet(StatementPattern node) {
			if (isGroupRoot(node)) {
				rewrite(node);
			}
		}

		@Override
		public void meet(Service node) {
			// Skip SERVICE subtrees to avoid changing remote semantics.
		}

		@Override
		public void meet(Projection node) {
			if (node.isSubquery() && !(node.getParentNode() instanceof QueryRoot)) {
				return;
			}
			super.meet(node);
		}

		@Override
		public void meet(Exists node) {
			// Skip EXISTS subqueries.
		}

		@Override
		public void meet(Not node) {
			// Skip NOT EXISTS subqueries.
		}

		private boolean isGroupRoot(TupleExpr node) {
			if (node.getParentNode() == null) {
				return false;
			}
			return !(node.getParentNode() instanceof Join
					|| node.getParentNode() instanceof LeftJoin
					|| node.getParentNode() instanceof Union);
		}

		private void rewrite(TupleExpr node) {
			if (config.debugLogging() && LOGGER.isDebugEnabled()) {
				LOGGER.debug("SparqlUo: rewriting group rooted at {}", node.getClass().getSimpleName());
			}
			BeGroupNode group = builder.build(node);
			transformer.transform(group);
			TupleExpr replacement = serializer.serialize(group);
			node.replaceWith(replacement);
		}

	}
}
