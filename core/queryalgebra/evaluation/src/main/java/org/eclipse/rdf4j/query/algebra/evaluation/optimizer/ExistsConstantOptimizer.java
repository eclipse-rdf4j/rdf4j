/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.EmptySet;
import org.eclipse.rdf4j.query.algebra.Exists;
import org.eclipse.rdf4j.query.algebra.Filter;
import org.eclipse.rdf4j.query.algebra.LeftJoin;
import org.eclipse.rdf4j.query.algebra.Not;
import org.eclipse.rdf4j.query.algebra.SingletonSet;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.ValueExpr;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryOptimizer;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractSimpleQueryModelVisitor;

/**
 * Simplifies Filters and LeftJoin conditions when EXISTS / NOT EXISTS is constant.
 */
public class ExistsConstantOptimizer implements QueryOptimizer {

	@Override
	public void optimize(TupleExpr tupleExpr, Dataset dataset, BindingSet bindings) {
		tupleExpr.visit(new ExistsConstantVisitor());
	}

	private static final class ExistsConstantVisitor extends AbstractSimpleQueryModelVisitor<RuntimeException> {
		@Override
		public void meet(Filter filter) {
			super.meet(filter);
			Boolean constant = constantExists(filter.getCondition());
			if (constant == null) {
				return;
			}
			if (constant) {
				filter.replaceWith(filter.getArg());
			} else {
				filter.replaceWith(new EmptySet());
			}
		}

		@Override
		public void meet(LeftJoin leftJoin) {
			super.meet(leftJoin);
			ValueExpr condition = leftJoin.getCondition();
			if (condition == null) {
				return;
			}
			Boolean constant = constantExists(condition);
			if (constant == null) {
				return;
			}
			if (constant) {
				leftJoin.setCondition(null);
			} else {
				leftJoin.replaceWith(leftJoin.getLeftArg());
			}
		}
	}

	private static Boolean constantExists(ValueExpr expr) {
		if (expr instanceof Exists) {
			TupleExpr subquery = ((Exists) expr).getSubQuery();
			if (subquery instanceof EmptySet) {
				return Boolean.FALSE;
			}
			if (subquery instanceof SingletonSet) {
				return Boolean.TRUE;
			}
			return null;
		}
		if (expr instanceof Not) {
			Boolean nested = constantExists(((Not) expr).getArg());
			return nested == null ? null : !nested;
		}
		return null;
	}
}
