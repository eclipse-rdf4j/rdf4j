/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer.sparqluo;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.Var;

public class BeBgpCoalescer {
	void coalesce(BeGroupNode group) {
		List<BeNode> rebuilt = new ArrayList<>();
		List<BeBgpNode> segment = new ArrayList<>();

		for (BeNode child : group.getChildren()) {
			if (child instanceof BeBgpNode) {
				segment.add((BeBgpNode) child);
				continue;
			}

			flushSegment(segment, rebuilt);

			if (child instanceof BeGroupNode) {
				coalesce((BeGroupNode) child);
			} else if (child instanceof BeUnionNode) {
				for (BeGroupNode branch : ((BeUnionNode) child).getBranches()) {
					coalesce(branch);
				}
			} else if (child instanceof BeOptionalNode) {
				coalesce(((BeOptionalNode) child).getRight());
			}

			rebuilt.add(child);
		}

		flushSegment(segment, rebuilt);
		group.replaceChildren(rebuilt);
	}

	private void flushSegment(List<BeBgpNode> segment, List<BeNode> output) {
		if (segment.isEmpty()) {
			return;
		}

		List<PatternEntry> entries = new ArrayList<>();
		int index = 0;
		for (BeBgpNode node : segment) {
			for (StatementPattern pattern : node.getStatementPatterns()) {
				entries.add(new PatternEntry(pattern, index++));
			}
		}

		UnionFind uf = new UnionFind(entries.size());
		for (int i = 0; i < entries.size(); i++) {
			StatementPattern left = entries.get(i).pattern;
			for (int j = i + 1; j < entries.size(); j++) {
				StatementPattern right = entries.get(j).pattern;
				if (coalescable(left, right)) {
					uf.union(i, j);
				}
			}
		}

		Map<Integer, List<PatternEntry>> byRoot = new HashMap<>();
		for (int i = 0; i < entries.size(); i++) {
			int root = uf.find(i);
			byRoot.computeIfAbsent(root, key -> new ArrayList<>()).add(entries.get(i));
		}

		List<Component> components = new ArrayList<>();
		for (List<PatternEntry> componentEntries : byRoot.values()) {
			componentEntries.sort((a, b) -> Integer.compare(a.index, b.index));
			List<StatementPattern> patterns = new ArrayList<>(componentEntries.size());
			for (PatternEntry entry : componentEntries) {
				patterns.add(entry.pattern);
			}
			components.add(new Component(componentEntries.get(0).index, patterns));
		}

		components.sort((a, b) -> Integer.compare(a.minIndex, b.minIndex));
		for (Component component : components) {
			output.add(new BeBgpNode(component.patterns));
		}

		segment.clear();
	}

	private boolean coalescable(StatementPattern left, StatementPattern right) {
		Set<String> leftVars = subjectObjectVars(left);
		if (leftVars.isEmpty()) {
			return false;
		}
		Set<String> rightVars = subjectObjectVars(right);
		if (rightVars.isEmpty()) {
			return false;
		}
		for (String var : leftVars) {
			if (rightVars.contains(var)) {
				return true;
			}
		}
		return false;
	}

	private Set<String> subjectObjectVars(StatementPattern pattern) {
		Set<String> vars = new HashSet<>(2);
		collectVarName(vars, pattern.getSubjectVar());
		collectVarName(vars, pattern.getObjectVar());
		return vars;
	}

	private void collectVarName(Set<String> target, Var var) {
		if (var != null && !var.hasValue()) {
			target.add(var.getName());
		}
	}

	private static final class PatternEntry {
		private final StatementPattern pattern;
		private final int index;

		private PatternEntry(StatementPattern pattern, int index) {
			this.pattern = pattern;
			this.index = index;
		}
	}

	private static final class Component {
		private final int minIndex;
		private final List<StatementPattern> patterns;

		private Component(int minIndex, List<StatementPattern> patterns) {
			this.minIndex = minIndex;
			this.patterns = patterns;
		}
	}

	private static final class UnionFind {
		private final int[] parent;
		private final int[] rank;

		private UnionFind(int size) {
			this.parent = new int[size];
			this.rank = new int[size];
			for (int i = 0; i < size; i++) {
				parent[i] = i;
			}
		}

		private int find(int node) {
			int root = parent[node];
			if (root != node) {
				parent[node] = find(root);
			}
			return parent[node];
		}

		private void union(int left, int right) {
			int leftRoot = find(left);
			int rightRoot = find(right);
			if (leftRoot == rightRoot) {
				return;
			}
			if (rank[leftRoot] < rank[rightRoot]) {
				parent[leftRoot] = rightRoot;
			} else if (rank[leftRoot] > rank[rightRoot]) {
				parent[rightRoot] = leftRoot;
			} else {
				parent[rightRoot] = leftRoot;
				rank[leftRoot]++;
			}
		}
	}
}
