/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import java.time.Clock;
import java.time.Duration;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.LongAdder;

/**
 * In-memory statistics store for join pattern fanout metrics.
 */
public class MemoryJoinStats implements JoinStatsProvider {

	public static final Duration DEFAULT_INVALIDATION_WINDOW = Duration.ofMinutes(10);
	public static final long DEFAULT_INVALIDATION_STATEMENT_THRESHOLD = 100_000L;
	public static final double DEFAULT_BASELINE_DRIFT_RATIO = 0.5d;

	public static final class InvalidationSettings {
		private final Duration window;
		private final long statementThreshold;
		private final double baselineDriftRatio;

		private InvalidationSettings(Duration window, long statementThreshold, double baselineDriftRatio) {
			this.window = window;
			this.statementThreshold = statementThreshold;
			this.baselineDriftRatio = baselineDriftRatio;
		}

		public static InvalidationSettings disabled() {
			return new InvalidationSettings(Duration.ZERO, 0, 0.0d);
		}

		public static InvalidationSettings of(Duration window, long statementThreshold) {
			return of(window, statementThreshold, DEFAULT_BASELINE_DRIFT_RATIO);
		}

		public static InvalidationSettings of(Duration window, long statementThreshold, double baselineDriftRatio) {
			Objects.requireNonNull(window, "window");
			if (window.isNegative() || window.isZero()) {
				throw new IllegalArgumentException("window must be positive");
			}
			if (statementThreshold <= 0) {
				throw new IllegalArgumentException("statementThreshold must be positive");
			}
			if (baselineDriftRatio < 0.0d) {
				throw new IllegalArgumentException("baselineDriftRatio must be >= 0");
			}
			return new InvalidationSettings(window, statementThreshold, baselineDriftRatio);
		}

		public Duration getWindow() {
			return window;
		}

		public long getStatementThreshold() {
			return statementThreshold;
		}

		public double getBaselineDriftRatio() {
			return baselineDriftRatio;
		}

		private boolean enabled() {
			return statementThreshold > 0 && !window.isZero();
		}
	}

	private static final class Stats {
		private final LongAdder calls = new LongAdder();
		private final LongAdder results = new LongAdder();
		private final java.util.concurrent.atomic.AtomicLong maxResults = new java.util.concurrent.atomic.AtomicLong();
		private final long priorCalls;
		private final double priorResults;
		private final double baselineCardinality;

		private Stats(long priorCalls, double priorResults, double baselineCardinality) {
			this.priorCalls = priorCalls;
			this.priorResults = priorResults;
			this.baselineCardinality = baselineCardinality;
		}

		private double averageResults() {
			long actualCalls = calls.sum();
			long totalCalls = actualCalls + priorCalls;
			if (totalCalls == 0) {
				return 0.0d;
			}
			return (results.sum() + priorResults) / totalCalls;
		}

		private double maxResults() {
			return maxResults.get();
		}

		private long actualCalls() {
			return calls.sum();
		}

		private double baselineCardinality() {
			return baselineCardinality;
		}

		private Stats withBaseline(double newBaseline) {
			Stats updated = new Stats(priorCalls, priorResults, newBaseline);
			updated.calls.add(calls.sum());
			updated.results.add(results.sum());
			updated.maxResults.set(maxResults.get());
			return updated;
		}

		private void recordResults(long resultCount) {
			results.add(resultCount);
			maxResults.accumulateAndGet(resultCount, Math::max);
		}
	}

	private final Map<PatternKey, Stats> stats = new ConcurrentHashMap<>();
	private final InvalidationSettings invalidationSettings;
	private final Clock clock;
	private final Object invalidationLock = new Object();
	private final AtomicLong windowStartMillis;
	private final LongAdder statementsAddedInWindow = new LongAdder();

	public MemoryJoinStats() {
		this(InvalidationSettings.of(DEFAULT_INVALIDATION_WINDOW, DEFAULT_INVALIDATION_STATEMENT_THRESHOLD),
				Clock.systemUTC());
	}

	public MemoryJoinStats(InvalidationSettings invalidationSettings) {
		this(invalidationSettings, Clock.systemUTC());
	}

	public MemoryJoinStats(InvalidationSettings invalidationSettings, Clock clock) {
		this.invalidationSettings = Objects.requireNonNull(invalidationSettings, "invalidationSettings");
		this.clock = Objects.requireNonNull(clock, "clock");
		long start = invalidationSettings.enabled() ? clock.millis() : 0L;
		this.windowStartMillis = new AtomicLong(start);
	}

	@Override
	public void reset() {
		stats.clear();
	}

	@Override
	public void recordCall(PatternKey key) {
		stats.computeIfAbsent(key, ignored -> new Stats(0, 0, 0.0d)).calls.increment();
	}

	@Override
	public void recordResults(PatternKey key, long resultCount) {
		if (resultCount < 0) {
			resultCount = 0;
		}
		stats.computeIfAbsent(key, ignored -> new Stats(0, 0, 0.0d)).recordResults(resultCount);
	}

	@Override
	public void seedIfAbsent(PatternKey key, double defaultCardinality, long priorCalls) {
		long seedCalls = Math.max(0, priorCalls);
		double priorResults = Math.max(0.0d, defaultCardinality) * seedCalls;
		stats.compute(key, (ignored, existing) -> {
			if (existing == null) {
				return new Stats(seedCalls, priorResults, defaultCardinality);
			}
			if (baselineDrifted(existing, defaultCardinality)) {
				return new Stats(seedCalls, priorResults, defaultCardinality);
			}
			if (shouldInitializeBaseline(existing, defaultCardinality)) {
				return existing.withBaseline(defaultCardinality);
			}
			return existing;
		});
	}

	@Override
	public double getAverageResults(PatternKey key) {
		Stats entry = stats.get(key);
		return entry == null ? 0.0d : entry.averageResults();
	}

	@Override
	public double getMaxResults(PatternKey key) {
		Stats entry = stats.get(key);
		return entry == null ? 0.0d : entry.maxResults();
	}

	@Override
	public boolean hasStats(PatternKey key) {
		return stats.containsKey(key);
	}

	@Override
	public long getTotalCalls() {
		long total = 0;
		for (Stats entry : stats.values()) {
			total += entry.actualCalls();
		}
		return total;
	}

	@Override
	public void recordStatementsAdded(long statementCount) {
		if (!invalidationSettings.enabled() || statementCount <= 0) {
			return;
		}
		synchronized (invalidationLock) {
			long nowMillis = clock.millis();
			long windowStart = windowStartMillis.get();
			long windowMillis = invalidationSettings.getWindow().toMillis();
			if (windowMillis <= 0) {
				return;
			}
			if (nowMillis - windowStart >= windowMillis) {
				windowStartMillis.set(nowMillis);
				statementsAddedInWindow.reset();
			}
			statementsAddedInWindow.add(statementCount);
			if (statementsAddedInWindow.sum() >= invalidationSettings.getStatementThreshold()) {
				reset();
				windowStartMillis.set(nowMillis);
				statementsAddedInWindow.reset();
			}
		}
	}

	private boolean baselineDrifted(Stats existing, double newBaseline) {
		double driftRatio = invalidationSettings.getBaselineDriftRatio();
		if (driftRatio <= 0.0d) {
			return false;
		}
		double baseline = existing.baselineCardinality();
		if (baseline <= 0.0d) {
			return false;
		}
		if (newBaseline <= 0.0d) {
			return baseline > 0.0d;
		}
		double relativeChange = Math.abs(newBaseline - baseline) / baseline;
		return relativeChange >= driftRatio;
	}

	private boolean shouldInitializeBaseline(Stats existing, double newBaseline) {
		return existing.baselineCardinality() <= 0.0d && newBaseline > 0.0d;
	}
}
