/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.LongAdder;

/**
 * In-memory statistics store for join pattern fanout metrics.
 */
public class MemoryJoinStats implements JoinStatsProvider {

	private static final class Stats {
		private final LongAdder calls = new LongAdder();
		private final LongAdder results = new LongAdder();
		private final long priorCalls;
		private final double priorResults;

		private Stats(long priorCalls, double priorResults) {
			this.priorCalls = priorCalls;
			this.priorResults = priorResults;
		}

		private double averageResults() {
			long actualCalls = calls.sum();
			long totalCalls = actualCalls + priorCalls;
			if (totalCalls == 0) {
				return 0.0d;
			}
			return (results.sum() + priorResults) / totalCalls;
		}

		private long actualCalls() {
			return calls.sum();
		}
	}

	private final Map<PatternKey, Stats> stats = new ConcurrentHashMap<>();

	@Override
	public void reset() {
		stats.clear();
	}

	@Override
	public void recordCall(PatternKey key) {
		stats.computeIfAbsent(key, ignored -> new Stats(0, 0)).calls.increment();
	}

	@Override
	public void recordResults(PatternKey key, long resultCount) {
		if (resultCount < 0) {
			resultCount = 0;
		}
		stats.computeIfAbsent(key, ignored -> new Stats(0, 0)).results.add(resultCount);
	}

	@Override
	public void seedIfAbsent(PatternKey key, double defaultCardinality, long priorCalls) {
		long seedCalls = Math.max(0, priorCalls);
		double priorResults = Math.max(0.0d, defaultCardinality) * seedCalls;
		stats.computeIfAbsent(key, ignored -> new Stats(seedCalls, priorResults));
	}

	@Override
	public double getAverageResults(PatternKey key) {
		Stats entry = stats.get(key);
		return entry == null ? 0.0d : entry.averageResults();
	}

	@Override
	public boolean hasStats(PatternKey key) {
		return stats.containsKey(key);
	}

	@Override
	public long getTotalCalls() {
		long total = 0;
		for (Stats entry : stats.values()) {
			total += entry.actualCalls();
		}
		return total;
	}
}
