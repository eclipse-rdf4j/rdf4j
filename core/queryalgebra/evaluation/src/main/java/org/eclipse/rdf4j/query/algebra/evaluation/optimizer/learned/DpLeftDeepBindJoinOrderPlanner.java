/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;

import org.eclipse.rdf4j.query.algebra.TupleExpr;

/**
 * Left-deep dynamic programming planner for small join groups.
 */
public class DpLeftDeepBindJoinOrderPlanner implements JoinOrderPlanner {

	private static final double INF = Double.POSITIVE_INFINITY;

	private final BindJoinCostModel costModel;

	public DpLeftDeepBindJoinOrderPlanner(BindJoinCostModel costModel) {
		this.costModel = Objects.requireNonNull(costModel, "costModel");
	}

	@Override
	public List<TupleExpr> order(List<TupleExpr> operands, Set<String> initiallyBoundVars) {
		int size = operands.size();
		if (size <= 1) {
			return new ArrayList<>(operands);
		}

		int totalMasks = 1 << size;
		double[] cost = new double[totalMasks];
		double[] card = new double[totalMasks];
		int[] prevMask = new int[totalMasks];
		int[] prevIndex = new int[totalMasks];

		Set<String>[] boundVars = buildBoundVars(operands, initiallyBoundVars);

		for (int mask = 0; mask < totalMasks; mask++) {
			cost[mask] = INF;
			card[mask] = INF;
			prevMask[mask] = -1;
			prevIndex[mask] = -1;
		}

		for (int i = 0; i < size; i++) {
			int mask = 1 << i;
			double scanCard = costModel.estimateScanCardinality(operands.get(i), initiallyBoundVars);
			card[mask] = scanCard;
			cost[mask] = 1.0d;
			prevMask[mask] = 0;
			prevIndex[mask] = i;
		}

		for (int mask = 1; mask < totalMasks; mask++) {
			if ((mask & (mask - 1)) == 0) {
				continue;
			}
			for (int j = 0; j < size; j++) {
				int bit = 1 << j;
				if ((mask & bit) == 0) {
					continue;
				}
				int fromMask = mask ^ bit;
				double outer = card[fromMask];
				Set<String> fromBound = boundVars[fromMask];
				double fanout = estimateFanoutWithConnectivity(operands.get(j), fromBound, initiallyBoundVars);
				double candidateCard = outer * fanout;
				double candidateCost = cost[fromMask] + outer;
				if (candidateCost < cost[mask]
						|| (candidateCost == cost[mask] && candidateCard < card[mask])) {
					cost[mask] = candidateCost;
					card[mask] = candidateCard;
					prevMask[mask] = fromMask;
					prevIndex[mask] = j;
				}
			}
		}

		return reconstructOrder(operands, prevMask, prevIndex, totalMasks - 1);
	}

	private Set<String>[] buildBoundVars(List<TupleExpr> operands, Set<String> initiallyBoundVars) {
		int size = operands.size();
		int totalMasks = 1 << size;
		@SuppressWarnings("unchecked")
		Set<String>[] boundVars = (Set<String>[]) new Set<?>[totalMasks];
		boundVars[0] = new HashSet<>(initiallyBoundVars);
		for (int mask = 1; mask < totalMasks; mask++) {
			int bit = mask & -mask;
			int index = Integer.numberOfTrailingZeros(bit);
			int prev = mask ^ bit;
			Set<String> next = new HashSet<>(boundVars[prev]);
			next.addAll(filteredBindingNames(operands.get(index)));
			boundVars[mask] = next;
		}
		return boundVars;
	}

	private double estimateFanoutWithConnectivity(TupleExpr expr, Set<String> boundVars,
			Set<String> initiallyBoundVars) {
		Set<String> names = filteredBindingNames(expr);
		if (names.isEmpty() || boundVars.isEmpty() || disjoint(names, boundVars)) {
			return costModel.estimateScanCardinality(expr, initiallyBoundVars);
		}
		return costModel.estimateFanout(expr, boundVars);
	}

	private Set<String> filteredBindingNames(TupleExpr expr) {
		Set<String> names = new HashSet<>(costModel.bindingNames(expr));
		names.removeIf(name -> name.startsWith("_const_"));
		return names;
	}

	private boolean disjoint(Set<String> left, Set<String> right) {
		for (String name : left) {
			if (right.contains(name)) {
				return false;
			}
		}
		return true;
	}

	private List<TupleExpr> reconstructOrder(List<TupleExpr> operands, int[] prevMask, int[] prevIndex,
			int finalMask) {
		Deque<TupleExpr> order = new ArrayDeque<>(operands.size());
		int mask = finalMask;
		while (mask != 0) {
			int index = prevIndex[mask];
			order.addFirst(operands.get(index));
			mask = prevMask[mask];
		}
		return new ArrayList<>(order);
	}
}
