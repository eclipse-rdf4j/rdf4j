/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;

import org.eclipse.rdf4j.model.vocabulary.RDF;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.helpers.collectors.StatementPatternCollector;

/**
 * Left-deep dynamic programming planner for small join groups.
 */
public class DpLeftDeepBindJoinOrderPlanner implements JoinOrderPlanner {

	private static final double DISCONNECTED_PENALTY = 1.0e9d;
	private static final String DEBUG_PROPERTY = "rdf4j.dp.debug";
	private static final String DEBUG_MAX_OPERANDS_PROPERTY = "rdf4j.dp.debug.maxOperands";
	private static final int DEFAULT_DEBUG_MAX_OPERANDS = 6;

	private final BindJoinCostModel costModel;

	public DpLeftDeepBindJoinOrderPlanner(BindJoinCostModel costModel) {
		this.costModel = Objects.requireNonNull(costModel, "costModel");
	}

	@Override
	public List<TupleExpr> order(List<TupleExpr> operands, Set<String> initiallyBoundVars) {
		int size = operands.size();
		if (size <= 1) {
			return new ArrayList<>(operands);
		}

		boolean debug = isDebugEnabled(size);
		List<String> debugLabels = debug ? operandLabels(operands) : List.of();
		if (debug) {
			System.out.println("DP debug operands=" + debugLabels);
		}

		int totalMasks = 1 << size;
		@SuppressWarnings("unchecked")
		List<PlanEntry>[] plans = (List<PlanEntry>[]) new List<?>[totalMasks];

		Set<String>[] boundVars = buildBoundVars(operands, initiallyBoundVars);

		for (int i = 0; i < size; i++) {
			int mask = 1 << i;
			TupleExpr operand = operands.get(i);
			double scanCost = costModel.estimateScanCardinality(operand, initiallyBoundVars);
			if (scanCost <= 0.0d) {
				scanCost = 1.0d;
			}
			double cardinality = scanCost;
			Set<String> names = filteredBindingNames(operand);
			boolean disconnected = isIsolated(operand, operands);
			if (!initiallyBoundVars.isEmpty() && (names.isEmpty() || disjoint(names, initiallyBoundVars))) {
				disconnected = true;
			}
			if (disconnected) {
				scanCost *= DISCONNECTED_PENALTY;
				cardinality *= DISCONNECTED_PENALTY;
			}
			List<PlanEntry> entries = new ArrayList<>(1);
			entries.add(new PlanEntry(scanCost, cardinality, 0, i, -1));
			plans[mask] = entries;
			if (debug) {
				System.out.println("DP debug mask=" + maskBits(mask, size) + " init="
						+ debugLabels.get(i) + " cost=" + format(scanCost) + " card=" + format(cardinality));
			}
		}

		for (int mask = 1; mask < totalMasks; mask++) {
			if ((mask & (mask - 1)) == 0) {
				continue;
			}
			List<PlanEntry> entries = new ArrayList<>();
			for (int j = 0; j < size; j++) {
				int bit = 1 << j;
				if ((mask & bit) == 0) {
					continue;
				}
				int fromMask = mask ^ bit;
				List<PlanEntry> fromPlans = plans[fromMask];
				if (fromPlans == null || fromPlans.isEmpty()) {
					continue;
				}
				Set<String> fromBound = boundVars[fromMask];
				double fanout = estimateFanoutWithConnectivity(operands.get(j), fromBound, initiallyBoundVars);
				if (debug) {
					System.out.println("DP debug mask=" + maskBits(mask, size) + " from=" + maskBits(fromMask, size)
							+ " add=" + debugLabels.get(j) + " fanout=" + format(fanout));
				}
				for (int entryIndex = 0; entryIndex < fromPlans.size(); entryIndex++) {
					PlanEntry from = fromPlans.get(entryIndex);
					double outer = from.cardinality;
					double candidateCard = outer * fanout;
					double candidateCost = from.cost + candidateCard;
					if (!Double.isFinite(candidateCost) || !Double.isFinite(candidateCard)) {
						continue;
					}
					if (debug) {
						System.out.println("DP debug  -> order=" + orderLabels(operands, plans, fromMask, entryIndex,
								debugLabels, size)
								+ " + " + debugLabels.get(j)
								+ " outer=" + format(outer)
								+ " card=" + format(candidateCard)
								+ " cost=" + format(candidateCost));
					}
					addCandidate(entries, new PlanEntry(candidateCost, candidateCard, fromMask, j, entryIndex));
				}
			}
			plans[mask] = entries;
			if (debug) {
				for (int entryIndex = 0; entryIndex < entries.size(); entryIndex++) {
					PlanEntry entry = entries.get(entryIndex);
					System.out.println("DP debug mask=" + maskBits(mask, size) + " plan="
							+ orderLabels(operands, plans, mask, entryIndex, debugLabels, size)
							+ " cost=" + format(entry.cost)
							+ " card=" + format(entry.cardinality));
				}
			}
		}

		int finalMask = totalMasks - 1;
		List<PlanEntry> finalPlans = plans[finalMask];
		if (finalPlans == null || finalPlans.isEmpty()) {
			return new ArrayList<>(operands);
		}
		int bestIndex = selectBestPlan(finalPlans);
		return reconstructOrder(operands, plans, finalMask, bestIndex);
	}

	private Set<String>[] buildBoundVars(List<TupleExpr> operands, Set<String> initiallyBoundVars) {
		int size = operands.size();
		int totalMasks = 1 << size;
		@SuppressWarnings("unchecked")
		Set<String>[] boundVars = (Set<String>[]) new Set<?>[totalMasks];
		boundVars[0] = new HashSet<>(initiallyBoundVars);
		for (int mask = 1; mask < totalMasks; mask++) {
			int bit = mask & -mask;
			int index = Integer.numberOfTrailingZeros(bit);
			int prev = mask ^ bit;
			Set<String> next = new HashSet<>(boundVars[prev]);
			next.addAll(filteredBindingNames(operands.get(index)));
			boundVars[mask] = next;
		}
		return boundVars;
	}

	private double estimateFanoutWithConnectivity(TupleExpr expr, Set<String> boundVars,
			Set<String> initiallyBoundVars) {
		Set<String> names = filteredBindingNames(expr);
		if (names.isEmpty() || boundVars.isEmpty() || disjoint(names, boundVars)) {
			double scan = costModel.estimateScanCardinality(expr, initiallyBoundVars);
			if (scan <= 0.0d) {
				scan = 1.0d;
			}
			return scan * DISCONNECTED_PENALTY;
		}
		return costModel.estimateFanout(expr, boundVars);
	}

	private Set<String> filteredBindingNames(TupleExpr expr) {
		Set<String> names = new HashSet<>(costModel.bindingNames(expr));
		names.removeIf(name -> name.startsWith("_const_"));
		return names;
	}

	private boolean isIsolated(TupleExpr expr, List<TupleExpr> operands) {
		Set<String> names = filteredBindingNames(expr);
		if (names.isEmpty()) {
			return true;
		}
		for (TupleExpr candidate : operands) {
			if (candidate == expr) {
				continue;
			}
			if (!disjoint(names, filteredBindingNames(candidate))) {
				return false;
			}
		}
		return true;
	}

	private boolean disjoint(Set<String> left, Set<String> right) {
		for (String name : left) {
			if (right.contains(name)) {
				return false;
			}
		}
		return true;
	}

	private List<TupleExpr> reconstructOrder(List<TupleExpr> operands, List<PlanEntry>[] plans, int finalMask,
			int finalEntry) {
		Deque<TupleExpr> order = new ArrayDeque<>(operands.size());
		int mask = finalMask;
		int entryIndex = finalEntry;
		while (mask != 0) {
			PlanEntry entry = plans[mask].get(entryIndex);
			order.addFirst(operands.get(entry.prevIndex));
			entryIndex = entry.prevEntry;
			mask = entry.prevMask;
		}
		return new ArrayList<>(order);
	}

	private void addCandidate(List<PlanEntry> entries, PlanEntry candidate) {
		for (int i = 0; i < entries.size();) {
			PlanEntry existing = entries.get(i);
			if (dominates(existing, candidate)) {
				return;
			}
			if (dominates(candidate, existing)) {
				entries.remove(i);
				continue;
			}
			i++;
		}
		entries.add(candidate);
	}

	private boolean dominates(PlanEntry left, PlanEntry right) {
		return left.cost <= right.cost && left.cardinality <= right.cardinality;
	}

	private int selectBestPlan(List<PlanEntry> entries) {
		int bestIndex = 0;
		PlanEntry best = entries.get(0);
		for (int i = 1; i < entries.size(); i++) {
			PlanEntry candidate = entries.get(i);
			if (candidate.cost < best.cost
					|| (candidate.cost == best.cost && candidate.cardinality < best.cardinality)) {
				best = candidate;
				bestIndex = i;
			}
		}
		return bestIndex;
	}

	private boolean isDebugEnabled(int size) {
		if (!Boolean.getBoolean(DEBUG_PROPERTY)) {
			return false;
		}
		int max = Integer.getInteger(DEBUG_MAX_OPERANDS_PROPERTY, DEFAULT_DEBUG_MAX_OPERANDS);
		return size <= Math.max(1, max);
	}

	private List<String> operandLabels(List<TupleExpr> operands) {
		List<String> labels = new ArrayList<>(operands.size());
		for (TupleExpr expr : operands) {
			List<StatementPattern> patterns = StatementPatternCollector.process(expr);
			if (patterns.isEmpty()) {
				labels.add(expr.getClass().getSimpleName());
				continue;
			}
			labels.add(patternLabel(patterns.get(0)));
		}
		return labels;
	}

	private String patternLabel(StatementPattern pattern) {
		Var predicate = pattern.getPredicateVar();
		String label = predicateLabel(predicate);
		if (predicate != null && predicate.hasValue() && RDF.TYPE.equals(predicate.getValue())) {
			Var object = pattern.getObjectVar();
			if (object != null && object.hasValue()) {
				label = label + "(" + object.getValue().stringValue() + ")";
			}
		}
		return label;
	}

	private String predicateLabel(Var predicate) {
		if (predicate == null || !predicate.hasValue()) {
			return "<var>";
		}
		return predicate.getValue().stringValue();
	}

	private String orderLabels(List<TupleExpr> operands, List<PlanEntry>[] plans, int mask, int entryIndex,
			List<String> labels, int size) {
		List<String> order = new ArrayList<>(size);
		int currentMask = mask;
		int currentEntry = entryIndex;
		while (currentMask != 0) {
			PlanEntry entry = plans[currentMask].get(currentEntry);
			order.add(0, labels.get(entry.prevIndex));
			currentEntry = entry.prevEntry;
			currentMask = entry.prevMask;
		}
		return order.toString();
	}

	private String maskBits(int mask, int size) {
		String binary = Integer.toBinaryString(mask);
		if (binary.length() >= size) {
			return binary;
		}
		StringBuilder builder = new StringBuilder(size);
		for (int i = binary.length(); i < size; i++) {
			builder.append('0');
		}
		builder.append(binary);
		return builder.toString();
	}

	private String format(double value) {
		if (value == 0.0d) {
			return "0";
		}
		if (value < 1.0d) {
			return String.format("%.3f", value);
		}
		if (value < 1000.0d) {
			return String.format("%.3f", value);
		}
		return String.format("%.0f", value);
	}

	private static final class PlanEntry {
		private final double cost;
		private final double cardinality;
		private final int prevMask;
		private final int prevIndex;
		private final int prevEntry;

		private PlanEntry(double cost, double cardinality, int prevMask, int prevIndex, int prevEntry) {
			this.cost = cost;
			this.cardinality = cardinality;
			this.prevMask = prevMask;
			this.prevIndex = prevIndex;
			this.prevEntry = prevEntry;
		}
	}
}
