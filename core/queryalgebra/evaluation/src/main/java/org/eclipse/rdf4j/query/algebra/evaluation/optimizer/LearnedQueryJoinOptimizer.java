/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.Exists;
import org.eclipse.rdf4j.query.algebra.Filter;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.QueryModelNode;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.ValueExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.VariableScopeChange;
import org.eclipse.rdf4j.query.algebra.evaluation.TripleSource;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned.BindJoinCostModel;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned.DpLeftDeepBindJoinOrderPlanner;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned.GreedyBindJoinOrderPlanner;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned.HybridBindJoinOrderPlanner;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned.JoinOrderPlanner;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned.LearnedBindJoinCostModel;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned.LearnedJoinConfig;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractQueryModelVisitor;
import org.eclipse.rdf4j.query.algebra.helpers.TupleExprs;
import org.eclipse.rdf4j.query.algebra.helpers.collectors.StatementPatternCollector;

/**
 * Join optimizer that uses learned fanout statistics to estimate costs.
 */
public class LearnedQueryJoinOptimizer extends QueryJoinOptimizer {

	private static final long DEFAULT_PRIOR_CALLS = 2;

	private final JoinStatsProvider statsProvider;
	private final JoinOrderPlanner joinPlanner;
	private final LearnedJoinConfig config;

	public LearnedQueryJoinOptimizer(EvaluationStatistics statistics, TripleSource tripleSource,
			JoinStatsProvider statsProvider) {
		this(statistics, false, tripleSource, statsProvider, new LearnedJoinConfig());
	}

	public LearnedQueryJoinOptimizer(EvaluationStatistics statistics, TripleSource tripleSource,
			JoinStatsProvider statsProvider, LearnedJoinConfig config) {
		this(statistics, false, tripleSource, statsProvider, config);
	}

	public LearnedQueryJoinOptimizer(EvaluationStatistics statistics, boolean trackResultSize,
			TripleSource tripleSource, JoinStatsProvider statsProvider) {
		this(statistics, trackResultSize, tripleSource, statsProvider, new LearnedJoinConfig());
	}

	public LearnedQueryJoinOptimizer(EvaluationStatistics statistics, boolean trackResultSize,
			TripleSource tripleSource, JoinStatsProvider statsProvider, LearnedJoinConfig config) {
		super(statistics, trackResultSize, tripleSource);
		this.statsProvider = Objects.requireNonNull(statsProvider, "statsProvider");
		this.config = Objects.requireNonNull(config, "config");
		Objects.requireNonNull(tripleSource, "tripleSource");
		BindJoinCostModel costModel = new LearnedBindJoinCostModel(statistics, statsProvider);
		JoinOrderPlanner greedy = new GreedyBindJoinOrderPlanner(costModel);
		JoinOrderPlanner dp = new DpLeftDeepBindJoinOrderPlanner(costModel);
		this.joinPlanner = new HybridBindJoinOrderPlanner(config, greedy, dp);
	}

	@Override
	public void optimize(TupleExpr tupleExpr, Dataset dataset, BindingSet bindings) {
		tupleExpr.visit(new LearnedJoinVisitor(dataset, bindings));
	}

	protected class LearnedJoinVisitor extends JoinVisitor {

		private final Dataset dataset;
		private final BindingSet bindings;
		private final Deque<Set<String>> scopedBoundVars = new ArrayDeque<>();
		private Deque<TupleExpr> plannedOrder;

		private LearnedJoinVisitor(Dataset dataset, BindingSet bindings) {
			this.dataset = dataset;
			this.bindings = bindings;
		}

		@Override
		public void meet(Join node) {
			Deque<TupleExpr> previousPlan = plannedOrder;
			try {
				List<TupleExpr> joinArgs = getJoinArgs(node, new ArrayList<>());
				List<TupleExpr> orderedExtensions = getExtensionTupleExprs(joinArgs);
				joinArgs.removeAll(orderedExtensions);
				List<TupleExpr> subSelects = getSubSelects(joinArgs);
				List<TupleExpr> orderedSubselects = reorderSubselects(subSelects);
				joinArgs.removeAll(orderedSubselects);
				if (joinArgs.isEmpty()) {
					plannedOrder = null;
				} else if (!hasLearnedStats(joinArgs)) {
					plannedOrder = null;
				} else {
					Set<String> initiallyBoundVars = determineInitiallyBoundVars(joinArgs);
					JoinOrderPlanner planner = plannerFor(node);
					List<TupleExpr> planned = planner.order(joinArgs, initiallyBoundVars);
					if (isConnectedPlan(planned, initiallyBoundVars)) {
						plannedOrder = new ArrayDeque<>(planned);
					} else {
						plannedOrder = null;
					}
				}
				super.meet(node);
			} finally {
				plannedOrder = previousPlan;
			}
		}

		@Override
		public void meet(Filter node) {
			if (containsExists(node.getCondition())) {
				Set<String> bound = filterBoundVars(node);
				if (!bound.isEmpty()) {
					scopedBoundVars.push(bound);
					try {
						node.getArg().visit(this);
						node.getCondition().visit(this);
					} finally {
						scopedBoundVars.pop();
					}
					return;
				}
			}
			super.meet(node);
		}

		@Override
		public void meet(StatementPattern node) {
			double estimate = estimateCardinality(node);
			node.setResultSizeEstimate(estimate);
		}

		@Override
		protected double getTupleExprCost(TupleExpr tupleExpr, Map<TupleExpr, Double> cardinalityMap,
				Map<TupleExpr, List<Var>> varsMap, Map<Var, Integer> varFreqMap) {
			if (tupleExpr instanceof StatementPattern) {
				StatementPattern statementPattern = (StatementPattern) tupleExpr;
				double estimate = estimateCardinality(statementPattern);
				statementPattern.setCardinality(estimate);
				statementPattern.setResultSizeEstimate(estimate);
			}
			return super.getTupleExprCost(tupleExpr, cardinalityMap, varsMap, varFreqMap);
		}

		@Override
		protected TupleExpr selectNextTupleExpr(List<TupleExpr> expressions, Map<TupleExpr, Double> cardinalityMap,
				Map<TupleExpr, List<Var>> varsMap, Map<Var, Integer> varFreqMap) {
			if (plannedOrder != null && !plannedOrder.isEmpty()) {
				TupleExpr planned = nextPlanned(expressions);
				if (planned != null) {
					if (planned.getCostEstimate() < 0) {
						planned.setCostEstimate(getTupleExprCost(planned, cardinalityMap, varsMap, varFreqMap));
					}
					return planned;
				}
			}
			return super.selectNextTupleExpr(expressions, cardinalityMap, varsMap, varFreqMap);
		}

		private TupleExpr nextPlanned(List<TupleExpr> expressions) {
			while (!plannedOrder.isEmpty()) {
				TupleExpr candidate = plannedOrder.removeFirst();
				if (expressions.contains(candidate)) {
					return candidate;
				}
			}
			return null;
		}

		private JoinOrderPlanner plannerFor(Join node) {
			List<ValueExpr> filters = collectAncestorFilters(node);
			if (filters.isEmpty()) {
				return joinPlanner;
			}
			BindJoinCostModel costModel = new LearnedBindJoinCostModel(statistics, statsProvider, filters);
			JoinOrderPlanner greedy = new GreedyBindJoinOrderPlanner(costModel);
			JoinOrderPlanner dp = new DpLeftDeepBindJoinOrderPlanner(costModel);
			return new HybridBindJoinOrderPlanner(config, greedy, dp);
		}

		private List<ValueExpr> collectAncestorFilters(Join node) {
			List<ValueExpr> filters = List.of();
			QueryModelNode current = node.getParentNode();
			while (current != null) {
				if (current instanceof VariableScopeChange
						&& ((VariableScopeChange) current).isVariableScopeChange()) {
					break;
				}
				if (current instanceof Filter) {
					Filter filter = (Filter) current;
					if (filters.isEmpty()) {
						filters = List.of(filter.getCondition());
					} else {
						if (filters.size() == 1) {
							filters = new ArrayList<>(filters);
						}
						filters.add(filter.getCondition());
					}
				}
				current = current.getParentNode();
			}
			return filters;
		}

		private Set<String> determineInitiallyBoundVars(List<TupleExpr> joinArgs) {
			Set<String> candidates = new HashSet<>();
			for (TupleExpr expr : joinArgs) {
				candidates.addAll(expr.getBindingNames());
			}
			Set<String> bound = new HashSet<>(scopedBoundVars());
			for (String name : candidates) {
				if (name.startsWith("_const_")) {
					continue;
				}
				if (bound.contains(name)) {
					continue;
				}
				if (getUnboundVars(List.of(Var.of(name))).isEmpty()) {
					bound.add(name);
				}
			}
			return bound;
		}

		private boolean isConnectedPlan(List<TupleExpr> plan, Set<String> initiallyBoundVars) {
			if (plan.isEmpty()) {
				return true;
			}
			Set<String> bound = new HashSet<>();
			for (TupleExpr expr : plan) {
				Set<String> names = filteredBindingNames(expr);
				if (!bound.isEmpty() && disjoint(bound, names)) {
					return false;
				}
				bound.addAll(names);
			}
			return true;
		}

		private Set<String> filteredBindingNames(TupleExpr expr) {
			Set<String> names = new HashSet<>(expr.getBindingNames());
			names.removeIf(name -> name.startsWith("_const_"));
			return names;
		}

		private boolean disjoint(Set<String> left, Set<String> right) {
			for (String name : left) {
				if (right.contains(name)) {
					return false;
				}
			}
			return true;
		}

		private Set<String> scopedBoundVars() {
			if (scopedBoundVars.isEmpty()) {
				return Set.of();
			}
			Set<String> bound = new HashSet<>();
			for (Set<String> scope : scopedBoundVars) {
				bound.addAll(scope);
			}
			return bound;
		}

		private Set<String> filterBoundVars(Filter filter) {
			Set<String> bound = new HashSet<>(filter.getBindingNames());
			bound.removeIf(name -> name.startsWith("_const_"));
			return bound;
		}

		private boolean containsExists(ValueExpr expr) {
			if (expr == null) {
				return false;
			}
			boolean[] found = new boolean[1];
			expr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
				@Override
				public void meet(Exists node) {
					found[0] = true;
				}

				@Override
				protected void meetNode(QueryModelNode node) {
					if (!found[0]) {
						super.meetNode(node);
					}
				}
			});
			return found[0];
		}

		private List<TupleExpr> getExtensionTupleExprs(List<TupleExpr> expressions) {
			if (expressions.isEmpty()) {
				return List.of();
			}

			List<TupleExpr> extensions = List.of();
			for (TupleExpr expr : expressions) {
				if (TupleExprs.containsExtension(expr)) {
					if (extensions.isEmpty()) {
						extensions = List.of(expr);
					} else {
						if (extensions.size() == 1) {
							extensions = new ArrayList<>(extensions);
						}
						extensions.add(expr);
					}
				}
			}
			return extensions;
		}

		private boolean hasLearnedStats(List<TupleExpr> expressions) {
			boolean seeded = false;
			for (TupleExpr expr : expressions) {
				if (expr instanceof StatementPattern) {
					if (ensureStats((StatementPattern) expr)) {
						seeded = true;
					}
					continue;
				}
				for (StatementPattern pattern : StatementPatternCollector.process(expr)) {
					if (ensureStats(pattern)) {
						seeded = true;
					}
				}
			}
			return seeded;
		}

		private boolean ensureStats(StatementPattern pattern) {
			PatternKey key = buildKey(pattern);
			if (statsProvider.hasStats(key)) {
				return true;
			}
			double defaultEstimate = statistics.getCardinality(pattern);
			statsProvider.seedIfAbsent(key, defaultEstimate, DEFAULT_PRIOR_CALLS);
			return statsProvider.hasStats(key);
		}

		private double estimateCardinality(StatementPattern node) {
			PatternKey key = buildKey(node);
			double defaultEstimate = statistics.getCardinality(node);
			if (!statsProvider.hasStats(key)) {
				return defaultEstimate;
			}
			statsProvider.seedIfAbsent(key, defaultEstimate, DEFAULT_PRIOR_CALLS);
			double estimate = statsProvider.getAverageResults(key);
			if (estimate <= 0.0d) {
				estimate = defaultEstimate;
			}
			return estimate;
		}

		private PatternKey buildKey(StatementPattern node) {
			int mask = 0;
			if (isBound(node.getSubjectVar())) {
				mask |= PatternKey.SUBJECT_BOUND;
			}
			if (isBound(node.getPredicateVar())) {
				mask |= PatternKey.PREDICATE_BOUND;
			}
			if (isBound(node.getObjectVar())) {
				mask |= PatternKey.OBJECT_BOUND;
			}
			Var predVar = node.getPredicateVar();
			IRI predicateKey = null;
			if (predVar != null && predVar.hasValue() && predVar.getValue() instanceof IRI) {
				predicateKey = (IRI) predVar.getValue();
			}
			return new PatternKey(predicateKey, mask);
		}

		private boolean isBound(Var var) {
			if (var == null) {
				return false;
			}
			List<Var> unbound = getUnboundVars(List.of(var));
			return unbound.isEmpty();
		}
	}
}
