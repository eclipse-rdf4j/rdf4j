/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.TripleSource;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned.BindJoinCostModel;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned.DpLeftDeepBindJoinOrderPlanner;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned.GreedyBindJoinOrderPlanner;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned.HybridBindJoinOrderPlanner;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned.JoinOrderPlanner;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned.LearnedBindJoinCostModel;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned.LearnedJoinConfig;
import org.eclipse.rdf4j.query.algebra.helpers.TupleExprs;
import org.eclipse.rdf4j.query.algebra.helpers.collectors.StatementPatternCollector;

/**
 * Join optimizer that uses learned fanout statistics to estimate costs.
 */
public class LearnedQueryJoinOptimizer extends QueryJoinOptimizer {

	private static final long DEFAULT_PRIOR_CALLS = 2;

	private final JoinStatsProvider statsProvider;
	private final JoinOrderPlanner joinPlanner;
	private final LearnedJoinConfig config;

	public LearnedQueryJoinOptimizer(EvaluationStatistics statistics, TripleSource tripleSource,
			JoinStatsProvider statsProvider) {
		this(statistics, false, tripleSource, statsProvider, new LearnedJoinConfig());
	}

	public LearnedQueryJoinOptimizer(EvaluationStatistics statistics, TripleSource tripleSource,
			JoinStatsProvider statsProvider, LearnedJoinConfig config) {
		this(statistics, false, tripleSource, statsProvider, config);
	}

	public LearnedQueryJoinOptimizer(EvaluationStatistics statistics, boolean trackResultSize,
			TripleSource tripleSource, JoinStatsProvider statsProvider) {
		this(statistics, trackResultSize, tripleSource, statsProvider, new LearnedJoinConfig());
	}

	public LearnedQueryJoinOptimizer(EvaluationStatistics statistics, boolean trackResultSize,
			TripleSource tripleSource, JoinStatsProvider statsProvider, LearnedJoinConfig config) {
		super(statistics, trackResultSize, tripleSource);
		this.statsProvider = Objects.requireNonNull(statsProvider, "statsProvider");
		this.config = Objects.requireNonNull(config, "config");
		Objects.requireNonNull(tripleSource, "tripleSource");
		BindJoinCostModel costModel = new LearnedBindJoinCostModel(statistics, statsProvider);
		JoinOrderPlanner greedy = new GreedyBindJoinOrderPlanner(costModel);
		JoinOrderPlanner dp = new DpLeftDeepBindJoinOrderPlanner(costModel);
		this.joinPlanner = new HybridBindJoinOrderPlanner(config, greedy, dp);
	}

	@Override
	public void optimize(TupleExpr tupleExpr, Dataset dataset, BindingSet bindings) {
		tupleExpr.visit(new LearnedJoinVisitor(dataset, bindings));
	}

	protected class LearnedJoinVisitor extends JoinVisitor {

		private final Dataset dataset;
		private final BindingSet bindings;
		private Deque<TupleExpr> plannedOrder;

		private LearnedJoinVisitor(Dataset dataset, BindingSet bindings) {
			this.dataset = dataset;
			this.bindings = bindings;
		}

		@Override
		public void meet(Join node) {
			Deque<TupleExpr> previousPlan = plannedOrder;
			try {
				List<TupleExpr> joinArgs = getJoinArgs(node, new ArrayList<>());
				List<TupleExpr> orderedExtensions = getExtensionTupleExprs(joinArgs);
				joinArgs.removeAll(orderedExtensions);
				List<TupleExpr> subSelects = getSubSelects(joinArgs);
				List<TupleExpr> orderedSubselects = reorderSubselects(subSelects);
				joinArgs.removeAll(orderedSubselects);
				if (joinArgs.isEmpty()) {
					plannedOrder = null;
				} else if (!hasLearnedStats(joinArgs)) {
					plannedOrder = null;
				} else {
					Set<String> initiallyBoundVars = determineInitiallyBoundVars(joinArgs);
					List<TupleExpr> planned = joinPlanner.order(joinArgs, initiallyBoundVars);
					plannedOrder = new ArrayDeque<>(planned);
				}
				super.meet(node);
			} finally {
				plannedOrder = previousPlan;
			}
		}

		@Override
		public void meet(StatementPattern node) {
			double estimate = estimateCardinality(node);
			node.setResultSizeEstimate(estimate);
		}

		@Override
		protected double getTupleExprCost(TupleExpr tupleExpr, Map<TupleExpr, Double> cardinalityMap,
				Map<TupleExpr, List<Var>> varsMap, Map<Var, Integer> varFreqMap) {
			if (tupleExpr instanceof StatementPattern) {
				StatementPattern statementPattern = (StatementPattern) tupleExpr;
				double estimate = estimateCardinality(statementPattern);
				statementPattern.setCardinality(estimate);
				statementPattern.setResultSizeEstimate(estimate);
			}
			return super.getTupleExprCost(tupleExpr, cardinalityMap, varsMap, varFreqMap);
		}

		@Override
		protected TupleExpr selectNextTupleExpr(List<TupleExpr> expressions, Map<TupleExpr, Double> cardinalityMap,
				Map<TupleExpr, List<Var>> varsMap, Map<Var, Integer> varFreqMap) {
			if (plannedOrder != null && !plannedOrder.isEmpty()) {
				TupleExpr planned = nextPlanned(expressions);
				if (planned != null) {
					if (planned.getCostEstimate() < 0) {
						planned.setCostEstimate(getTupleExprCost(planned, cardinalityMap, varsMap, varFreqMap));
					}
					return planned;
				}
			}
			return super.selectNextTupleExpr(expressions, cardinalityMap, varsMap, varFreqMap);
		}

		private TupleExpr nextPlanned(List<TupleExpr> expressions) {
			while (!plannedOrder.isEmpty()) {
				TupleExpr candidate = plannedOrder.removeFirst();
				if (expressions.contains(candidate)) {
					return candidate;
				}
			}
			return null;
		}

		private Set<String> determineInitiallyBoundVars(List<TupleExpr> joinArgs) {
			Set<String> candidates = new HashSet<>();
			for (TupleExpr expr : joinArgs) {
				candidates.addAll(expr.getBindingNames());
			}
			Set<String> bound = new HashSet<>();
			for (String name : candidates) {
				if (name.startsWith("_const_")) {
					continue;
				}
				if (getUnboundVars(List.of(Var.of(name))).isEmpty()) {
					bound.add(name);
				}
			}
			return bound;
		}

		private List<TupleExpr> getExtensionTupleExprs(List<TupleExpr> expressions) {
			if (expressions.isEmpty()) {
				return List.of();
			}

			List<TupleExpr> extensions = List.of();
			for (TupleExpr expr : expressions) {
				if (TupleExprs.containsExtension(expr)) {
					if (extensions.isEmpty()) {
						extensions = List.of(expr);
					} else {
						if (extensions.size() == 1) {
							extensions = new ArrayList<>(extensions);
						}
						extensions.add(expr);
					}
				}
			}
			return extensions;
		}

		private boolean hasLearnedStats(List<TupleExpr> expressions) {
			for (TupleExpr expr : expressions) {
				if (expr instanceof StatementPattern) {
					if (statsProvider.hasStats(buildKey((StatementPattern) expr))) {
						return true;
					}
					continue;
				}
				for (StatementPattern pattern : StatementPatternCollector.process(expr)) {
					if (statsProvider.hasStats(buildKey(pattern))) {
						return true;
					}
				}
			}
			return false;
		}

		private double estimateCardinality(StatementPattern node) {
			PatternKey key = buildKey(node);
			double defaultEstimate = statistics.getCardinality(node);
			if (!statsProvider.hasStats(key)) {
				return defaultEstimate;
			}
			statsProvider.seedIfAbsent(key, defaultEstimate, DEFAULT_PRIOR_CALLS);
			double estimate = statsProvider.getAverageResults(key);
			if (estimate <= 0.0d) {
				estimate = defaultEstimate;
			}
			return estimate;
		}

		private PatternKey buildKey(StatementPattern node) {
			int mask = 0;
			if (isBound(node.getSubjectVar())) {
				mask |= PatternKey.SUBJECT_BOUND;
			}
			if (isBound(node.getPredicateVar())) {
				mask |= PatternKey.PREDICATE_BOUND;
			}
			if (isBound(node.getObjectVar())) {
				mask |= PatternKey.OBJECT_BOUND;
			}
			Var predVar = node.getPredicateVar();
			IRI predicateKey = null;
			if (predVar != null && predVar.hasValue() && predVar.getValue() instanceof IRI) {
				predicateKey = (IRI) predVar.getValue();
			}
			return new PatternKey(predicateKey, mask);
		}

		private boolean isBound(Var var) {
			if (var == null) {
				return false;
			}
			List<Var> unbound = getUnboundVars(List.of(var));
			return unbound.isEmpty();
		}
	}
}
