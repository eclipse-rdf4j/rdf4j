/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import java.util.List;
import java.util.Map;
import java.util.Objects;

import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.TripleSource;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;

/**
 * Join optimizer that uses learned fanout statistics to estimate costs.
 */
public class LearnedQueryJoinOptimizer extends QueryJoinOptimizer {

	private static final long DEFAULT_PRIOR_CALLS = 2;

	private final JoinStatsProvider statsProvider;

	public LearnedQueryJoinOptimizer(EvaluationStatistics statistics, TripleSource tripleSource,
			JoinStatsProvider statsProvider) {
		this(statistics, false, tripleSource, statsProvider);
	}

	public LearnedQueryJoinOptimizer(EvaluationStatistics statistics, boolean trackResultSize,
			TripleSource tripleSource, JoinStatsProvider statsProvider) {
		super(statistics, trackResultSize, tripleSource);
		this.statsProvider = Objects.requireNonNull(statsProvider, "statsProvider");
	}

	@Override
	public void optimize(TupleExpr tupleExpr, Dataset dataset, BindingSet bindings) {
		tupleExpr.visit(new LearnedJoinVisitor());
	}

	protected class LearnedJoinVisitor extends JoinVisitor {

		@Override
		public void meet(StatementPattern node) {
			double estimate = estimateCardinality(node);
			node.setResultSizeEstimate(estimate);
		}

		@Override
		protected double getTupleExprCost(TupleExpr tupleExpr, Map<TupleExpr, Double> cardinalityMap,
				Map<TupleExpr, List<Var>> varsMap, Map<Var, Integer> varFreqMap) {
			if (tupleExpr instanceof StatementPattern) {
				StatementPattern statementPattern = (StatementPattern) tupleExpr;
				double estimate = estimateCardinality(statementPattern);
				statementPattern.setCardinality(estimate);
				statementPattern.setResultSizeEstimate(estimate);
			}
			return super.getTupleExprCost(tupleExpr, cardinalityMap, varsMap, varFreqMap);
		}

		private double estimateCardinality(StatementPattern node) {
			PatternKey key = buildKey(node);
			double defaultEstimate = statistics.getCardinality(node);
			statsProvider.seedIfAbsent(key, defaultEstimate, DEFAULT_PRIOR_CALLS);
			double estimate = statsProvider.getAverageResults(key);
			if (estimate <= 0.0d) {
				estimate = defaultEstimate;
			}
			return estimate;
		}

		private PatternKey buildKey(StatementPattern node) {
			int mask = 0;
			if (isBound(node.getSubjectVar())) {
				mask |= PatternKey.SUBJECT_BOUND;
			}
			if (isBound(node.getPredicateVar())) {
				mask |= PatternKey.PREDICATE_BOUND;
			}
			if (isBound(node.getObjectVar())) {
				mask |= PatternKey.OBJECT_BOUND;
			}
			Var predVar = node.getPredicateVar();
			IRI predicateKey = null;
			if (predVar != null && predVar.hasValue() && predVar.getValue() instanceof IRI) {
				predicateKey = (IRI) predVar.getValue();
			}
			return new PatternKey(predicateKey, mask);
		}

		private boolean isBound(Var var) {
			if (var == null) {
				return false;
			}
			List<Var> unbound = getUnboundVars(List.of(var));
			return unbound.isEmpty();
		}
	}
}
