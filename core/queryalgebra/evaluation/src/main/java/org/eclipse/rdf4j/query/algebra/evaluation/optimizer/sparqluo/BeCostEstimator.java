/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer.sparqluo;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.SingletonSet;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;

public class BeCostEstimator {
	private final EvaluationStatistics evaluationStatistics;
	private final SparqlUoConfig config;
	private final BeTreeSerializer serializer = new BeTreeSerializer();
	private final Map<BeBgpNode, Double> bgpCardinalityCache = new IdentityHashMap<>();
	private final Map<BeNode, BindingInfo> bindingInfoCache = new IdentityHashMap<>();

	public BeCostEstimator(EvaluationStatistics evaluationStatistics) {
		this(evaluationStatistics, SparqlUoConfig.defaultConfig());
	}

	public BeCostEstimator(EvaluationStatistics evaluationStatistics, SparqlUoConfig config) {
		this.evaluationStatistics = evaluationStatistics;
		this.config = config;
	}

	public double estimateGroupCost(BeGroupNode group) {
		return estimateGroup(group, BindingInfo.empty(), 1.0).cost;
	}

	public double estimateGroupResultSize(BeGroupNode group) {
		return estimateGroup(group, BindingInfo.empty(), 1.0).resultSize;
	}

	private GroupEstimate estimateGroup(BeGroupNode group, BindingInfo seedInfo, double seedSize) {
		double cost = 0.0;
		double currentSize = seedSize;
		BindingInfo currentInfo = seedInfo;
		int index = 0;

		while (index < group.size()) {
			BeNode node = group.getChild(index);
			if (node instanceof BeOptionalNode) {
				BeOptionalNode optional = (BeOptionalNode) node;
				GroupEstimate rightEstimate = estimateGroup(optional.getRight(), currentInfo, 1.0);
				int sharedVars = sharedAssuredCount(currentInfo, bindingInfo(optional));
				currentSize = fOptional(currentSize, rightEstimate.resultSize, sharedVars);
				cost += rightEstimate.cost + currentSize;
				currentInfo = BindingInfo.optional(currentInfo, bindingInfo(optional));
				index++;
				continue;
			}

			List<BeNode> segment = new ArrayList<>();
			while (index < group.size() && !(group.getChild(index) instanceof BeOptionalNode)) {
				segment.add(group.getChild(index));
				index++;
			}

			SegmentEstimate segmentEstimate = estimateJoinSegment(segment, currentInfo, currentSize);
			cost += segmentEstimate.cost;
			currentSize = segmentEstimate.resultSize;
			currentInfo = segmentEstimate.info;
		}

		return new GroupEstimate(cost, currentSize, currentInfo);
	}

	private SegmentEstimate estimateJoinSegment(List<BeNode> segment, BindingInfo seedInfo, double seedSize) {
		if (segment.isEmpty()) {
			return new SegmentEstimate(0.0, seedSize, seedInfo);
		}
		if (!config.simulateJoinOrder() || segment.size() == 1) {
			return estimateJoinSegmentInOrder(segment, seedInfo, seedSize);
		}

		List<BeNode> remaining = new ArrayList<>(segment);
		double cost = 0.0;
		double currentSize = seedSize;
		BindingInfo currentInfo = seedInfo;

		while (!remaining.isEmpty()) {
			BeNode best = null;
			NodeEstimate bestEstimate = null;
			double bestScore = Double.POSITIVE_INFINITY;
			for (BeNode candidate : remaining) {
				NodeEstimate estimate = estimateNode(candidate);
				int sharedVars = sharedAssuredCount(currentInfo, estimate.info);
				double joinedSize = fAnd(currentSize, estimate.resultSize, sharedVars);
				double score = estimate.cost + joinedSize;
				if (score < bestScore) {
					bestScore = score;
					best = candidate;
					bestEstimate = estimate;
				}
			}

			if (best == null || bestEstimate == null) {
				break;
			}

			int sharedVars = sharedAssuredCount(currentInfo, bestEstimate.info);
			currentSize = fAnd(currentSize, bestEstimate.resultSize, sharedVars);
			cost += bestEstimate.cost + currentSize;
			currentInfo = BindingInfo.join(currentInfo, bestEstimate.info);
			remaining.remove(best);
		}

		return new SegmentEstimate(cost, currentSize, currentInfo);
	}

	private SegmentEstimate estimateJoinSegmentInOrder(List<BeNode> segment, BindingInfo seedInfo, double seedSize) {
		double cost = 0.0;
		double currentSize = seedSize;
		BindingInfo currentInfo = seedInfo;

		for (BeNode node : segment) {
			NodeEstimate estimate = estimateNode(node);
			int sharedVars = sharedAssuredCount(currentInfo, estimate.info);
			currentSize = fAnd(currentSize, estimate.resultSize, sharedVars);
			cost += estimate.cost + currentSize;
			currentInfo = BindingInfo.join(currentInfo, estimate.info);
		}

		return new SegmentEstimate(cost, currentSize, currentInfo);
	}

	private NodeEstimate estimateNode(BeNode node) {
		double nodeCost = estimateNodeCost(node);
		double nodeSize = estimateNodeResultSize(node);
		BindingInfo info = bindingInfo(node);
		return new NodeEstimate(nodeCost, nodeSize, info);
	}

	private double estimateNodeResultSize(BeNode node) {
		switch (node.getType()) {
		case BGP:
			return estimateBgpCardinality((BeBgpNode) node);
		case UNION:
			return estimateUnionResultSize((BeUnionNode) node);
		case OPTIONAL:
			return estimateGroupResultSize(((BeOptionalNode) node).getRight());
		case GROUP:
			return estimateGroupResultSize((BeGroupNode) node);
		case BARRIER:
			return evaluationStatistics.getCardinality(((BeBarrierNode) node).getTupleExpr());
		default:
			throw new IllegalStateException("Unsupported BE node type: " + node.getType());
		}
	}

	private double estimateNodeCost(BeNode node) {
		switch (node.getType()) {
		case BGP:
			return estimateBgpCardinality((BeBgpNode) node);
		case UNION:
			return estimateUnionCost((BeUnionNode) node);
		case OPTIONAL:
			return estimateGroupCost(((BeOptionalNode) node).getRight());
		case GROUP:
			return estimateGroupCost((BeGroupNode) node);
		case BARRIER:
			return evaluationStatistics.getCardinality(((BeBarrierNode) node).getTupleExpr());
		default:
			throw new IllegalStateException("Unsupported BE node type: " + node.getType());
		}
	}

	private double estimateUnionResultSize(BeUnionNode node) {
		double sum = 0.0;
		for (BeGroupNode branch : node.getBranches()) {
			sum += estimateGroupResultSize(branch);
		}
		return sum;
	}

	private double estimateUnionCost(BeUnionNode node) {
		double sum = 0.0;
		for (BeGroupNode branch : node.getBranches()) {
			sum += estimateGroupCost(branch);
		}
		return sum;
	}

	private double estimateBgpCardinality(BeBgpNode node) {
		return bgpCardinalityCache.computeIfAbsent(node, key -> {
			TupleExpr expr = buildBgpExpr(key.getStatementPatterns());
			return evaluationStatistics.getCardinality(expr);
		});
	}

	private TupleExpr buildBgpExpr(List<StatementPattern> patterns) {
		TupleExpr expr = null;
		for (StatementPattern pattern : patterns) {
			StatementPattern clone = pattern.clone();
			if (expr == null) {
				expr = clone;
			} else {
				expr = new Join(expr, clone);
			}
		}
		return expr != null ? expr : new SingletonSet();
	}

	private double fAnd(double left, double right, int sharedVars) {
		double result = left * right;
		if (sharedVars > 0) {
			result /= Math.pow(config.assumedVarDomainCardinality(), sharedVars);
		}
		return Math.max(0.0, result);
	}

	private double fOptional(double left, double right, int sharedVars) {
		double expectedMatches = fAnd(left, right, sharedVars);
		double matchContribution = expectedMatches * config.optionalMatchRate() * config.optionalMultiplicity();
		return Math.max(left, left + matchContribution);
	}

	private BindingInfo bindingInfo(BeNode node) {
		return bindingInfoCache.computeIfAbsent(node, key -> {
			TupleExpr expr = serializer.serialize(node);
			return new BindingInfo(expr.getBindingNames(), expr.getAssuredBindingNames());
		});
	}

	private int sharedAssuredCount(BindingInfo left, BindingInfo right) {
		if (left.assuredBindingNames.isEmpty() || right.assuredBindingNames.isEmpty()) {
			return 0;
		}
		int count = 0;
		for (String name : left.assuredBindingNames) {
			if (right.assuredBindingNames.contains(name)) {
				count++;
			}
		}
		return count;
	}

	private static final class GroupEstimate {
		private final double cost;
		private final double resultSize;
		private final BindingInfo info;

		private GroupEstimate(double cost, double resultSize, BindingInfo info) {
			this.cost = cost;
			this.resultSize = resultSize;
			this.info = info;
		}
	}

	private static final class SegmentEstimate {
		private final double cost;
		private final double resultSize;
		private final BindingInfo info;

		private SegmentEstimate(double cost, double resultSize, BindingInfo info) {
			this.cost = cost;
			this.resultSize = resultSize;
			this.info = info;
		}
	}

	private static final class NodeEstimate {
		private final double cost;
		private final double resultSize;
		private final BindingInfo info;

		private NodeEstimate(double cost, double resultSize, BindingInfo info) {
			this.cost = cost;
			this.resultSize = resultSize;
			this.info = info;
		}
	}

	private static final class BindingInfo {
		private static final BindingInfo EMPTY = new BindingInfo(Set.of(), Set.of());

		private final Set<String> bindingNames;
		private final Set<String> assuredBindingNames;

		private BindingInfo(Set<String> bindingNames, Set<String> assuredBindingNames) {
			this.bindingNames = Set.copyOf(bindingNames);
			this.assuredBindingNames = Set.copyOf(assuredBindingNames);
		}

		private static BindingInfo empty() {
			return EMPTY;
		}

		private static BindingInfo join(BindingInfo left, BindingInfo right) {
			Set<String> names = new HashSet<>(left.bindingNames);
			names.addAll(right.bindingNames);
			Set<String> assured = new HashSet<>(left.assuredBindingNames);
			assured.addAll(right.assuredBindingNames);
			return new BindingInfo(names, assured);
		}

		private static BindingInfo optional(BindingInfo left, BindingInfo right) {
			Set<String> names = new HashSet<>(left.bindingNames);
			names.addAll(right.bindingNames);
			return new BindingInfo(names, left.assuredBindingNames);
		}
	}
}
