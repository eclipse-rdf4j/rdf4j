/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer.sparqluo;

import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.SingletonSet;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;

public class BeCostEstimator {
	private final EvaluationStatistics evaluationStatistics;
	private final Map<BeBgpNode, Double> bgpCardinalityCache = new IdentityHashMap<>();
	private double optionalMultiplier = 1.0;

	public BeCostEstimator(EvaluationStatistics evaluationStatistics) {
		this.evaluationStatistics = evaluationStatistics;
	}

	public void setOptionalMultiplier(double optionalMultiplier) {
		this.optionalMultiplier = optionalMultiplier;
	}

	public double estimateGroupCost(BeGroupNode group) {
		double currentSize = 1.0;
		double totalCost = 0.0;
		for (BeNode child : group.getChildren()) {
			double childCost = estimateNodeCost(child);
			double childSize = estimateNodeResultSize(child);
			if (child instanceof BeOptionalNode) {
				currentSize = fOptional(currentSize, childSize);
			} else {
				currentSize = fAnd(currentSize, childSize);
			}
			totalCost += childCost + currentSize;
		}
		return totalCost;
	}

	public double estimateGroupResultSize(BeGroupNode group) {
		double currentSize = 1.0;
		for (BeNode child : group.getChildren()) {
			double childSize = estimateNodeResultSize(child);
			if (child instanceof BeOptionalNode) {
				currentSize = fOptional(currentSize, childSize);
			} else {
				currentSize = fAnd(currentSize, childSize);
			}
		}
		return currentSize;
	}

	private double estimateNodeResultSize(BeNode node) {
		switch (node.getType()) {
		case BGP:
			return estimateBgpCardinality((BeBgpNode) node);
		case UNION:
			return estimateUnionResultSize((BeUnionNode) node);
		case OPTIONAL:
			return estimateGroupResultSize(((BeOptionalNode) node).getRight());
		case GROUP:
			return estimateGroupResultSize((BeGroupNode) node);
		case BARRIER:
			return evaluationStatistics.getCardinality(((BeBarrierNode) node).getTupleExpr());
		default:
			throw new IllegalStateException("Unsupported BE node type: " + node.getType());
		}
	}

	private double estimateNodeCost(BeNode node) {
		switch (node.getType()) {
		case BGP:
			return estimateBgpCardinality((BeBgpNode) node);
		case UNION:
			return estimateUnionCost((BeUnionNode) node);
		case OPTIONAL:
			return estimateGroupCost(((BeOptionalNode) node).getRight());
		case GROUP:
			return estimateGroupCost((BeGroupNode) node);
		case BARRIER:
			return evaluationStatistics.getCardinality(((BeBarrierNode) node).getTupleExpr());
		default:
			throw new IllegalStateException("Unsupported BE node type: " + node.getType());
		}
	}

	private double estimateUnionResultSize(BeUnionNode node) {
		double sum = 0.0;
		for (BeGroupNode branch : node.getBranches()) {
			sum += estimateGroupResultSize(branch);
		}
		return sum;
	}

	private double estimateUnionCost(BeUnionNode node) {
		double sum = 0.0;
		for (BeGroupNode branch : node.getBranches()) {
			sum += estimateGroupCost(branch);
		}
		return sum;
	}

	private double estimateBgpCardinality(BeBgpNode node) {
		return bgpCardinalityCache.computeIfAbsent(node, key -> {
			TupleExpr expr = buildBgpExpr(key.getStatementPatterns());
			return evaluationStatistics.getCardinality(expr);
		});
	}

	private TupleExpr buildBgpExpr(List<StatementPattern> patterns) {
		TupleExpr expr = null;
		for (StatementPattern pattern : patterns) {
			StatementPattern clone = pattern.clone();
			if (expr == null) {
				expr = clone;
			} else {
				expr = new Join(expr, clone);
			}
		}
		return expr != null ? expr : new SingletonSet();
	}

	private double fAnd(double left, double right) {
		return left * right;
	}

	private double fOptional(double left, double right) {
		return left * right * optionalMultiplier;
	}
}
