/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import java.util.Comparator;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Set;

import org.eclipse.rdf4j.common.iteration.AbstractCloseableIteration;
import org.eclipse.rdf4j.common.iteration.CloseableIteration;
import org.eclipse.rdf4j.common.order.StatementOrder;
import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Resource;
import org.eclipse.rdf4j.model.Statement;
import org.eclipse.rdf4j.model.Value;
import org.eclipse.rdf4j.model.ValueFactory;
import org.eclipse.rdf4j.query.algebra.evaluation.TripleSource;

/**
 * TripleSource wrapper that records call counts and result sizes.
 */
public class LearningTripleSource implements TripleSource {

	protected final TripleSource delegate;
	protected final JoinStatsProvider statsProvider;

	public LearningTripleSource(TripleSource delegate, JoinStatsProvider statsProvider) {
		this.delegate = Objects.requireNonNull(delegate, "delegate");
		this.statsProvider = Objects.requireNonNull(statsProvider, "statsProvider");
	}

	@Override
	public CloseableIteration<? extends Statement> getStatements(Resource subj, IRI pred, Value obj,
			Resource... contexts) {
		PatternKey key = buildKey(subj, pred, obj);
		statsProvider.recordCall(key);
		CloseableIteration<? extends Statement> base = delegate.getStatements(subj, pred, obj, contexts);
		return new CountingIteration(base, statsProvider, key);
	}

	@Override
	public CloseableIteration<? extends Statement> getStatements(StatementOrder order, Resource subj, IRI pred,
			Value obj, Resource... contexts) {
		PatternKey key = buildKey(subj, pred, obj);
		statsProvider.recordCall(key);
		CloseableIteration<? extends Statement> base = delegate.getStatements(order, subj, pred, obj, contexts);
		return new CountingIteration(base, statsProvider, key);
	}

	@Override
	public Set<StatementOrder> getSupportedOrders(Resource subj, IRI pred, Value obj, Resource... contexts) {
		return delegate.getSupportedOrders(subj, pred, obj, contexts);
	}

	@Override
	public Comparator<Value> getComparator() {
		return delegate.getComparator();
	}

	@Override
	public ValueFactory getValueFactory() {
		return delegate.getValueFactory();
	}

	protected static PatternKey buildKey(Resource subj, IRI pred, Value obj) {
		int mask = 0;
		if (subj != null) {
			mask |= PatternKey.SUBJECT_BOUND;
		}
		if (pred != null) {
			mask |= PatternKey.PREDICATE_BOUND;
		}
		if (obj != null) {
			mask |= PatternKey.OBJECT_BOUND;
		}
		return new PatternKey(pred, mask);
	}

	protected static final class CountingIteration<T> extends AbstractCloseableIteration<T> {

		private final CloseableIteration<? extends T> delegate;
		private final JoinStatsProvider statsProvider;
		private final PatternKey key;
		private long count;

		protected CountingIteration(CloseableIteration<? extends T> delegate, JoinStatsProvider statsProvider,
				PatternKey key) {
			this.delegate = delegate;
			this.statsProvider = statsProvider;
			this.key = key;
		}

		@Override
		public boolean hasNext() {
			if (isClosed()) {
				return false;
			} else if (Thread.currentThread().isInterrupted()) {
				close();
				return false;
			}
			boolean result = delegate.hasNext();
			if (!result) {
				close();
			}
			return result;
		}

		@Override
		public T next() {
			if (isClosed()) {
				throw new NoSuchElementException("The iteration has been closed.");
			} else if (Thread.currentThread().isInterrupted()) {
				close();
				throw new NoSuchElementException("The iteration has been interrupted.");
			}
			try {
				T statement = delegate.next();
				count++;
				return statement;
			} catch (NoSuchElementException e) {
				close();
				throw e;
			}
		}

		@Override
		public void remove() {
			if (isClosed()) {
				throw new IllegalStateException("The iteration has been closed.");
			} else if (Thread.currentThread().isInterrupted()) {
				close();
				throw new IllegalStateException("The iteration has been interrupted.");
			}
			try {
				delegate.remove();
			} catch (IllegalStateException e) {
				close();
				throw e;
			}
		}

		@Override
		protected void handleClose() {
			try {
				delegate.close();
			} finally {
				statsProvider.recordResults(key, count);
			}
		}
	}
}
