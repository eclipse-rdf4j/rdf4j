/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import java.util.Comparator;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.atomic.AtomicLong;

import org.eclipse.rdf4j.common.iteration.AbstractCloseableIteration;
import org.eclipse.rdf4j.common.iteration.CloseableIteration;
import org.eclipse.rdf4j.common.order.StatementOrder;
import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Resource;
import org.eclipse.rdf4j.model.Statement;
import org.eclipse.rdf4j.model.Value;
import org.eclipse.rdf4j.model.ValueFactory;
import org.eclipse.rdf4j.query.algebra.evaluation.TripleSource;

/**
 * TripleSource wrapper that records call counts and result sizes.
 */
public class LearningTripleSource implements TripleSource {

	private static final int DEFAULT_SAMPLE_RATE = 8;
	private static final int SAMPLE_RATE = Integer.getInteger("rdf4j.learned.stats.sampleRate", DEFAULT_SAMPLE_RATE);
	private static final AtomicLong SAMPLE_COUNTER = new AtomicLong();
	private static final long HOT_KEY_CALL_THRESHOLD = Long.getLong("rdf4j.learned.stats.hotKeyCalls", 256L);
	private static final double HOT_KEY_RESULT_THRESHOLD = parseDoubleProperty(
			"rdf4j.learned.stats.hotKeyResults", 100_000d);

	private static double parseDoubleProperty(String name, double defaultValue) {
		String value = System.getProperty(name);
		if (value == null) {
			return defaultValue;
		}
		try {
			return Double.parseDouble(value);
		} catch (NumberFormatException e) {
			return defaultValue;
		}
	}

	protected final TripleSource delegate;
	protected final JoinStatsProvider statsProvider;

	public LearningTripleSource(TripleSource delegate, JoinStatsProvider statsProvider) {
		this.delegate = Objects.requireNonNull(delegate, "delegate");
		this.statsProvider = Objects.requireNonNull(statsProvider, "statsProvider");
	}

	@Override
	public CloseableIteration<? extends Statement> getStatements(Resource subj, IRI pred, Value obj,
			Resource... contexts) {
		CloseableIteration<? extends Statement> base = delegate.getStatements(subj, pred, obj, contexts);
		PatternKey key = keyForRecording(subj, pred, obj);
		if (key == null) {
			return base;
		}
		return new CountingIteration<>(base, statsProvider, key);
	}

	@Override
	public CloseableIteration<? extends Statement> getStatements(StatementOrder order, Resource subj, IRI pred,
			Value obj, Resource... contexts) {
		CloseableIteration<? extends Statement> base = delegate.getStatements(order, subj, pred, obj, contexts);
		PatternKey key = keyForRecording(subj, pred, obj);
		if (key == null) {
			return base;
		}
		return new CountingIteration<>(base, statsProvider, key);
	}

	@Override
	public Set<StatementOrder> getSupportedOrders(Resource subj, IRI pred, Value obj, Resource... contexts) {
		return delegate.getSupportedOrders(subj, pred, obj, contexts);
	}

	@Override
	public Comparator<Value> getComparator() {
		return delegate.getComparator();
	}

	@Override
	public ValueFactory getValueFactory() {
		return delegate.getValueFactory();
	}

	protected static PatternKey buildKey(Resource subj, IRI pred, Value obj) {
		int mask = 0;
		if (subj != null) {
			mask |= PatternKey.SUBJECT_BOUND;
		}
		if (pred != null) {
			mask |= PatternKey.PREDICATE_BOUND;
		}
		if (obj != null) {
			mask |= PatternKey.OBJECT_BOUND;
		}
		IRI predicateKey = PatternKeys.predicateKey(pred, obj);
		return new PatternKey(predicateKey, mask);
	}

	private PatternKey keyForRecording(Resource subj, IRI pred, Value obj) {
		if (pred != null && subj == null && obj == null) {
			return null;
		}
		if (!shouldSample()) {
			return null;
		}
		PatternKey key = buildKey(subj, pred, obj);
		if (isHotKey(key)) {
			return null;
		}
		return key;
	}

	private boolean isHotKey(PatternKey key) {
		if (HOT_KEY_CALL_THRESHOLD <= 0L || HOT_KEY_RESULT_THRESHOLD <= 0.0d) {
			return false;
		}
		if (!statsProvider.hasStats(key)) {
			return false;
		}
		long calls = statsProvider.getCalls(key);
		if (calls < 0L || calls < HOT_KEY_CALL_THRESHOLD) {
			return false;
		}
		return statsProvider.getAverageResults(key) >= HOT_KEY_RESULT_THRESHOLD;
	}

	private static boolean shouldSample() {
		if (SAMPLE_RATE <= 0) {
			return false;
		}
		if (SAMPLE_RATE == 1) {
			return true;
		}
		return SAMPLE_COUNTER.getAndIncrement() % SAMPLE_RATE == 0;
	}

	protected static final class CountingIteration<T> extends AbstractCloseableIteration<T> {

		private final CloseableIteration<? extends T> delegate;
		private final JoinStatsProvider statsProvider;
		private final PatternKey key;
		private long count;
		private boolean recordedCall;
		private boolean sawHasNextTrue;

		protected CountingIteration(CloseableIteration<? extends T> delegate, JoinStatsProvider statsProvider,
				PatternKey key) {
			this.delegate = delegate;
			this.statsProvider = statsProvider;
			this.key = key;
		}

		@Override
		public boolean hasNext() {
			if (isClosed()) {
				return false;
			} else if (Thread.currentThread().isInterrupted()) {
				close();
				return false;
			}
			boolean result = delegate.hasNext();
			if (result) {
				sawHasNextTrue = true;
			}
			if (!result) {
				close();
			}
			return result;
		}

		@Override
		public T next() {
			if (isClosed()) {
				throw new NoSuchElementException("The iteration has been closed.");
			} else if (Thread.currentThread().isInterrupted()) {
				close();
				throw new NoSuchElementException("The iteration has been interrupted.");
			}
			try {
				T statement = delegate.next();
				if (!recordedCall) {
					statsProvider.recordCall(key);
					recordedCall = true;
				}
				count++;
				return statement;
			} catch (NoSuchElementException e) {
				close();
				throw e;
			}
		}

		@Override
		public void remove() {
			if (isClosed()) {
				throw new IllegalStateException("The iteration has been closed.");
			} else if (Thread.currentThread().isInterrupted()) {
				close();
				throw new IllegalStateException("The iteration has been interrupted.");
			}
			try {
				delegate.remove();
			} catch (IllegalStateException e) {
				close();
				throw e;
			}
		}

		@Override
		protected void handleClose() {
			try {
				delegate.close();
			} finally {
				if (!recordedCall) {
					if (sawHasNextTrue) {
						return;
					}
					statsProvider.recordCall(key);
					recordedCall = true;
				}
				statsProvider.recordResults(key, count);
			}
		}
	}
}
