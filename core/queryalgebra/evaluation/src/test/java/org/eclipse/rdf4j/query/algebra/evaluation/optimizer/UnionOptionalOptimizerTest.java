/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;

import org.eclipse.rdf4j.query.QueryLanguage;
import org.eclipse.rdf4j.query.algebra.Filter;
import org.eclipse.rdf4j.query.algebra.LeftJoin;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.Union;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.EvaluationStrategy;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryOptimizer;
import org.eclipse.rdf4j.query.algebra.evaluation.TripleSource;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractQueryModelVisitor;
import org.eclipse.rdf4j.query.impl.EmptyBindingSet;
import org.eclipse.rdf4j.query.parser.ParsedTupleQuery;
import org.eclipse.rdf4j.query.parser.QueryParserUtil;
import org.junit.jupiter.api.Test;

public class UnionOptionalOptimizerTest {

	private static final String UNION_OPTIONAL_ENABLED = "rdf4j.optimizer.unionOptional.enabled";
	private static final String UNION_FLATTEN_ENABLED = "rdf4j.optimizer.unionOptional.flatten.enabled";
	private static final String UNION_REORDER_ENABLED = "rdf4j.optimizer.unionOptional.unionReorder.enabled";

	@Test
	public void testUnionFlatteningEnabled() {
		String previousEnabled = System.getProperty(UNION_OPTIONAL_ENABLED);
		String previousFlatten = System.getProperty(UNION_FLATTEN_ENABLED);
		System.setProperty(UNION_OPTIONAL_ENABLED, "true");
		System.setProperty(UNION_FLATTEN_ENABLED, "true");
		try {
			TupleExpr expr = parseNestedUnion();
			runStandardPipeline(expr);
			assertThat(hasUnionWithUnionLeftArg(expr)).isFalse();
		} finally {
			restoreProperty(UNION_OPTIONAL_ENABLED, previousEnabled);
			restoreProperty(UNION_FLATTEN_ENABLED, previousFlatten);
		}
	}

	@Test
	public void testUnionFlatteningDisabled() {
		String previousEnabled = System.getProperty(UNION_OPTIONAL_ENABLED);
		String previousFlatten = System.getProperty(UNION_FLATTEN_ENABLED);
		System.setProperty(UNION_OPTIONAL_ENABLED, "false");
		System.setProperty(UNION_FLATTEN_ENABLED, "false");
		try {
			TupleExpr expr = parseNestedUnion();
			runStandardPipeline(expr);
			assertThat(hasUnionWithUnionLeftArg(expr)).isTrue();
		} finally {
			restoreProperty(UNION_OPTIONAL_ENABLED, previousEnabled);
			restoreProperty(UNION_FLATTEN_ENABLED, previousFlatten);
		}
	}

	@Test
	public void testUnionReorderEnabled() {
		String previousEnabled = System.getProperty(UNION_OPTIONAL_ENABLED);
		String previousReorder = System.getProperty(UNION_REORDER_ENABLED);
		System.setProperty(UNION_OPTIONAL_ENABLED, "true");
		System.setProperty(UNION_REORDER_ENABLED, "true");
		try {
			TupleExpr expr = parseUnionWithDifferentCosts();
			runStandardPipeline(expr);
			Union union = firstUnion(expr);
			StatementPattern left = (StatementPattern) union.getLeftArg();
			assertThat(left.getSubjectVar().hasValue()).isTrue();
			assertThat(left.getPredicateVar().hasValue()).isTrue();
			assertThat(left.getObjectVar().hasValue()).isTrue();
		} finally {
			restoreProperty(UNION_OPTIONAL_ENABLED, previousEnabled);
			restoreProperty(UNION_REORDER_ENABLED, previousReorder);
		}
	}

	@Test
	public void testUnionReorderDisabled() {
		String previousEnabled = System.getProperty(UNION_OPTIONAL_ENABLED);
		String previousReorder = System.getProperty(UNION_REORDER_ENABLED);
		System.setProperty(UNION_OPTIONAL_ENABLED, "false");
		System.setProperty(UNION_REORDER_ENABLED, "false");
		try {
			TupleExpr expr = parseUnionWithDifferentCosts();
			runStandardPipeline(expr);
			Union union = firstUnion(expr);
			StatementPattern left = (StatementPattern) union.getLeftArg();
			assertThat(left.getSubjectVar().hasValue()).isFalse();
			assertThat(left.getPredicateVar().hasValue()).isFalse();
			assertThat(left.getObjectVar().hasValue()).isFalse();
		} finally {
			restoreProperty(UNION_OPTIONAL_ENABLED, previousEnabled);
			restoreProperty(UNION_REORDER_ENABLED, previousReorder);
		}
	}

	@Test
	public void testUnionReorderSkipsLowConfidence() {
		StatementPattern left = statementPatternWithCardinality(10.0);
		StatementPattern right = statementPatternWithCardinality(9.0);
		Union union = new Union(left, right);

		new UnionReorderOptimizer(new EvaluationStatistics())
				.optimize(union, null, EmptyBindingSet.getInstance());

		assertThat(union.getLeftArg()).isSameAs(left);
	}

	@Test
	public void testUnionReorderSkipsSmallWork() {
		StatementPattern left = statementPatternWithCardinality(100.0);
		StatementPattern right = statementPatternWithCardinality(1.0);
		Union union = new Union(left, right);

		new UnionReorderOptimizer(new EvaluationStatistics())
				.optimize(union, null, EmptyBindingSet.getInstance());

		assertThat(union.getLeftArg()).isSameAs(left);
	}

	@Test
	public void testUnionDuplicatesPreserved() {
		String previousEnabled = System.getProperty(UNION_OPTIONAL_ENABLED);
		String previousFlatten = System.getProperty(UNION_FLATTEN_ENABLED);
		String previousReorder = System.getProperty(UNION_REORDER_ENABLED);
		System.setProperty(UNION_OPTIONAL_ENABLED, "true");
		System.setProperty(UNION_FLATTEN_ENABLED, "true");
		System.setProperty(UNION_REORDER_ENABLED, "true");
		try {
			TupleExpr expr = parseUnionWithDuplicateArms();
			runStandardPipeline(expr);
			assertThat(countStatementPatterns(expr)).isEqualTo(2);
		} finally {
			restoreProperty(UNION_OPTIONAL_ENABLED, previousEnabled);
			restoreProperty(UNION_FLATTEN_ENABLED, previousFlatten);
			restoreProperty(UNION_REORDER_ENABLED, previousReorder);
		}
	}

	@Test
	public void testUnionFilterArmStaysScoped() {
		TupleExpr expr = parseUnionFilterInside();
		runStandardPipeline(expr);
		Union union = firstUnion(expr);
		assertThat(union.getParentNode()).isNotInstanceOf(Filter.class);
		assertThat(containsFilter(union)).isTrue();
	}

	@Test
	public void testOptionalCorrelationPreserved() {
		TupleExpr expr = parseOptionalCorrelation();
		runStandardPipeline(expr);
		LeftJoin leftJoin = firstLeftJoin(expr);
		assertThat(containsVar(leftJoin.getLeftArg(), "s")).isTrue();
		assertThat(containsVar(leftJoin.getRightArg(), "s")).isTrue();
	}

	@Test
	public void testOptionalFilterOutsideStaysOutside() {
		TupleExpr expr = parseOptionalFilterOutside();
		runStandardPipeline(expr);
		LeftJoin leftJoin = firstLeftJoin(expr);
		assertThat(leftJoin.getParentNode()).isInstanceOf(Filter.class);
	}

	@Test
	public void testOptionalFilterInsideStaysInside() {
		TupleExpr expr = parseOptionalFilterInside();
		runStandardPipeline(expr);
		LeftJoin leftJoin = firstLeftJoin(expr);
		assertThat(containsFilter(leftJoin.getRightArg())).isTrue();
	}

	private static TupleExpr parseNestedUnion() {
		String query = String.join(System.lineSeparator(),
				"SELECT * WHERE {",
				"  { { ?s <http://example.com/p1> ?x } UNION { ?s <http://example.com/p2> ?y } }",
				"  UNION",
				"  { ?s <http://example.com/p3> ?z }",
				"}");
		ParsedTupleQuery parsed = QueryParserUtil.parseTupleQuery(QueryLanguage.SPARQL, query, null);
		return parsed.getTupleExpr();
	}

	private static TupleExpr parseUnionWithDifferentCosts() {
		String query = String.join(System.lineSeparator(),
				"SELECT * WHERE {",
				"  { ?s ?p ?o }",
				"  UNION",
				"  { <http://example.com/s1> <http://example.com/p1> <http://example.com/o1> }",
				"}");
		ParsedTupleQuery parsed = QueryParserUtil.parseTupleQuery(QueryLanguage.SPARQL, query, null);
		return parsed.getTupleExpr();
	}

	private static TupleExpr parseOptionalFilterOutside() {
		String query = String.join(System.lineSeparator(),
				"SELECT * WHERE {",
				"  ?s <http://example.com/p1> ?x .",
				"  OPTIONAL { ?s <http://example.com/p2> ?y . }",
				"  FILTER(?y < 5)",
				"}");
		ParsedTupleQuery parsed = QueryParserUtil.parseTupleQuery(QueryLanguage.SPARQL, query, null);
		return parsed.getTupleExpr();
	}

	private static TupleExpr parseOptionalFilterInside() {
		String query = String.join(System.lineSeparator(),
				"SELECT * WHERE {",
				"  ?s <http://example.com/p1> ?x .",
				"  OPTIONAL { ?s <http://example.com/p2> ?y . FILTER(?y < 5) }",
				"}");
		ParsedTupleQuery parsed = QueryParserUtil.parseTupleQuery(QueryLanguage.SPARQL, query, null);
		return parsed.getTupleExpr();
	}

	private static TupleExpr parseUnionWithDuplicateArms() {
		String query = String.join(System.lineSeparator(),
				"SELECT * WHERE {",
				"  { ?s <http://example.com/p1> ?x }",
				"  UNION",
				"  { ?s <http://example.com/p1> ?x }",
				"}");
		ParsedTupleQuery parsed = QueryParserUtil.parseTupleQuery(QueryLanguage.SPARQL, query, null);
		return parsed.getTupleExpr();
	}

	private static TupleExpr parseUnionFilterInside() {
		String query = String.join(System.lineSeparator(),
				"SELECT * WHERE {",
				"  { ?s <http://example.com/p1> ?x }",
				"  UNION",
				"  { ?s <http://example.com/p2> ?y . FILTER(?y < 5) }",
				"}");
		ParsedTupleQuery parsed = QueryParserUtil.parseTupleQuery(QueryLanguage.SPARQL, query, null);
		return parsed.getTupleExpr();
	}

	private static TupleExpr parseOptionalCorrelation() {
		String query = String.join(System.lineSeparator(),
				"SELECT * WHERE {",
				"  ?s <http://example.com/p1> ?x .",
				"  OPTIONAL { ?s <http://example.com/p2> ?y . }",
				"}");
		ParsedTupleQuery parsed = QueryParserUtil.parseTupleQuery(QueryLanguage.SPARQL, query, null);
		return parsed.getTupleExpr();
	}

	private static void runStandardPipeline(TupleExpr expr) {
		StandardQueryOptimizerPipeline pipeline = new StandardQueryOptimizerPipeline(
				mock(EvaluationStrategy.class),
				mock(TripleSource.class),
				new EvaluationStatistics());
		for (QueryOptimizer optimizer : pipeline.getOptimizers()) {
			optimizer.optimize(expr, null, EmptyBindingSet.getInstance());
		}
	}

	private static boolean hasUnionWithUnionLeftArg(TupleExpr expr) {
		UnionLeftArgChecker checker = new UnionLeftArgChecker();
		expr.visit(checker);
		return checker.hasUnionWithUnionLeftArg;
	}

	private static Union firstUnion(TupleExpr expr) {
		FirstUnionCollector collector = new FirstUnionCollector();
		expr.visit(collector);
		return collector.union;
	}

	private static LeftJoin firstLeftJoin(TupleExpr expr) {
		FirstLeftJoinCollector collector = new FirstLeftJoinCollector();
		expr.visit(collector);
		return collector.leftJoin;
	}

	private static boolean containsFilter(TupleExpr expr) {
		FilterCollector collector = new FilterCollector();
		expr.visit(collector);
		return collector.foundFilter;
	}

	private static int countStatementPatterns(TupleExpr expr) {
		StatementPatternCounter counter = new StatementPatternCounter();
		expr.visit(counter);
		return counter.count;
	}

	private static boolean containsVar(TupleExpr expr, String name) {
		VarNameCollector collector = new VarNameCollector(name);
		expr.visit(collector);
		return collector.foundVar;
	}

	private static void restoreProperty(String key, String value) {
		if (value == null) {
			System.clearProperty(key);
		} else {
			System.setProperty(key, value);
		}
	}

	private static StatementPattern statementPatternWithCardinality(double cardinality) {
		StatementPattern pattern = new StatementPattern(new Var("s"), new Var("p"), new Var("o"));
		pattern.setCardinality(cardinality);
		return pattern;
	}

	private static final class UnionLeftArgChecker extends AbstractQueryModelVisitor<RuntimeException> {
		private boolean hasUnionWithUnionLeftArg = false;

		@Override
		public void meet(Union union) {
			if (union.getLeftArg() instanceof Union) {
				hasUnionWithUnionLeftArg = true;
			}
			super.meet(union);
		}
	}

	private static final class FirstUnionCollector extends AbstractQueryModelVisitor<RuntimeException> {
		private Union union;

		@Override
		public void meet(Union node) {
			if (union == null) {
				union = node;
			}
			super.meet(node);
		}
	}

	private static final class FirstLeftJoinCollector extends AbstractQueryModelVisitor<RuntimeException> {
		private LeftJoin leftJoin;

		@Override
		public void meet(LeftJoin node) {
			if (leftJoin == null) {
				leftJoin = node;
			}
			super.meet(node);
		}
	}

	private static final class FilterCollector extends AbstractQueryModelVisitor<RuntimeException> {
		private boolean foundFilter = false;

		@Override
		public void meet(Filter node) {
			foundFilter = true;
			super.meet(node);
		}
	}

	private static final class StatementPatternCounter extends AbstractQueryModelVisitor<RuntimeException> {
		private int count = 0;

		@Override
		public void meet(StatementPattern node) {
			count++;
			super.meet(node);
		}
	}

	private static final class VarNameCollector extends AbstractQueryModelVisitor<RuntimeException> {
		private final String name;
		private boolean foundVar = false;

		private VarNameCollector(String name) {
			this.name = name;
		}

		@Override
		public void meet(Var var) {
			if (name.equals(var.getName())) {
				foundVar = true;
			}
		}
	}
}
