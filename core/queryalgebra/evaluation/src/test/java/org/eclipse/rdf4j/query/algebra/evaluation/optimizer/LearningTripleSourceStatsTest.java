/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Set;

import org.eclipse.rdf4j.common.iteration.CloseableIteration;
import org.eclipse.rdf4j.common.iteration.CloseableIteratorIteration;
import org.eclipse.rdf4j.common.order.StatementOrder;
import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Resource;
import org.eclipse.rdf4j.model.Statement;
import org.eclipse.rdf4j.model.Value;
import org.eclipse.rdf4j.model.ValueFactory;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.query.QueryEvaluationException;
import org.eclipse.rdf4j.query.algebra.evaluation.TripleSource;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.MemoryJoinStats.InvalidationSettings;
import org.junit.jupiter.api.Test;

class LearningTripleSourceStatsTest {

	private static final ValueFactory VF = SimpleValueFactory.getInstance();
	private static final IRI PREDICATE = VF.createIRI("urn:test:pred");

	@Test
	void existsShortCircuitDoesNotRecordStats() throws QueryEvaluationException {
		MemoryJoinStats stats = new MemoryJoinStats(InvalidationSettings.disabled());
		LearningTripleSource source = new LearningTripleSource(new StubTripleSource(3, PREDICATE), stats);

		try (CloseableIteration<? extends Statement> iter = source.getStatements(null, PREDICATE, null)) {
			assertTrue(iter.hasNext(), "Expected at least one statement");
		}

		PatternKey key = new PatternKey(PREDICATE, PatternKey.PREDICATE_BOUND);
		assertFalse(stats.hasStats(key), "EXISTS-style checks should not seed learned stats");
	}

	@Test
	void iterationRecordsFullCounts() throws QueryEvaluationException {
		MemoryJoinStats stats = new MemoryJoinStats(InvalidationSettings.disabled());
		LearningTripleSource source = new LearningTripleSource(new StubTripleSource(3, PREDICATE), stats);

		try (CloseableIteration<? extends Statement> iter = source.getStatements(null, PREDICATE, null)) {
			while (iter.hasNext()) {
				iter.next();
			}
		}

		PatternKey key = new PatternKey(PREDICATE, PatternKey.PREDICATE_BOUND);
		assertTrue(stats.hasStats(key), "Expected learned stats for fully iterated patterns");
		assertEquals(3.0d, stats.getAverageResults(key));
	}

	private static final class StubTripleSource implements TripleSource {
		private final List<Statement> statements;
		private final ValueFactory valueFactory = SimpleValueFactory.getInstance();

		private StubTripleSource(int count, IRI predicate) {
			this.statements = new ArrayList<>(count);
			for (int i = 0; i < count; i++) {
				IRI subject = valueFactory.createIRI("urn:test:s" + i);
				IRI object = valueFactory.createIRI("urn:test:o" + i);
				statements.add(valueFactory.createStatement(subject, predicate, object));
			}
		}

		@Override
		public CloseableIteration<? extends Statement> getStatements(Resource subj, IRI pred, Value obj,
				Resource... contexts) {
			return new CloseableIteratorIteration<>(statements.iterator());
		}

		@Override
		public CloseableIteration<? extends Statement> getStatements(StatementOrder order, Resource subj, IRI pred,
				Value obj, Resource... contexts) {
			return getStatements(subj, pred, obj, contexts);
		}

		@Override
		public Set<StatementOrder> getSupportedOrders(Resource subj, IRI pred, Value obj, Resource... contexts) {
			return Set.of();
		}

		@Override
		public ValueFactory getValueFactory() {
			return valueFactory;
		}

		@Override
		public Comparator<Value> getComparator() {
			return Comparator.comparing(Value::stringValue);
		}
	}
}
