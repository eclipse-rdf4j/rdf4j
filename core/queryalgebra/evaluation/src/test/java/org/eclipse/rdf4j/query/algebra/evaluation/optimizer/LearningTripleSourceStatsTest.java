/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Set;

import org.eclipse.rdf4j.common.iteration.CloseableIteration;
import org.eclipse.rdf4j.common.iteration.CloseableIteratorIteration;
import org.eclipse.rdf4j.common.order.StatementOrder;
import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Resource;
import org.eclipse.rdf4j.model.Statement;
import org.eclipse.rdf4j.model.Value;
import org.eclipse.rdf4j.model.ValueFactory;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.query.QueryEvaluationException;
import org.eclipse.rdf4j.query.algebra.evaluation.TripleSource;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.MemoryJoinStats.InvalidationSettings;
import org.junit.jupiter.api.Test;

class LearningTripleSourceStatsTest {

	private static final ValueFactory VF = SimpleValueFactory.getInstance();
	private static final IRI PREDICATE = VF.createIRI("urn:test:pred");

	@Test
	void existsShortCircuitDoesNotRecordStats() throws QueryEvaluationException {
		MemoryJoinStats stats = new MemoryJoinStats(InvalidationSettings.disabled());
		LearningTripleSource source = new LearningTripleSource(new StubTripleSource(3, PREDICATE), stats);

		try (CloseableIteration<? extends Statement> iter = source.getStatements(null, PREDICATE, null)) {
			assertTrue(iter.hasNext(), "Expected at least one statement");
		}

		PatternKey key = new PatternKey(PREDICATE, PatternKey.PREDICATE_BOUND);
		assertFalse(stats.hasStats(key), "EXISTS-style checks should not seed learned stats");
	}

	@Test
	void predicateOnlyPatternsSkipStats() throws QueryEvaluationException {
		MemoryJoinStats stats = new MemoryJoinStats(InvalidationSettings.disabled());
		LearningTripleSource source = new LearningTripleSource(new StubTripleSource(3, PREDICATE), stats);

		for (int i = 0; i < 32; i++) {
			try (CloseableIteration<? extends Statement> iter = source.getStatements(null, PREDICATE, null)) {
				while (iter.hasNext()) {
					iter.next();
				}
			}
		}

		PatternKey key = new PatternKey(PREDICATE, PatternKey.PREDICATE_BOUND);
		assertFalse(stats.hasStats(key), "Predicate-only patterns should not record learned stats");
	}

	@Test
	void hotKeySkipsRecording() throws QueryEvaluationException {
		HotKeyJoinStatsProvider stats = new HotKeyJoinStatsProvider();
		LearningTripleSource source = new LearningTripleSource(new StubTripleSource(3, PREDICATE), stats);
		Resource subject = VF.createIRI("urn:test:s0");

		for (int i = 0; i < 8; i++) {
			try (CloseableIteration<? extends Statement> iter = source.getStatements(subject, PREDICATE, null)) {
				while (iter.hasNext()) {
					iter.next();
				}
			}
		}

		assertEquals(0, stats.recordedCalls(), "Hot keys should skip stats recording");
		assertEquals(0, stats.recordedResults(), "Hot keys should skip stats recording");
	}

	@Test
	void iterationRecordsFullCounts() throws QueryEvaluationException {
		MemoryJoinStats stats = new MemoryJoinStats(InvalidationSettings.disabled());
		LearningTripleSource source = new LearningTripleSource(new StubTripleSource(3, PREDICATE), stats);
		Resource subject = VF.createIRI("urn:test:s0");

		for (int i = 0; i < 32; i++) {
			try (CloseableIteration<? extends Statement> iter = source.getStatements(subject, PREDICATE, null)) {
				while (iter.hasNext()) {
					iter.next();
				}
			}
		}

		PatternKey key = new PatternKey(PREDICATE, PatternKey.SUBJECT_BOUND | PatternKey.PREDICATE_BOUND);
		assertTrue(stats.hasStats(key), "Expected learned stats for fully iterated patterns");
		assertEquals(3.0d, stats.getAverageResults(key));
	}

	private static final class StubTripleSource implements TripleSource {
		private final List<Statement> statements;
		private final ValueFactory valueFactory = SimpleValueFactory.getInstance();

		private StubTripleSource(int count, IRI predicate) {
			this.statements = new ArrayList<>(count);
			for (int i = 0; i < count; i++) {
				IRI subject = valueFactory.createIRI("urn:test:s" + i);
				IRI object = valueFactory.createIRI("urn:test:o" + i);
				statements.add(valueFactory.createStatement(subject, predicate, object));
			}
		}

		@Override
		public CloseableIteration<? extends Statement> getStatements(Resource subj, IRI pred, Value obj,
				Resource... contexts) {
			return new CloseableIteratorIteration<>(statements.iterator());
		}

		@Override
		public CloseableIteration<? extends Statement> getStatements(StatementOrder order, Resource subj, IRI pred,
				Value obj, Resource... contexts) {
			return getStatements(subj, pred, obj, contexts);
		}

		@Override
		public Set<StatementOrder> getSupportedOrders(Resource subj, IRI pred, Value obj, Resource... contexts) {
			return Set.of();
		}

		@Override
		public ValueFactory getValueFactory() {
			return valueFactory;
		}

		@Override
		public Comparator<Value> getComparator() {
			return Comparator.comparing(Value::stringValue);
		}
	}

	private static final class HotKeyJoinStatsProvider implements JoinStatsProvider {
		private int calls;
		private int results;

		@Override
		public void reset() {
			calls = 0;
			results = 0;
		}

		@Override
		public void recordCall(PatternKey key) {
			calls++;
		}

		@Override
		public void recordResults(PatternKey key, long resultCount) {
			results++;
		}

		@Override
		public void seedIfAbsent(PatternKey key, double defaultCardinality, long priorCalls) {
		}

		@Override
		public double getAverageResults(PatternKey key) {
			return Double.MAX_VALUE;
		}

		@Override
		public boolean hasStats(PatternKey key) {
			return true;
		}

		@Override
		public long getCalls(PatternKey key) {
			return Long.MAX_VALUE;
		}

		@Override
		public long getTotalCalls() {
			return calls;
		}

		private int recordedCalls() {
			return calls;
		}

		private int recordedResults() {
			return results;
		}
	}
}
