/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.impl;

import static org.assertj.core.api.Assertions.assertThat;

import java.util.List;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;

import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.algebra.And;
import org.eclipse.rdf4j.query.algebra.BinaryValueOperator;
import org.eclipse.rdf4j.query.algebra.BindingSetAssignment;
import org.eclipse.rdf4j.query.algebra.Compare;
import org.eclipse.rdf4j.query.algebra.Exists;
import org.eclipse.rdf4j.query.algebra.Filter;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.NAryValueOperator;
import org.eclipse.rdf4j.query.algebra.QueryRoot;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.UnaryValueOperator;
import org.eclipse.rdf4j.query.algebra.ValueExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.SparqlUoQueryOptimizerPipeline;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.sparqluo.SparqlUoConfig;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractQueryModelVisitor;
import org.eclipse.rdf4j.query.impl.EmptyBindingSet;
import org.eclipse.rdf4j.query.impl.ListBindingSet;
import org.junit.jupiter.api.Test;

class SparqlUoBindingSetAssignmentJoinOrderTest {

	@Test
	void avoidsCrossProductOfValuesBeforeStatementPattern() {
		IRI follows = SimpleValueFactory.getInstance().createIRI("urn:follows");

		BindingSetAssignment uValues = createValues("u", "urn:u1", "urn:u2", "urn:u3", "urn:u4");
		BindingSetAssignment vValues = createValues("v", "urn:v1", "urn:v2", "urn:v3", "urn:v4");

		StatementPattern followsPattern = new StatementPattern(
				new Var("u"),
				new Var("pFollows", follows),
				new Var("v"));
		Join valuesCrossProduct = new Join(uValues, vValues);
		Join join = new Join(valuesCrossProduct, followsPattern);

		Exists reciprocal = new Exists(new StatementPattern(
				new Var("v"),
				new Var("pReciprocal", follows),
				new Var("u")));
		Compare neq = new Compare(new Var("u"), new Var("v"), Compare.CompareOp.NE);

		TupleExpr expr = new QueryRoot(new Filter(join, new And(reciprocal, neq)));

		optimize(expr);

		assertThat(containsCartesianJoinBetweenValues(expr)).isFalse();
		assertThat(containsExistsFilterOnStatementPattern(expr, follows)).isTrue();
	}

	private static BindingSetAssignment createValues(String name, String... values) {
		List<BindingSet> bindingSets = List.of(values)
				.stream()
				.map(SimpleValueFactory.getInstance()::createIRI)
				.map(iri -> (BindingSet) new ListBindingSet(List.of(name), iri))
				.toList();
		BindingSetAssignment assignment = new BindingSetAssignment();
		assignment.setBindingNames(Set.of(name));
		assignment.setBindingSets(bindingSets);
		return assignment;
	}

	private static void optimize(TupleExpr expr) {
		EmptyTripleSource tripleSource = new EmptyTripleSource();
		EvaluationStatistics evaluationStatistics = new EvaluationStatistics() {
			@Override
			public double getCardinality(TupleExpr tupleExpr) {
				if (tupleExpr instanceof StatementPattern) {
					return 100_000.0;
				}
				return super.getCardinality(tupleExpr);
			}
		};
		DefaultEvaluationStrategy strategy = new DefaultEvaluationStrategy(tripleSource, null, null, 0L,
				evaluationStatistics);
		SparqlUoConfig config = SparqlUoConfig.builder()
				.enableOptionalFilterJoin(false)
				.build();
		strategy.setOptimizerPipeline(
				new SparqlUoQueryOptimizerPipeline(strategy, tripleSource, evaluationStatistics, config));
		strategy.optimize(expr, evaluationStatistics, EmptyBindingSet.getInstance());
	}

	private static boolean containsDirectValuesToStatementPatternJoin(TupleExpr expr, IRI predicate) {
		AtomicBoolean found = new AtomicBoolean(false);
		expr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			public void meet(Join node) throws RuntimeException {
				if (found.get()) {
					return;
				}

				StatementPattern statementPattern = null;
				if (node.getLeftArg() instanceof StatementPattern
						&& node.getRightArg() instanceof BindingSetAssignment) {
					statementPattern = (StatementPattern) node.getLeftArg();
				} else if (node.getRightArg() instanceof StatementPattern
						&& node.getLeftArg() instanceof BindingSetAssignment) {
					statementPattern = (StatementPattern) node.getRightArg();
				}

				if (statementPattern != null) {
					Var predicateVar = statementPattern.getPredicateVar();
					if (predicateVar != null && predicateVar.hasValue() && predicateVar.getValue().equals(predicate)) {
						found.set(true);
					}
				}

				super.meet(node);
			}
		});
		return found.get();
	}

	private static boolean containsCartesianJoinBetweenValues(TupleExpr expr) {
		AtomicBoolean found = new AtomicBoolean(false);
		expr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			public void meet(Join node) throws RuntimeException {
				if (found.get()) {
					return;
				}

				if (node.getLeftArg() instanceof BindingSetAssignment
						&& node.getRightArg() instanceof BindingSetAssignment) {
					BindingSetAssignment left = (BindingSetAssignment) node.getLeftArg();
					BindingSetAssignment right = (BindingSetAssignment) node.getRightArg();
					if (isDisjoint(left.getBindingNames(), right.getBindingNames())) {
						found.set(true);
						return;
					}
				}

				super.meet(node);
			}
		});
		return found.get();
	}

	private static boolean isDisjoint(Set<String> left, Set<String> right) {
		for (String name : left) {
			if (right.contains(name)) {
				return false;
			}
		}
		return true;
	}

	private static boolean containsExistsFilterOnStatementPattern(TupleExpr expr, IRI predicate) {
		AtomicBoolean found = new AtomicBoolean(false);
		expr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			public void meet(Filter node) throws RuntimeException {
				if (found.get()) {
					return;
				}
				if (!(node.getArg() instanceof StatementPattern)) {
					return;
				}
				StatementPattern statementPattern = (StatementPattern) node.getArg();
				Var predicateVar = statementPattern.getPredicateVar();
				if (predicateVar == null || !predicateVar.hasValue() || !predicateVar.getValue().equals(predicate)) {
					return;
				}
				if (!containsExists(node.getCondition())) {
					return;
				}
				found.set(true);
			}
		});
		return found.get();
	}

	private static boolean containsExists(ValueExpr expr) {
		if (expr == null) {
			return false;
		}
		if (expr instanceof Exists) {
			return true;
		}
		if (expr instanceof UnaryValueOperator) {
			return containsExists(((UnaryValueOperator) expr).getArg());
		}
		if (expr instanceof BinaryValueOperator) {
			BinaryValueOperator binary = (BinaryValueOperator) expr;
			return containsExists(binary.getLeftArg()) || containsExists(binary.getRightArg());
		}
		if (expr instanceof NAryValueOperator) {
			for (ValueExpr arg : ((NAryValueOperator) expr).getArguments()) {
				if (containsExists(arg)) {
					return true;
				}
			}
		}
		return false;
	}
}
