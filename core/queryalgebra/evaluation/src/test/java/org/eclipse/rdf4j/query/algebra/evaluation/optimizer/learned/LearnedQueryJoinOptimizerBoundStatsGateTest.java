/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned;

import static org.junit.jupiter.api.Assertions.assertTrue;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Set;

import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EmptyTripleSource;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.JoinStatsProvider;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.LearnedQueryJoinOptimizer;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.PatternKey;
import org.eclipse.rdf4j.query.impl.EmptyBindingSet;
import org.junit.jupiter.api.Test;

class LearnedQueryJoinOptimizerBoundStatsGateTest {

	private static final IRI PREDICATE = SimpleValueFactory.getInstance().createIRI("urn:test:pred");

	@Test
	void learnedStatsGateConsidersInitialBindings() throws Exception {
		LearnedQueryJoinOptimizer optimizer = new LearnedQueryJoinOptimizer(new EvaluationStatistics(),
				new EmptyTripleSource(), new AlwaysStatsProvider());
		Object visitor = newLearnedJoinVisitor(optimizer);

		TupleExpr first = pattern("b", "c");
		TupleExpr second = pattern("a", "b");

		boolean hasStats = hasLearnedStats(visitor, List.of(first, second), Set.of("b"));
		assertTrue(hasStats, "Expected learned stats when initial bindings make patterns bound");
	}

	private static TupleExpr pattern(String subjectName, String objectName) {
		return new StatementPattern(Var.of(subjectName), Var.of("_const_p", PREDICATE), Var.of(objectName));
	}

	private static Object newLearnedJoinVisitor(LearnedQueryJoinOptimizer optimizer) throws Exception {
		Class<?> visitorClass = Class.forName(LearnedQueryJoinOptimizer.class.getName() + "$LearnedJoinVisitor");
		Constructor<?> ctor = visitorClass.getDeclaredConstructor(LearnedQueryJoinOptimizer.class, Dataset.class,
				BindingSet.class);
		ctor.setAccessible(true);
		return ctor.newInstance(optimizer, null, EmptyBindingSet.getInstance());
	}

	private static boolean hasLearnedStats(Object visitor, List<TupleExpr> plan, Set<String> boundVars)
			throws Exception {
		Method method = visitor.getClass().getDeclaredMethod("hasLearnedStats", List.class, Set.class);
		method.setAccessible(true);
		return (boolean) method.invoke(visitor, plan, boundVars);
	}

	private static final class AlwaysStatsProvider implements JoinStatsProvider {

		@Override
		public void reset() {
		}

		@Override
		public void recordCall(PatternKey key) {
		}

		@Override
		public void recordResults(PatternKey key, long resultCount) {
		}

		@Override
		public void seedIfAbsent(PatternKey key, double defaultCardinality, long priorCalls) {
		}

		@Override
		public double getAverageResults(PatternKey key) {
			return 1.0d;
		}

		@Override
		public boolean hasStats(PatternKey key) {
			return true;
		}

		@Override
		public long getTotalCalls() {
			return 0;
		}
	}
}
