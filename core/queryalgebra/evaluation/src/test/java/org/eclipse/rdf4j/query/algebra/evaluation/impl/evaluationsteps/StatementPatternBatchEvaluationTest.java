/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.impl.evaluationsteps;

import static org.assertj.core.api.Assertions.assertThat;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

import org.eclipse.rdf4j.common.iteration.CloseableIteration;
import org.eclipse.rdf4j.common.iteration.CloseableIteratorIteration;
import org.eclipse.rdf4j.common.iteration.Iterations;
import org.eclipse.rdf4j.common.order.StatementOrder;
import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Resource;
import org.eclipse.rdf4j.model.Statement;
import org.eclipse.rdf4j.model.Value;
import org.eclipse.rdf4j.model.ValueFactory;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.MutableBindingSet;
import org.eclipse.rdf4j.query.QueryEvaluationException;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryBindingSet;
import org.eclipse.rdf4j.query.algebra.evaluation.TripleSource;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.QueryEvaluationContext;
import org.junit.jupiter.api.Test;

class StatementPatternBatchEvaluationTest {

	@Test
	@SuppressWarnings("unchecked")
	void evaluateBatchUsesBulkTripleSourceWhenAvailable() throws Exception {
		Class<?> bulkClass = Class.forName("org.eclipse.rdf4j.query.algebra.evaluation.BulkTripleSource");
		ValueFactory vf = SimpleValueFactory.getInstance();
		AtomicInteger batchCalls = new AtomicInteger();
		AtomicInteger singleCalls = new AtomicInteger();

		List<Statement> statements = List.of(
				vf.createStatement(vf.createIRI("urn:s1"), vf.createIRI("urn:p"), vf.createIRI("urn:o1")),
				vf.createStatement(vf.createIRI("urn:s2"), vf.createIRI("urn:p"), vf.createIRI("urn:o2"))
		);

		InvocationHandler handler = (proxy, method, args) -> {
			String name = method.getName();
			if (method.getDeclaringClass() == Object.class) {
				return method.invoke(this, args);
			}
			if (name.equals("getStatementsBatch")) {
				batchCalls.incrementAndGet();
				StatementPattern pattern = (StatementPattern) args[0];
				Iterable<BindingSet> bindings = (Iterable<BindingSet>) args[1];
				Resource[] contexts = (Resource[]) args[2];
				StatementOrder order = (StatementOrder) args[3];
				return batchEvaluate(pattern, bindings, statements, contexts, order);
			}
			if (name.equals("getStatements")) {
				singleCalls.incrementAndGet();
				return new CloseableIteratorIteration<>(List.<Statement>of().iterator());
			}
			if (name.equals("getSupportedOrders")) {
				return java.util.Set.of();
			}
			if (name.equals("getValueFactory")) {
				return vf;
			}
			throw new UnsupportedOperationException("Unexpected method: " + name);
		};

		Object proxy = Proxy.newProxyInstance(
				StatementPatternBatchEvaluationTest.class.getClassLoader(),
				new Class<?>[] { bulkClass, TripleSource.class },
				handler);
		TripleSource tripleSource = (TripleSource) proxy;

		StatementPattern pattern = new StatementPattern(
				new Var("s"),
				new Var("p", vf.createIRI("urn:p")),
				new Var("o"));
		QueryEvaluationContext context = new QueryEvaluationContext.Minimal((org.eclipse.rdf4j.query.Dataset) null);
		StatementPatternQueryEvaluationStep step = new StatementPatternQueryEvaluationStep(pattern, context,
				tripleSource);

		Method evaluateBatch = step.getClass().getMethod("evaluateBatch", Iterable.class);
		List<BindingSet> bindings = List.of(binding("s", vf.createIRI("urn:s1")),
				binding("s", vf.createIRI("urn:s2")));

		try (CloseableIteration<BindingSet> iteration = (CloseableIteration<BindingSet>) evaluateBatch.invoke(step,
				bindings)) {
			List<BindingSet> results = Iterations.asList(iteration);
			assertThat(results).hasSize(2);
			assertThat(results).allSatisfy(result -> assertThat(result.getValue("o")).isNotNull());
		}

		assertThat(batchCalls.get()).isEqualTo(1);
		assertThat(singleCalls.get()).isZero();
	}

	private static CloseableIteration<BindingSet> batchEvaluate(StatementPattern pattern,
			Iterable<BindingSet> bindings,
			List<Statement> statements,
			Resource[] contexts,
			StatementOrder order) throws QueryEvaluationException {
		List<BindingSet> results = new ArrayList<>();
		IRI expectedPredicate = (IRI) pattern.getPredicateVar().getValue();
		for (BindingSet bindingSet : bindings) {
			Value subj = bindingSet.getValue("s");
			for (Statement statement : statements) {
				if (subj != null && !subj.equals(statement.getSubject())) {
					continue;
				}
				if (!statement.getPredicate().equals(expectedPredicate)) {
					continue;
				}
				QueryBindingSet result = new QueryBindingSet(bindingSet);
				result.addBinding("o", statement.getObject());
				results.add(result);
			}
		}
		return new CloseableIteratorIteration<>(results.iterator());
	}

	private static BindingSet binding(String name, Value value) {
		MutableBindingSet bindingSet = new QueryBindingSet();
		bindingSet.addBinding(name, value);
		return bindingSet;
	}
}
