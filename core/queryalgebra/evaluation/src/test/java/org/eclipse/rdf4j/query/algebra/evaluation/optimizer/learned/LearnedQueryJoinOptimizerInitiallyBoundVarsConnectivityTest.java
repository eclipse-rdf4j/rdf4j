/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned;

import static org.junit.jupiter.api.Assertions.assertTrue;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Set;

import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.ValueFactory;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EmptyTripleSource;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.JoinStatsProvider;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.LearnedQueryJoinOptimizer;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.MemoryJoinStats;
import org.eclipse.rdf4j.query.impl.EmptyBindingSet;
import org.junit.jupiter.api.Test;

class LearnedQueryJoinOptimizerInitiallyBoundVarsConnectivityTest {

	private static final ValueFactory VF = SimpleValueFactory.getInstance();

	@Test
	void connectivityGateAccountsForInitiallyBoundVars() throws Exception {
		EvaluationStatistics stats = new EvaluationStatistics();
		JoinStatsProvider statsProvider = new MemoryJoinStats(MemoryJoinStats.InvalidationSettings.disabled());
		LearnedQueryJoinOptimizer optimizer = new LearnedQueryJoinOptimizer(stats, new EmptyTripleSource(),
				statsProvider);

		TupleExpr first = pattern("x", "a", VF.createIRI("urn:p1"));
		TupleExpr second = pattern("y", "b", VF.createIRI("urn:p2"));

		boolean connected = isConnectedPlan(newLearnedJoinVisitor(optimizer), List.of(first, second),
				Set.of("x", "y"));
		assertTrue(connected, "Expected connectivity through initially bound vars");
	}

	private static TupleExpr pattern(String subjectName, String objectName, IRI predicate) {
		return new StatementPattern(Var.of(subjectName), Var.of("_const_p", predicate), Var.of(objectName));
	}

	private static Object newLearnedJoinVisitor(LearnedQueryJoinOptimizer optimizer) throws Exception {
		Class<?> visitorClass = Class.forName(LearnedQueryJoinOptimizer.class.getName() + "$LearnedJoinVisitor");
		Constructor<?> ctor = visitorClass.getDeclaredConstructor(LearnedQueryJoinOptimizer.class, Dataset.class,
				BindingSet.class);
		ctor.setAccessible(true);
		return ctor.newInstance(optimizer, null, EmptyBindingSet.getInstance());
	}

	private static boolean isConnectedPlan(Object visitor, List<TupleExpr> plan, Set<String> initiallyBoundVars)
			throws Exception {
		Method method = visitor.getClass().getDeclaredMethod("isConnectedPlan", List.class, Set.class);
		method.setAccessible(true);
		return (boolean) method.invoke(visitor, plan, initiallyBoundVars);
	}
}
