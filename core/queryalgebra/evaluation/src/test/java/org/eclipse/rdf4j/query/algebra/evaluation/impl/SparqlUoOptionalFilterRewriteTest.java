/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.impl;

import static org.assertj.core.api.Assertions.assertThat;

import java.util.concurrent.atomic.AtomicBoolean;

import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.QueryLanguage;
import org.eclipse.rdf4j.query.algebra.Exists;
import org.eclipse.rdf4j.query.algebra.LeftJoin;
import org.eclipse.rdf4j.query.algebra.Not;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.SparqlUoQueryOptimizerPipeline;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.sparqluo.SparqlUoConfig;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractQueryModelVisitor;
import org.eclipse.rdf4j.query.impl.EmptyBindingSet;
import org.eclipse.rdf4j.query.parser.ParsedTupleQuery;
import org.eclipse.rdf4j.query.parser.QueryParserUtil;
import org.junit.jupiter.api.Test;

class SparqlUoOptionalFilterRewriteTest {

	@Test
	void convertsFunctionCallFilterToJoin() {
		String query = "SELECT * WHERE { "
				+ "?s <urn:p1> ?o . "
				+ "OPTIONAL { ?s <urn:p2> ?v . BIND(STR(?v) AS ?vStr) } "
				+ "FILTER(CONTAINS(?vStr, \"foo\")) "
				+ "}";

		TupleExpr expr = optimize(query);

		assertThat(containsLeftJoin(expr)).isFalse();
	}

	@Test
	void rewritesNotBoundOptionalToNotExists() {
		String query = "SELECT * WHERE { "
				+ "?s <urn:p1> ?o . "
				+ "OPTIONAL { ?s <urn:p2> ?x . } "
				+ "FILTER(!BOUND(?x)) "
				+ "}";

		TupleExpr expr = optimize(query);

		assertThat(containsLeftJoin(expr)).isFalse();
		assertThat(containsNotExists(expr)).isTrue();
	}

	@Test
	void convertsNestedOptionalFilterToJoins() {
		String query = "SELECT * WHERE { "
				+ "?s <urn:p1> ?o . "
				+ "OPTIONAL { ?s <urn:p2> ?a . BIND(?a AS ?optA) } "
				+ "OPTIONAL { ?s <urn:p3> ?b . BIND(?b AS ?optB) } "
				+ "FILTER(?optA = ?optB) "
				+ "}";

		TupleExpr expr = optimize(query);

		assertThat(containsLeftJoin(expr)).isFalse();
	}

	@Test
	void removesOptionalBindLeftJoin() {
		String query = "SELECT * WHERE { "
				+ "?s <urn:p1> ?o . "
				+ "OPTIONAL { BIND(STR(?s) AS ?sStr) } "
				+ "OPTIONAL { BIND(STR(?o) AS ?oStr) } "
				+ "FILTER(CONTAINS(?sStr, \"foo\") || CONTAINS(?oStr, \"foo\")) "
				+ "}";

		TupleExpr expr = optimize(query);

		assertThat(containsLeftJoin(expr)).isFalse();
	}

	private static TupleExpr optimize(String query) {
		ParsedTupleQuery parsedQuery = QueryParserUtil.parseTupleQuery(QueryLanguage.SPARQL, query, null);
		TupleExpr expr = parsedQuery.getTupleExpr();

		EmptyTripleSource tripleSource = new EmptyTripleSource();
		EvaluationStatistics evaluationStatistics = new EvaluationStatistics();
		DefaultEvaluationStrategy strategy = new DefaultEvaluationStrategy(tripleSource, null, null, 0L,
				evaluationStatistics);
		SparqlUoConfig config = SparqlUoConfig.builder().allowNonImprovingTransforms(true).build();
		strategy.setOptimizerPipeline(
				new SparqlUoQueryOptimizerPipeline(strategy, tripleSource, evaluationStatistics, config));
		BindingSet bindings = EmptyBindingSet.getInstance();
		strategy.optimize(expr, evaluationStatistics, bindings);
		return expr;
	}

	private static boolean containsLeftJoin(TupleExpr expr) {
		AtomicBoolean found = new AtomicBoolean(false);
		expr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			public void meet(LeftJoin node) {
				found.set(true);
			}
		});
		return found.get();
	}

	private static boolean containsNotExists(TupleExpr expr) {
		AtomicBoolean found = new AtomicBoolean(false);
		expr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			public void meet(Not node) {
				if (node.getArg() instanceof Exists) {
					found.set(true);
				}
				super.meet(node);
			}
		});
		return found.get();
	}
}
