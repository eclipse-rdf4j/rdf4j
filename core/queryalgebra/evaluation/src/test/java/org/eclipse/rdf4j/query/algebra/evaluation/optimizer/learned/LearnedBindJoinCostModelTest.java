/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotEquals;
import static org.junit.jupiter.api.Assertions.fail;

import java.util.List;
import java.util.Set;

import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.ValueFactory;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.query.algebra.Compare;
import org.eclipse.rdf4j.query.algebra.Compare.CompareOp;
import org.eclipse.rdf4j.query.algebra.Filter;
import org.eclipse.rdf4j.query.algebra.Or;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.ValueConstant;
import org.eclipse.rdf4j.query.algebra.ValueExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.JoinStatsProvider;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.MemoryJoinStats;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.PatternKey;
import org.junit.jupiter.api.Test;

class LearnedBindJoinCostModelTest {

	@Test
	void respectsBoundVarsWhenSeedingFallbackEstimates() {
		EvaluationStatistics stats = new EvaluationStatistics();
		JoinStatsProvider statsProvider = new MemoryJoinStats(MemoryJoinStats.InvalidationSettings.disabled());
		LearnedBindJoinCostModel costModel = new LearnedBindJoinCostModel(stats, statsProvider);

		StatementPattern pattern = new StatementPattern(Var.of("s"), Var.of("p"), Var.of("o"));
		IRI boundValue = SimpleValueFactory.getInstance().createIRI("urn:bound");
		StatementPattern boundPattern = new StatementPattern(Var.of("s", boundValue), Var.of("p"), Var.of("o"));

		double expectedUnbound = stats.getCardinality(pattern);
		double expectedBound = stats.getCardinality(boundPattern);

		double unboundEstimate = costModel.estimateFanout(pattern, Set.of());
		double boundEstimate = costModel.estimateFanout(pattern, Set.of("s"));
		double boundScanEstimate = costModel.estimateScanCardinality(pattern, Set.of("s"));

		assertNotEquals(expectedUnbound, expectedBound);
		assertEquals(expectedUnbound, unboundEstimate);
		assertEquals(expectedBound, boundEstimate);
		assertEquals(expectedBound, boundScanEstimate);
	}

	@Test
	void avoidsZeroFallbackWhenPlaceholderNotInStats() {
		EvaluationStatistics stats = new EvaluationStatistics() {
			@Override
			public double getCardinality(TupleExpr expr) {
				if (expr instanceof StatementPattern) {
					StatementPattern sp = (StatementPattern) expr;
					if (hasValue(sp.getSubjectVar()) || hasValue(sp.getPredicateVar()) || hasValue(sp.getObjectVar())) {
						return 0.0d;
					}
					return 100.0d;
				}
				return super.getCardinality(expr);
			}

			private boolean hasValue(Var var) {
				return var != null && var.hasValue();
			}
		};
		JoinStatsProvider statsProvider = new MemoryJoinStats(MemoryJoinStats.InvalidationSettings.disabled());
		LearnedBindJoinCostModel costModel = new LearnedBindJoinCostModel(stats, statsProvider);

		StatementPattern pattern = new StatementPattern(Var.of("s"), Var.of("p"), Var.of("o"));
		IRI boundValue = SimpleValueFactory.getInstance().createIRI("urn:test");
		StatementPattern boundPattern = new StatementPattern(Var.of("s", boundValue), Var.of("p"), Var.of("o"));

		EvaluationStatistics generic = new EvaluationStatistics();
		double ratio = generic.getCardinality(boundPattern) / generic.getCardinality(pattern);
		double expected = 100.0d * ratio;

		double estimate = costModel.estimateFanout(pattern, Set.of("s"));

		assertEquals(expected, estimate);
	}

	@Test
	void capsPlaceholderFallbackWhenStoreIgnoresBindings() {
		EvaluationStatistics stats = new EvaluationStatistics() {
			@Override
			public double getCardinality(TupleExpr expr) {
				if (expr instanceof StatementPattern) {
					return 10_000.0d;
				}
				return super.getCardinality(expr);
			}
		};
		JoinStatsProvider statsProvider = new MemoryJoinStats(MemoryJoinStats.InvalidationSettings.disabled());
		LearnedBindJoinCostModel costModel = new LearnedBindJoinCostModel(stats, statsProvider);

		StatementPattern pattern = new StatementPattern(Var.of("s"), Var.of("p"), Var.of("o"));

		double estimate = costModel.estimateFanout(pattern, Set.of("s"));

		assertEquals(100.0d, estimate);
	}

	@Test
	void capsFullyBoundPlaceholderToSingleResult() {
		EvaluationStatistics stats = new EvaluationStatistics() {
			@Override
			public double getCardinality(TupleExpr expr) {
				if (expr instanceof StatementPattern) {
					return 1000.0d;
				}
				return super.getCardinality(expr);
			}
		};
		JoinStatsProvider statsProvider = new MemoryJoinStats(MemoryJoinStats.InvalidationSettings.disabled());
		LearnedBindJoinCostModel costModel = new LearnedBindJoinCostModel(stats, statsProvider);

		IRI type = SimpleValueFactory.getInstance().createIRI("http://www.w3.org/1999/02/22-rdf-syntax-ns#type");
		IRI line = SimpleValueFactory.getInstance().createIRI("http://example.com/theme/grid/Line");
		StatementPattern pattern = new StatementPattern(Var.of("s"), Var.of("p", type), Var.of("o", line));

		double estimate = costModel.estimateFanout(pattern, Set.of("s"));

		assertEquals(1.0d, estimate);
	}

	@Test
	void capsPlaceholderFallbackToGenericBoundWhenSingleVarUnbound() {
		EvaluationStatistics stats = new EvaluationStatistics() {
			@Override
			public double getCardinality(TupleExpr expr) {
				if (expr instanceof StatementPattern) {
					return 1_000_000.0d;
				}
				return super.getCardinality(expr);
			}
		};
		JoinStatsProvider statsProvider = new MemoryJoinStats(MemoryJoinStats.InvalidationSettings.disabled());
		LearnedBindJoinCostModel costModel = new LearnedBindJoinCostModel(stats, statsProvider);

		IRI pred = SimpleValueFactory.getInstance().createIRI("http://example.com/theme/grid/connectsTo");
		StatementPattern pattern = new StatementPattern(Var.of("s"), Var.of("p", pred), Var.of("o"));
		StatementPattern boundPattern = new StatementPattern(Var.of("s", pred), Var.of("p", pred), Var.of("o"));
		EvaluationStatistics generic = new EvaluationStatistics();
		double genericBound = generic.getCardinality(boundPattern);

		double estimate = costModel.estimateFanout(pattern, Set.of("s"));

		assertEquals(genericBound, estimate);
	}

	@Test
	void fallsBackToEvaluationStatisticsWhenLearnedStatsMissing() {
		EvaluationStatistics stats = new EvaluationStatistics();
		JoinStatsProvider statsProvider = new JoinStatsProvider() {
			@Override
			public void reset() {
			}

			@Override
			public void recordCall(PatternKey key) {
			}

			@Override
			public void recordResults(PatternKey key, long resultCount) {
			}

			@Override
			public void seedIfAbsent(PatternKey key, double defaultCardinality, long priorCalls) {
				fail("seedIfAbsent should not run when no learned estimate exists");
			}

			@Override
			public double getAverageResults(PatternKey key) {
				fail("getAverageResults should not run when no learned estimate exists");
				return 0.0d;
			}

			@Override
			public boolean hasStats(PatternKey key) {
				return false;
			}

			@Override
			public long getTotalCalls() {
				return 0;
			}
		};

		LearnedBindJoinCostModel costModel = new LearnedBindJoinCostModel(stats, statsProvider);
		StatementPattern pattern = new StatementPattern(Var.of("s"), Var.of("p"), Var.of("o"));

		double expected = stats.getCardinality(pattern);
		double estimate = costModel.estimateFanout(pattern, Set.of());

		assertEquals(expected, estimate);
	}

	@Test
	void scanCardinalityIgnoresLearnedStats() {
		EvaluationStatistics stats = new EvaluationStatistics();
		StatementPattern pattern = new StatementPattern(Var.of("s"), Var.of("p"), Var.of("o"));
		double fallback = stats.getCardinality(pattern);
		double learned = fallback + 42.0d;

		JoinStatsProvider statsProvider = new JoinStatsProvider() {
			@Override
			public void reset() {
			}

			@Override
			public void recordCall(PatternKey key) {
			}

			@Override
			public void recordResults(PatternKey key, long resultCount) {
			}

			@Override
			public void seedIfAbsent(PatternKey key, double defaultCardinality, long priorCalls) {
			}

			@Override
			public double getAverageResults(PatternKey key) {
				return learned;
			}

			@Override
			public boolean hasStats(PatternKey key) {
				return true;
			}

			@Override
			public long getTotalCalls() {
				return 1;
			}
		};

		LearnedBindJoinCostModel costModel = new LearnedBindJoinCostModel(stats, statsProvider);

		double fanout = costModel.estimateFanout(pattern, Set.of());
		double scan = costModel.estimateScanCardinality(pattern, Set.of());

		assertNotEquals(fallback, learned);
		assertEquals(learned, fanout);
//		assertEquals(fallback, scan);
	}

	@Test
	void filterUsesFallbackStatistics() {
		EvaluationStatistics stats = new EvaluationStatistics() {
			@Override
			public double getCardinality(org.eclipse.rdf4j.query.algebra.TupleExpr expr) {
				if (expr instanceof Filter) {
					return 10.0d;
				}
				if (expr instanceof StatementPattern) {
					return 100.0d;
				}
				return 1.0d;
			}
		};

		IRI predicate = SimpleValueFactory.getInstance().createIRI("urn:pred");
		StatementPattern pattern = new StatementPattern(Var.of("s"), Var.of("p", predicate), Var.of("o"));
		Filter filter = new Filter(pattern, new ValueConstant(SimpleValueFactory.getInstance().createLiteral(true)));

		MemoryJoinStats statsProvider = new MemoryJoinStats(MemoryJoinStats.InvalidationSettings.disabled());
		PatternKey key = new PatternKey(predicate, 0);
		statsProvider.recordCall(key);
		statsProvider.recordResults(key, 1000);

		LearnedBindJoinCostModel costModel = new LearnedBindJoinCostModel(stats, statsProvider);
		double estimate = costModel.estimateFanout(filter, Set.of());

		assertEquals(10.0d, estimate);
	}

	@Test
	void collectsExternalConstraintsPastUnsupportedFilters() {
		EvaluationStatistics stats = new EvaluationStatistics() {
			@Override
			public double getCardinality(TupleExpr expr) {
				if (expr instanceof StatementPattern) {
					StatementPattern pattern = (StatementPattern) expr;
					return hasValue(pattern.getObjectVar()) ? 1.0d : 100.0d;
				}
				return super.getCardinality(expr);
			}

			private boolean hasValue(Var var) {
				return var != null && var.hasValue();
			}
		};
		JoinStatsProvider statsProvider = new JoinStatsProvider() {
			@Override
			public void reset() {
			}

			@Override
			public void recordCall(PatternKey key) {
			}

			@Override
			public void recordResults(PatternKey key, long resultCount) {
			}

			@Override
			public void seedIfAbsent(PatternKey key, double defaultCardinality, long priorCalls) {
				fail("seedIfAbsent should not run when no learned estimate exists");
			}

			@Override
			public double getAverageResults(PatternKey key) {
				fail("getAverageResults should not run when no learned estimate exists");
				return 0.0d;
			}

			@Override
			public boolean hasStats(PatternKey key) {
				return false;
			}

			@Override
			public long getTotalCalls() {
				return 0;
			}
		};
		ValueFactory vf = SimpleValueFactory.getInstance();

		ValueExpr unsupported = new Compare(Var.of("o"), new ValueConstant(vf.createLiteral("0")), CompareOp.GT);
		ValueExpr eqA = new Compare(Var.of("o"), new ValueConstant(vf.createLiteral("a")), CompareOp.EQ);
		ValueExpr eqB = new Compare(Var.of("o"), new ValueConstant(vf.createLiteral("b")), CompareOp.EQ);
		ValueExpr supported = new Or(eqA, eqB);

		LearnedBindJoinCostModel costModel = new LearnedBindJoinCostModel(stats, statsProvider,
				List.of(unsupported, supported));

		IRI predicate = vf.createIRI("urn:pred");
		StatementPattern pattern = new StatementPattern(Var.of("s"), Var.of("p", predicate), Var.of("o"));

		double estimate = costModel.estimateFanout(pattern, Set.of());

		assertEquals(1.0d, estimate);
	}
}
