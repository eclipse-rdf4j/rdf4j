/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotEquals;

import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.junit.jupiter.api.Test;

class DpVsGreedyJoinOrderingTest {

	@Test
	void dpBeatsGreedyForGlobalCost() {
		TupleExpr a = new StatementPattern(new Var("sa"), new Var("pa"), new Var("oa"));
		TupleExpr b = new StatementPattern(new Var("sb"), new Var("pb"), new Var("ob"));
		TupleExpr c = new StatementPattern(new Var("sc"), new Var("pc"), new Var("oc"));

		BindJoinCostModel costModel = new StubCostModel(a, b, c);
		JoinOrderPlanner greedy = new GreedyBindJoinOrderPlanner(costModel);
		JoinOrderPlanner dp = new DpLeftDeepBindJoinOrderPlanner(costModel);

		List<TupleExpr> operands = List.of(a, b, c);
		List<TupleExpr> greedyOrder = greedy.order(operands, Set.of());
		List<TupleExpr> dpOrder = dp.order(operands, Set.of());

		assertEquals(List.of(a, b, c), greedyOrder);
		assertEquals(List.of(b, c, a), dpOrder);
		assertNotEquals(greedyOrder, dpOrder);
	}

	@Test
	void avoidsIsolatedFirstPattern() {
		TupleExpr a = new StatementPattern(new Var("sa"), new Var("pa"), new Var("oa"));
		TupleExpr b = new StatementPattern(new Var("sb"), new Var("pb"), new Var("ob"));
		TupleExpr c = new StatementPattern(new Var("sc"), new Var("pc"), new Var("oc"));

		BindJoinCostModel costModel = new BindJoinCostModel() {
			private final Map<TupleExpr, Set<String>> bindings = Map.of(
					a, Set.of("x"),
					b, Set.of("x", "y"),
					c, Set.of("z"));

			@Override
			public double estimateFanout(TupleExpr expr, Set<String> boundVars) {
				return 1.0d;
			}

			@Override
			public double estimateScanCardinality(TupleExpr expr, Set<String> initiallyBoundVars) {
				if (expr == a) {
					return 10.0d;
				}
				if (expr == b) {
					return 20.0d;
				}
				if (expr == c) {
					return 1.0d;
				}
				return 1.0d;
			}

			@Override
			public Set<String> bindingNames(TupleExpr expr) {
				return bindings.getOrDefault(expr, Set.of());
			}
		};

		JoinOrderPlanner greedy = new GreedyBindJoinOrderPlanner(costModel);
		JoinOrderPlanner dp = new DpLeftDeepBindJoinOrderPlanner(costModel);
		List<TupleExpr> operands = List.of(a, b, c);

		List<TupleExpr> greedyOrder = greedy.order(operands, Set.of());
		List<TupleExpr> dpOrder = dp.order(operands, Set.of());

		assertEquals(a, greedyOrder.get(0));
		assertEquals(a, dpOrder.get(0));
	}

	private static final class StubCostModel implements BindJoinCostModel {

		private final Map<TupleExpr, Set<String>> bindings;
		private final TupleExpr a;
		private final TupleExpr b;
		private final TupleExpr c;

		private StubCostModel(TupleExpr a, TupleExpr b, TupleExpr c) {
			this.a = a;
			this.b = b;
			this.c = c;
			this.bindings = Map.of(
					a, Set.of("x"),
					b, Set.of("x", "y"),
					c, Set.of("y"));
		}

		@Override
		public double estimateFanout(TupleExpr expr, Set<String> boundVars) {
			if (expr == a) {
				return boundVars.contains("x") ? 0.1d : 1.0d;
			}
			if (expr == b) {
				if (boundVars.contains("x") || boundVars.contains("y")) {
					return 1000.0d;
				}
				return 100.0d;
			}
			if (expr == c) {
				return 1.0d;
			}
			return 1.0d;
		}

		@Override
		public double estimateScanCardinality(TupleExpr expr, Set<String> initiallyBoundVars) {
			if (expr == a) {
				return 1.0d;
			}
			if (expr == b) {
				return 100.0d;
			}
			if (expr == c) {
				return 1000.0d;
			}
			return 1.0d;
		}

		@Override
		public Set<String> bindingNames(TupleExpr expr) {
			return bindings.getOrDefault(expr, Set.of());
		}
	}
}
