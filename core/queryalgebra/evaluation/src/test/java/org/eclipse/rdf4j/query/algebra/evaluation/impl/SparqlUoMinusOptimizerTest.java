/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.impl;

import static org.assertj.core.api.Assertions.assertThat;

import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.ValueFactory;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.QueryLanguage;
import org.eclipse.rdf4j.query.algebra.Difference;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.SparqlUoQueryOptimizerPipeline;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.sparqluo.SparqlUoConfig;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractQueryModelVisitor;
import org.eclipse.rdf4j.query.impl.EmptyBindingSet;
import org.eclipse.rdf4j.query.impl.MapBindingSet;
import org.eclipse.rdf4j.query.parser.ParsedTupleQuery;
import org.eclipse.rdf4j.query.parser.QueryParserUtil;
import org.junit.jupiter.api.Test;

class SparqlUoMinusOptimizerTest {

	private static final ValueFactory VF = SimpleValueFactory.getInstance();

	@Test
	void removesMinusWhenNoSharedVariables() {
		String query = "SELECT * WHERE { ?s <urn:p1> ?o MINUS { ?x <urn:p2> ?y } }";

		SparqlUoConfig config = SparqlUoConfig.builder().allowNonImprovingTransforms(true).build();
		TupleExpr expr = optimize(query, config);

		assertThat(containsDifference(expr)).isFalse();
	}

	@Test
	void removesMinusWhenRightSideIsGround() {
		String query = "SELECT * WHERE { ?s <urn:p1> ?o MINUS { <urn:a> <urn:p2> <urn:b> } }";

		SparqlUoConfig config = SparqlUoConfig.builder().allowNonImprovingTransforms(true).build();
		TupleExpr expr = optimize(query, config);

		assertThat(containsDifference(expr)).isFalse();
	}

	@Test
	void doesNotRemoveMinusWhenVariablesOverlap() {
		String query = "SELECT * WHERE { ?s <urn:p1> ?o MINUS { ?s <urn:p2> ?x } }";

		SparqlUoConfig config = SparqlUoConfig.builder().allowNonImprovingTransforms(true).build();
		TupleExpr expr = optimize(query, config);

		assertThat(containsDifference(expr)).isTrue();
	}

	@Test
	void doesNotRemoveMinusWhenOuterOptionalScopeBindsRightVariables() {
		String query = "SELECT * WHERE { ?s <urn:p1> ?o OPTIONAL { BIND(1 AS ?maybe) MINUS { ?s <urn:p2> ?x } } }";

		SparqlUoConfig config = SparqlUoConfig.builder().allowNonImprovingTransforms(true).build();
		TupleExpr expr = optimize(query, config);

		assertThat(containsDifference(expr)).isTrue();
	}

	@Test
	void doesNotRemoveMinusWhenIncomingBindingsShareVariables() {
		String query = "SELECT * WHERE { ?s <urn:p1> ?o MINUS { ?x <urn:p2> ?y } }";

		SparqlUoConfig config = SparqlUoConfig.builder().allowNonImprovingTransforms(true).build();
		MapBindingSet bindings = new MapBindingSet();
		IRI boundValue = VF.createIRI("urn:bound");
		bindings.addBinding("x", boundValue);
		TupleExpr expr = optimize(query, config, bindings);

		assertThat(containsDifference(expr)).isTrue();
	}

	@Test
	void splitsMinusUnionWhenEnabled() {
		String query = "SELECT * WHERE { ?s <urn:p1> ?o MINUS { { ?s <urn:p2> ?o } UNION { ?s <urn:p3> ?o } } }";
		String property = SparqlUoConfig.PROP_ENABLE_MINUS_UNION_SPLIT;
		String previous = System.getProperty(property);
		System.setProperty(property, "true");
		try {
			SparqlUoConfig config = SparqlUoConfig.fromSystemProperties();
			TupleExpr expr = optimize(query, config);
			DifferenceStats stats = differenceStats(expr);
			assertThat(stats.unionOnRight).isFalse();
			assertThat(stats.count).isEqualTo(2);
		} finally {
			if (previous == null) {
				System.clearProperty(property);
			} else {
				System.setProperty(property, previous);
			}
		}
	}

	private static boolean containsDifference(TupleExpr expr) {
		AtomicBoolean found = new AtomicBoolean(false);
		expr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			public void meet(Difference node) {
				found.set(true);
			}
		});
		return found.get();
	}

	private static DifferenceStats differenceStats(TupleExpr expr) {
		AtomicInteger count = new AtomicInteger();
		AtomicBoolean unionOnRight = new AtomicBoolean();
		expr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			public void meet(Difference node) {
				count.incrementAndGet();
				if (node.getRightArg() instanceof org.eclipse.rdf4j.query.algebra.Union) {
					unionOnRight.set(true);
				}
				super.meet(node);
			}
		});
		return new DifferenceStats(count.get(), unionOnRight.get());
	}

	private static TupleExpr optimize(String query, SparqlUoConfig config) {
		return optimize(query, config, EmptyBindingSet.getInstance());
	}

	private static TupleExpr optimize(String query, SparqlUoConfig config, BindingSet bindings) {
		ParsedTupleQuery parsedQuery = QueryParserUtil.parseTupleQuery(QueryLanguage.SPARQL, query, null);
		TupleExpr expr = parsedQuery.getTupleExpr();

		EmptyTripleSource tripleSource = new EmptyTripleSource();
		EvaluationStatistics evaluationStatistics = new EvaluationStatistics();
		DefaultEvaluationStrategy strategy = new DefaultEvaluationStrategy(tripleSource, null, null, 0L,
				evaluationStatistics);
		strategy.setOptimizerPipeline(
				new SparqlUoQueryOptimizerPipeline(strategy, tripleSource, evaluationStatistics, config));
		strategy.optimize(expr, evaluationStatistics, bindings);
		return expr;
	}

	private static final class DifferenceStats {
		private final int count;
		private final boolean unionOnRight;

		private DifferenceStats(int count, boolean unionOnRight) {
			this.count = count;
			this.unionOnRight = unionOnRight;
		}
	}
}
