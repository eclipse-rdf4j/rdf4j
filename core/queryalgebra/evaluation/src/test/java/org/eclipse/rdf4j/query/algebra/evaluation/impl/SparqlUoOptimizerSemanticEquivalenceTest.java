/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.impl;

import static org.assertj.core.api.Assertions.assertThat;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import org.eclipse.rdf4j.common.iteration.CloseableIteration;
import org.eclipse.rdf4j.common.iteration.CloseableIteratorIteration;
import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Resource;
import org.eclipse.rdf4j.model.Statement;
import org.eclipse.rdf4j.model.Value;
import org.eclipse.rdf4j.model.ValueFactory;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.QueryLanguage;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryBindingSet;
import org.eclipse.rdf4j.query.algebra.evaluation.TripleSource;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.SparqlUoQueryOptimizerPipeline;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.sparqluo.SparqlUoConfig;
import org.eclipse.rdf4j.query.impl.EmptyBindingSet;
import org.eclipse.rdf4j.query.parser.ParsedTupleQuery;
import org.eclipse.rdf4j.query.parser.QueryParserUtil;
import org.junit.jupiter.api.Test;

class SparqlUoOptimizerSemanticEquivalenceTest {

	private static final ValueFactory VF = SimpleValueFactory.getInstance();

	@Test
	void unionAndOptionalQueriesRemainEquivalent() {
		List<Statement> statements = List.of(
				VF.createStatement(VF.createIRI("urn:a"), VF.createIRI("urn:p1"), VF.createIRI("urn:o1")),
				VF.createStatement(VF.createIRI("urn:a"), VF.createIRI("urn:p2"), VF.createIRI("urn:o2")),
				VF.createStatement(VF.createIRI("urn:b"), VF.createIRI("urn:p1"), VF.createIRI("urn:o3")),
				VF.createStatement(VF.createIRI("urn:b"), VF.createIRI("urn:p3"), VF.createIRI("urn:o4"))
		);

		Strategies strategies = createStrategies(statements);

		assertEquivalentResults(
				"SELECT ?s WHERE { { ?s <urn:p1> ?o } UNION { ?s <urn:p1> ?o } }",
				strategies
		);

		assertEquivalentResults(
				"SELECT ?s ?o2 WHERE { ?s <urn:p1> ?o OPTIONAL { ?s <urn:p2> ?o2 } }",
				strategies
		);

		assertEquivalentResults(
				"SELECT * WHERE { { ?s <urn:p1> ?o . ?s <urn:p2> ?x } UNION { ?s <urn:p1> ?o . ?s <urn:p3> ?y } }",
				strategies
		);

		assertEquivalentResults(
				"SELECT * WHERE { ?s <urn:p1> ?o OPTIONAL { ?s <urn:p2> ?o2 } ?s <urn:p3> ?o3 }",
				strategies
		);
	}

	@Test
	void nestedOptionalAndPredicateVarQueriesRemainEquivalent() {
		List<Statement> statements = List.of(
				VF.createStatement(VF.createIRI("urn:a"), VF.createIRI("urn:p1"), VF.createIRI("urn:o1")),
				VF.createStatement(VF.createIRI("urn:a"), VF.createIRI("urn:p2"), VF.createIRI("urn:o2")),
				VF.createStatement(VF.createIRI("urn:a"), VF.createIRI("urn:p3"), VF.createIRI("urn:o3")),
				VF.createStatement(VF.createIRI("urn:b"), VF.createIRI("urn:p1"), VF.createIRI("urn:o4")),
				VF.createStatement(VF.createIRI("urn:c"), VF.createIRI("urn:p1"), VF.createIRI("urn:o5")),
				VF.createStatement(VF.createIRI("urn:c"), VF.createIRI("urn:p2"), VF.createIRI("urn:o6")),
				VF.createStatement(VF.createIRI("urn:d"), VF.createIRI("urn:p4"), VF.createIRI("urn:o7"))
		);

		Strategies strategies = createStrategies(statements);

		assertEquivalentResults(
				"SELECT ?s ?o2 ?o3 WHERE { ?s <urn:p1> ?o OPTIONAL { ?s <urn:p2> ?o2 OPTIONAL { ?s <urn:p3> ?o3 } } }",
				strategies
		);

		assertEquivalentResults(
				"SELECT ?s ?p ?o ?x ?y WHERE { ?s ?p ?o . ?x ?p ?y }",
				strategies
		);
	}

	@Test
	void filterAndUnionOptionalQueriesRemainEquivalent() {
		List<Statement> statements = List.of(
				VF.createStatement(VF.createIRI("urn:a"), VF.createIRI("urn:p1"), VF.createIRI("urn:o1")),
				VF.createStatement(VF.createIRI("urn:a"), VF.createIRI("urn:p2"), VF.createIRI("urn:o2")),
				VF.createStatement(VF.createIRI("urn:b"), VF.createIRI("urn:p1"), VF.createIRI("urn:o3")),
				VF.createStatement(VF.createIRI("urn:c"), VF.createIRI("urn:p1"), VF.createIRI("urn:o4")),
				VF.createStatement(VF.createIRI("urn:c"), VF.createIRI("urn:p2"), VF.createIRI("urn:o5"))
		);

		Strategies strategies = createStrategies(statements);

		assertEquivalentResults(
				"SELECT ?s ?o2 WHERE { ?s <urn:p1> ?o FILTER(?o != <urn:o3>) OPTIONAL { ?s <urn:p2> ?o2 } }",
				strategies
		);

		assertEquivalentResults(
				"SELECT ?s ?o2 WHERE { { ?s <urn:p1> ?o } UNION { ?s <urn:p1> ?o OPTIONAL { ?s <urn:p2> ?o2 } } }",
				strategies
		);
	}

	private Strategies createStrategies(List<Statement> statements) {
		TripleSource tripleSource = new ListTripleSource(statements);
		EvaluationStatistics evaluationStatistics = new EvaluationStatistics();

		DefaultEvaluationStrategy baseline = new DefaultEvaluationStrategy(tripleSource, null, null, 0L,
				evaluationStatistics);
		DefaultEvaluationStrategy optimized = new DefaultEvaluationStrategy(tripleSource, null, null, 0L,
				evaluationStatistics);
		SparqlUoConfig config = SparqlUoConfig.builder().allowNonImprovingTransforms(true).build();
		optimized.setOptimizerPipeline(new SparqlUoQueryOptimizerPipeline(optimized, tripleSource,
				evaluationStatistics, config));
		return new Strategies(baseline, optimized);
	}

	private void assertEquivalentResults(String query, Strategies strategies) {
		List<BindingSet> baselineResults = evaluate(query, strategies.baseline);
		List<BindingSet> optimizedResults = evaluate(query, strategies.optimized);
		assertThat(asCounts(baselineResults)).isEqualTo(asCounts(optimizedResults));
	}

	private List<BindingSet> evaluate(String query, DefaultEvaluationStrategy strategy) {
		ParsedTupleQuery parsedQuery = QueryParserUtil.parseTupleQuery(QueryLanguage.SPARQL, query, null);
		TupleExpr expr = parsedQuery.getTupleExpr().clone();
		strategy.optimize(expr, new EvaluationStatistics(), EmptyBindingSet.getInstance());
		try (CloseableIteration<BindingSet> results = strategy.precompile(expr)
				.evaluate(EmptyBindingSet.getInstance())) {
			List<BindingSet> collected = new ArrayList<>();
			while (results.hasNext()) {
				collected.add(new QueryBindingSet(results.next()));
			}
			return collected;
		}
	}

	private Map<BindingSet, Long> asCounts(List<BindingSet> results) {
		Map<BindingSet, Long> counts = new HashMap<>();
		for (BindingSet result : results) {
			QueryBindingSet copy = new QueryBindingSet(result);
			counts.merge(copy, 1L, Long::sum);
		}
		return counts;
	}

	private static final class Strategies {
		private final DefaultEvaluationStrategy baseline;
		private final DefaultEvaluationStrategy optimized;

		private Strategies(DefaultEvaluationStrategy baseline, DefaultEvaluationStrategy optimized) {
			this.baseline = baseline;
			this.optimized = optimized;
		}
	}

	private static final class ListTripleSource implements TripleSource {
		private final List<Statement> statements;

		private ListTripleSource(List<Statement> statements) {
			this.statements = List.copyOf(statements);
		}

		@Override
		public CloseableIteration<? extends Statement> getStatements(Resource subj, IRI pred, Value obj,
				Resource... contexts) {
			List<Statement> matches = new ArrayList<>();
			boolean hasContexts = contexts != null && contexts.length > 0;
			for (Statement statement : statements) {
				if (subj != null && !subj.equals(statement.getSubject())) {
					continue;
				}
				if (pred != null && !pred.equals(statement.getPredicate())) {
					continue;
				}
				if (obj != null && !obj.equals(statement.getObject())) {
					continue;
				}
				if (hasContexts && !matchesContext(statement, contexts)) {
					continue;
				}
				matches.add(statement);
			}
			return new CloseableIteratorIteration<>(matches.iterator());
		}

		@Override
		public ValueFactory getValueFactory() {
			return VF;
		}

		private boolean matchesContext(Statement statement, Resource[] contexts) {
			for (Resource context : contexts) {
				if (Objects.equals(context, statement.getContext())) {
					return true;
				}
			}
			return false;
		}
	}
}
