/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.impl;

import static org.assertj.core.api.Assertions.assertThat;

import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

import org.eclipse.rdf4j.model.ValueFactory;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.algebra.BindingSetAssignment;
import org.eclipse.rdf4j.query.algebra.Compare;
import org.eclipse.rdf4j.query.algebra.Compare.CompareOp;
import org.eclipse.rdf4j.query.algebra.Difference;
import org.eclipse.rdf4j.query.algebra.Exists;
import org.eclipse.rdf4j.query.algebra.Filter;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.Not;
import org.eclipse.rdf4j.query.algebra.QueryRoot;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryBindingSet;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.NotExistsSemiJoinOptimizer;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractQueryModelVisitor;
import org.eclipse.rdf4j.query.impl.EmptyBindingSet;
import org.junit.jupiter.api.Test;

class NotExistsSemiJoinOptimizerCorrelationTest {

	@Test
	void doesNotRewriteWhenSubqueryUsesExternalValuesVar() {
		ValueFactory vf = SimpleValueFactory.getInstance();

		BindingSetAssignment values = new BindingSetAssignment();
		QueryBindingSet bindings = new QueryBindingSet();
		bindings.addBinding("threshold", vf.createLiteral(10));
		values.setBindingSets(List.<BindingSet>of(bindings));

		TupleExpr left = new Join(values,
				new StatementPattern(Var.of("service"), Var.of("p"), Var.of("o")));

		TupleExpr subQuery = new Filter(
				new StatementPattern(Var.of("service"), Var.of("p2"), Var.of("late")),
				new Compare(Var.of("late"), Var.of("threshold"), CompareOp.GT));

		TupleExpr expr = new QueryRoot(new Filter(left, new Not(new Exists(subQuery))));

		new NotExistsSemiJoinOptimizer(new EvaluationStatistics(), true)
				.optimize(expr, null, EmptyBindingSet.getInstance());

		assertThat(containsDifference(expr)).isFalse();
	}

	private static boolean containsDifference(TupleExpr expr) {
		AtomicBoolean found = new AtomicBoolean(false);
		expr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			public void meet(Difference node) {
				found.set(true);
			}
		});
		return found.get();
	}
}
