/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EmptyTripleSource;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.JoinStatsProvider;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.LearnedQueryJoinOptimizer;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.PatternKey;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.QueryJoinOptimizer;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractQueryModelVisitor;
import org.eclipse.rdf4j.query.parser.ParsedQuery;
import org.eclipse.rdf4j.query.parser.sparql.SPARQLParser;
import org.junit.jupiter.api.Test;

class LearnedQueryJoinOptimizerDefaultOrderTest {

	private static final String EX_NS = "http://example.com/";
	private static final String P_A = EX_NS + "pA";
	private static final String P_B = EX_NS + "pB";
	private static final String P_C = EX_NS + "pC";
	private static final Set<String> TARGET_PREDICATES = Set.of(P_A, P_B, P_C);

	private static final String QUERY = String.join("\n",
			"PREFIX ex: <http://example.com/>",
			"SELECT * WHERE {",
			"  ?s ex:pA ?x .",
			"  ?x ex:pB ?o .",
			"  ?w ex:pC ?v .",
			"}");

	@Test
	void matchesDefaultJoinOrderWithoutLearnedStats() throws Exception {
		SPARQLParser parser = new SPARQLParser();
		EvaluationStatistics stats = new FixedEvaluationStatistics();

		ParsedQuery defaultQuery = parser.parseQuery(QUERY, null);
		QueryJoinOptimizer defaultOptimizer = new QueryJoinOptimizer(stats, new EmptyTripleSource());
		defaultOptimizer.optimize(defaultQuery.getTupleExpr(), null, null);
		List<String> defaultOrder = orderedPredicateIris(defaultQuery.getTupleExpr());

		ParsedQuery learnedQuery = parser.parseQuery(QUERY, null);
		LearnedQueryJoinOptimizer learnedOptimizer = new LearnedQueryJoinOptimizer(stats, new EmptyTripleSource(),
				new EmptyJoinStatsProvider());
		learnedOptimizer.optimize(learnedQuery.getTupleExpr(), null, null);
		List<String> learnedOrder = orderedPredicateIris(learnedQuery.getTupleExpr());

		assertEquals(defaultOrder, learnedOrder,
				"Learned join ordering should match default when no learned stats exist");
	}

	private List<String> orderedPredicateIris(TupleExpr tupleExpr) {
		List<String> order = new ArrayList<>();
		tupleExpr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			public void meet(StatementPattern node) {
				IRI predicate = node.getPredicateVar() != null && node.getPredicateVar().hasValue()
						&& node.getPredicateVar().getValue() instanceof IRI
								? (IRI) node.getPredicateVar().getValue()
								: null;
				if (predicate != null) {
					String iri = predicate.stringValue();
					if (TARGET_PREDICATES.contains(iri)) {
						order.add(iri);
					}
				}
			}
		});
		return order;
	}

	private static final class EmptyJoinStatsProvider implements JoinStatsProvider {

		@Override
		public void reset() {
		}

		@Override
		public void recordCall(PatternKey key) {
		}

		@Override
		public void recordResults(PatternKey key, long resultCount) {
		}

		@Override
		public void seedIfAbsent(PatternKey key, double defaultCardinality, long priorCalls) {
		}

		@Override
		public double getAverageResults(PatternKey key) {
			return 0.0d;
		}

		@Override
		public boolean hasStats(PatternKey key) {
			return false;
		}

		@Override
		public long getTotalCalls() {
			return 0;
		}
	}

	private static final class FixedEvaluationStatistics extends EvaluationStatistics {
		@Override
		public double getCardinality(TupleExpr expr) {
			if (expr instanceof StatementPattern) {
				String predicate = predicate((StatementPattern) expr);
				if (P_A.equals(predicate)) {
					return 10.0d;
				}
				if (P_B.equals(predicate)) {
					return 10.0d;
				}
				if (P_C.equals(predicate)) {
					return 8.0d;
				}
			}
			return super.getCardinality(expr);
		}

		private String predicate(StatementPattern pattern) {
			if (pattern.getPredicateVar() == null || !pattern.getPredicateVar().hasValue()
					|| !(pattern.getPredicateVar().getValue() instanceof IRI)) {
				return null;
			}
			return ((IRI) pattern.getPredicateVar().getValue()).stringValue();
		}
	}
}
