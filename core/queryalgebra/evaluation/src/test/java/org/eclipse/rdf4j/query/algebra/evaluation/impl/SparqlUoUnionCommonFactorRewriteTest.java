/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.impl;

import static org.assertj.core.api.Assertions.assertThat;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;

import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.model.vocabulary.RDF;
import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.QueryLanguage;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.Union;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.SparqlUoQueryOptimizerPipeline;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.sparqluo.SparqlUoConfig;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractQueryModelVisitor;
import org.eclipse.rdf4j.query.impl.EmptyBindingSet;
import org.eclipse.rdf4j.query.parser.ParsedTupleQuery;
import org.eclipse.rdf4j.query.parser.QueryParserUtil;
import org.junit.jupiter.api.Test;

class SparqlUoUnionCommonFactorRewriteTest {

	private static final IRI CLINICAL_TRIAL = SimpleValueFactory.getInstance()
			.createIRI("http://example.com/theme/pharma/ClinicalTrial");

	@Test
	void pullsCommonJoinFactorsAboveUnion() {
		String query = String.join(" ",
				"PREFIX pharma: <http://example.com/theme/pharma/>",
				"SELECT ?trial ?result ?bv WHERE {",
				"  {",
				"    ?trial a pharma:ClinicalTrial ; pharma:phase ?phase .",
				"    FILTER(?phase = 3)",
				"    ?trial pharma:hasArm ?arm .",
				"    ?arm pharma:hasResult ?result .",
				"    ?result pharma:biomarkerValue ?bv .",
				"    FILTER(?bv > 2.0)",
				"  }",
				"  UNION",
				"  {",
				"    ?trial a pharma:ClinicalTrial ; pharma:phase ?phase .",
				"    FILTER(?phase = 3)",
				"    ?trial pharma:hasArm ?arm .",
				"    ?arm pharma:hasResult ?result .",
				"    ?result pharma:pValue ?p .",
				"    FILTER(?p < 0.001)",
				"    OPTIONAL { ?result pharma:biomarkerValue ?bv . }",
				"  }",
				"}");

		TupleExpr expr = optimize(query);
		Union union = findUnion(expr);

		assertThat(union).as("union should still exist").isNotNull();
		assertThat(union.getParentNode()).as("common factors should be joined above the union")
				.isInstanceOf(Join.class);

		assertThat(countClinicalTrialType(union)).as("clinical trial type stays outside union").isZero();
		assertThat(countClinicalTrialType(expr)).as("clinical trial type appears once after factoring")
				.isEqualTo(1);
	}

	@Test
	void skipsCommonFactorPullUpWhenRangeFiltersMakeBranchesSelective() {
		String query = String.join(" ",
				"PREFIX pharma: <http://example.com/theme/pharma/>",
				"SELECT ?trial ?result ?bv WHERE {",
				"  {",
				"    ?trial a pharma:ClinicalTrial ; pharma:phase ?phase .",
				"    FILTER(?phase = 3)",
				"    ?trial pharma:hasArm ?arm .",
				"    ?arm pharma:hasResult ?result .",
				"    ?result pharma:biomarkerValue ?bv .",
				"    FILTER(?bv > 2.0)",
				"  }",
				"  UNION",
				"  {",
				"    ?trial a pharma:ClinicalTrial ; pharma:phase ?phase .",
				"    FILTER(?phase = 3)",
				"    ?trial pharma:hasArm ?arm .",
				"    ?arm pharma:hasResult ?result .",
				"    ?result pharma:pValue ?p .",
				"    FILTER(?p < 0.001)",
				"    OPTIONAL { ?result pharma:biomarkerValue ?bv . }",
				"  }",
				"}");

		SparqlUoConfig config = SparqlUoConfig.builder().allowNonImprovingTransforms(false).build();
		TupleExpr expr = optimize(query, new EvaluationStatistics(), config);
		Union union = findUnion(expr);

		assertThat(union).as("union should still exist").isNotNull();
		assertThat(union.getParentNode()).as("common factors should stay inside union")
				.isNotInstanceOf(Join.class);
		assertThat(countClinicalTrialType(union)).as("clinical trial type appears in each branch")
				.isEqualTo(2);
	}

	private static TupleExpr optimize(String query) {
		SparqlUoConfig config = SparqlUoConfig.builder().allowNonImprovingTransforms(true).build();
		return optimize(query, new EvaluationStatistics(), config);
	}

	private static TupleExpr optimize(String query, EvaluationStatistics evaluationStatistics, SparqlUoConfig config) {
		ParsedTupleQuery parsedQuery = QueryParserUtil.parseTupleQuery(QueryLanguage.SPARQL, query, null);
		TupleExpr expr = parsedQuery.getTupleExpr();

		EmptyTripleSource tripleSource = new EmptyTripleSource();
		DefaultEvaluationStrategy strategy = new DefaultEvaluationStrategy(tripleSource, null, null, 0L,
				evaluationStatistics);
		strategy.setOptimizerPipeline(
				new SparqlUoQueryOptimizerPipeline(strategy, tripleSource, evaluationStatistics, config));
		BindingSet bindings = EmptyBindingSet.getInstance();
		strategy.optimize(expr, evaluationStatistics, bindings);
		return expr;
	}

	private static Union findUnion(TupleExpr expr) {
		AtomicReference<Union> found = new AtomicReference<>();
		expr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			public void meet(Union node) {
				if (found.get() == null) {
					found.set(node);
				}
				super.meet(node);
			}
		});
		return found.get();
	}

	private static int countClinicalTrialType(TupleExpr expr) {
		AtomicInteger count = new AtomicInteger(0);
		expr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			public void meet(StatementPattern node) {
				if (node.getPredicateVar() != null && node.getPredicateVar().hasValue()
						&& RDF.TYPE.equals(node.getPredicateVar().getValue())
						&& node.getObjectVar() != null && node.getObjectVar().hasValue()
						&& CLINICAL_TRIAL.equals(node.getObjectVar().getValue())) {
					count.incrementAndGet();
				}
				super.meet(node);
			}
		});
		return count.get();
	}
}
