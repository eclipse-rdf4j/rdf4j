/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.impl;

import static org.assertj.core.api.Assertions.assertThat;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.query.QueryLanguage;
import org.eclipse.rdf4j.query.algebra.Compare;
import org.eclipse.rdf4j.query.algebra.Compare.CompareOp;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.LeftJoin;
import org.eclipse.rdf4j.query.algebra.Projection;
import org.eclipse.rdf4j.query.algebra.QueryRoot;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.Union;
import org.eclipse.rdf4j.query.algebra.ValueConstant;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryOptimizer;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryOptimizerTest;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.SparqlUoOptimizer;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractQueryModelVisitor;
import org.eclipse.rdf4j.query.impl.EmptyBindingSet;
import org.eclipse.rdf4j.query.impl.SimpleDataset;
import org.eclipse.rdf4j.query.parser.ParsedTupleQuery;
import org.eclipse.rdf4j.query.parser.QueryParserUtil;
import org.junit.jupiter.api.Test;

public class SparqlUoOptimizerTest extends QueryOptimizerTest {

	@Override
	public QueryOptimizer getOptimizer() {
		return new SparqlUoOptimizer(new FixedEvaluationStatistics(), true);
	}

	@Test
	public void testMergeRewritesUnion() {
		String query = "SELECT * WHERE { ?s <urn:p1> ?o . { ?s <urn:p2> ?o2 } UNION { ?s <urn:p3> ?o3 } }";
		TupleExpr expr = optimize(query);

		assertThat(expr).isInstanceOf(Projection.class);
		Projection projection = (Projection) expr;
		assertThat(projection.getArg()).isInstanceOf(Union.class);
		Union union = (Union) projection.getArg();

		assertJoinPredicates(union.getLeftArg(), "urn:p1", "urn:p2");
		assertJoinPredicates(union.getRightArg(), "urn:p1", "urn:p3");
	}

	@Test
	public void testInjectRewritesOptional() {
		String query = "SELECT * WHERE { ?s <urn:p1> ?o OPTIONAL { ?s <urn:p2> ?o2 } }";
		TupleExpr expr = optimize(query);

		assertThat(expr).isInstanceOf(Projection.class);
		Projection projection = (Projection) expr;
		assertThat(projection.getArg()).isInstanceOf(LeftJoin.class);
		LeftJoin leftJoin = (LeftJoin) projection.getArg();

		assertJoinPredicates(leftJoin.getLeftArg(), "urn:p1");
		assertJoinPredicates(leftJoin.getRightArg(), "urn:p1", "urn:p2");
	}

	@Test
	public void testInjectIntoOptionalWithUnion() {
		String query = "SELECT * WHERE { ?s <urn:p1> ?o OPTIONAL { ?s <urn:p2> ?o2 . { ?s <urn:p3> ?o3 } UNION { ?s <urn:p4> ?o4 } } }";
		TupleExpr expr = optimize(query);

		assertThat(expr).isInstanceOf(Projection.class);
		Projection projection = (Projection) expr;
		assertThat(projection.getArg()).isInstanceOf(LeftJoin.class);
		LeftJoin leftJoin = (LeftJoin) projection.getArg();

		assertJoinPredicates(leftJoin.getLeftArg(), "urn:p1");

		List<String> rightPredicates = collectPredicates(leftJoin.getRightArg());
		assertThat(rightPredicates).contains("urn:p1", "urn:p2", "urn:p3", "urn:p4");
	}

	@Test
	public void testInjectRewritesOptionalWithCondition() {
		StatementPattern left = new StatementPattern(
				new Var("s"),
				new Var("p1", SimpleValueFactory.getInstance().createIRI("urn:p1")),
				new Var("o"));
		StatementPattern right = new StatementPattern(
				new Var("s"),
				new Var("p2", SimpleValueFactory.getInstance().createIRI("urn:p2")),
				new Var("o2"));
		ValueConstant constant = new ValueConstant(SimpleValueFactory.getInstance().createIRI("urn:c"));
		Compare condition = new Compare(new Var("o2"), constant, CompareOp.EQ);
		LeftJoin join = new LeftJoin(left, right, condition);
		QueryRoot root = new QueryRoot(join);

		QueryOptimizer optimizer = getOptimizer();
		optimizer.optimize(root, new SimpleDataset(), EmptyBindingSet.getInstance());
		TupleExpr expr = root.getArg();

		assertThat(expr).isInstanceOf(LeftJoin.class);
		LeftJoin leftJoin = (LeftJoin) expr;
		assertThat(leftJoin.getCondition()).isNotNull();
		assertJoinPredicates(leftJoin.getLeftArg(), "urn:p1");
		assertJoinPredicates(leftJoin.getRightArg(), "urn:p1", "urn:p2");
	}

	private TupleExpr optimize(String query) {
		ParsedTupleQuery parsedQuery = QueryParserUtil.parseTupleQuery(QueryLanguage.SPARQL, query, null);
		QueryOptimizer optimizer = getOptimizer();
		optimizer.optimize(parsedQuery.getTupleExpr(), new SimpleDataset(), EmptyBindingSet.getInstance());
		TupleExpr root = parsedQuery.getTupleExpr();
		if (root instanceof QueryRoot) {
			return ((QueryRoot) root).getArg();
		}
		return root;
	}

	private void assertJoinPredicates(TupleExpr expr, String... predicateIris) {
		assertThat(expr).isInstanceOfAny(Join.class, StatementPattern.class);
		List<String> predicates = new ArrayList<>();
		collectStatementPatterns(expr, predicates);
		assertThat(predicates).containsExactlyInAnyOrder(predicateIris);
	}

	private void collectStatementPatterns(TupleExpr expr, List<String> predicates) {
		expr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			public void meet(StatementPattern node) {
				Var predicateVar = node.getPredicateVar();
				if (predicateVar != null && predicateVar.hasValue() && predicateVar.getValue() instanceof IRI) {
					predicates.add(((IRI) predicateVar.getValue()).stringValue());
				}
			}

			@Override
			public void meet(Join node) {
				node.getLeftArg().visit(this);
				node.getRightArg().visit(this);
			}
		});
	}

	private List<String> collectPredicates(TupleExpr expr) {
		List<String> predicates = new ArrayList<>();
		expr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			public void meet(StatementPattern node) {
				Var predicateVar = node.getPredicateVar();
				if (predicateVar != null && predicateVar.hasValue() && predicateVar.getValue() instanceof IRI) {
					predicates.add(((IRI) predicateVar.getValue()).stringValue());
				}
			}
		});
		return predicates;
	}

	private static final class FixedEvaluationStatistics extends EvaluationStatistics {
		@Override
		public double getCardinality(TupleExpr expr) {
			if (expr instanceof Join) {
				return 1.0;
			}
			if (expr instanceof StatementPattern) {
				StatementPattern pattern = (StatementPattern) expr;
				Var predicate = pattern.getPredicateVar();
				if (predicate != null && predicate.hasValue() && predicate.getValue() instanceof IRI) {
					String iri = ((IRI) predicate.getValue()).stringValue();
					if (iri.endsWith("p1")) {
						return 100.0;
					}
					if (iri.endsWith("p2")) {
						return 2.0;
					}
					if (iri.endsWith("p3")) {
						return 3.0;
					}
				}
				return 10.0;
			}
			return super.getCardinality(expr);
		}
	}
}
