/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;

import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.ValueFactory;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.query.algebra.Exists;
import org.eclipse.rdf4j.query.algebra.Filter;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.QueryModelNode;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.ValueExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EmptyTripleSource;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.JoinStatsProvider;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.LearnedQueryJoinOptimizer;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.PatternKey;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractQueryModelVisitor;
import org.eclipse.rdf4j.query.algebra.helpers.collectors.StatementPatternCollector;
import org.eclipse.rdf4j.query.impl.EmptyBindingSet;
import org.eclipse.rdf4j.query.parser.ParsedQuery;
import org.eclipse.rdf4j.query.parser.sparql.SPARQLParser;
import org.junit.jupiter.api.Test;

class LearnedQueryJoinOptimizerExistsScopeTest {

	private static final ValueFactory VF = SimpleValueFactory.getInstance();
	private static final String EX_NS = "http://example.com/";
	private static final IRI P1 = VF.createIRI(EX_NS, "p1");
	private static final IRI P2 = VF.createIRI(EX_NS, "p2");

	private static final String QUERY = String.join("\n",
			"PREFIX ex: <http://example.com/>",
			"SELECT * WHERE {",
			"  ?s ex:p1 ?o .",
			"  ?s ex:p2 ?x .",
			"  FILTER EXISTS { ?s ex:p4 ?y . }",
			"}");

	@Test
	void doesNotTreatExistsFilterArgVarsAsInitiallyBound() throws Exception {
		EvaluationStatistics stats = new EvaluationStatistics();
		JoinStatsProvider statsProvider = new MaskAwareStatsProvider();
		LearnedJoinConfig config = new LearnedJoinConfig(LearnedJoinConfig.DEFAULT_DP_THRESHOLD, false);
		LearnedQueryJoinOptimizer optimizer = new LearnedQueryJoinOptimizer(stats, new EmptyTripleSource(),
				statsProvider, config);

		ParsedQuery parsed = new SPARQLParser().parseQuery(QUERY, null);
		TupleExpr expr = parsed.getTupleExpr();
		optimizer.optimize(expr, null, EmptyBindingSet.getInstance());

		Filter existsFilter = findExistsFilter(expr);
		assertNotNull(existsFilter, "Expected EXISTS filter");
		List<String> order = joinOrderSignature(existsFilter.getArg());
		assertEquals(List.of(P2.stringValue(), P1.stringValue()), order);
	}

	private static Filter findExistsFilter(TupleExpr expr) {
		Filter[] found = new Filter[1];
		expr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			public void meet(Filter node) {
				if (found[0] == null && containsExists(node.getCondition())) {
					found[0] = node;
				}
				super.meet(node);
			}
		});
		return found[0];
	}

	private static boolean containsExists(ValueExpr expr) {
		if (expr == null) {
			return false;
		}
		boolean[] found = new boolean[1];
		expr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			public void meet(Exists node) {
				found[0] = true;
			}

			@Override
			protected void meetNode(QueryModelNode node) {
				if (!found[0]) {
					super.meetNode(node);
				}
			}
		});
		return found[0];
	}

	private static List<String> joinOrderSignature(TupleExpr expr) {
		Join join = findLargestJoin(expr);
		if (join == null) {
			return List.of();
		}
		List<TupleExpr> operands = flattenJoin(join);
		List<String> order = new ArrayList<>(operands.size());
		for (TupleExpr operand : operands) {
			List<StatementPattern> patterns = StatementPatternCollector.process(operand);
			if (patterns.isEmpty()) {
				order.add(operand.getClass().getSimpleName());
				continue;
			}
			Var predicate = patterns.get(0).getPredicateVar();
			order.add(predicateLabel(predicate));
		}
		return order;
	}

	private static Join findLargestJoin(TupleExpr expr) {
		Join[] best = new Join[1];
		int[] bestSize = new int[1];
		expr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			public void meet(Join node) {
				int size = flattenJoin(node).size();
				if (size > bestSize[0]) {
					bestSize[0] = size;
					best[0] = node;
				}
				super.meet(node);
			}
		});
		return best[0];
	}

	private static List<TupleExpr> flattenJoin(TupleExpr expr) {
		List<TupleExpr> operands = new ArrayList<>();
		Deque<TupleExpr> stack = new ArrayDeque<>();
		stack.push(expr);
		while (!stack.isEmpty()) {
			TupleExpr current = stack.pop();
			if (current instanceof Join) {
				Join join = (Join) current;
				stack.push(join.getRightArg());
				stack.push(join.getLeftArg());
			} else {
				operands.add(current);
			}
		}
		return operands;
	}

	private static String predicateLabel(Var predicate) {
		if (predicate == null || !predicate.hasValue()) {
			return "<var>";
		}
		return predicate.getValue().stringValue();
	}

	private static final class MaskAwareStatsProvider implements JoinStatsProvider {
		@Override
		public void reset() {
		}

		@Override
		public void recordCall(PatternKey key) {
		}

		@Override
		public void recordResults(PatternKey key, long resultCount) {
		}

		@Override
		public void seedIfAbsent(PatternKey key, double defaultCardinality, long priorCalls) {
		}

		@Override
		public double getAverageResults(PatternKey key) {
			if (key == null || key.getPredicate() == null) {
				return 0.0d;
			}
			boolean fullyBound = (key.getBoundMask()
					& (PatternKey.SUBJECT_BOUND | PatternKey.OBJECT_BOUND)) == (PatternKey.SUBJECT_BOUND
							| PatternKey.OBJECT_BOUND);
			if (P1.equals(key.getPredicate())) {
				return fullyBound ? 1.0d : 100.0d;
			}
			if (P2.equals(key.getPredicate())) {
				return fullyBound ? 2.0d : 10.0d;
			}
			return 0.0d;
		}

		@Override
		public double getMaxResults(PatternKey key) {
			return 0.0d;
		}

		@Override
		public boolean hasStats(PatternKey key) {
			return true;
		}

		@Override
		public long getTotalCalls() {
			return 0;
		}
	}
}
