/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EmptyTripleSource;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.JoinStatsProvider;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.LearnedQueryJoinOptimizer;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.PatternKey;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractQueryModelVisitor;
import org.eclipse.rdf4j.query.parser.ParsedQuery;
import org.eclipse.rdf4j.query.parser.sparql.SPARQLParser;
import org.junit.jupiter.api.Test;

class LearnedQueryJoinOptimizerBindingSetAssignmentTest {

	private static final String EX_NS = "http://example.com/";
	private static final IRI P_BOUND = SimpleValueFactory.getInstance().createIRI(EX_NS, "pBound");
	private static final IRI P_UNBOUND = SimpleValueFactory.getInstance().createIRI(EX_NS, "pUnbound");

	private static final String QUERY = String.join("\n",
			"PREFIX ex: <http://example.com/>",
			"SELECT * WHERE {",
			"  VALUES ?b { ex:b1 ex:b2 }",
			"  ?x ex:pUnbound ?y .",
			"  ?b ex:pBound ?x .",
			"}");

	@Test
	void treatsValuesBindingsAsInitiallyBound() throws Exception {
		SPARQLParser parser = new SPARQLParser();
		ParsedQuery parsedQuery = parser.parseQuery(QUERY, null);
		LearnedQueryJoinOptimizer optimizer = new LearnedQueryJoinOptimizer(new EvaluationStatistics(),
				new EmptyTripleSource(), new BindingAwareStatsProvider());

		optimizer.optimize(parsedQuery.getTupleExpr(), null, null);

		List<IRI> order = orderedPredicates(parsedQuery.getTupleExpr());
		assertEquals(List.of(P_BOUND, P_UNBOUND), order,
				"VALUES bindings should bias join ordering toward bound patterns");
	}

	private List<IRI> orderedPredicates(TupleExpr tupleExpr) {
		List<IRI> order = new ArrayList<>();
		tupleExpr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			public void meet(StatementPattern node) {
				IRI predicate = null;
				if (node.getPredicateVar() != null && node.getPredicateVar().hasValue()
						&& node.getPredicateVar().getValue() instanceof IRI) {
					predicate = (IRI) node.getPredicateVar().getValue();
				}
				if (P_BOUND.equals(predicate) || P_UNBOUND.equals(predicate)) {
					order.add(predicate);
				}
			}
		});
		return order;
	}

	private static final class BindingAwareStatsProvider implements JoinStatsProvider {

		@Override
		public void reset() {
		}

		@Override
		public void recordCall(PatternKey key) {
		}

		@Override
		public void recordResults(PatternKey key, long resultCount) {
		}

		@Override
		public void seedIfAbsent(PatternKey key, double defaultCardinality, long priorCalls) {
		}

		@Override
		public double getAverageResults(PatternKey key) {
			IRI predicate = key.getPredicate();
			if (P_BOUND.equals(predicate)) {
				boolean subjectBound = (key.getBoundMask() & PatternKey.SUBJECT_BOUND) != 0;
				return subjectBound ? 1.0d : 1000.0d;
			}
			if (P_UNBOUND.equals(predicate)) {
				return 10.0d;
			}
			return 1000.0d;
		}

		@Override
		public boolean hasStats(PatternKey key) {
			return true;
		}

		@Override
		public long getTotalCalls() {
			return 0;
		}
	}
}
