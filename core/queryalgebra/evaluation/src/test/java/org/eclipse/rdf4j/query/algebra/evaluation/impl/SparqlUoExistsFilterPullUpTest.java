/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.impl;

import static org.assertj.core.api.Assertions.assertThat;

import java.util.List;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.algebra.And;
import org.eclipse.rdf4j.query.algebra.BindingSetAssignment;
import org.eclipse.rdf4j.query.algebra.Compare;
import org.eclipse.rdf4j.query.algebra.Exists;
import org.eclipse.rdf4j.query.algebra.Filter;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.QueryRoot;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.ValueExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.SparqlUoQueryOptimizerPipeline;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.sparqluo.SparqlUoConfig;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractQueryModelVisitor;
import org.eclipse.rdf4j.query.impl.EmptyBindingSet;
import org.eclipse.rdf4j.query.impl.ListBindingSet;
import org.junit.jupiter.api.Test;

class SparqlUoExistsFilterPullUpTest {

	@Test
	void pullsUpExistsFilterAboveJoinWhenRightIntroducesNoBindings() {
		IRI follows = SimpleValueFactory.getInstance().createIRI("urn:follows");

		BindingSetAssignment uValues = createValues("u", "urn:u1", "urn:u2");
		BindingSetAssignment vValues = createValues("v", "urn:v1", "urn:v2");
		Join valuesJoin = new Join(uValues, vValues);

		Exists reciprocal = new Exists(new StatementPattern(
				new Var("v"),
				new Var("pReciprocal", follows),
				new Var("u")));
		Compare neq = new Compare(new Var("u"), new Var("v"), Compare.CompareOp.NE);
		Filter filter = new Filter(valuesJoin, new And(reciprocal, neq));

		StatementPattern followsPattern = new StatementPattern(
				new Var("u"),
				new Var("pFollows", follows),
				new Var("v"));
		TupleExpr expr = new QueryRoot(new Join(filter, followsPattern));

		optimize(expr);

		Filter existsFilter = findFilterWithExists(expr);
		assertThat(existsFilter).isNotNull();
		assertThat(containsStatementPatternWithPredicate(existsFilter.getArg(), follows)).isTrue();
	}

	private static BindingSetAssignment createValues(String name, String value1, String value2) {
		IRI iri1 = SimpleValueFactory.getInstance().createIRI(value1);
		IRI iri2 = SimpleValueFactory.getInstance().createIRI(value2);
		List<BindingSet> bindingSets = List.of(
				new ListBindingSet(List.of(name), iri1),
				new ListBindingSet(List.of(name), iri2));
		BindingSetAssignment assignment = new BindingSetAssignment();
		assignment.setBindingNames(Set.of(name));
		assignment.setBindingSets(bindingSets);
		return assignment;
	}

	private static void optimize(TupleExpr expr) {
		EmptyTripleSource tripleSource = new EmptyTripleSource();
		EvaluationStatistics evaluationStatistics = new EvaluationStatistics() {
			@Override
			public double getCardinality(TupleExpr tupleExpr) {
				if (tupleExpr instanceof StatementPattern) {
					return 100_000.0;
				}
				return super.getCardinality(tupleExpr);
			}
		};
		DefaultEvaluationStrategy strategy = new DefaultEvaluationStrategy(tripleSource, null, null, 0L,
				evaluationStatistics);
		SparqlUoConfig config = SparqlUoConfig.builder()
				.enableOptionalFilterJoin(false)
				.build();
		strategy.setOptimizerPipeline(
				new SparqlUoQueryOptimizerPipeline(strategy, tripleSource, evaluationStatistics, config));
		strategy.optimize(expr, evaluationStatistics, EmptyBindingSet.getInstance());
	}

	private static Filter findFilterWithExists(TupleExpr expr) {
		AtomicReference<Filter> found = new AtomicReference<>();
		expr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			public void meet(Filter node) throws RuntimeException {
				if (found.get() == null && containsExists(node.getCondition())) {
					found.set(node);
				}
				super.meet(node);
			}
		});
		return found.get();
	}

	private static boolean containsExists(ValueExpr expr) {
		if (expr == null) {
			return false;
		}
		if (expr instanceof Exists) {
			return true;
		}
		if (expr instanceof org.eclipse.rdf4j.query.algebra.UnaryValueOperator) {
			return containsExists(((org.eclipse.rdf4j.query.algebra.UnaryValueOperator) expr).getArg());
		}
		if (expr instanceof org.eclipse.rdf4j.query.algebra.BinaryValueOperator) {
			org.eclipse.rdf4j.query.algebra.BinaryValueOperator binary = (org.eclipse.rdf4j.query.algebra.BinaryValueOperator) expr;
			return containsExists(binary.getLeftArg()) || containsExists(binary.getRightArg());
		}
		if (expr instanceof org.eclipse.rdf4j.query.algebra.NAryValueOperator) {
			for (ValueExpr arg : ((org.eclipse.rdf4j.query.algebra.NAryValueOperator) expr).getArguments()) {
				if (containsExists(arg)) {
					return true;
				}
			}
			return false;
		}
		return false;
	}

	private static boolean containsStatementPatternWithPredicate(TupleExpr expr, IRI predicate) {
		AtomicBoolean found = new AtomicBoolean(false);
		expr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			public void meet(StatementPattern node) throws RuntimeException {
				Var predicateVar = node.getPredicateVar();
				if (predicateVar != null && predicateVar.hasValue() && predicateVar.getValue().equals(predicate)) {
					found.set(true);
				}
			}
		});
		return found.get();
	}
}
