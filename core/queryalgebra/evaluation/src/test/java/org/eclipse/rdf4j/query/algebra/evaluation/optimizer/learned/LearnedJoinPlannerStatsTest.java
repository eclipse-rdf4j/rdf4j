/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.optimizer.learned;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotEquals;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.model.vocabulary.RDF;
import org.eclipse.rdf4j.query.QueryLanguage;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.EvaluationStatistics;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.JoinStatsProvider;
import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.PatternKey;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractQueryModelVisitor;
import org.eclipse.rdf4j.query.algebra.helpers.collectors.StatementPatternCollector;
import org.eclipse.rdf4j.query.parser.ParsedTupleQuery;
import org.eclipse.rdf4j.query.parser.QueryParserUtil;
import org.junit.jupiter.api.Test;

class LearnedJoinPlannerStatsTest {

	private static final String GRID_QUERY = String.join("\n",
			"PREFIX grid: <http://example.com/theme/grid/>",
			"SELECT (COUNT(DISTINCT ?line) AS ?count) WHERE {",
			"  ?line a grid:Line ; grid:connectsTo ?substation .",
			"  ?substation grid:name ?name .",
			"  FILTER(?name = \"Substation 0\" || ?name = \"Substation 1\")",
			"  FILTER EXISTS { ?line grid:connectsTo ?other . }",
			"  OPTIONAL { ?line grid:connectsTo ?other2 . }",
			"}");

	private static final String PHARMA_QUERY = String.join("\n",
			"PREFIX pharma: <http://example.com/theme/pharma/>",
			"SELECT ?combo (COUNT(DISTINCT ?target) AS ?sharedTargets) WHERE {",
			"  ?combo a pharma:Combination ; pharma:combinationOf ?drugA ; pharma:combinationOf ?drugB .",
			"  FILTER(?drugA != ?drugB)",
			"  ?drugA pharma:targets ?target .",
			"  ?drugB pharma:targets ?target .",
			"  OPTIONAL { ?drugA pharma:hasSideEffect ?sideEffect . BIND(?sideEffect AS ?optSideEffect) }",
			"  FILTER(?optSideEffect != <http://example.com/theme/pharma/side-effect/0>)",
			"  FILTER EXISTS { ?drugB pharma:hasSideEffect ?sideEffect2 . }",
			"}",
			"GROUP BY ?combo",
			"HAVING(COUNT(DISTINCT ?target) > 1)");

	@Test
	void gridQueryDpOrderShiftsWithStats() {
		TupleExpr expr = parse(GRID_QUERY);
		List<TupleExpr> operands = flattenJoin(findLargestJoin(expr));

		IRI connectsTo = iri("http://example.com/theme/grid/connectsTo");
		IRI name = iri("http://example.com/theme/grid/name");
		IRI rdfType = RDF.TYPE;

		JoinStatsProvider statsPreferName = stats(Map.of(
				key(name, PatternKey.PREDICATE_BOUND), 10.0d,
				key(name, PatternKey.SUBJECT_BOUND | PatternKey.PREDICATE_BOUND), 1.0d,
				key(connectsTo, PatternKey.PREDICATE_BOUND), 100000.0d,
				key(connectsTo, PatternKey.PREDICATE_BOUND | PatternKey.OBJECT_BOUND), 1.0d,
				key(rdfType, PatternKey.PREDICATE_BOUND | PatternKey.OBJECT_BOUND), 50.0d));
		List<String> preferNameOrder = dpOrder(operands, statsPreferName);

		JoinStatsProvider statsPreferConnectsTo = stats(Map.of(
				key(name, PatternKey.PREDICATE_BOUND), 10000.0d,
				key(connectsTo, PatternKey.PREDICATE_BOUND), 1.0d,
				key(connectsTo, PatternKey.PREDICATE_BOUND | PatternKey.SUBJECT_BOUND), 1.0d,
				key(rdfType, PatternKey.PREDICATE_BOUND | PatternKey.OBJECT_BOUND), 50.0d));
		List<String> preferConnectsToOrder = dpOrder(operands, statsPreferConnectsTo);

		assertEquals(List.of(name.stringValue(), connectsTo.stringValue(), rdfType.stringValue()), preferNameOrder);
		assertEquals(List.of(connectsTo.stringValue(), rdfType.stringValue(), name.stringValue()),
				preferConnectsToOrder);
		assertNotEquals(preferNameOrder, preferConnectsToOrder);
	}

	@Test
	void pharmaQueryDpOrderRespondsToTargetsStats() {
		TupleExpr expr = parse(PHARMA_QUERY);
		List<TupleExpr> operands = flattenJoin(findLargestJoin(expr));

		IRI targets = iri("http://example.com/theme/pharma/targets");
		IRI combinationOf = iri("http://example.com/theme/pharma/combinationOf");
		IRI rdfType = RDF.TYPE;

		JoinStatsProvider statsAvoidTargets = stats(Map.of(
				key(targets, PatternKey.PREDICATE_BOUND), 50000.0d,
				key(targets, PatternKey.PREDICATE_BOUND | PatternKey.SUBJECT_BOUND), 5.0d,
				key(combinationOf, PatternKey.PREDICATE_BOUND), 100.0d,
				key(combinationOf, PatternKey.PREDICATE_BOUND | PatternKey.SUBJECT_BOUND), 10.0d,
				key(rdfType, PatternKey.PREDICATE_BOUND | PatternKey.OBJECT_BOUND), 50.0d));
		List<String> avoidTargetsOrder = dpOrder(operands, statsAvoidTargets);

		JoinStatsProvider statsPreferTargets = stats(Map.of(
				key(targets, PatternKey.PREDICATE_BOUND), 1.0d,
				key(targets, PatternKey.PREDICATE_BOUND | PatternKey.SUBJECT_BOUND), 1.0d,
				key(combinationOf, PatternKey.PREDICATE_BOUND), 10000.0d,
				key(rdfType, PatternKey.PREDICATE_BOUND | PatternKey.OBJECT_BOUND), 10000.0d));
		List<String> preferTargetsOrder = dpOrder(operands, statsPreferTargets);

		assertEquals(List.of(combinationOf.stringValue(), rdfType.stringValue(), targets.stringValue(),
				targets.stringValue(), combinationOf.stringValue()), avoidTargetsOrder);
		assertEquals(List.of(targets.stringValue(), combinationOf.stringValue(), rdfType.stringValue(),
				targets.stringValue(), combinationOf.stringValue()), preferTargetsOrder);
		assertNotEquals(avoidTargetsOrder, preferTargetsOrder);
	}

	private static TupleExpr parse(String query) {
		ParsedTupleQuery parsed = QueryParserUtil.parseTupleQuery(QueryLanguage.SPARQL, query, null);
		return parsed.getTupleExpr();
	}

	private static Join findLargestJoin(TupleExpr expr) {
		Join[] best = new Join[1];
		int[] bestSize = new int[1];
		expr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			public void meet(Join node) {
				int size = flattenJoin(node).size();
				if (size > bestSize[0]) {
					bestSize[0] = size;
					best[0] = node;
				}
				super.meet(node);
			}
		});
		if (best[0] == null) {
			throw new IllegalStateException("No Join node found in query");
		}
		return best[0];
	}

	private static List<TupleExpr> flattenJoin(TupleExpr expr) {
		List<TupleExpr> operands = new ArrayList<>();
		flattenJoin(expr, operands);
		return operands;
	}

	private static void flattenJoin(TupleExpr expr, List<TupleExpr> operands) {
		if (expr instanceof Join) {
			Join join = (Join) expr;
			flattenJoin(join.getLeftArg(), operands);
			flattenJoin(join.getRightArg(), operands);
			return;
		}
		operands.add(expr);
	}

	private static List<String> dpOrder(List<TupleExpr> operands, JoinStatsProvider statsProvider) {
		BindJoinCostModel costModel = new LearnedBindJoinCostModel(new EvaluationStatistics(), statsProvider);
		JoinOrderPlanner planner = new DpLeftDeepBindJoinOrderPlanner(costModel);
		List<TupleExpr> ordered = planner.order(new ArrayList<>(operands), Set.of());
		List<String> order = new ArrayList<>();
		for (TupleExpr expr : ordered) {
			List<StatementPattern> patterns = StatementPatternCollector.process(expr);
			if (patterns.isEmpty()) {
				continue;
			}
			Var pred = patterns.get(0).getPredicateVar();
			order.add(predicateLabel(pred));
		}
		return order;
	}

	private static String predicateLabel(Var predicate) {
		if (predicate == null || !predicate.hasValue()) {
			return "<var>";
		}
		return predicate.getValue().stringValue();
	}

	private static JoinStatsProvider stats(Map<PatternKey, Double> estimates) {
		return new PatternKeyStatsProvider(estimates);
	}

	private static IRI iri(String value) {
		return SimpleValueFactory.getInstance().createIRI(value);
	}

	private static PatternKey key(IRI predicate, int mask) {
		return new PatternKey(predicate, mask);
	}

	private static final class PatternKeyStatsProvider implements JoinStatsProvider {
		private final Map<PatternKey, Double> estimates;

		private PatternKeyStatsProvider(Map<PatternKey, Double> estimates) {
			this.estimates = Objects.requireNonNull(estimates, "estimates");
		}

		@Override
		public void reset() {
		}

		@Override
		public void recordCall(PatternKey key) {
		}

		@Override
		public void recordResults(PatternKey key, long resultCount) {
		}

		@Override
		public void seedIfAbsent(PatternKey key, double defaultCardinality, long priorCalls) {
		}

		@Override
		public double getAverageResults(PatternKey key) {
			Double estimate = estimates.get(key);
			return estimate == null ? 0.0d : estimate;
		}

		@Override
		public boolean hasStats(PatternKey key) {
			return estimates.containsKey(key);
		}

		@Override
		public long getTotalCalls() {
			return 0;
		}

		@Override
		public void recordStatementsAdded(long statementCount) {
		}
	}
}
