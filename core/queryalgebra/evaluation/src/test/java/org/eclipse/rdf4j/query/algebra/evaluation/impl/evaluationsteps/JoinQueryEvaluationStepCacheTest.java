/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.impl.evaluationsteps;

import static org.assertj.core.api.Assertions.assertThat;

import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

import org.eclipse.rdf4j.common.iteration.CloseableIteration;
import org.eclipse.rdf4j.common.iteration.CloseableIteratorIteration;
import org.eclipse.rdf4j.common.iteration.EmptyIteration;
import org.eclipse.rdf4j.common.iteration.Iterations;
import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Resource;
import org.eclipse.rdf4j.model.Statement;
import org.eclipse.rdf4j.model.Value;
import org.eclipse.rdf4j.model.ValueFactory;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.MutableBindingSet;
import org.eclipse.rdf4j.query.QueryEvaluationException;
import org.eclipse.rdf4j.query.algebra.BindingSetAssignment;
import org.eclipse.rdf4j.query.algebra.Extension;
import org.eclipse.rdf4j.query.algebra.ExtensionElem;
import org.eclipse.rdf4j.query.algebra.FunctionCall;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryBindingSet;
import org.eclipse.rdf4j.query.algebra.evaluation.TripleSource;
import org.eclipse.rdf4j.query.algebra.evaluation.function.numeric.Rand;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.QueryEvaluationContext;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.StrictEvaluationStrategy;
import org.eclipse.rdf4j.query.impl.EmptyBindingSet;
import org.junit.jupiter.api.Test;

class JoinQueryEvaluationStepCacheTest {

	@Test
	void joinKeyCachingAvoidsDuplicateRightEvaluation() {
		ValueFactory vf = SimpleValueFactory.getInstance();
		AtomicInteger getStatementsCalls = new AtomicInteger();
		Statement statement = vf.createStatement(
				vf.createIRI("urn:subj"),
				vf.createIRI("urn:p"),
				vf.createIRI("urn:obj"));

		TripleSource tripleSource = new TripleSource() {
			@Override
			public CloseableIteration<? extends Statement> getStatements(Resource subj, IRI pred, Value obj,
					Resource... contexts) throws QueryEvaluationException {
				getStatementsCalls.incrementAndGet();
				if (subj != null && !subj.equals(statement.getSubject())) {
					return new EmptyIteration<>();
				}
				if (pred != null && !pred.equals(statement.getPredicate())) {
					return new EmptyIteration<>();
				}
				if (obj != null && !obj.equals(statement.getObject())) {
					return new EmptyIteration<>();
				}
				return new CloseableIteratorIteration<>(List.of(statement).iterator());
			}

			@Override
			public ValueFactory getValueFactory() {
				return vf;
			}
		};

		StrictEvaluationStrategy strategy = new StrictEvaluationStrategy(tripleSource, null, null);
		QueryEvaluationContext context = new QueryEvaluationContext.Minimal((org.eclipse.rdf4j.query.Dataset) null);

		BindingSetAssignment left = new BindingSetAssignment();
		MutableBindingSet leftBinding1 = new QueryBindingSet();
		leftBinding1.addBinding("s", vf.createIRI("urn:subj"));
		MutableBindingSet leftBinding2 = new QueryBindingSet();
		leftBinding2.addBinding("s", vf.createIRI("urn:subj"));
		left.setBindingSets(List.of(leftBinding1, leftBinding2));

		StatementPattern right = new StatementPattern(
				new Var("s"),
				new Var("p", vf.createIRI("urn:p")),
				new Var("o"));
		Join join = new Join(left, right);

		JoinQueryEvaluationStep step = new JoinQueryEvaluationStep(strategy, join, context);

		try (CloseableIteration<BindingSet> iteration = step.evaluate(EmptyBindingSet.getInstance())) {
			List<BindingSet> results = Iterations.asList(iteration);
			assertThat(results).hasSize(2);
		}

		assertThat(getStatementsCalls.get()).isEqualTo(1);
	}

	@Test
	void joinKeyCachingSkippedForNonDeterministicRightSide() {
		ValueFactory vf = SimpleValueFactory.getInstance();
		Statement statement = vf.createStatement(
				vf.createIRI("urn:subj"),
				vf.createIRI("urn:p"),
				vf.createIRI("urn:obj"));

		TripleSource tripleSource = new TripleSource() {
			@Override
			public CloseableIteration<? extends Statement> getStatements(Resource subj, IRI pred, Value obj,
					Resource... contexts) throws QueryEvaluationException {
				if (subj != null && !subj.equals(statement.getSubject())) {
					return new EmptyIteration<>();
				}
				if (pred != null && !pred.equals(statement.getPredicate())) {
					return new EmptyIteration<>();
				}
				if (obj != null && !obj.equals(statement.getObject())) {
					return new EmptyIteration<>();
				}
				return new CloseableIteratorIteration<>(List.of(statement).iterator());
			}

			@Override
			public ValueFactory getValueFactory() {
				return vf;
			}
		};

		StrictEvaluationStrategy strategy = new StrictEvaluationStrategy(tripleSource, null, null);
		QueryEvaluationContext context = new QueryEvaluationContext.Minimal((org.eclipse.rdf4j.query.Dataset) null);

		BindingSetAssignment left = new BindingSetAssignment();
		MutableBindingSet leftBinding1 = new QueryBindingSet();
		leftBinding1.addBinding("s", vf.createIRI("urn:subj"));
		MutableBindingSet leftBinding2 = new QueryBindingSet();
		leftBinding2.addBinding("s", vf.createIRI("urn:subj"));
		left.setBindingSets(List.of(leftBinding1, leftBinding2));

		StatementPattern right = new StatementPattern(
				new Var("s"),
				new Var("p", vf.createIRI("urn:p")),
				new Var("o"));
		Extension extension = new Extension(right);
		extension.addElement(new ExtensionElem(
				new FunctionCall(new Rand().getURI()),
				"r"));
		Join join = new Join(left, extension);

		JoinQueryEvaluationStep step = new JoinQueryEvaluationStep(strategy, join, context);

		try (CloseableIteration<BindingSet> iteration = step.evaluate(EmptyBindingSet.getInstance())) {
			List<BindingSet> results = Iterations.asList(iteration);
			assertThat(results).hasSize(2);
		}

		assertThat(join.getAlgorithmName()).isNotEqualTo("JoinKeyCacheIterator");
	}

	@Test
	void joinKeyCachingSkippedForBindingSetAssignmentRightSide() {
		ValueFactory vf = SimpleValueFactory.getInstance();
		Statement statement = vf.createStatement(
				vf.createIRI("urn:subj"),
				vf.createIRI("urn:p"),
				vf.createIRI("urn:obj"));

		TripleSource tripleSource = new TripleSource() {
			@Override
			public CloseableIteration<? extends Statement> getStatements(Resource subj, IRI pred, Value obj,
					Resource... contexts) throws QueryEvaluationException {
				if (subj != null && !subj.equals(statement.getSubject())) {
					return new EmptyIteration<>();
				}
				if (pred != null && !pred.equals(statement.getPredicate())) {
					return new EmptyIteration<>();
				}
				if (obj != null && !obj.equals(statement.getObject())) {
					return new EmptyIteration<>();
				}
				return new CloseableIteratorIteration<>(List.of(statement).iterator());
			}

			@Override
			public ValueFactory getValueFactory() {
				return vf;
			}
		};

		StrictEvaluationStrategy strategy = new StrictEvaluationStrategy(tripleSource, null, null);
		QueryEvaluationContext context = new QueryEvaluationContext.Minimal((org.eclipse.rdf4j.query.Dataset) null);

		StatementPattern left = new StatementPattern(
				new Var("s"),
				new Var("p", vf.createIRI("urn:p")),
				new Var("o"));

		BindingSetAssignment right = new BindingSetAssignment();
		MutableBindingSet rightBinding1 = new QueryBindingSet();
		rightBinding1.addBinding("s", vf.createIRI("urn:subj"));
		MutableBindingSet rightBinding2 = new QueryBindingSet();
		rightBinding2.addBinding("s", vf.createIRI("urn:subj"));
		right.setBindingSets(List.of(rightBinding1, rightBinding2));

		Join join = new Join(left, right);

		JoinQueryEvaluationStep step = new JoinQueryEvaluationStep(strategy, join, context);

		try (CloseableIteration<BindingSet> iteration = step.evaluate(EmptyBindingSet.getInstance())) {
			List<BindingSet> results = Iterations.asList(iteration);
			assertThat(results).hasSize(2);
		}

		assertThat(join.getAlgorithmName()).isNotEqualTo("JoinKeyCacheIterator");
	}

	@Test
	void joinKeyCachingSkippedWhenJoinKeyMatchesRightBindings() {
		ValueFactory vf = SimpleValueFactory.getInstance();
		IRI follows = vf.createIRI("urn:follows");
		Statement first = vf.createStatement(
				vf.createIRI("urn:u1"),
				follows,
				vf.createIRI("urn:v1"));
		Statement second = vf.createStatement(
				vf.createIRI("urn:v1"),
				follows,
				vf.createIRI("urn:u1"));

		TripleSource tripleSource = new TripleSource() {
			@Override
			public CloseableIteration<? extends Statement> getStatements(Resource subj, IRI pred, Value obj,
					Resource... contexts) throws QueryEvaluationException {
				List<Statement> statements = List.of(first, second);
				List<Statement> results = statements.stream()
						.filter(stmt -> subj == null || subj.equals(stmt.getSubject()))
						.filter(stmt -> pred == null || pred.equals(stmt.getPredicate()))
						.filter(stmt -> obj == null || obj.equals(stmt.getObject()))
						.toList();
				return new CloseableIteratorIteration<>(results.iterator());
			}

			@Override
			public ValueFactory getValueFactory() {
				return vf;
			}
		};

		StrictEvaluationStrategy strategy = new StrictEvaluationStrategy(tripleSource, null, null);
		QueryEvaluationContext context = new QueryEvaluationContext.Minimal((org.eclipse.rdf4j.query.Dataset) null);

		StatementPattern left = new StatementPattern(
				new Var("u"),
				new Var("p", follows),
				new Var("v"));
		StatementPattern right = new StatementPattern(
				new Var("v"),
				new Var("p", follows),
				new Var("u"));

		Join join = new Join(left, right);
		JoinQueryEvaluationStep step = new JoinQueryEvaluationStep(strategy, join, context);

		try (CloseableIteration<BindingSet> iteration = step.evaluate(EmptyBindingSet.getInstance())) {
			List<BindingSet> results = Iterations.asList(iteration);
			assertThat(results).hasSize(2);
		}

		assertThat(join.getAlgorithmName()).isNotEqualTo("JoinKeyCacheIterator");
	}

	@Test
	void joinKeyCachingSkippedWhenRightAddsOnlyConstantBindings() {
		ValueFactory vf = SimpleValueFactory.getInstance();
		Statement statement = vf.createStatement(
				vf.createIRI("urn:subj"),
				vf.createIRI("urn:p"),
				vf.createIRI("urn:obj"));

		TripleSource tripleSource = new TripleSource() {
			@Override
			public CloseableIteration<? extends Statement> getStatements(Resource subj, IRI pred, Value obj,
					Resource... contexts) throws QueryEvaluationException {
				if (subj != null && !subj.equals(statement.getSubject())) {
					return new EmptyIteration<>();
				}
				if (pred != null && !pred.equals(statement.getPredicate())) {
					return new EmptyIteration<>();
				}
				if (obj != null && !obj.equals(statement.getObject())) {
					return new EmptyIteration<>();
				}
				return new CloseableIteratorIteration<>(List.of(statement).iterator());
			}

			@Override
			public ValueFactory getValueFactory() {
				return vf;
			}
		};

		StrictEvaluationStrategy strategy = new StrictEvaluationStrategy(tripleSource, null, null);
		QueryEvaluationContext context = new QueryEvaluationContext.Minimal((org.eclipse.rdf4j.query.Dataset) null);

		BindingSetAssignment left = new BindingSetAssignment();
		MutableBindingSet leftBinding = new QueryBindingSet();
		leftBinding.addBinding("s", vf.createIRI("urn:subj"));
		left.setBindingSets(List.of(leftBinding));

		StatementPattern right = new StatementPattern(
				new Var("s"),
				new Var("p", vf.createIRI("urn:p")),
				new Var("o", vf.createIRI("urn:obj")));
		Join join = new Join(left, right);

		JoinQueryEvaluationStep step = new JoinQueryEvaluationStep(strategy, join, context);

		try (CloseableIteration<BindingSet> iteration = step.evaluate(EmptyBindingSet.getInstance())) {
			List<BindingSet> results = Iterations.asList(iteration);
			assertThat(results).hasSize(1);
		}

		assertThat(join.getAlgorithmName()).isNotEqualTo("JoinKeyCacheIterator");
	}
}
