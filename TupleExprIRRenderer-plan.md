Take a look at [AGENTS.md](AGENTS.md) before you start.

# Plan for improving TupleExprIRRenderer, IR transforms, and rendering

Main rendering path — TupleExpr → raw IR → transformed IR → SPARQL.

The TupleExprt → raw IR step should have as little logic as possible, just enough to create a good representation of the TupleExpr tree. All the logic should be in the IR transforms, or if *really* needed, in the final rendering step.

- Module: core/queryrender
- Test class: [TupleExprIRRendererTest.java](core/queryrender/src/test/java/org/eclipse/rdf4j/queryrender/TupleExprIRRendererTest.java)

Read the following files before you start:
 - [IrTransforms.java](core/queryrender/src/main/java/org/eclipse/rdf4j/queryrender/sparql/ir/util/IrTransforms.java)
 - [TupleExprIRRenderer.java](core/queryrender/src/main/java/org/eclipse/rdf4j/queryrender/sparql/TupleExprIRRenderer.java)
 - [TupleExprToIrConverter.java](core/queryrender/src/main/java/org/eclipse/rdf4j/queryrender/sparql/TupleExprToIrConverter.java)
 - All the files in [ir](core/queryrender/src/main/java/org/eclipse/rdf4j/queryrender/sparql/ir)
 - All the files in [transform](core/queryrender/src/main/java/org/eclipse/rdf4j/queryrender/sparql/ir/util/transform)

Keep these in your context.

Nice to know:
 - Variables generated during SPARQL parsing typically have a prefix that tells you why they were generated. Such as the prefixes "_anon_path_" or "_anon_collection_" or "_anon_having_".
 - Test results are typically found in the `target/surefire-reports` folder of the module. For instance: [org.eclipse.rdf4j.queryrender.TupleExprIRRendererTest.txt](core/queryrender/target/surefire-reports/org.eclipse.rdf4j.queryrender.TupleExprIRRendererTest.txt)
 - When a test fails cfg.debugIR is automatically enabled, which prints the IR before and after transformation. This is very useful for understanding what is going on.

Important: Regularly run the tests in `core/queryrender` to ensure nothing breaks as you make changes.

Finally, re-read this entire plan regularly and keep it up to date as you make changes.

# Diffing the expected and actual from a failing test

Use the following example to diff the expected and actual algebra from a failing test. This is very useful to understand what is going on.

```bash
delta --keep-plus-minus-markers --paging=never -n core/queryrender/target/surefire-reports/org.eclipse.rdf4j.queryrender.TupleExprIRRendererTest#testOptionalServicePathScope_SPARQL_expected.txt core/queryrender/target/surefire-reports/org.eclipse.rdf4j.queryrender.TupleExprIRRendererTest#testOptionalServicePathScope_SPARQL_actual.txt
```
To diff the TupleExpr algebra from the expeted and actual query, use the following command:
```bash
delta --keep-plus-minus-markers --paging=never -n core/queryrender/target/surefire-reports/org.eclipse.rdf4j.queryrender.TupleExprIRRendererTest#testOptionalServicePathScope_TupleExpr_expected.txt core/queryrender/target/surefire-reports/org.eclipse.rdf4j.queryrender.TupleExprIRRendererTest#testOptionalServicePathScope_TupleExpr_actual.txt
```

It is also useful to look at the regular failsafe report:
```bash
tail 1000 core/queryrender/target/surefire-reports/org.eclipse.rdf4j.queryrender.TupleExprIRRendererTest.txt
```

# Current task

Before you start fixing the test, fill in the plan below. Focus on discovering if there are any issues in the TupleExpr to IR conversion or if the issue is in a transformer or if it's during printing.

Run the the following test: org.eclipse.rdf4j.queryrender.TupleExprIRRendererTest#deep_union_path_2

Use the diff command above to diff the expected and actual SPARQL and algebra from a failing test. This will help you understand what is going on.

The issue here is that a union that is added by the user will have a new scope, and branches of the union will also have a new scope. If the branches don't have a new scope, then it means that the union wasn't added by the user and that it's probably added by the parser while parsing an alt path sequence.

You need to find a general solution for the issue with a union added by a user creating a new scope in each branch, even though the branches don't end up with more than a single curly brace each. And also the issue with an alt path generating a union, and if that union is inside one of the branches of a real union, then it ends up with a new scope even though it was generated by the parser because of the alt path.

DO NOT CHANGE ANYTHING ABOVE THIS LINE.
-----------------------------------------------------------

LOOK AT THE CODE, UNDERSTAND HOW IT WORKS, MAKE A PLAN FOR HOW YOU INTEND TO FIND THE ROOT CAUSE AND HOW TO FIX IT. THEN START WORKING.

# Overall plan
- Reproduce the failure by running the single test offline with IR debug enabled, then diff expected vs actual SPARQL and TupleExpr.
- Identify where the unintended scope comes from: TupleExpr→IR conversion (`TupleExprToIrConverter#meet(Union)`), IR transforms, or final printing.
- Verify `Union#isVariableScopeChange()` and `rootHasExplicitScope(...)` usage for unions vs parser‑generated alternation paths; adjust newScope propagation accordingly.
- Add a conservative heuristic to distinguish user UNIONS from parser alt‑path unions in nested contexts, using algebra node types and `_anon_path_` bridge variables.
- Validate with targeted tests in `core/queryrender` and re‑diff reports until fixed; keep changes minimal and localized.

# Step by step plan
1) Build module offline (skip tests) to warm deps.
2) Run `TupleExprIRRendererTest#deep_union_path_2` offline and capture reports.
3) Diff SPARQL and TupleExpr expected vs actual to pinpoint scope/braces.
4) Inspect IR debug: check `IrUnion`/`IrBGP.newScope` flags in raw and transformed IR for the failing case.
5) Review `TupleExprToIrConverter#meet(Union)` and `rootHasExplicitScope` logic; confirm when branches get `newScope`.
6) If needed, refine `rootHasExplicitScope`/branch wrapping so only user UNIONS add branch scopes; alt‑path‑generated internals should not.
7) Re‑run the single test; expand to adjacent deep‑union path tests if necessary.
8) Run full `core/queryrender` tests offline to ensure no regressions.

# Work log
- Read TupleExprIRRenderer-plan.md, TupleExprIRRendererTest.java (located and inspected `deep_union_path_2`), IrTransforms.java, IR node classes (IrBGP, IrUnion, IrNode), and TupleExprToIrConverter.java.
- Observed: `meet(Union)` sets `IrUnion.newScope = u.isVariableScopeChange()` and may wrap each branch into an `IrBGP` with `newScope=true` when `rootHasExplicitScope(branch)`; printing of `IrBGP` adds an extra nested block when `newScope` is true.
- Hypothesis: a nested UNION created during path handling or transforms is being marked as a new scope erroneously, leading to extra braces in UNION branches.
- Built `core/queryrender` offline with tests skipped; then ran `TupleExprIRRendererTest#deep_union_path_2` offline — it passed locally (1 test run, 0 failures). Will broaden scope if needed to reproduce the failure described.
- Implemented refined UNION branch printing to avoid double braces when branches are marked `newScope`: changed `IrUnion.print` to always render one pair of braces per branch while preserving the `newScope` hint for transforms. This keeps textual output stable while retaining scoping semantics for passes that rely on the flag.
- Initially tried to force `newScope` on UNION branches when the algebra UNION has `isVariableScopeChange()`, but that caused broader regressions (blocked alternation fusions inside GRAPH/VALUES). Backed that change out to keep IR conversion conservative and let `IrUnion.isNewScope` drive transform heuristics.
- Verified targeted deep UNION path tests and specific UNION/GRAPH+VALUES cases; all targeted tests passed after the printing refinement.
