


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > HashJoinIteration</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.query.algebra.evaluation.iterator</a>
</div>

<h1>Coverage Summary for Class: HashJoinIteration (org.eclipse.rdf4j.query.algebra.evaluation.iterator)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">HashJoinIteration</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (14/21)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    31.7%
  </span>
  <span class="absValue">
    (59/186)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    78.7%
  </span>
  <span class="absValue">
    (122/155)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;package org.eclipse.rdf4j.query.algebra.evaluation.iterator;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.function.Function;
&nbsp;import java.util.function.IntFunction;
&nbsp;
&nbsp;import org.eclipse.rdf4j.common.iteration.CloseableIteration;
&nbsp;import org.eclipse.rdf4j.common.iteration.LookAheadIteration;
&nbsp;import org.eclipse.rdf4j.common.iterator.EmptyIterator;
&nbsp;import org.eclipse.rdf4j.common.iterator.UnionIterator;
&nbsp;import org.eclipse.rdf4j.model.Value;
&nbsp;import org.eclipse.rdf4j.query.BindingSet;
&nbsp;import org.eclipse.rdf4j.query.MutableBindingSet;
&nbsp;import org.eclipse.rdf4j.query.QueryEvaluationException;
&nbsp;import org.eclipse.rdf4j.query.algebra.Join;
&nbsp;import org.eclipse.rdf4j.query.algebra.LeftJoin;
&nbsp;import org.eclipse.rdf4j.query.algebra.TupleExpr;
&nbsp;import org.eclipse.rdf4j.query.algebra.evaluation.EvaluationStrategy;
&nbsp;import org.eclipse.rdf4j.query.algebra.evaluation.QueryBindingSet;
&nbsp;import org.eclipse.rdf4j.query.algebra.evaluation.QueryEvaluationStep;
&nbsp;import org.eclipse.rdf4j.query.algebra.evaluation.impl.QueryEvaluationContext;
&nbsp;import org.eclipse.rdf4j.query.impl.EmptyBindingSet;
&nbsp;
&nbsp;/**
&nbsp; * Generic hash join implementation suitable for use by Sail implementations.
&nbsp; *
&nbsp; * @author MJAHale
&nbsp; */
&nbsp;public class HashJoinIteration extends LookAheadIteration&lt;BindingSet, QueryEvaluationException&gt; {
&nbsp;
&nbsp;	/*-----------*
&nbsp;	 * Variables *
&nbsp;	 *-----------*/
&nbsp;
&nbsp;	protected final String[] joinAttributes;
&nbsp;	private final CloseableIteration&lt;BindingSet, QueryEvaluationException&gt; leftIter;
&nbsp;	private final CloseableIteration&lt;BindingSet, QueryEvaluationException&gt; rightIter;
&nbsp;	private final boolean leftJoin;
&nbsp;	private Iterator&lt;BindingSet&gt; scanList;
&nbsp;	private CloseableIteration&lt;BindingSet, QueryEvaluationException&gt; restIter;
&nbsp;	private Map&lt;BindingSetHashKey, List&lt;BindingSet&gt;&gt; hashTable;
&nbsp;	private BindingSet currentScanElem;
&nbsp;	private Iterator&lt;BindingSet&gt; hashTableValues;
&nbsp;
&nbsp;	private final IntFunction&lt;Map&lt;BindingSetHashKey, List&lt;BindingSet&gt;&gt;&gt; mapMaker;
&nbsp;
&nbsp;	private final IntFunction&lt;List&lt;BindingSet&gt;&gt; mapValueMaker;
&nbsp;	private final Function&lt;BindingSet, MutableBindingSet&gt; bsMaker;
&nbsp;
&nbsp;	/*--------------*
&nbsp;	 * Constructors *
&nbsp;	 *--------------*/
&nbsp;
&nbsp;	@Deprecated(forRemoval = true)
&nbsp;	public HashJoinIteration(EvaluationStrategy strategy, Join join, BindingSet bindings)
&nbsp;			throws QueryEvaluationException {
<b class="nc">&nbsp;		this(strategy, join.getLeftArg(), join.getRightArg(), bindings, false);</b>
<b class="nc">&nbsp;		join.setAlgorithm(this);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Deprecated(forRemoval = true)
&nbsp;	public HashJoinIteration(EvaluationStrategy strategy, LeftJoin join, BindingSet bindings)
&nbsp;			throws QueryEvaluationException {
<b class="nc">&nbsp;		this(strategy, join.getLeftArg(), join.getRightArg(), bindings, true);</b>
<b class="nc">&nbsp;		join.setAlgorithm(this);</b>
&nbsp;	}
&nbsp;
&nbsp;	public HashJoinIteration(EvaluationStrategy strategy, TupleExpr left, TupleExpr right, BindingSet bindings,
&nbsp;			boolean leftJoin) throws QueryEvaluationException {
<b class="nc">&nbsp;		this(strategy.evaluate(left, bindings), left.getBindingNames(), strategy.evaluate(right, bindings),</b>
<b class="nc">&nbsp;				right.getBindingNames(), leftJoin);</b>
&nbsp;	}
&nbsp;
&nbsp;	public HashJoinIteration(QueryEvaluationStep left, QueryEvaluationStep right,
&nbsp;			BindingSet bindings,
&nbsp;			boolean leftJoin, String[] joinAttributes, QueryEvaluationContext context)
<b class="fc">&nbsp;			throws QueryEvaluationException {</b>
<b class="fc">&nbsp;		this.leftIter = left.evaluate(bindings);</b>
<b class="fc">&nbsp;		this.rightIter = right.evaluate(bindings);</b>
<b class="fc">&nbsp;		this.joinAttributes = joinAttributes;</b>
<b class="fc">&nbsp;		this.leftJoin = leftJoin;</b>
<b class="fc">&nbsp;		this.mapMaker = this::makeHashTable;</b>
<b class="fc">&nbsp;		this.mapValueMaker = this::makeHashValue;</b>
<b class="fc">&nbsp;		this.bsMaker = context::createBindingSet;</b>
&nbsp;	}
&nbsp;
&nbsp;	public HashJoinIteration(
&nbsp;			CloseableIteration&lt;BindingSet, QueryEvaluationException&gt; leftIter, Set&lt;String&gt; leftBindingNames,
&nbsp;			CloseableIteration&lt;BindingSet, QueryEvaluationException&gt; rightIter, Set&lt;String&gt; rightBindingNames,
&nbsp;			boolean leftJoin
<b class="nc">&nbsp;	) throws QueryEvaluationException {</b>
<b class="nc">&nbsp;		this.leftIter = leftIter;</b>
<b class="nc">&nbsp;		this.rightIter = rightIter;</b>
<b class="nc">&nbsp;		this.mapMaker = this::makeHashTable;</b>
&nbsp;
<b class="nc">&nbsp;		joinAttributes = leftBindingNames.stream().filter(rightBindingNames::contains).toArray(String[]::new);</b>
&nbsp;
<b class="nc">&nbsp;		this.leftJoin = leftJoin;</b>
<b class="nc">&nbsp;		this.mapValueMaker = this::makeHashValue;</b>
<b class="nc">&nbsp;		this.bsMaker = QueryBindingSet::new;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Deprecated(forRemoval = true)
&nbsp;	public HashJoinIteration(
&nbsp;			CloseableIteration&lt;BindingSet, QueryEvaluationException&gt; leftIter, Set&lt;String&gt; leftBindingNames,
&nbsp;			CloseableIteration&lt;BindingSet, QueryEvaluationException&gt; rightIter, Set&lt;String&gt; rightBindingNames,
&nbsp;			boolean leftJoin, IntFunction&lt;Map&lt;BindingSetHashKey, List&lt;BindingSet&gt;&gt;&gt; mapMaker,
&nbsp;			IntFunction&lt;List&lt;BindingSet&gt;&gt; mapValueMaker
<b class="nc">&nbsp;	) throws QueryEvaluationException {</b>
<b class="nc">&nbsp;		this.leftIter = leftIter;</b>
<b class="nc">&nbsp;		this.rightIter = rightIter;</b>
<b class="nc">&nbsp;		this.mapMaker = mapMaker;</b>
&nbsp;
<b class="nc">&nbsp;		joinAttributes = leftBindingNames.stream().filter(rightBindingNames::contains).toArray(String[]::new);</b>
&nbsp;
<b class="nc">&nbsp;		this.leftJoin = leftJoin;</b>
<b class="nc">&nbsp;		this.mapValueMaker = mapValueMaker;</b>
<b class="nc">&nbsp;		this.bsMaker = QueryBindingSet::new;</b>
&nbsp;	}
&nbsp;
&nbsp;	/*---------*
&nbsp;	 * Methods *
&nbsp;	 *---------*/
&nbsp;
&nbsp;	@Override
&nbsp;	protected BindingSet getNextElement() throws QueryEvaluationException {
<b class="fc">&nbsp;		Map&lt;BindingSetHashKey, List&lt;BindingSet&gt;&gt; nextHashTable = hashTable;</b>
<b class="fc">&nbsp;		if (nextHashTable == null) {</b>
<b class="fc">&nbsp;			nextHashTable = hashTable = setupHashTable();</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		Iterator&lt;BindingSet&gt; nextHashTableValues = hashTableValues;</b>
&nbsp;
<b class="fc">&nbsp;		while (currentScanElem == null) {</b>
<b class="fc">&nbsp;			if (scanList.hasNext()) {</b>
<b class="fc">&nbsp;				currentScanElem = nextFromCache(scanList);</b>
&nbsp;			} else {
<b class="fc">&nbsp;				disposeCache(scanList); // exhausted so can free</b>
&nbsp;
<b class="fc">&nbsp;				if (restIter.hasNext()) {</b>
<b class="fc">&nbsp;					currentScanElem = restIter.next();</b>
&nbsp;				} else {
&nbsp;					// no more elements available
<b class="fc">&nbsp;					return null;</b>
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="pc">&nbsp;			if (currentScanElem != null) {</b>
<b class="fc">&nbsp;				if (currentScanElem instanceof EmptyBindingSet) {</b>
&nbsp;					// the empty bindingset should be merged with all bindingset in the
&nbsp;					// hash table
<b class="fc">&nbsp;					Collection&lt;List&lt;BindingSet&gt;&gt; values = nextHashTable.values();</b>
<b class="pc">&nbsp;					boolean empty = values.isEmpty() || values.size() == 1 &amp;&amp; values.contains(null);</b>
<b class="pc">&nbsp;					nextHashTableValues = hashTableValues = empty ? new EmptyIterator&lt;&gt;() : new UnionIterator&lt;&gt;(values);</b>
<b class="pc">&nbsp;					if (!nextHashTableValues.hasNext()) {</b>
<b class="fc">&nbsp;						currentScanElem = null;</b>
<b class="fc">&nbsp;						closeHashValue(nextHashTableValues);</b>
<b class="fc">&nbsp;						nextHashTableValues = hashTableValues = null;</b>
&nbsp;					}
<b class="fc">&nbsp;				} else {</b>
<b class="fc">&nbsp;					BindingSetHashKey key = BindingSetHashKey.create(joinAttributes, currentScanElem);</b>
<b class="fc">&nbsp;					List&lt;BindingSet&gt; hashValue = nextHashTable.get(key);</b>
<b class="pc">&nbsp;					if (hashValue != null &amp;&amp; !hashValue.isEmpty()) {</b>
<b class="fc">&nbsp;						nextHashTableValues = hashTableValues = hashValue.iterator();</b>
<b class="pc">&nbsp;					} else if (leftJoin) {</b>
<b class="nc">&nbsp;						nextHashTableValues = hashTableValues = Collections.singletonList(EmptyBindingSet.getInstance())</b>
<b class="nc">&nbsp;								.iterator();</b>
&nbsp;					} else {
<b class="fc">&nbsp;						currentScanElem = null;</b>
<b class="fc">&nbsp;						closeHashValue(nextHashTableValues);</b>
<b class="fc">&nbsp;						nextHashTableValues = hashTableValues = null;</b>
&nbsp;					}
<b class="fc">&nbsp;				}</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="pc">&nbsp;		if (nextHashTableValues != null) {</b>
<b class="fc">&nbsp;			BindingSet nextHashTableValue = nextHashTableValues.next();</b>
&nbsp;
<b class="fc">&nbsp;			MutableBindingSet result = bsMaker.apply(currentScanElem);</b>
&nbsp;
<b class="fc">&nbsp;			for (String name : nextHashTableValue.getBindingNames()) {</b>
<b class="fc">&nbsp;				if (!result.hasBinding(name)) {</b>
<b class="fc">&nbsp;					Value v = nextHashTableValue.getValue(name);</b>
<b class="fc">&nbsp;					if (v != null) {</b>
<b class="fc">&nbsp;						result.addBinding(name, v);</b>
&nbsp;					}
&nbsp;				}
<b class="fc">&nbsp;			}</b>
&nbsp;
<b class="fc">&nbsp;			if (!nextHashTableValues.hasNext()) {</b>
&nbsp;				// we&#39;ve exhausted the current scanlist entry
<b class="fc">&nbsp;				currentScanElem = null;</b>
<b class="fc">&nbsp;				closeHashValue(nextHashTableValues);</b>
<b class="fc">&nbsp;				nextHashTableValues = hashTableValues = null;</b>
&nbsp;			}
<b class="fc">&nbsp;			return result;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return EmptyBindingSet.getInstance();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected void handleClose() throws QueryEvaluationException {
&nbsp;		try {
<b class="fc">&nbsp;			super.handleClose();</b>
&nbsp;		} finally {
<b class="nc">&nbsp;			try {</b>
<b class="pc">&nbsp;				if (leftIter != null) {</b>
<b class="fc">&nbsp;					leftIter.close();</b>
&nbsp;				}
&nbsp;			} finally {
<b class="nc">&nbsp;				try {</b>
<b class="pc">&nbsp;					if (rightIter != null) {</b>
<b class="fc">&nbsp;						rightIter.close();</b>
&nbsp;					}
&nbsp;				} finally {
<b class="nc">&nbsp;					try {</b>
<b class="fc">&nbsp;						Iterator&lt;BindingSet&gt; toCloseHashTableValues = hashTableValues;</b>
<b class="fc">&nbsp;						hashTableValues = null;</b>
<b class="pc">&nbsp;						if (toCloseHashTableValues != null) {</b>
<b class="fc">&nbsp;							closeHashValue(toCloseHashTableValues);</b>
&nbsp;						}
&nbsp;					} finally {
<b class="nc">&nbsp;						try {</b>
<b class="fc">&nbsp;							Iterator&lt;BindingSet&gt; toCloseScanList = scanList;</b>
<b class="fc">&nbsp;							scanList = null;</b>
<b class="pc">&nbsp;							if (toCloseScanList != null) {</b>
<b class="fc">&nbsp;								disposeCache(toCloseScanList);</b>
&nbsp;							}
&nbsp;						} finally {
<b class="fc">&nbsp;							Map&lt;BindingSetHashKey, List&lt;BindingSet&gt;&gt; toCloseHashTable = hashTable;</b>
<b class="fc">&nbsp;							hashTable = null;</b>
<b class="pc">&nbsp;							if (toCloseHashTable != null) {</b>
<b class="fc">&nbsp;								disposeHashTable(toCloseHashTable);</b>
&nbsp;							}
<b class="fc">&nbsp;						}</b>
<b class="fc">&nbsp;					}</b>
<b class="fc">&nbsp;				}</b>
<b class="fc">&nbsp;			}</b>
<b class="fc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private Map&lt;BindingSetHashKey, List&lt;BindingSet&gt;&gt; setupHashTable() throws QueryEvaluationException {
&nbsp;
&nbsp;		Collection&lt;BindingSet&gt; leftArgResults;
<b class="fc">&nbsp;		Collection&lt;BindingSet&gt; rightArgResults = makeIterationCache(rightIter);</b>
<b class="fc">&nbsp;		if (!leftJoin) {</b>
<b class="fc">&nbsp;			leftArgResults = makeIterationCache(leftIter);</b>
&nbsp;
<b class="fc">&nbsp;			while (leftIter.hasNext() &amp;&amp; rightIter.hasNext()) {</b>
<b class="fc">&nbsp;				add(leftArgResults, leftIter.next());</b>
<b class="fc">&nbsp;				add(rightArgResults, rightIter.next());</b>
&nbsp;			}
&nbsp;		} else {
<b class="fc">&nbsp;			leftArgResults = Collections.emptyList();</b>
&nbsp;
<b class="fc">&nbsp;			while (rightIter.hasNext()) {</b>
<b class="fc">&nbsp;				add(rightArgResults, rightIter.next());</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		Collection&lt;BindingSet&gt; smallestResult;
&nbsp;
<b class="fc">&nbsp;		if (leftJoin || leftIter.hasNext()) { // leftArg is the greater relation</b>
<b class="fc">&nbsp;			smallestResult = rightArgResults;</b>
<b class="fc">&nbsp;			scanList = leftArgResults.iterator();</b>
<b class="fc">&nbsp;			restIter = leftIter;</b>
&nbsp;		} else { // rightArg is the greater relation (or they are equal)
<b class="fc">&nbsp;			smallestResult = leftArgResults;</b>
<b class="fc">&nbsp;			scanList = rightArgResults.iterator();</b>
<b class="fc">&nbsp;			restIter = rightIter;</b>
&nbsp;		}
&nbsp;
&nbsp;		// help free memory before allocating the hash table
<b class="fc">&nbsp;		leftArgResults = null;</b>
<b class="fc">&nbsp;		rightArgResults = null;</b>
&nbsp;
&nbsp;		// create the hash table for our join
&nbsp;		// hash table will never be any bigger than smallestResult.size()
<b class="fc">&nbsp;		Map&lt;BindingSetHashKey, List&lt;BindingSet&gt;&gt; resultHashTable = mapMaker.apply(smallestResult.size());</b>
<b class="fc">&nbsp;		int maxListSize = 1;</b>
<b class="fc">&nbsp;		for (BindingSet b : smallestResult) {</b>
<b class="fc">&nbsp;			BindingSetHashKey hashKey = BindingSetHashKey.create(joinAttributes, b);</b>
&nbsp;
<b class="fc">&nbsp;			List&lt;BindingSet&gt; hashValue = resultHashTable.get(hashKey);</b>
<b class="fc">&nbsp;			boolean newEntry = (hashValue == null);</b>
<b class="fc">&nbsp;			if (newEntry) {</b>
<b class="fc">&nbsp;				hashValue = mapValueMaker.apply(maxListSize);</b>
&nbsp;			}
<b class="fc">&nbsp;			add(hashValue, b);</b>
&nbsp;			// always do a put() in case the map implementation is not memory-based
&nbsp;			// e.g. it serializes the values
<b class="fc">&nbsp;			putHashTableEntry(resultHashTable, hashKey, hashValue, newEntry);</b>
&nbsp;
<b class="fc">&nbsp;			maxListSize = Math.max(maxListSize, hashValue.size());</b>
<b class="fc">&nbsp;		}</b>
<b class="fc">&nbsp;		return resultHashTable;</b>
&nbsp;	}
&nbsp;
&nbsp;	protected void putHashTableEntry(Map&lt;BindingSetHashKey, List&lt;BindingSet&gt;&gt; nextHashTable, BindingSetHashKey hashKey,
&nbsp;			List&lt;BindingSet&gt; hashValue, boolean newEntry) throws QueryEvaluationException {
&nbsp;		// by default, we use a standard memory hash map
&nbsp;		// so we only need to do the put() if the list is new
<b class="fc">&nbsp;		if (newEntry) {</b>
<b class="fc">&nbsp;			nextHashTable.put(hashKey, hashValue);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Utility methods to make it easier to inserted custom store dependent list
&nbsp;	 *
&nbsp;	 * @return list
&nbsp;	 */
&nbsp;	protected Collection&lt;BindingSet&gt; makeIterationCache(CloseableIteration&lt;BindingSet, QueryEvaluationException&gt; iter) {
<b class="fc">&nbsp;		return new ArrayList&lt;&gt;();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Utility methods to make it easier to inserted custom store dependent maps
&nbsp;	 *
&nbsp;	 * @return map
&nbsp;	 */
&nbsp;	protected Map&lt;BindingSetHashKey, List&lt;BindingSet&gt;&gt; makeHashTable(int initialSize) {
&nbsp;		Map&lt;BindingSetHashKey, List&lt;BindingSet&gt;&gt; nextHashTable;
<b class="fc">&nbsp;		if (joinAttributes.length &gt; 0) {</b>
&nbsp;			// we should probably adjust for the load factor
&nbsp;			// but we are only one rehash away and this might save a bit of memory
&nbsp;			// when we have more than one value per entry
<b class="fc">&nbsp;			nextHashTable = new HashMap&lt;&gt;(initialSize);</b>
&nbsp;		} else {
<b class="fc">&nbsp;			List&lt;BindingSet&gt; l = (initialSize &gt; 0) ? new ArrayList&lt;&gt;(initialSize) : null;</b>
<b class="fc">&nbsp;			nextHashTable = Collections.singletonMap(BindingSetHashKey.EMPTY, l);</b>
&nbsp;		}
<b class="fc">&nbsp;		return nextHashTable;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Utility methods to make it easier to inserted custom store dependent list
&nbsp;	 *
&nbsp;	 * @return list
&nbsp;	 */
&nbsp;	protected List&lt;BindingSet&gt; makeHashValue(int currentMaxListSize) {
&nbsp;		// we pick an initial size that means we may only have to resize once
&nbsp;		// while saving memory in the case that the list doesn&#39;t reach max size
<b class="fc">&nbsp;		return new ArrayList&lt;&gt;(currentMaxListSize / 2 + 1);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Utility methods to clear-up in case not using in-memory cache.
&nbsp;	 */
&nbsp;	protected void disposeCache(Iterator&lt;BindingSet&gt; iter) {
<b class="fc">&nbsp;	}</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Utility methods to clear-up in case not using in-memory hash table.
&nbsp;	 */
&nbsp;	protected void disposeHashTable(Map&lt;BindingSetHashKey, List&lt;BindingSet&gt;&gt; map) {
<b class="fc">&nbsp;	}</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Utility methods to clear-up in case not using in-memory hash table.
&nbsp;	 */
&nbsp;	protected &lt;E&gt; void closeHashValue(Iterator&lt;E&gt; iter) {
<b class="fc">&nbsp;	}</b>
&nbsp;
&nbsp;	// hooks for LimitedSizeHashJoinIterator
&nbsp;
&nbsp;	protected &lt;E&gt; E nextFromCache(Iterator&lt;E&gt; iter) {
<b class="fc">&nbsp;		return iter.next();</b>
&nbsp;	}
&nbsp;
&nbsp;	protected &lt;E&gt; void add(Collection&lt;E&gt; col, E value) throws QueryEvaluationException {
<b class="fc">&nbsp;		col.add(value);</b>
&nbsp;	}
&nbsp;
&nbsp;	protected &lt;E&gt; void addAll(Collection&lt;E&gt; col, List&lt;E&gt; values) throws QueryEvaluationException {
<b class="nc">&nbsp;		col.addAll(values);</b>
&nbsp;	}
&nbsp;
&nbsp;	public static String[] hashJoinAttributeNames(Join join) {
<b class="fc">&nbsp;		Set&lt;String&gt; leftBindingNames = join.getLeftArg().getBindingNames();</b>
<b class="fc">&nbsp;		Set&lt;String&gt; rightBindingNames = join.getRightArg().getBindingNames();</b>
<b class="fc">&nbsp;		return leftBindingNames.stream().filter(rightBindingNames::contains).toArray(String[]::new);</b>
&nbsp;	}
&nbsp;
&nbsp;	public static String[] hashJoinAttributeNames(LeftJoin join) {
<b class="nc">&nbsp;		Set&lt;String&gt; leftBindingNames = join.getLeftArg().getBindingNames();</b>
<b class="nc">&nbsp;		Set&lt;String&gt; rightBindingNames = join.getRightArg().getBindingNames();</b>
<b class="nc">&nbsp;		return leftBindingNames.stream().filter(rightBindingNames::contains).toArray(String[]::new);</b>
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:22</div>
</div>
</body>
</html>
