


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > Literals</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.model.util</a>
</div>

<h1>Coverage Summary for Class: Literals (org.eclipse.rdf4j.model.util)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Literals</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    14.7%
  </span>
  <span class="absValue">
    (5/34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    8.8%
  </span>
  <span class="absValue">
    (9/102)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    12.5%
  </span>
  <span class="absValue">
    (16/128)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;package org.eclipse.rdf4j.model.util;
&nbsp;
&nbsp;import java.math.BigDecimal;
&nbsp;import java.math.BigInteger;
&nbsp;import java.util.Date;
&nbsp;import java.util.IllformedLocaleException;
&nbsp;import java.util.Locale;
&nbsp;import java.util.Optional;
&nbsp;
&nbsp;import javax.xml.datatype.Duration;
&nbsp;import javax.xml.datatype.XMLGregorianCalendar;
&nbsp;
&nbsp;import org.eclipse.rdf4j.model.Literal;
&nbsp;import org.eclipse.rdf4j.model.Value;
&nbsp;import org.eclipse.rdf4j.model.ValueFactory;
&nbsp;import org.eclipse.rdf4j.model.base.CoreDatatype;
&nbsp;import org.eclipse.rdf4j.model.datatypes.XMLDatatypeUtil;
&nbsp;import org.eclipse.rdf4j.model.impl.SimpleLiteral;
&nbsp;import org.eclipse.rdf4j.model.vocabulary.XSD;
&nbsp;
&nbsp;/**
&nbsp; * Various utility methods related to {@link Literal}.
&nbsp; *
&nbsp; * @author Arjohn Kampman
&nbsp; * @author Peter Ansell
&nbsp; *
&nbsp; * @See {@link Values}
&nbsp; */
&nbsp;public class Literals {
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets the label of the supplied literal. The fallback value is returned in case the supplied literal is
&nbsp;	 * &lt;var&gt;null&lt;/var&gt;.
&nbsp;	 *
&nbsp;	 * @param l        The literal to get the label for.
&nbsp;	 * @param fallback The value to fall back to in case the supplied literal is &lt;var&gt;null&lt;/var&gt;.
&nbsp;	 * @return Either the literal&#39;s label, or the fallback value.
&nbsp;	 */
&nbsp;	public static String getLabel(Literal l, String fallback) {
<b class="nc">&nbsp;		return l != null ? l.getLabel() : fallback;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the result of {@link #getLabel(Literal, String) getLabel((Literal)v, fallback} in case the supplied value
&nbsp;	 * is a literal, returns the fallback value otherwise.
&nbsp;	 */
&nbsp;	public static String getLabel(Value v, String fallback) {
<b class="nc">&nbsp;		return v instanceof Literal ? getLabel((Literal) v, fallback) : fallback;</b>
&nbsp;	}
&nbsp;
&nbsp;	public static String getLabel(Optional&lt;Value&gt; v, String fallback) {
<b class="nc">&nbsp;		return v != null ? getLabel(v.orElseGet(null), fallback) : fallback;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Retrieves the {@link org.eclipse.rdf4j.model.vocabulary.XSD.Datatype} value for the supplied Literal, if it has
&nbsp;	 * one.
&nbsp;	 *
&nbsp;	 * @param l a Literal
&nbsp;	 * @return an Optional {@link org.eclipse.rdf4j.model.vocabulary.XSD.Datatype} enum, if one is available. Note that
&nbsp;	 *         the absence of this enum does &lt;i&gt;not&lt;/i&gt; indicate that the literal has no datatype, merely that it has no
&nbsp;	 *         cached enum representation of that datatype.
&nbsp;	 * @since 3.5.0
&nbsp;	 * @deprecated Use {@link Literal#getCoreDatatype()} instead.
&nbsp;	 */
&nbsp;	@Deprecated(since = &quot;4.0.0&quot;, forRemoval = true)
&nbsp;	public static Optional&lt;XSD.Datatype&gt; getXsdDatatype(Literal l) {
<b class="nc">&nbsp;		if (l instanceof SimpleLiteral) {</b>
<b class="nc">&nbsp;			return ((SimpleLiteral) l).getXsdDatatype();</b>
&nbsp;		}
<b class="nc">&nbsp;		return Optional.empty();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets the byte value of the supplied literal. The fallback value is returned in case {@link Literal#byteValue()}
&nbsp;	 * throws a {@link NumberFormatException}.
&nbsp;	 *
&nbsp;	 * @param l        The literal to get the byte value for.
&nbsp;	 * @param fallback The value to fall back to in case no byte value could gotten from the literal.
&nbsp;	 * @return Either the literal&#39;s byte value, or the fallback value.
&nbsp;	 */
&nbsp;	public static byte getByteValue(Literal l, byte fallback) {
&nbsp;		try {
<b class="nc">&nbsp;			return l.byteValue();</b>
<b class="nc">&nbsp;		} catch (NumberFormatException e) {</b>
<b class="nc">&nbsp;			return fallback;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the result of {@link #getByteValue(Literal, byte) getByteValue((Literal)value, fallback)} in case the
&nbsp;	 * supplied value is a literal, returns the fallback value otherwise.
&nbsp;	 */
&nbsp;	public static byte getByteValue(Value v, byte fallback) {
<b class="nc">&nbsp;		if (v instanceof Literal) {</b>
<b class="nc">&nbsp;			return getByteValue((Literal) v, fallback);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			return fallback;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets the short value of the supplied literal. The fallback value is returned in case {@link Literal#shortValue()}
&nbsp;	 * throws a {@link NumberFormatException}.
&nbsp;	 *
&nbsp;	 * @param l        The literal to get the short value for.
&nbsp;	 * @param fallback The value to fall back to in case no short value could gotten from the literal.
&nbsp;	 * @return Either the literal&#39;s short value, or the fallback value.
&nbsp;	 */
&nbsp;	public static short getShortValue(Literal l, short fallback) {
&nbsp;		try {
<b class="nc">&nbsp;			return l.shortValue();</b>
<b class="nc">&nbsp;		} catch (NumberFormatException e) {</b>
<b class="nc">&nbsp;			return fallback;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the result of {@link #getShortValue(Literal, short) getShortValue((Literal)value, fallback)} in case the
&nbsp;	 * supplied value is a literal, returns the fallback value otherwise.
&nbsp;	 */
&nbsp;	public static short getShortValue(Value v, short fallback) {
<b class="nc">&nbsp;		if (v instanceof Literal) {</b>
<b class="nc">&nbsp;			return getShortValue((Literal) v, fallback);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			return fallback;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets the int value of the supplied literal. The fallback value is returned in case {@link Literal#intValue()}
&nbsp;	 * throws a {@link NumberFormatException}.
&nbsp;	 *
&nbsp;	 * @param l        The literal to get the int value for.
&nbsp;	 * @param fallback The value to fall back to in case no int value could gotten from the literal.
&nbsp;	 * @return Either the literal&#39;s int value, or the fallback value.
&nbsp;	 */
&nbsp;	public static int getIntValue(Literal l, int fallback) {
&nbsp;		try {
<b class="nc">&nbsp;			return l.intValue();</b>
<b class="nc">&nbsp;		} catch (NumberFormatException e) {</b>
<b class="nc">&nbsp;			return fallback;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the result of {@link #getIntValue(Literal, int) getIntValue((Literal)value, fallback)} in case the
&nbsp;	 * supplied value is a literal, returns the fallback value otherwise.
&nbsp;	 */
&nbsp;	public static int getIntValue(Value v, int fallback) {
<b class="nc">&nbsp;		if (v instanceof Literal) {</b>
<b class="nc">&nbsp;			return getIntValue((Literal) v, fallback);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			return fallback;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets the long value of the supplied literal. The fallback value is returned in case {@link Literal#longValue()}
&nbsp;	 * throws a {@link NumberFormatException}.
&nbsp;	 *
&nbsp;	 * @param l        The literal to get the long value for.
&nbsp;	 * @param fallback The value to fall back to in case no long value could gotten from the literal.
&nbsp;	 * @return Either the literal&#39;s long value, or the fallback value.
&nbsp;	 */
&nbsp;	public static long getLongValue(Literal l, long fallback) {
&nbsp;		try {
<b class="nc">&nbsp;			return l.longValue();</b>
<b class="nc">&nbsp;		} catch (NumberFormatException e) {</b>
<b class="nc">&nbsp;			return fallback;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the result of {@link #getLongValue(Literal, long) getLongValue((Literal)value, fallback)} in case the
&nbsp;	 * supplied value is a literal, returns the fallback value otherwise.
&nbsp;	 */
&nbsp;	public static long getLongValue(Value v, long fallback) {
<b class="nc">&nbsp;		if (v instanceof Literal) {</b>
<b class="nc">&nbsp;			return getLongValue((Literal) v, fallback);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			return fallback;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets the integer value of the supplied literal. The fallback value is returned in case
&nbsp;	 * {@link Literal#integerValue()} throws a {@link NumberFormatException}.
&nbsp;	 *
&nbsp;	 * @param l        The literal to get the integer value for.
&nbsp;	 * @param fallback The value to fall back to in case no integer value could gotten from the literal.
&nbsp;	 * @return Either the literal&#39;s integer value, or the fallback value.
&nbsp;	 */
&nbsp;	public static BigInteger getIntegerValue(Literal l, BigInteger fallback) {
&nbsp;		try {
<b class="nc">&nbsp;			return l.integerValue();</b>
<b class="nc">&nbsp;		} catch (NumberFormatException e) {</b>
<b class="nc">&nbsp;			return fallback;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the result of {@link #getIntegerValue(Literal, BigInteger) getIntegerValue((Literal)value, fallback)} in
&nbsp;	 * case the supplied value is a literal, returns the fallback value otherwise.
&nbsp;	 */
&nbsp;	public static BigInteger getIntegerValue(Value v, BigInteger fallback) {
<b class="nc">&nbsp;		if (v instanceof Literal) {</b>
<b class="nc">&nbsp;			return getIntegerValue((Literal) v, fallback);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			return fallback;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets the decimal value of the supplied literal. The fallback value is returned in case
&nbsp;	 * {@link Literal#decimalValue()} throws a {@link NumberFormatException}.
&nbsp;	 *
&nbsp;	 * @param l        The literal to get the decimal value for.
&nbsp;	 * @param fallback The value to fall back to in case no decimal value could gotten from the literal.
&nbsp;	 * @return Either the literal&#39;s decimal value, or the fallback value.
&nbsp;	 */
&nbsp;	public static BigDecimal getDecimalValue(Literal l, BigDecimal fallback) {
&nbsp;		try {
<b class="nc">&nbsp;			return l.decimalValue();</b>
<b class="nc">&nbsp;		} catch (NumberFormatException e) {</b>
<b class="nc">&nbsp;			return fallback;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the result of {@link #getDecimalValue(Literal, BigDecimal) getDecimalValue((Literal)value, fallback)} in
&nbsp;	 * case the supplied value is a literal, returns the fallback value otherwise.
&nbsp;	 */
&nbsp;	public static BigDecimal getDecimalValue(Value v, BigDecimal fallback) {
<b class="nc">&nbsp;		if (v instanceof Literal) {</b>
<b class="nc">&nbsp;			return getDecimalValue((Literal) v, fallback);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			return fallback;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets the float value of the supplied literal. The fallback value is returned in case {@link Literal#floatValue()}
&nbsp;	 * throws a {@link NumberFormatException}.
&nbsp;	 *
&nbsp;	 * @param l        The literal to get the float value for.
&nbsp;	 * @param fallback The value to fall back to in case no float value could gotten from the literal.
&nbsp;	 * @return Either the literal&#39;s float value, or the fallback value.
&nbsp;	 */
&nbsp;	public static float getFloatValue(Literal l, float fallback) {
&nbsp;		try {
<b class="nc">&nbsp;			return l.floatValue();</b>
<b class="nc">&nbsp;		} catch (NumberFormatException e) {</b>
<b class="nc">&nbsp;			return fallback;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the result of {@link #getFloatValue(Literal, float) getFloatValue((Literal)value, fallback)} in case the
&nbsp;	 * supplied value is a literal, returns the fallback value otherwise.
&nbsp;	 */
&nbsp;	public static float getFloatValue(Value v, float fallback) {
<b class="nc">&nbsp;		if (v instanceof Literal) {</b>
<b class="nc">&nbsp;			return getFloatValue((Literal) v, fallback);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			return fallback;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets the double value of the supplied literal. The fallback value is returned in case
&nbsp;	 * {@link Literal#doubleValue()} throws a {@link NumberFormatException}.
&nbsp;	 *
&nbsp;	 * @param l        The literal to get the double value for.
&nbsp;	 * @param fallback The value to fall back to in case no double value could gotten from the literal.
&nbsp;	 * @return Either the literal&#39;s double value, or the fallback value.
&nbsp;	 */
&nbsp;	public static double getDoubleValue(Literal l, double fallback) {
&nbsp;		try {
<b class="nc">&nbsp;			return l.doubleValue();</b>
<b class="nc">&nbsp;		} catch (NumberFormatException e) {</b>
<b class="nc">&nbsp;			return fallback;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the result of {@link #getDoubleValue(Literal, double) getDoubleValue((Literal)value, fallback)} in case
&nbsp;	 * the supplied value is a literal, returns the fallback value otherwise.
&nbsp;	 */
&nbsp;	public static double getDoubleValue(Value v, double fallback) {
<b class="nc">&nbsp;		if (v instanceof Literal) {</b>
<b class="nc">&nbsp;			return getDoubleValue((Literal) v, fallback);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			return fallback;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets the boolean value of the supplied literal. The fallback value is returned in case
&nbsp;	 * {@link Literal#booleanValue()} throws a {@link NumberFormatException}.
&nbsp;	 *
&nbsp;	 * @param l        The literal to get the boolean value for.
&nbsp;	 * @param fallback The value to fall back to in case no boolean value could gotten from the literal.
&nbsp;	 * @return Either the literal&#39;s boolean value, or the fallback value.
&nbsp;	 */
&nbsp;	public static boolean getBooleanValue(Literal l, boolean fallback) {
&nbsp;		try {
<b class="fc">&nbsp;			return l.booleanValue();</b>
<b class="nc">&nbsp;		} catch (IllegalArgumentException e) {</b>
<b class="nc">&nbsp;			return fallback;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the result of {@link #getBooleanValue(Literal, boolean) getBooleanValue((Literal)value, fallback)} in
&nbsp;	 * case the supplied value is a literal, returns the fallback value otherwise.
&nbsp;	 */
&nbsp;	public static boolean getBooleanValue(Value v, boolean fallback) {
<b class="fc">&nbsp;		if (v instanceof Literal) {</b>
<b class="fc">&nbsp;			return getBooleanValue((Literal) v, fallback);</b>
&nbsp;		} else {
<b class="fc">&nbsp;			return fallback;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets the calendar value of the supplied literal. The fallback value is returned in case
&nbsp;	 * {@link Literal#calendarValue()} throws a {@link NumberFormatException}.
&nbsp;	 *
&nbsp;	 * @param l        The literal to get the calendar value for.
&nbsp;	 * @param fallback The value to fall back to in case no calendar value could gotten from the literal.
&nbsp;	 * @return Either the literal&#39;s calendar value, or the fallback value.
&nbsp;	 */
&nbsp;	public static XMLGregorianCalendar getCalendarValue(Literal l, XMLGregorianCalendar fallback) {
&nbsp;		try {
<b class="nc">&nbsp;			return l.calendarValue();</b>
<b class="nc">&nbsp;		} catch (IllegalArgumentException e) {</b>
<b class="nc">&nbsp;			return fallback;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets the {@link Duration} value of the supplied literal. The fallback value is returned in case
&nbsp;	 * {@link XMLDatatypeUtil#parseDuration(String)} throws an exception.
&nbsp;	 *
&nbsp;	 * @param l        The literal to get the {@link Duration} value for.
&nbsp;	 * @param fallback The value to fall back to in case no Duration value could gotten from the literal.
&nbsp;	 * @return Either the literal&#39;s Duration value, or the fallback value.
&nbsp;	 */
&nbsp;	public static Duration getDurationValue(Literal l, Duration fallback) {
&nbsp;		try {
<b class="nc">&nbsp;			return XMLDatatypeUtil.parseDuration(l.getLabel());</b>
<b class="nc">&nbsp;		} catch (IllegalArgumentException | UnsupportedOperationException e) {</b>
<b class="nc">&nbsp;			return fallback;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the result of {@link #getCalendarValue(Literal, XMLGregorianCalendar) getCalendarValue((Literal)value,
&nbsp;	 * fallback)} in case the supplied value is a literal, returns the fallback value otherwise.
&nbsp;	 */
&nbsp;	public static XMLGregorianCalendar getCalendarValue(Value v, XMLGregorianCalendar fallback) {
<b class="nc">&nbsp;		if (v instanceof Literal) {</b>
<b class="nc">&nbsp;			return getCalendarValue((Literal) v, fallback);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			return fallback;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Creates a typed {@link Literal} out of the supplied object, mapping the runtime type of the object to the
&nbsp;	 * appropriate XML Schema type. If no mapping is available, the method returns a literal with the string
&nbsp;	 * representation of the supplied object as the value, and {@link XSD#STRING} as the datatype. Recognized types are
&nbsp;	 * {@link Boolean}, {@link Byte}, {@link Double}, {@link Float}, {@link Integer}, {@link Long}, {@link Short},
&nbsp;	 * {@link XMLGregorianCalendar } , and {@link Date}.
&nbsp;	 *
&nbsp;	 * @param valueFactory
&nbsp;	 * @param object       an object to be converted to a typed literal.
&nbsp;	 * @return a typed literal representation of the supplied object.
&nbsp;	 * @throws NullPointerException If the object was null.
&nbsp;	 * @deprecated since 3.5.0 - use {@link Values#literal(Object)} instead.
&nbsp;	 */
&nbsp;	@Deprecated
&nbsp;	public static Literal createLiteral(ValueFactory valueFactory, Object object) {
&nbsp;		try {
<b class="nc">&nbsp;			return createLiteral(valueFactory, object, false);</b>
<b class="nc">&nbsp;		} catch (LiteralUtilException e) {</b>
&nbsp;			// This should not happen by design
<b class="nc">&nbsp;			throw new IllegalStateException(e);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Creates a typed {@link Literal} out of the supplied object, mapping the runtime type of the object to the
&nbsp;	 * appropriate XML Schema type. If no mapping is available, the method throws a {@link LiteralUtilException}.
&nbsp;	 * Recognized types are {@link Boolean}, {@link Byte}, {@link Double}, {@link Float}, {@link Integer}, {@link Long},
&nbsp;	 * {@link Short}, {@link XMLGregorianCalendar } , and {@link Date}.
&nbsp;	 *
&nbsp;	 * @param valueFactory
&nbsp;	 * @param object       an object to be converted to a typed literal.
&nbsp;	 * @return a typed literal representation of the supplied object.
&nbsp;	 * @throws LiteralUtilException If the literal could not be created.
&nbsp;	 * @throws NullPointerException If the object was null.
&nbsp;	 * @deprecated since 3.5.0 - use {@link Values#literal(Object, boolean)} instead.
&nbsp;	 */
&nbsp;	@Deprecated
&nbsp;	public static Literal createLiteralOrFail(ValueFactory valueFactory, Object object) throws LiteralUtilException {
<b class="nc">&nbsp;		return createLiteral(valueFactory, object, true);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Creates a typed {@link Literal} out of the supplied object, mapping the runtime type of the object to the
&nbsp;	 * appropriate XML Schema type. If no mapping is available, the method throws an exception if the boolean parameter
&nbsp;	 * is true, or if it is false it returns a literal with the string representation of the supplied object as the
&nbsp;	 * value, and {@link XSD#STRING} as the datatype. Recognized types are {@link Boolean}, {@link Byte},
&nbsp;	 * {@link Double}, {@link Float}, {@link Integer}, {@link Long}, {@link Short}, {@link XMLGregorianCalendar } , and
&nbsp;	 * {@link Date}.
&nbsp;	 *
&nbsp;	 * @param valueFactory            The {@link ValueFactory} to use when creating the result.
&nbsp;	 * @param object                  an object to be converted to a typed literal.
&nbsp;	 * @param throwExceptionOnFailure If true throws a {@link LiteralUtilException} when the object is not recognised.
&nbsp;	 *                                If false it returns a string typed literal based on the objects toString method.
&nbsp;	 * @return a typed literal representation of the supplied object.
&nbsp;	 * @throws LiteralUtilException If the literal could not be created.
&nbsp;	 * @throws NullPointerException If the object was null.
&nbsp;	 */
&nbsp;	private static Literal createLiteral(ValueFactory valueFactory, Object object, boolean throwExceptionOnFailure)
&nbsp;			throws LiteralUtilException {
<b class="nc">&nbsp;		if (object == null) {</b>
<b class="nc">&nbsp;			throw new NullPointerException(&quot;Cannot create a literal from a null&quot;);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (object instanceof Boolean) {</b>
<b class="nc">&nbsp;			return valueFactory.createLiteral((Boolean) object);</b>
<b class="nc">&nbsp;		} else if (object instanceof Byte) {</b>
<b class="nc">&nbsp;			return valueFactory.createLiteral((Byte) object);</b>
<b class="nc">&nbsp;		} else if (object instanceof Double) {</b>
<b class="nc">&nbsp;			return valueFactory.createLiteral((Double) object);</b>
<b class="nc">&nbsp;		} else if (object instanceof Float) {</b>
<b class="nc">&nbsp;			return valueFactory.createLiteral((Float) object);</b>
<b class="nc">&nbsp;		} else if (object instanceof Integer) {</b>
<b class="nc">&nbsp;			return valueFactory.createLiteral((Integer) object);</b>
<b class="nc">&nbsp;		} else if (object instanceof Long) {</b>
<b class="nc">&nbsp;			return valueFactory.createLiteral((Long) object);</b>
<b class="nc">&nbsp;		} else if (object instanceof Short) {</b>
<b class="nc">&nbsp;			return valueFactory.createLiteral((Short) object);</b>
<b class="nc">&nbsp;		} else if (object instanceof XMLGregorianCalendar) {</b>
<b class="nc">&nbsp;			return valueFactory.createLiteral((XMLGregorianCalendar) object);</b>
<b class="nc">&nbsp;		} else if (object instanceof Date) {</b>
<b class="nc">&nbsp;			return valueFactory.createLiteral((Date) object);</b>
<b class="nc">&nbsp;		} else if (object instanceof String) {</b>
<b class="nc">&nbsp;			return valueFactory.createLiteral(object.toString(), CoreDatatype.XSD.STRING);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			if (throwExceptionOnFailure) {</b>
<b class="nc">&nbsp;				throw new LiteralUtilException(&quot;Did not recognise object when creating literal&quot;);</b>
&nbsp;			}
<b class="nc">&nbsp;			return valueFactory.createLiteral(object.toString(), CoreDatatype.XSD.STRING);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Helper method for determining whether a literal could be created from an object using a {@link ValueFactory}.
&nbsp;	 *
&nbsp;	 * @param object an object to check for the possibility of being converted to a typed literal.
&nbsp;	 * @return True if a literal could be created from the given object, based solely on its type and the methods
&nbsp;	 *         available on the {@link ValueFactory} interface and false otherwise. Returns false if the object is null.
&nbsp;	 * @deprecated since 3.5.0
&nbsp;	 */
&nbsp;	@Deprecated
&nbsp;	public static boolean canCreateLiteral(Object object) {
<b class="nc">&nbsp;		if (object == null) {</b>
&nbsp;			// Cannot create a literal from a null
&nbsp;			// Avoid throwing a NullPointerException here to enable universal
&nbsp;			// usage
&nbsp;			// of this method
<b class="nc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return object instanceof Boolean || object instanceof Byte || object instanceof Double</b>
&nbsp;				|| object instanceof Float
&nbsp;				|| object instanceof Integer || object instanceof Long || object instanceof Short
&nbsp;				|| object instanceof XMLGregorianCalendar || object instanceof Date || object instanceof String;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Helper method to determine whether a literal is a language literal, and not a typed literal.
&nbsp;	 *
&nbsp;	 * @param literal The literal to check
&nbsp;	 * @return True if the literal has a language tag attached to it and false otherwise.
&nbsp;	 */
&nbsp;	public static boolean isLanguageLiteral(Literal literal) {
<b class="fc">&nbsp;		return literal.getCoreDatatype() == CoreDatatype.RDF.LANGSTRING;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Normalizes the given &lt;a href=&quot;https://tools.ietf.org/html/bcp47&quot;&gt;BCP47&lt;/a&gt; language tag according to the rules
&nbsp;	 * defined in &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc5646.html#section-2.1.1&quot;&gt;RFC 5646, section 2.1.1&lt;/a&gt;:
&nbsp;	 * &lt;p&gt;
&nbsp;	 * &lt;blockquote&gt; All subtags, including extension and private use subtags, use lowercase letters with two exceptions:
&nbsp;	 * two-letter and four-letter subtags that neither appear at the start of the tag nor occur after singletons. Such
&nbsp;	 * two-letter subtags are all uppercase (as in the tags &quot;en-CA-x-ca&quot; or &quot;sgn-BE-FR&quot;) and four- letter subtags are
&nbsp;	 * titlecase (as in the tag &quot;az-Latn-x-latn&quot;). &lt;/blockquote&gt;
&nbsp;	 *
&nbsp;	 * @param languageTag An unnormalized, valid, language tag
&nbsp;	 * @return A normalized version of the given language tag
&nbsp;	 * @throws IllformedLocaleException If the given language tag is ill-formed according to the rules specified in
&nbsp;	 *                                  BCP47 (RFC 5646).
&nbsp;	 */
&nbsp;	public static String normalizeLanguageTag(String languageTag) throws IllformedLocaleException {
&nbsp;		// check if language tag is well-formed
<b class="fc">&nbsp;		new Locale.Builder().setLanguageTag(languageTag);</b>
&nbsp;
&nbsp;		// all subtags are case-insensitive
<b class="fc">&nbsp;		String normalizedTag = languageTag.toLowerCase();</b>
&nbsp;
<b class="fc">&nbsp;		String[] subtags = normalizedTag.split(&quot;-&quot;);</b>
<b class="pc">&nbsp;		for (int i = 1; i &lt; subtags.length; i++) {</b>
<b class="nc">&nbsp;			String subtag = subtags[i];</b>
&nbsp;
<b class="nc">&nbsp;			if (subtag.length() == 2) {</b>
&nbsp;				// exception 1: two-letter subtags not at the starte and not preceded by a singleton are upper case
<b class="nc">&nbsp;				if (subtags[i - 1].length() &gt; 1 &amp;&amp; subtag.matches(&quot;\\w\\w&quot;)) {</b>
<b class="nc">&nbsp;					subtags[i] = subtag.toUpperCase();</b>
&nbsp;				}
<b class="nc">&nbsp;			} else if (subtag.length() == 4) {</b>
&nbsp;				// exception 2: four-letter subtags not at the start and not preceded by a singleton are title case
<b class="nc">&nbsp;				if (subtags[i - 1].length() &gt; 1 &amp;&amp; subtag.matches(&quot;\\w\\w\\w\\w&quot;)) {</b>
<b class="nc">&nbsp;					subtags[i] = subtag.substring(0, 1).toUpperCase() + subtag.substring(1);</b>
&nbsp;				}
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return String.join(&quot;-&quot;, subtags);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Checks if the given string is a well-formed &lt;a href=&quot;https://tools.ietf.org/html/bcp47&quot;&gt;BCP47&lt;/a&gt; language tag
&nbsp;	 * according to the rules defined in &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc5646.html#section-2.1.1&quot;&gt;RFC 5646,
&nbsp;	 * section 2.1.1&lt;/a&gt;.
&nbsp;	 *
&nbsp;	 * @param languageTag A language tag
&nbsp;	 * @return &lt;code&gt;true&lt;/code&gt; if the given language tag is well-formed according to the rules specified in BCP47.
&nbsp;	 */
&nbsp;	public static boolean isValidLanguageTag(String languageTag) {
&nbsp;		try {
<b class="nc">&nbsp;			new Locale.Builder().setLanguageTag(languageTag);</b>
<b class="nc">&nbsp;			return true;</b>
<b class="nc">&nbsp;		} catch (IllformedLocaleException e) {</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Implements language range filtering for SPARQL langMatches
&nbsp;	 * (https://www.w3.org/TR/sparql11-query/#func-langMatches).
&nbsp;	 *
&nbsp;	 * @param langTag   the tag to filter
&nbsp;	 * @param langRange the range to filter against
&nbsp;	 * @return true if langTag matches langRange
&nbsp;	 */
&nbsp;	public static boolean langMatches(String langTag, String langRange) {
<b class="fc">&nbsp;		boolean result = false;</b>
<b class="pc">&nbsp;		if (langRange.equals(&quot;*&quot;)) {</b>
<b class="nc">&nbsp;			result = langTag.length() &gt; 0;</b>
<b class="fc">&nbsp;		} else if (langTag.length() == langRange.length()) {</b>
<b class="fc">&nbsp;			result = langTag.equalsIgnoreCase(langRange);</b>
<b class="pc">&nbsp;		} else if (langTag.length() &gt; langRange.length()) {</b>
&nbsp;			// check if the range is a prefix of the tag
<b class="nc">&nbsp;			String prefix = langTag.substring(0, langRange.length());</b>
<b class="nc">&nbsp;			result = prefix.equalsIgnoreCase(langRange) &amp;&amp; langTag.charAt(langRange.length()) == &#39;-&#39;;</b>
&nbsp;		}
<b class="fc">&nbsp;		return result;</b>
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	protected Literals() {</b>
&nbsp;		// Protected default constructor to prevent instantiation
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:22</div>
</div>
</body>
</html>
