


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > AllocatedNodesList</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.sail.nativerdf.btree</a>
</div>

<h1>Coverage Summary for Class: AllocatedNodesList (org.eclipse.rdf4j.sail.nativerdf.btree)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AllocatedNodesList</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/78)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;package org.eclipse.rdf4j.sail.nativerdf.btree;
&nbsp;
&nbsp;import java.io.Closeable;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.nio.channels.FileChannel;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.BitSet;
&nbsp;
&nbsp;import org.eclipse.rdf4j.common.io.ByteArrayUtil;
&nbsp;import org.eclipse.rdf4j.common.io.NioFile;
&nbsp;
&nbsp;/**
&nbsp; * List of allocated BTree nodes, persisted to a file on disk.
&nbsp; *
&nbsp; * @author Arjohn Kampman
&nbsp; */
&nbsp;class AllocatedNodesList implements Closeable {
&nbsp;
&nbsp;	/*-----------*
&nbsp;	 * Constants *
&nbsp;	 *-----------*/
&nbsp;
&nbsp;	/**
&nbsp;	 * Magic number &quot;Allocated Nodes File&quot; to detect whether the file is actually an allocated nodes file. The first
&nbsp;	 * three bytes of the file should be equal to this magic number.
&nbsp;	 */
<b class="nc">&nbsp;	private static final byte[] MAGIC_NUMBER = new byte[] { &#39;a&#39;, &#39;n&#39;, &#39;f&#39; };</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * The file format version number, stored as the fourth byte in allocated nodes files.
&nbsp;	 */
&nbsp;	private static final byte FILE_FORMAT_VERSION = 1;
&nbsp;
<b class="nc">&nbsp;	private static final int HEADER_LENGTH = MAGIC_NUMBER.length + 1;</b>
&nbsp;
&nbsp;	/*-----------*
&nbsp;	 * Variables *
&nbsp;	 *-----------*/
&nbsp;
&nbsp;	/**
&nbsp;	 * The BTree associated with this allocated nodes list.
&nbsp;	 */
&nbsp;	private final BTree btree;
&nbsp;
&nbsp;	/**
&nbsp;	 * The allocated nodes file.
&nbsp;	 */
&nbsp;	private final NioFile nioFile;
&nbsp;
&nbsp;	/**
&nbsp;	 * Bit set recording which nodes have been allocated, using node IDs as index.
&nbsp;	 */
&nbsp;	private BitSet allocatedNodes;
&nbsp;
&nbsp;	/**
&nbsp;	 * Flag indicating whether the set of allocated nodes has changed and needs to be written to file.
&nbsp;	 */
<b class="nc">&nbsp;	private boolean needsSync = false;</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Flag indicating whether file writes should be forced to disk using {@link FileChannel#force(boolean)}.
&nbsp;	 */
&nbsp;	private final boolean forceSync;
&nbsp;
&nbsp;	/*--------------*
&nbsp;	 * Constructors *
&nbsp;	 *--------------*/
&nbsp;
&nbsp;	/**
&nbsp;	 * Creates a new AllocatedNodelist for the specified BTree.
&nbsp;	 */
<b class="nc">&nbsp;	public AllocatedNodesList(File allocNodesFile, BTree btree, boolean forceSync) throws IOException {</b>
<b class="nc">&nbsp;		if (allocNodesFile == null) {</b>
<b class="nc">&nbsp;			throw new IllegalArgumentException(&quot;allocNodesFile must not be null&quot;);</b>
&nbsp;		}
<b class="nc">&nbsp;		if (btree == null) {</b>
<b class="nc">&nbsp;			throw new IllegalArgumentException(&quot;btree muts not be null&quot;);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		this.nioFile = new NioFile(allocNodesFile);</b>
<b class="nc">&nbsp;		this.btree = btree;</b>
<b class="nc">&nbsp;		this.forceSync = forceSync;</b>
&nbsp;	}
&nbsp;
&nbsp;	/*---------*
&nbsp;	 * Methods *
&nbsp;	 *---------*/
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets the allocated nodes file.
&nbsp;	 */
&nbsp;	public File getFile() {
<b class="nc">&nbsp;		return nioFile.getFile();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public synchronized void close() throws IOException {
<b class="nc">&nbsp;		close(true);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Deletes the allocated nodes file.
&nbsp;	 *
&nbsp;	 * @return &lt;var&gt;true&lt;/var&gt; if the file was deleted.
&nbsp;	 */
&nbsp;	public synchronized boolean delete() throws IOException {
<b class="nc">&nbsp;		close(false);</b>
<b class="nc">&nbsp;		return nioFile.delete();</b>
&nbsp;	}
&nbsp;
&nbsp;	public synchronized void close(boolean syncChanges) throws IOException {
<b class="nc">&nbsp;		if (syncChanges) {</b>
<b class="nc">&nbsp;			sync();</b>
&nbsp;		}
<b class="nc">&nbsp;		allocatedNodes = null;</b>
<b class="nc">&nbsp;		needsSync = false;</b>
<b class="nc">&nbsp;		nioFile.close();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Writes any changes that are cached in memory to disk.
&nbsp;	 *
&nbsp;	 * @throws IOException
&nbsp;	 */
&nbsp;	public synchronized void sync() throws IOException {
<b class="nc">&nbsp;		if (needsSync) {</b>
&nbsp;			// Trim bit set
<b class="nc">&nbsp;			BitSet bitSet = allocatedNodes;</b>
<b class="nc">&nbsp;			int bitSetLength = allocatedNodes.length();</b>
<b class="nc">&nbsp;			if (bitSetLength &lt; allocatedNodes.size()) {</b>
<b class="nc">&nbsp;				bitSet = allocatedNodes.get(0, bitSetLength);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			byte[] data = ByteArrayUtil.toByteArray(bitSet);</b>
&nbsp;
&nbsp;			// Write bit set to file
<b class="nc">&nbsp;			nioFile.truncate(HEADER_LENGTH + data.length);</b>
<b class="nc">&nbsp;			nioFile.writeBytes(MAGIC_NUMBER, 0);</b>
<b class="nc">&nbsp;			nioFile.writeByte(FILE_FORMAT_VERSION, MAGIC_NUMBER.length);</b>
<b class="nc">&nbsp;			nioFile.writeBytes(data, HEADER_LENGTH);</b>
&nbsp;
<b class="nc">&nbsp;			if (forceSync) {</b>
<b class="nc">&nbsp;				nioFile.force(false);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			needsSync = false;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private void scheduleSync() throws IOException {
<b class="nc">&nbsp;		if (needsSync == false) {</b>
<b class="nc">&nbsp;			nioFile.truncate(0);</b>
<b class="nc">&nbsp;			needsSync = true;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Clears the allocated nodes list.
&nbsp;	 *
&nbsp;	 * @throws IOException If an I/O error occurred.
&nbsp;	 */
&nbsp;	public synchronized void clear() throws IOException {
<b class="nc">&nbsp;		if (allocatedNodes != null) {</b>
<b class="nc">&nbsp;			allocatedNodes.clear();</b>
&nbsp;		} else {
&nbsp;			// bit set has not yet been initialized
<b class="nc">&nbsp;			allocatedNodes = new BitSet();</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		scheduleSync();</b>
&nbsp;	}
&nbsp;
&nbsp;	public synchronized int allocateNode() throws IOException {
<b class="nc">&nbsp;		initAllocatedNodes();</b>
&nbsp;
<b class="nc">&nbsp;		int newNodeID = allocatedNodes.nextClearBit(1);</b>
<b class="nc">&nbsp;		allocatedNodes.set(newNodeID);</b>
&nbsp;
<b class="nc">&nbsp;		scheduleSync();</b>
&nbsp;
<b class="nc">&nbsp;		return newNodeID;</b>
&nbsp;	}
&nbsp;
&nbsp;	public synchronized void freeNode(int nodeID) throws IOException {
<b class="nc">&nbsp;		initAllocatedNodes();</b>
<b class="nc">&nbsp;		allocatedNodes.clear(nodeID);</b>
<b class="nc">&nbsp;		scheduleSync();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the highest allocated node ID.
&nbsp;	 */
&nbsp;	public synchronized int getMaxNodeID() throws IOException {
<b class="nc">&nbsp;		initAllocatedNodes();</b>
<b class="nc">&nbsp;		return Math.max(0, allocatedNodes.length() - 1);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the number of allocated nodes.
&nbsp;	 */
&nbsp;	public synchronized int getNodeCount() throws IOException {
<b class="nc">&nbsp;		initAllocatedNodes();</b>
<b class="nc">&nbsp;		return allocatedNodes.cardinality();</b>
&nbsp;	}
&nbsp;
&nbsp;	private void initAllocatedNodes() throws IOException {
<b class="nc">&nbsp;		if (allocatedNodes == null) {</b>
<b class="nc">&nbsp;			if (nioFile.size() &gt; 0L) {</b>
<b class="nc">&nbsp;				loadAllocatedNodesInfo();</b>
&nbsp;			} else {
<b class="nc">&nbsp;				crawlAllocatedNodes();</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private void loadAllocatedNodesInfo() throws IOException {
&nbsp;		byte[] data;
&nbsp;
<b class="nc">&nbsp;		if (nioFile.size() &gt;= HEADER_LENGTH &amp;&amp; Arrays.equals(MAGIC_NUMBER, nioFile.readBytes(0, MAGIC_NUMBER.length))) {</b>
<b class="nc">&nbsp;			byte version = nioFile.readByte(MAGIC_NUMBER.length);</b>
<b class="nc">&nbsp;			if (version &gt; FILE_FORMAT_VERSION) {</b>
<b class="nc">&nbsp;				throw new IOException(&quot;Unable to read allocated nodes file; it uses a newer file format&quot;);</b>
<b class="nc">&nbsp;			} else if (version != FILE_FORMAT_VERSION) {</b>
<b class="nc">&nbsp;				throw new IOException(&quot;Unable to read allocated nodes file; invalid file format version: &quot; + version);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			data = nioFile.readBytes(HEADER_LENGTH, (int) (nioFile.size() - HEADER_LENGTH));</b>
<b class="nc">&nbsp;		} else {</b>
&nbsp;			// assume header is missing (old file format)
<b class="nc">&nbsp;			data = nioFile.readBytes(0, (int) nioFile.size());</b>
<b class="nc">&nbsp;			scheduleSync();</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		allocatedNodes = ByteArrayUtil.toBitSet(data);</b>
&nbsp;	}
&nbsp;
&nbsp;	private void crawlAllocatedNodes() throws IOException {
<b class="nc">&nbsp;		allocatedNodes = new BitSet();</b>
&nbsp;
<b class="nc">&nbsp;		Node rootNode = btree.readRootNode();</b>
<b class="nc">&nbsp;		if (rootNode != null) {</b>
<b class="nc">&nbsp;			crawlAllocatedNodes(rootNode);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		scheduleSync();</b>
&nbsp;	}
&nbsp;
&nbsp;	private void crawlAllocatedNodes(Node node) throws IOException {
&nbsp;		try {
<b class="nc">&nbsp;			allocatedNodes.set(node.getID());</b>
&nbsp;
<b class="nc">&nbsp;			if (!node.isLeaf()) {</b>
<b class="nc">&nbsp;				for (int i = 0; i &lt; node.getValueCount() + 1; i++) {</b>
<b class="nc">&nbsp;					crawlAllocatedNodes(node.getChildNode(i));</b>
&nbsp;				}
&nbsp;			}
&nbsp;
&nbsp;		} finally {
<b class="nc">&nbsp;			node.release();</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:22</div>
</div>
</body>
</html>
