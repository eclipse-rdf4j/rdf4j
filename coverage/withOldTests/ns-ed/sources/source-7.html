


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > GraphPatterns</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.sparqlbuilder.graphpattern</a>
</div>

<h1>Coverage Summary for Class: GraphPatterns (org.eclipse.rdf4j.sparqlbuilder.graphpattern)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">GraphPatterns</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/36)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2018 Eclipse RDF4J contributors.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;
&nbsp;package org.eclipse.rdf4j.sparqlbuilder.graphpattern;
&nbsp;
&nbsp;import java.util.function.Consumer;
&nbsp;
&nbsp;import org.eclipse.rdf4j.model.BNode;
&nbsp;import org.eclipse.rdf4j.model.IRI;
&nbsp;import org.eclipse.rdf4j.model.Resource;
&nbsp;import org.eclipse.rdf4j.model.Value;
&nbsp;import org.eclipse.rdf4j.sparqlbuilder.constraint.propertypath.builder.EmptyPropertyPathBuilder;
&nbsp;import org.eclipse.rdf4j.sparqlbuilder.core.Projectable;
&nbsp;import org.eclipse.rdf4j.sparqlbuilder.rdf.Rdf;
&nbsp;import org.eclipse.rdf4j.sparqlbuilder.rdf.RdfBlankNode.PropertiesBlankNode;
&nbsp;import org.eclipse.rdf4j.sparqlbuilder.rdf.RdfObject;
&nbsp;import org.eclipse.rdf4j.sparqlbuilder.rdf.RdfPredicate;
&nbsp;import org.eclipse.rdf4j.sparqlbuilder.rdf.RdfPredicateObjectList;
&nbsp;import org.eclipse.rdf4j.sparqlbuilder.rdf.RdfSubject;
&nbsp;
&nbsp;/**
&nbsp; * A class with static methods to create graph patterns.
&nbsp; *
&nbsp; * @see &lt;a href=&quot;http://www.w3.org/TR/2013/REC-sparql11-query-20130321/#GraphPattern&quot;&gt;SPARQL Graph Pattern&lt;/a&gt;
&nbsp; */
&nbsp;public class GraphPatterns {
&nbsp;	// prevent instantiation of this class
&nbsp;	private GraphPatterns() {
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Create a triple pattern with the given subject, predicate, and object(s)
&nbsp;	 *
&nbsp;	 * @param subject
&nbsp;	 * @param predicate
&nbsp;	 * @param objects
&nbsp;	 *
&nbsp;	 * @return a new {@link TriplePattern}
&nbsp;	 *
&nbsp;	 * @see &lt;a href=&quot;http://www.w3.org/TR/2013/REC-sparql11-query-20130321/#QSynTriples&quot;&gt; Triple pattern syntax&lt;/a&gt;
&nbsp;	 */
&nbsp;	public static TriplePattern tp(RdfSubject subject, RdfPredicate predicate, RdfObject... objects) {
<b class="nc">&nbsp;		return new TriplesSameSubject(subject, predicate, objects);</b>
&nbsp;	}
&nbsp;
&nbsp;	public static TriplePattern tp(RdfSubject subject, RdfPredicate predicate, Value... objects) {
<b class="nc">&nbsp;		return tp(subject, predicate, Rdf.objects(objects));</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Create a triple pattern with the given subject, predicate, and object(s)
&nbsp;	 *
&nbsp;	 * @param subject   the triple pattern subject
&nbsp;	 * @param predicate the triple pattern predicate as a {@link IRI}
&nbsp;	 * @param objects   the triples pattern object(s)
&nbsp;	 *
&nbsp;	 * @return a new {@link TriplePattern}
&nbsp;	 *
&nbsp;	 * @see &lt;a href=&quot;http://www.w3.org/TR/2013/REC-sparql11-query-20130321/#QSynTriples&quot;&gt; Triple pattern syntax&lt;/a&gt;
&nbsp;	 */
&nbsp;	public static TriplePattern tp(RdfSubject subject, IRI predicate, RdfObject... objects) {
<b class="nc">&nbsp;		return tp(subject, Rdf.iri(predicate), objects);</b>
&nbsp;	}
&nbsp;
&nbsp;	public static TriplePattern tp(RdfSubject subject, IRI predicate, Value... objects) {
<b class="nc">&nbsp;		return tp(subject, Rdf.iri(predicate), Rdf.objects(objects));</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Create a triple pattern with the given subject, predicate, and object(s)
&nbsp;	 *
&nbsp;	 * @param subject   the triple pattern subject
&nbsp;	 * @param predicate the triple pattern predicate as a {@link IRI}
&nbsp;	 * @param objects   the triples pattern object(s)
&nbsp;	 *
&nbsp;	 * @return a new {@link TriplePattern}
&nbsp;	 *
&nbsp;	 * @see &lt;a href=&quot;http://www.w3.org/TR/2013/REC-sparql11-query-20130321/#QSynTriples&quot;&gt; Triple pattern syntax&lt;/a&gt;
&nbsp;	 */
&nbsp;	public static TriplePattern tp(Resource subject, RdfPredicate predicate, RdfObject... objects) {
<b class="nc">&nbsp;		if (subject instanceof IRI) {</b>
<b class="nc">&nbsp;			return tp(Rdf.iri((IRI) subject), predicate, objects);</b>
&nbsp;		}
<b class="nc">&nbsp;		return tp(Rdf.bNode(((BNode) subject).getID()), predicate, objects);</b>
&nbsp;	}
&nbsp;
&nbsp;	public static TriplePattern tp(Resource subject, RdfPredicate predicate, Value... objects) {
<b class="nc">&nbsp;		return tp(subject, predicate, Rdf.objects(objects));</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Create a triple pattern with the given subject, predicate, and object(s)
&nbsp;	 *
&nbsp;	 * @param subject   the triple pattern subject as a {@link Resource}
&nbsp;	 * @param predicate the triple pattern predicate as a {@link IRI}
&nbsp;	 * @param objects   the triples pattern object(s)
&nbsp;	 *
&nbsp;	 * @return a new {@link TriplePattern}
&nbsp;	 *
&nbsp;	 * @see &lt;a href=&quot;http://www.w3.org/TR/2013/REC-sparql11-query-20130321/#QSynTriples&quot;&gt; Triple pattern syntax&lt;/a&gt;
&nbsp;	 */
&nbsp;	public static TriplePattern tp(Resource subject, IRI predicate, RdfObject... objects) {
<b class="nc">&nbsp;		return tp(subject, Rdf.iri(predicate), objects);</b>
&nbsp;	}
&nbsp;
&nbsp;	public static TriplePattern tp(Resource subject, IRI predicate, Value... objects) {
<b class="nc">&nbsp;		return tp(subject, Rdf.iri(predicate), Rdf.objects(objects));</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Create a triple pattern with the given subject and predicate-object list(s)
&nbsp;	 *
&nbsp;	 * @param subject
&nbsp;	 * @param lists
&nbsp;	 *
&nbsp;	 * @return a new {@link TriplePattern}
&nbsp;	 *
&nbsp;	 * @see &lt;a href=&quot;http://www.w3.org/TR/2013/REC-sparql11-query-20130321/#QSynTriples&quot;&gt; Triple pattern syntax&lt;/a&gt;
&nbsp;	 */
&nbsp;	public static TriplePattern tp(RdfSubject subject, RdfPredicateObjectList... lists) {
<b class="nc">&nbsp;		return new TriplesSameSubject(subject, lists);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Create a triple pattern from a property-list blank node
&nbsp;	 *
&nbsp;	 * @param bnode the PropertiesBlankNode instance to convert to a triple pattern
&nbsp;	 *
&nbsp;	 * @return the triple pattern represented by the expansion of this blank node
&nbsp;	 *
&nbsp;	 * @see &lt;a href=&quot;https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#QSynBlankNodes&quot;&gt; blank node syntax&lt;/a&gt;
&nbsp;	 */
&nbsp;	public static TriplePattern tp(PropertiesBlankNode bnode) {
<b class="nc">&nbsp;		return new BNodeTriplePattern(bnode);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Create a triple pattern from a property path and a list of objects.
&nbsp;	 *
&nbsp;	 * @param subject                the subject
&nbsp;	 * @param propertyPathConfigurer an object that accepts an {@link EmptyPropertyPathBuilder} and uses it to create a
&nbsp;	 *                               property path
&nbsp;	 * @param objects                the object(s) of the triple(s)
&nbsp;	 *
&nbsp;	 * @return the triple pattern
&nbsp;	 */
&nbsp;	public static TriplePattern tp(RdfSubject subject, Consumer&lt;EmptyPropertyPathBuilder&gt; propertyPathConfigurer,
&nbsp;			RdfObject... objects) {
<b class="nc">&nbsp;		EmptyPropertyPathBuilder builder = new EmptyPropertyPathBuilder();</b>
<b class="nc">&nbsp;		propertyPathConfigurer.accept(builder);</b>
<b class="nc">&nbsp;		return new TriplesSameSubject(subject, builder.build(), objects);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Create a group graph pattern containing the given graph patterns
&nbsp;	 *
&nbsp;	 * @param patterns the patterns to include in the group graph a pattern
&nbsp;	 * @return a new group graph pattern
&nbsp;	 *
&nbsp;	 * @see &lt;a href=&quot;http://www.w3.org/TR/2013/REC-sparql11-query-20130321/#GroupPatterns&quot;&gt;SPARQL Group Graph
&nbsp;	 *      Pattern&lt;/a&gt;
&nbsp;	 */
&nbsp;	public static GraphPatternNotTriples and(GraphPattern... patterns) {
<b class="nc">&nbsp;		GroupGraphPattern and = new GroupGraphPattern();</b>
&nbsp;
<b class="nc">&nbsp;		return new GraphPatternNotTriples(and.and(patterns));</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Create an alternative graph pattern containing the union of the given graph patterns: &lt;br&gt;
&nbsp;	 *
&nbsp;	 * &lt;pre&gt;
&nbsp;	 * { { pattern1 } UNION { pattern2 } UNION ... UNION { patternN } }
&nbsp;	 * &lt;/pre&gt;
&nbsp;	 *
&nbsp;	 * @param patterns the patterns to include in the union
&nbsp;	 * @return a new alternative graph pattern
&nbsp;	 *
&nbsp;	 * @see &lt;a href=&quot;http://www.w3.org/TR/2013/REC-sparql11-query-20130321/#alternatives&quot;&gt; SPARQL Alternative Graph
&nbsp;	 *      Patterns&lt;/a&gt;
&nbsp;	 */
&nbsp;	public static GraphPatternNotTriples union(GraphPattern... patterns) {
<b class="nc">&nbsp;		AlternativeGraphPattern union = new AlternativeGraphPattern();</b>
&nbsp;
<b class="nc">&nbsp;		return new GraphPatternNotTriples(union.union(patterns));</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Create an optional group graph pattern containing the given graph patterns: &lt;br&gt;
&nbsp;	 *
&nbsp;	 * &lt;pre&gt;
&nbsp;	 * {
&nbsp;	 *   OPTIONAL {
&nbsp;	 *     pattern1 .
&nbsp;	 *     pattern2 .
&nbsp;	 *     ...
&nbsp;	 *     patternN
&nbsp;	 *   }
&nbsp;	 * }
&nbsp;	 * &lt;/pre&gt;
&nbsp;	 *
&nbsp;	 * @param patterns the patterns to include in the optional graph pattern
&nbsp;	 * @return a new optional graph pattern
&nbsp;	 *
&nbsp;	 * @see &lt;a href=&quot;http://www.w3.org/TR/2013/REC-sparql11-query-20130321/#optionals&quot;&gt; SPARQL Optional Graph
&nbsp;	 *      Patterns&lt;/a&gt;
&nbsp;	 */
&nbsp;	public static GraphPatternNotTriples optional(GraphPattern... patterns) {
<b class="nc">&nbsp;		return and(patterns).optional();</b>
&nbsp;	}
&nbsp;
&nbsp;	public static GraphPatternNotTriples filterExists(GraphPattern... patterns) {
<b class="nc">&nbsp;		return filterExists(true, patterns);</b>
&nbsp;	}
&nbsp;
&nbsp;	public static GraphPatternNotTriples filterNotExists(GraphPattern... patterns) {
<b class="nc">&nbsp;		return filterExists(false, patterns);</b>
&nbsp;	}
&nbsp;
&nbsp;	public static GraphPatternNotTriples minus(GraphPattern... patterns) {
<b class="nc">&nbsp;		MinusGraphPattern minus = new MinusGraphPattern();</b>
<b class="nc">&nbsp;		minus.and(patterns);</b>
&nbsp;
<b class="nc">&nbsp;		return new GraphPatternNotTriples(minus);</b>
&nbsp;	}
&nbsp;
&nbsp;	public static GraphPatternNotTriples filterExists(boolean exists, GraphPattern... patterns) {
<b class="nc">&nbsp;		FilterExistsGraphPattern filterExists = new FilterExistsGraphPattern().exists(exists);</b>
<b class="nc">&nbsp;		filterExists.and(patterns);</b>
&nbsp;
<b class="nc">&nbsp;		return new GraphPatternNotTriples(filterExists);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Create a SPARQL subquery, including the given elements in its projection.
&nbsp;	 *
&nbsp;	 * @param projectables the elements to include in the projection of the subquery
&nbsp;	 * @return a new subquery
&nbsp;	 *
&nbsp;	 * @see &lt;a href=&quot;http://www.w3.org/TR/2013/REC-sparql11-query-20130321/#subqueries&quot;&gt; SPARQL Subquery&lt;/a&gt;
&nbsp;	 */
&nbsp;	public static SubSelect select(Projectable... projectables) {
<b class="nc">&nbsp;		return new SubSelect().select(projectables);</b>
&nbsp;	}
&nbsp;
&nbsp;	static GroupGraphPattern extractOrConvertToGGP(GraphPattern pattern) {
<b class="nc">&nbsp;		if (pattern instanceof GroupGraphPattern) {</b>
<b class="nc">&nbsp;			return (GroupGraphPattern) pattern;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (pattern instanceof GraphPatternNotTriples) {</b>
<b class="nc">&nbsp;			GraphPatternNotTriples gp = (GraphPatternNotTriples) pattern;</b>
<b class="nc">&nbsp;			if (gp.gp instanceof GroupGraphPattern) {</b>
<b class="nc">&nbsp;				return (GroupGraphPattern) gp.gp;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return new GroupGraphPattern(pattern);</b>
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:22</div>
</div>
</body>
</html>
