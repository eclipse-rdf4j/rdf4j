


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > SPARQLQueryComplianceTest</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.testsuite.query.parser.sparql.manifest</a>
</div>

<h1>Coverage Summary for Class: SPARQLQueryComplianceTest (org.eclipse.rdf4j.testsuite.query.parser.sparql.manifest)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SPARQLQueryComplianceTest</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    56.2%
  </span>
  <span class="absValue">
    (45/80)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77.7%
  </span>
  <span class="absValue">
    (129/166)
  </span>
</td>
</tr>
  <tr>
    <td class="name">SPARQLQueryComplianceTest$SPARQLQueryTestManifest</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    58.3%
  </span>
  <span class="absValue">
    (21/36)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    98.8%
  </span>
  <span class="absValue">
    (80/81)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (16/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    56.9%
  </span>
  <span class="absValue">
    (66/116)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.6%
  </span>
  <span class="absValue">
    (209/247)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2020 Eclipse RDF4J contributors.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;package org.eclipse.rdf4j.testsuite.query.parser.sparql.manifest;
&nbsp;
&nbsp;import static org.assertj.core.api.Assertions.assertThat;
&nbsp;import static org.assertj.core.api.Assertions.fail;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.InputStreamReader;
&nbsp;import java.net.URL;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.LinkedHashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Optional;
&nbsp;import java.util.Set;
&nbsp;
&nbsp;import org.apache.commons.lang3.StringUtils;
&nbsp;import org.eclipse.rdf4j.common.io.IOUtil;
&nbsp;import org.eclipse.rdf4j.common.iteration.Iterations;
&nbsp;import org.eclipse.rdf4j.common.text.StringUtil;
&nbsp;import org.eclipse.rdf4j.model.IRI;
&nbsp;import org.eclipse.rdf4j.model.Statement;
&nbsp;import org.eclipse.rdf4j.model.Value;
&nbsp;import org.eclipse.rdf4j.model.util.Literals;
&nbsp;import org.eclipse.rdf4j.query.BindingSet;
&nbsp;import org.eclipse.rdf4j.query.BooleanQuery;
&nbsp;import org.eclipse.rdf4j.query.Dataset;
&nbsp;import org.eclipse.rdf4j.query.GraphQuery;
&nbsp;import org.eclipse.rdf4j.query.GraphQueryResult;
&nbsp;import org.eclipse.rdf4j.query.Query;
&nbsp;import org.eclipse.rdf4j.query.QueryLanguage;
&nbsp;import org.eclipse.rdf4j.query.QueryResults;
&nbsp;import org.eclipse.rdf4j.query.TupleQuery;
&nbsp;import org.eclipse.rdf4j.query.TupleQueryResult;
&nbsp;import org.eclipse.rdf4j.query.dawg.DAWGTestResultSetUtil;
&nbsp;import org.eclipse.rdf4j.query.impl.MutableTupleQueryResult;
&nbsp;import org.eclipse.rdf4j.query.impl.SimpleDataset;
&nbsp;import org.eclipse.rdf4j.query.impl.TupleQueryResultBuilder;
&nbsp;import org.eclipse.rdf4j.query.resultio.BooleanQueryResultParserRegistry;
&nbsp;import org.eclipse.rdf4j.query.resultio.QueryResultFormat;
&nbsp;import org.eclipse.rdf4j.query.resultio.QueryResultIO;
&nbsp;import org.eclipse.rdf4j.query.resultio.TupleQueryResultParser;
&nbsp;import org.eclipse.rdf4j.repository.Repository;
&nbsp;import org.eclipse.rdf4j.repository.RepositoryConnection;
&nbsp;import org.eclipse.rdf4j.repository.sail.SailRepository;
&nbsp;import org.eclipse.rdf4j.repository.sail.SailRepositoryConnection;
&nbsp;import org.eclipse.rdf4j.rio.RDFFormat;
&nbsp;import org.eclipse.rdf4j.rio.RDFParser;
&nbsp;import org.eclipse.rdf4j.rio.Rio;
&nbsp;import org.eclipse.rdf4j.rio.helpers.BasicParserSettings;
&nbsp;import org.eclipse.rdf4j.rio.helpers.StatementCollector;
&nbsp;import org.eclipse.rdf4j.sail.memory.MemoryStore;
&nbsp;import org.junit.After;
&nbsp;import org.junit.Before;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;
&nbsp;/**
&nbsp; * Base functionality for SPARQL query compliance test suites .
&nbsp; *
&nbsp; * @author Jeen Broekstra
&nbsp; *
&nbsp; */
&nbsp;public abstract class SPARQLQueryComplianceTest extends SPARQLComplianceTest {
&nbsp;
<b class="fc">&nbsp;	private static final Logger logger = LoggerFactory.getLogger(SPARQLQueryComplianceTest.class);</b>
&nbsp;
&nbsp;	private final String queryFileURL;
&nbsp;	private final String resultFileURL;
&nbsp;	private final Dataset dataset;
&nbsp;	private final boolean ordered;
&nbsp;	private final boolean laxCardinality;
&nbsp;
&nbsp;	private Repository dataRepository;
&nbsp;
&nbsp;	/**
&nbsp;	 * @param displayName
&nbsp;	 * @param testURI
&nbsp;	 * @param name
&nbsp;	 * @param queryFileURL
&nbsp;	 * @param resultFileURL
&nbsp;	 * @param dataset
&nbsp;	 * @param ordered
&nbsp;	 */
&nbsp;	public SPARQLQueryComplianceTest(String displayName, String testURI, String name, String queryFileURL,
&nbsp;			String resultFileURL, Dataset dataset, boolean ordered, boolean laxCardinality) {
<b class="fc">&nbsp;		super(displayName, testURI, name);</b>
<b class="fc">&nbsp;		this.queryFileURL = queryFileURL;</b>
<b class="fc">&nbsp;		this.resultFileURL = resultFileURL;</b>
<b class="fc">&nbsp;		this.dataset = dataset;</b>
<b class="fc">&nbsp;		this.ordered = ordered;</b>
<b class="fc">&nbsp;		this.laxCardinality = laxCardinality;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Before
&nbsp;	public void setUp() throws Exception {
<b class="fc">&nbsp;		dataRepository = createRepository();</b>
<b class="fc">&nbsp;		if (dataset != null) {</b>
&nbsp;			try {
<b class="fc">&nbsp;				uploadDataset(dataset);</b>
<b class="nc">&nbsp;			} catch (Exception exc) {</b>
&nbsp;				try {
<b class="nc">&nbsp;					dataRepository.shutDown();</b>
<b class="nc">&nbsp;					dataRepository = null;</b>
<b class="nc">&nbsp;				} catch (Exception e2) {</b>
<b class="nc">&nbsp;					logger.error(e2.toString(), e2);</b>
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;				throw exc;</b>
<b class="fc">&nbsp;			}</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@After
&nbsp;	public void tearDown() throws Exception {
<b class="pc">&nbsp;		if (dataRepository != null) {</b>
<b class="fc">&nbsp;			dataRepository.shutDown();</b>
<b class="fc">&nbsp;			dataRepository = null;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected void runTest() throws Exception {
&nbsp;
<b class="fc">&nbsp;		logger.debug(&quot;running {}&quot;, getName());</b>
&nbsp;
<b class="pc">&nbsp;		try (RepositoryConnection conn = getDataRepository().getConnection()) {</b>
&nbsp;			// Some SPARQL Tests have non-XSD datatypes that must pass for the test
&nbsp;			// suite to complete successfully
<b class="fc">&nbsp;			conn.getParserConfig().set(BasicParserSettings.VERIFY_DATATYPE_VALUES, Boolean.FALSE);</b>
<b class="fc">&nbsp;			conn.getParserConfig().set(BasicParserSettings.FAIL_ON_UNKNOWN_DATATYPES, Boolean.FALSE);</b>
&nbsp;
<b class="fc">&nbsp;			String queryString = readQueryString();</b>
<b class="fc">&nbsp;			Query query = conn.prepareQuery(QueryLanguage.SPARQL, queryString, queryFileURL);</b>
<b class="fc">&nbsp;			if (dataset != null) {</b>
<b class="fc">&nbsp;				query.setDataset(dataset);</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			if (query instanceof TupleQuery) {</b>
<b class="fc">&nbsp;				TupleQueryResult actualResult = ((TupleQuery) query).evaluate();</b>
<b class="fc">&nbsp;				TupleQueryResult expectedResult = readExpectedTupleQueryResult();</b>
<b class="fc">&nbsp;				compareTupleQueryResults(actualResult, expectedResult);</b>
<b class="fc">&nbsp;			} else if (query instanceof GraphQuery) {</b>
<b class="fc">&nbsp;				GraphQueryResult gqr = ((GraphQuery) query).evaluate();</b>
<b class="fc">&nbsp;				Set&lt;Statement&gt; actualResult = Iterations.asSet(gqr);</b>
<b class="fc">&nbsp;				Set&lt;Statement&gt; expectedResult = readExpectedGraphQueryResult();</b>
&nbsp;
<b class="fc">&nbsp;				compareGraphs(actualResult, expectedResult);</b>
<b class="pc">&nbsp;			} else if (query instanceof BooleanQuery) {</b>
<b class="fc">&nbsp;				boolean actualResult = ((BooleanQuery) query).evaluate();</b>
<b class="fc">&nbsp;				boolean expectedResult = readExpectedBooleanQueryResult();</b>
<b class="fc">&nbsp;				assertThat(actualResult).isEqualTo(expectedResult);</b>
<b class="fc">&nbsp;			} else {</b>
<b class="nc">&nbsp;				throw new RuntimeException(&quot;Unexpected query type: &quot; + query.getClass());</b>
&nbsp;			}
<b class="pc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	protected abstract Repository newRepository() throws Exception;
&nbsp;
&nbsp;	private Repository createRepository() throws Exception {
<b class="fc">&nbsp;		Repository repo = newRepository();</b>
<b class="pc">&nbsp;		try (RepositoryConnection con = repo.getConnection()) {</b>
<b class="fc">&nbsp;			con.clear();</b>
<b class="fc">&nbsp;			con.clearNamespaces();</b>
<b class="pc">&nbsp;		}</b>
<b class="fc">&nbsp;		return repo;</b>
&nbsp;	}
&nbsp;
&nbsp;	private String readQueryString() throws IOException {
<b class="pc">&nbsp;		try (InputStream stream = new URL(queryFileURL).openStream()) {</b>
<b class="fc">&nbsp;			return IOUtil.readString(new InputStreamReader(stream, StandardCharsets.UTF_8));</b>
<b class="pc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private TupleQueryResult readExpectedTupleQueryResult() throws Exception {
<b class="fc">&nbsp;		Optional&lt;QueryResultFormat&gt; tqrFormat = QueryResultIO.getParserFormatForFileName(resultFileURL);</b>
&nbsp;
<b class="pc">&nbsp;		if (tqrFormat.isPresent()) {</b>
<b class="pc">&nbsp;			try (InputStream in = new URL(resultFileURL).openStream()) {</b>
<b class="fc">&nbsp;				TupleQueryResultParser parser = QueryResultIO.createTupleParser(tqrFormat.get());</b>
<b class="fc">&nbsp;				parser.setValueFactory(getDataRepository().getValueFactory());</b>
&nbsp;
<b class="fc">&nbsp;				TupleQueryResultBuilder qrBuilder = new TupleQueryResultBuilder();</b>
<b class="fc">&nbsp;				parser.setQueryResultHandler(qrBuilder);</b>
&nbsp;
<b class="fc">&nbsp;				parser.parseQueryResult(in);</b>
<b class="fc">&nbsp;				return qrBuilder.getQueryResult();</b>
<b class="pc">&nbsp;			}</b>
&nbsp;		} else {
<b class="nc">&nbsp;			Set&lt;Statement&gt; resultGraph = readExpectedGraphQueryResult();</b>
<b class="nc">&nbsp;			return DAWGTestResultSetUtil.toTupleQueryResult(resultGraph);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private boolean readExpectedBooleanQueryResult() throws Exception {
<b class="fc">&nbsp;		Optional&lt;QueryResultFormat&gt; bqrFormat = BooleanQueryResultParserRegistry.getInstance()</b>
<b class="fc">&nbsp;				.getFileFormatForFileName(resultFileURL);</b>
&nbsp;
<b class="pc">&nbsp;		if (bqrFormat.isPresent()) {</b>
<b class="pc">&nbsp;			try (InputStream in = new URL(resultFileURL).openStream()) {</b>
<b class="fc">&nbsp;				return QueryResultIO.parseBoolean(in, bqrFormat.get());</b>
<b class="pc">&nbsp;			}</b>
&nbsp;		} else {
<b class="nc">&nbsp;			Set&lt;Statement&gt; resultGraph = readExpectedGraphQueryResult();</b>
<b class="nc">&nbsp;			return DAWGTestResultSetUtil.toBooleanQueryResult(resultGraph);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private Set&lt;Statement&gt; readExpectedGraphQueryResult() throws Exception {
<b class="fc">&nbsp;		RDFFormat rdfFormat = Rio.getParserFormatForFileName(resultFileURL)</b>
<b class="fc">&nbsp;				.orElseThrow(Rio.unsupportedFormat(resultFileURL));</b>
&nbsp;
<b class="fc">&nbsp;		RDFParser parser = Rio.createParser(rdfFormat);</b>
<b class="fc">&nbsp;		parser.setPreserveBNodeIDs(true);</b>
<b class="fc">&nbsp;		parser.setValueFactory(getDataRepository().getValueFactory());</b>
&nbsp;
<b class="fc">&nbsp;		Set&lt;Statement&gt; result = new LinkedHashSet&lt;&gt;();</b>
<b class="fc">&nbsp;		parser.setRDFHandler(new StatementCollector(result));</b>
&nbsp;
<b class="pc">&nbsp;		try (InputStream in = new URL(resultFileURL).openStream()) {</b>
<b class="fc">&nbsp;			parser.parse(in, resultFileURL);</b>
<b class="pc">&nbsp;		}</b>
&nbsp;
<b class="fc">&nbsp;		return result;</b>
&nbsp;	}
&nbsp;
&nbsp;	private void compareTupleQueryResults(TupleQueryResult queryResult, TupleQueryResult expectedResult)
&nbsp;			throws Exception {
&nbsp;		// Create MutableTupleQueryResult to be able to re-iterate over the
&nbsp;		// results
<b class="fc">&nbsp;		MutableTupleQueryResult queryResultTable = new MutableTupleQueryResult(queryResult);</b>
<b class="fc">&nbsp;		MutableTupleQueryResult expectedResultTable = new MutableTupleQueryResult(expectedResult);</b>
&nbsp;
&nbsp;		boolean resultsEqual;
<b class="pc">&nbsp;		if (laxCardinality) {</b>
<b class="nc">&nbsp;			resultsEqual = QueryResults.isSubset(queryResultTable, expectedResultTable);</b>
&nbsp;		} else {
<b class="fc">&nbsp;			resultsEqual = QueryResults.equals(queryResultTable, expectedResultTable);</b>
&nbsp;
<b class="fc">&nbsp;			if (ordered) {</b>
&nbsp;				// also check the order in which solutions occur.
<b class="fc">&nbsp;				queryResultTable.beforeFirst();</b>
<b class="fc">&nbsp;				expectedResultTable.beforeFirst();</b>
&nbsp;
<b class="fc">&nbsp;				while (queryResultTable.hasNext()) {</b>
<b class="fc">&nbsp;					BindingSet bs = queryResultTable.next();</b>
<b class="fc">&nbsp;					BindingSet expectedBs = expectedResultTable.next();</b>
&nbsp;
<b class="fc">&nbsp;					if (!bs.equals(expectedBs)) {</b>
<b class="fc">&nbsp;						resultsEqual = false;</b>
<b class="fc">&nbsp;						break;</b>
&nbsp;					}
<b class="fc">&nbsp;				}</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (!resultsEqual) {</b>
<b class="fc">&nbsp;			queryResultTable.beforeFirst();</b>
<b class="fc">&nbsp;			expectedResultTable.beforeFirst();</b>
&nbsp;
&nbsp;			/*
&nbsp;			 * StringBuilder message = new StringBuilder(128); message.append(&quot;\n============ &quot;);
&nbsp;			 * message.append(getName()); message.append(&quot; =======================\n&quot;); message.append(
&nbsp;			 * &quot;Expected result: \n&quot;); while (expectedResultTable.hasNext()) {
&nbsp;			 * message.append(expectedResultTable.next()); message.append(&quot;\n&quot;); } message.append(&quot;=============&quot;);
&nbsp;			 * StringUtil.appendN(&#39;=&#39;, getName().length(), message); message.append(&quot;========================\n&quot;);
&nbsp;			 * message.append(&quot;Query result: \n&quot;); while (queryResultTable.hasNext()) {
&nbsp;			 * message.append(queryResultTable.next()); message.append(&quot;\n&quot;); } message.append(&quot;=============&quot;);
&nbsp;			 * StringUtil.appendN(&#39;=&#39;, getName().length(), message); message.append(&quot;========================\n&quot;);
&nbsp;			 */
&nbsp;
<b class="fc">&nbsp;			List&lt;BindingSet&gt; queryBindings = Iterations.asList(queryResultTable);</b>
&nbsp;
<b class="fc">&nbsp;			List&lt;BindingSet&gt; expectedBindings = Iterations.asList(expectedResultTable);</b>
&nbsp;
<b class="fc">&nbsp;			List&lt;BindingSet&gt; missingBindings = new ArrayList&lt;&gt;(expectedBindings);</b>
<b class="fc">&nbsp;			missingBindings.removeAll(queryBindings);</b>
&nbsp;
<b class="fc">&nbsp;			List&lt;BindingSet&gt; unexpectedBindings = new ArrayList&lt;&gt;(queryBindings);</b>
<b class="fc">&nbsp;			unexpectedBindings.removeAll(expectedBindings);</b>
&nbsp;
<b class="fc">&nbsp;			StringBuilder message = new StringBuilder();</b>
<b class="fc">&nbsp;			String header = &quot;=================================== &quot; + getName() + &quot; ===================================&quot;;</b>
<b class="fc">&nbsp;			String footer = StringUtils.leftPad(&quot;&quot;, header.length(), &quot;=&quot;);</b>
<b class="fc">&nbsp;			message.append(&quot;\n&quot;).append(header).append(&quot;\n&quot;);</b>
&nbsp;
<b class="fc">&nbsp;			message.append(&quot;# Query:\n\n&quot;);</b>
<b class="fc">&nbsp;			message.append(readQueryString().trim()).append(&quot;\n&quot;);</b>
<b class="fc">&nbsp;			message.append(footer).append(&quot;\n&quot;);</b>
&nbsp;
<b class="fc">&nbsp;			message.append(&quot;# Expected bindings:\n\n&quot;);</b>
<b class="fc">&nbsp;			for (BindingSet bs : expectedBindings) {</b>
<b class="fc">&nbsp;				printBindingSet(bs, message);</b>
<b class="fc">&nbsp;			}</b>
<b class="fc">&nbsp;			message.append(footer).append(&quot;\n&quot;);</b>
&nbsp;
<b class="fc">&nbsp;			message.append(&quot;# Actual bindings:\n\n&quot;);</b>
<b class="fc">&nbsp;			for (BindingSet bs : queryBindings) {</b>
<b class="fc">&nbsp;				printBindingSet(bs, message);</b>
<b class="fc">&nbsp;			}</b>
<b class="fc">&nbsp;			message.append(footer).append(&quot;\n&quot;);</b>
&nbsp;
<b class="fc">&nbsp;			if (!missingBindings.isEmpty()) {</b>
&nbsp;
<b class="fc">&nbsp;				message.append(&quot;# Missing bindings: \n\n&quot;);</b>
<b class="fc">&nbsp;				for (BindingSet bs : missingBindings) {</b>
<b class="fc">&nbsp;					printBindingSet(bs, message);</b>
<b class="fc">&nbsp;				}</b>
<b class="fc">&nbsp;				message.append(footer).append(&quot;\n&quot;);</b>
&nbsp;			}
&nbsp;
<b class="pc">&nbsp;			if (!unexpectedBindings.isEmpty()) {</b>
<b class="fc">&nbsp;				message.append(&quot;# Unexpected bindings: \n\n&quot;);</b>
<b class="fc">&nbsp;				for (BindingSet bs : unexpectedBindings) {</b>
<b class="fc">&nbsp;					printBindingSet(bs, message);</b>
<b class="fc">&nbsp;				}</b>
<b class="fc">&nbsp;				message.append(footer).append(&quot;\n&quot;);</b>
&nbsp;			}
&nbsp;
<b class="pc">&nbsp;			if (ordered &amp;&amp; missingBindings.isEmpty() &amp;&amp; unexpectedBindings.isEmpty()) {</b>
<b class="nc">&nbsp;				message.append(&quot;# Results are not in expected order.\n&quot;);</b>
<b class="nc">&nbsp;				message.append(footer).append(&quot;\n&quot;);</b>
<b class="nc">&nbsp;				message.append(&quot;# query result: \n\n&quot;);</b>
<b class="nc">&nbsp;				for (BindingSet bs : queryBindings) {</b>
<b class="nc">&nbsp;					printBindingSet(bs, message);</b>
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;				message.append(footer).append(&quot;\n&quot;);</b>
<b class="nc">&nbsp;				message.append(&quot;# expected result: \n\n&quot;);</b>
<b class="nc">&nbsp;				for (BindingSet bs : expectedBindings) {</b>
<b class="nc">&nbsp;					printBindingSet(bs, message);</b>
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;				message.append(footer).append(&quot;\n&quot;);</b>
<b class="pc">&nbsp;			} else if (missingBindings.isEmpty() &amp;&amp; unexpectedBindings.isEmpty()) {</b>
<b class="nc">&nbsp;				message.append(&quot;# unexpected duplicate in result.\n&quot;);</b>
<b class="nc">&nbsp;				message.append(footer).append(&quot;\n&quot;);</b>
<b class="nc">&nbsp;				message.append(&quot;# query result: \n\n&quot;);</b>
<b class="nc">&nbsp;				for (BindingSet bs : queryBindings) {</b>
<b class="nc">&nbsp;					printBindingSet(bs, message);</b>
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;				message.append(footer).append(&quot;\n&quot;);</b>
<b class="nc">&nbsp;				message.append(&quot;# expected result: \n\n&quot;);</b>
<b class="nc">&nbsp;				for (BindingSet bs : expectedBindings) {</b>
<b class="nc">&nbsp;					printBindingSet(bs, message);</b>
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;				message.append(footer).append(&quot;\n&quot;);</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			fail(message.toString());</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected Repository getDataRepository() {
<b class="fc">&nbsp;		return this.dataRepository;</b>
&nbsp;	}
&nbsp;
&nbsp;	protected static class SPARQLQueryTestManifest {
<b class="fc">&nbsp;		private final List&lt;Object[]&gt; tests = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;		private final List&lt;String&gt; subManifests = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;		public SPARQLQueryTestManifest(String filename, List&lt;String&gt; excludedSubdirs) {
<b class="fc">&nbsp;			this(filename, excludedSubdirs, true);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		public SPARQLQueryTestManifest(String filename, List&lt;String&gt; excludedSubdirs, boolean approvedOnly) {</b>
<b class="fc">&nbsp;			SailRepository sailRepository = new SailRepository(new MemoryStore());</b>
<b class="pc">&nbsp;			try (SailRepositoryConnection connection = sailRepository.getConnection()) {</b>
<b class="fc">&nbsp;				connection.add(new URL(filename), filename, RDFFormat.TURTLE);</b>
<b class="pc">&nbsp;			} catch (IOException e) {</b>
<b class="nc">&nbsp;				throw new RuntimeException(e);</b>
<b class="fc">&nbsp;			}</b>
&nbsp;
<b class="pc">&nbsp;			try (SailRepositoryConnection connection = sailRepository.getConnection()) {</b>
&nbsp;
<b class="fc">&nbsp;				String manifestQuery = &quot; PREFIX qt: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-query#&gt; &quot;</b>
&nbsp;						+ &quot;PREFIX mf: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#&gt; &quot;
&nbsp;						+ &quot;SELECT DISTINCT ?manifestFile &quot;
&nbsp;						+ &quot;WHERE { [] mf:include [ rdf:rest*/rdf:first ?manifestFile ] . }   &quot;;
&nbsp;
<b class="pc">&nbsp;				try (TupleQueryResult manifestResults = connection</b>
<b class="fc">&nbsp;						.prepareTupleQuery(QueryLanguage.SPARQL, manifestQuery, filename)</b>
<b class="fc">&nbsp;						.evaluate()) {</b>
<b class="fc">&nbsp;					for (BindingSet bindingSet : manifestResults) {</b>
<b class="fc">&nbsp;						String subManifestFile = bindingSet.getValue(&quot;manifestFile&quot;).stringValue();</b>
<b class="fc">&nbsp;						if (SPARQLQueryComplianceTest.includeSubManifest(subManifestFile, excludedSubdirs)) {</b>
<b class="fc">&nbsp;							getSubManifests().add(subManifestFile);</b>
&nbsp;						}
<b class="fc">&nbsp;					}</b>
<b class="pc">&nbsp;				}</b>
&nbsp;
<b class="fc">&nbsp;				StringBuilder query = new StringBuilder(512);</b>
<b class="fc">&nbsp;				query.append(&quot; PREFIX mf: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#&gt; \n&quot;);</b>
<b class="fc">&nbsp;				query.append(&quot; PREFIX dawgt: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-dawg#&gt; \n&quot;);</b>
<b class="fc">&nbsp;				query.append(&quot; PREFIX qt: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-query#&gt; \n&quot;);</b>
<b class="fc">&nbsp;				query.append(&quot; PREFIX sd: &lt;http://www.w3.org/ns/sparql-service-description#&gt; \n&quot;);</b>
<b class="fc">&nbsp;				query.append(&quot; PREFIX ent: &lt;http://www.w3.org/ns/entailment/&gt; \n&quot;);</b>
<b class="fc">&nbsp;				query.append(</b>
&nbsp;						&quot; SELECT DISTINCT ?testURI ?testName ?resultFile ?action ?queryFile ?defaultGraph ?ordered ?laxCardinality \n&quot;);
<b class="fc">&nbsp;				query.append(&quot; WHERE { [] rdf:first ?testURI . \n&quot;);</b>
<b class="fc">&nbsp;				if (approvedOnly) {</b>
<b class="fc">&nbsp;					query.append(&quot; ?testURI dawgt:approval dawgt:Approved . \n&quot;);</b>
&nbsp;				}
<b class="fc">&nbsp;				query.append(&quot; ?testURI mf:name ?testName; \n&quot;);</b>
<b class="fc">&nbsp;				query.append(&quot;          mf:result ?resultFile . \n&quot;);</b>
<b class="fc">&nbsp;				query.append(&quot; OPTIONAL { ?testURI mf:checkOrder ?ordered } \n&quot;);</b>
<b class="fc">&nbsp;				query.append(&quot; OPTIONAL { ?testURI  mf:requires ?requirement } \n&quot;);</b>
<b class="fc">&nbsp;				query.append(&quot; ?testURI mf:action ?action. \n&quot;);</b>
<b class="fc">&nbsp;				query.append(&quot; ?action qt:query ?queryFile . \n&quot;);</b>
<b class="fc">&nbsp;				query.append(&quot; OPTIONAL { ?action qt:data ?defaultGraph } \n&quot;);</b>
<b class="fc">&nbsp;				query.append(&quot; OPTIONAL { ?action sd:entailmentRegime ?regime } \n&quot;);</b>
<b class="fc">&nbsp;				query.append(&quot; OPTIONAL { ?testURI mf:resultCardinality ?laxCardinality, mf:LaxCardinality } \n&quot;);</b>
&nbsp;				// skip tests involving CSV result files, these are not query tests
<b class="fc">&nbsp;				query.append(&quot; FILTER(!STRENDS(STR(?resultFile), \&quot;csv\&quot;)) \n&quot;);</b>
&nbsp;				// skip tests involving entailment regimes
<b class="fc">&nbsp;				query.append(&quot; FILTER(!BOUND(?regime)) \n&quot;);</b>
&nbsp;				// skip test involving basic federation, these are tested separately.
<b class="fc">&nbsp;				query.append(&quot; FILTER (!BOUND(?requirement) || (?requirement != mf:BasicFederation)) \n&quot;);</b>
<b class="fc">&nbsp;				query.append(&quot; }\n&quot;);</b>
&nbsp;
<b class="pc">&nbsp;				try (TupleQueryResult result = connection.prepareTupleQuery(query.toString()).evaluate()) {</b>
&nbsp;
<b class="fc">&nbsp;					query.setLength(0);</b>
<b class="fc">&nbsp;					query.append(&quot; PREFIX qt: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-query#&gt; \n&quot;);</b>
<b class="fc">&nbsp;					query.append(&quot; SELECT ?graph \n&quot;);</b>
<b class="fc">&nbsp;					query.append(&quot; WHERE { ?action qt:graphData ?graph } \n&quot;);</b>
<b class="fc">&nbsp;					TupleQuery namedGraphsQuery = connection.prepareTupleQuery(query.toString());</b>
&nbsp;
<b class="fc">&nbsp;					for (BindingSet bs : result) {</b>
&nbsp;						// FIXME I&#39;m sure there&#39;s a neater way to do this
<b class="fc">&nbsp;						String testName = bs.getValue(&quot;testName&quot;).stringValue();</b>
<b class="fc">&nbsp;						String displayName = filename.substring(0, filename.lastIndexOf(&#39;/&#39;));</b>
<b class="fc">&nbsp;						displayName = displayName.substring(displayName.lastIndexOf(&#39;/&#39;) + 1, displayName.length())</b>
&nbsp;								+ &quot;: &quot; + testName;
&nbsp;
<b class="fc">&nbsp;						IRI defaultGraphURI = (IRI) bs.getValue(&quot;defaultGraph&quot;);</b>
<b class="fc">&nbsp;						Value action = bs.getValue(&quot;action&quot;);</b>
<b class="fc">&nbsp;						Value ordered = bs.getValue(&quot;ordered&quot;);</b>
&nbsp;
<b class="fc">&nbsp;						SimpleDataset dataset = null;</b>
&nbsp;
&nbsp;						// Query named graphs
<b class="fc">&nbsp;						namedGraphsQuery.setBinding(&quot;action&quot;, action);</b>
<b class="pc">&nbsp;						try (TupleQueryResult namedGraphs = namedGraphsQuery.evaluate()) {</b>
<b class="fc">&nbsp;							if (defaultGraphURI != null || namedGraphs.hasNext()) {</b>
<b class="fc">&nbsp;								dataset = new SimpleDataset();</b>
<b class="fc">&nbsp;								if (defaultGraphURI != null) {</b>
<b class="fc">&nbsp;									dataset.addDefaultGraph(defaultGraphURI);</b>
&nbsp;								}
<b class="fc">&nbsp;								while (namedGraphs.hasNext()) {</b>
<b class="fc">&nbsp;									BindingSet graphBindings = namedGraphs.next();</b>
<b class="fc">&nbsp;									IRI namedGraphURI = (IRI) graphBindings.getValue(&quot;graph&quot;);</b>
<b class="fc">&nbsp;									dataset.addNamedGraph(namedGraphURI);</b>
<b class="fc">&nbsp;								}</b>
&nbsp;							}
<b class="pc">&nbsp;						}</b>
&nbsp;
<b class="fc">&nbsp;						getTests().add(new Object[] {</b>
&nbsp;								displayName,
<b class="fc">&nbsp;								bs.getValue(&quot;testURI&quot;).stringValue(),</b>
&nbsp;								testName,
<b class="fc">&nbsp;								bs.getValue(&quot;queryFile&quot;).stringValue(),</b>
<b class="fc">&nbsp;								bs.getValue(&quot;resultFile&quot;).stringValue(),</b>
&nbsp;								dataset,
<b class="fc">&nbsp;								Literals.getBooleanValue(ordered, false),</b>
<b class="fc">&nbsp;								bs.hasBinding(&quot;laxCardinality&quot;)</b>
&nbsp;						});
<b class="fc">&nbsp;					}</b>
<b class="pc">&nbsp;				}</b>
&nbsp;
<b class="pc">&nbsp;			}</b>
&nbsp;
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * @return the tests
&nbsp;		 */
&nbsp;		public List&lt;Object[]&gt; getTests() {
<b class="fc">&nbsp;			return tests;</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * @return the subManifests
&nbsp;		 */
&nbsp;		public List&lt;String&gt; getSubManifests() {
<b class="fc">&nbsp;			return subManifests;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:22</div>
</div>
</body>
</html>
