


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > AbstractLiteral</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.model.base</a>
</div>

<h1>Coverage Summary for Class: AbstractLiteral (org.eclipse.rdf4j.model.base)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AbstractLiteral</td>
<td class="coverageStat">
  <span class="percent">
    77.3%
  </span>
  <span class="absValue">
    (17/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (18/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (30/35)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AbstractLiteral$BooleanLiteral</td>
<td class="coverageStat">
  <span class="percent">
    37.5%
  </span>
  <span class="absValue">
    (3/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (4/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    53.8%
  </span>
  <span class="absValue">
    (7/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractLiteral$CalendarLiteral</td>
<td class="coverageStat">
  <span class="percent">
    36.4%
  </span>
  <span class="absValue">
    (4/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    53.1%
  </span>
  <span class="absValue">
    (17/32)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractLiteral$DecimalLiteral</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractLiteral$IntegerLiteral</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractLiteral$NumberLiteral</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (12/21)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    58.3%
  </span>
  <span class="absValue">
    (14/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    69.4%
  </span>
  <span class="absValue">
    (25/36)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractLiteral$TaggedLiteral</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractLiteral$TemporalAccessorLiteral</td>
<td class="coverageStat">
  <span class="percent">
    64.3%
  </span>
  <span class="absValue">
    (9/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    28.6%
  </span>
  <span class="absValue">
    (4/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.9%
  </span>
  <span class="absValue">
    (94/107)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractLiteral$TemporalAmountLiteral</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/94)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/69)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractLiteral$TypedLiteral</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    56.2%
  </span>
  <span class="absValue">
    (9/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.6%
  </span>
  <span class="absValue">
    (25/27)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    56.2%
  </span>
  <span class="absValue">
    (59/105)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    26.6%
  </span>
  <span class="absValue">
    (49/184)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    61.7%
  </span>
  <span class="absValue">
    (205/332)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2020 Eclipse RDF4J contributors.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;
&nbsp;package org.eclipse.rdf4j.model.base;
&nbsp;
&nbsp;import static java.lang.Math.abs;
&nbsp;import static java.time.temporal.ChronoField.DAY_OF_MONTH;
&nbsp;import static java.time.temporal.ChronoField.HOUR_OF_DAY;
&nbsp;import static java.time.temporal.ChronoField.MINUTE_OF_HOUR;
&nbsp;import static java.time.temporal.ChronoField.MONTH_OF_YEAR;
&nbsp;import static java.time.temporal.ChronoField.NANO_OF_SECOND;
&nbsp;import static java.time.temporal.ChronoField.OFFSET_SECONDS;
&nbsp;import static java.time.temporal.ChronoField.SECOND_OF_MINUTE;
&nbsp;import static java.time.temporal.ChronoField.YEAR;
&nbsp;import static java.time.temporal.ChronoUnit.DAYS;
&nbsp;import static java.time.temporal.ChronoUnit.HOURS;
&nbsp;import static java.time.temporal.ChronoUnit.MINUTES;
&nbsp;import static java.time.temporal.ChronoUnit.MONTHS;
&nbsp;import static java.time.temporal.ChronoUnit.NANOS;
&nbsp;import static java.time.temporal.ChronoUnit.SECONDS;
&nbsp;import static java.time.temporal.ChronoUnit.YEARS;
&nbsp;import static java.util.Objects.requireNonNull;
&nbsp;
&nbsp;import java.math.BigDecimal;
&nbsp;import java.math.BigInteger;
&nbsp;import java.time.DateTimeException;
&nbsp;import java.time.format.DateTimeFormatter;
&nbsp;import java.time.format.DateTimeFormatterBuilder;
&nbsp;import java.time.format.DateTimeParseException;
&nbsp;import java.time.format.SignStyle;
&nbsp;import java.time.temporal.ChronoField;
&nbsp;import java.time.temporal.ChronoUnit;
&nbsp;import java.time.temporal.TemporalAccessor;
&nbsp;import java.time.temporal.TemporalAmount;
&nbsp;import java.time.temporal.TemporalUnit;
&nbsp;import java.util.Collection;
&nbsp;import java.util.EnumMap;
&nbsp;import java.util.EnumSet;
&nbsp;import java.util.GregorianCalendar;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Optional;
&nbsp;import java.util.function.Function;
&nbsp;import java.util.function.Predicate;
&nbsp;import java.util.regex.Matcher;
&nbsp;import java.util.regex.Pattern;
&nbsp;import java.util.stream.Stream;
&nbsp;
&nbsp;import javax.xml.datatype.DatatypeConfigurationException;
&nbsp;import javax.xml.datatype.DatatypeConstants;
&nbsp;import javax.xml.datatype.DatatypeFactory;
&nbsp;import javax.xml.datatype.XMLGregorianCalendar;
&nbsp;import javax.xml.namespace.QName;
&nbsp;
&nbsp;import org.eclipse.rdf4j.model.IRI;
&nbsp;import org.eclipse.rdf4j.model.Literal;
&nbsp;
&nbsp;/**
&nbsp; * Base class for {@link Literal}, offering common functionality.
&nbsp; *
&nbsp; * @author Alessandro Bollini
&nbsp; * @since 3.5.0
&nbsp; */
&nbsp;@SuppressWarnings(&quot;UseOfObsoleteDateTimeApi&quot;)
<b class="fc">&nbsp;public abstract class AbstractLiteral implements Literal {</b>
&nbsp;
&nbsp;	private static final long serialVersionUID = -1286527360744086451L;
&nbsp;
&nbsp;	static boolean reserved(IRI datatype) {
<b class="fc">&nbsp;		return CoreDatatype.RDF.LANGSTRING.getIri().equals(datatype);</b>
&nbsp;	}
&nbsp;
&nbsp;	static boolean reserved(CoreDatatype datatype) {
<b class="pc">&nbsp;		return CoreDatatype.RDF.LANGSTRING == datatype;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Converts this literal to a value.
&nbsp;	 *
&nbsp;	 * @param mapper a function mapping from the label of this literal to its value; returns a {@code null} value or
&nbsp;	 *               throws an {@code IllegalArgumentException} if the label of this literal doesn&#39;t represent a value
&nbsp;	 *               of the expected type
&nbsp;	 * @param &lt;V&gt;    the expected value type
&nbsp;	 *
&nbsp;	 * @return the value returned by {@code mapper}
&nbsp;	 *
&nbsp;	 * @throws NullPointerException if {@code mapper} is {@code null}
&nbsp;	 */
&nbsp;	private &lt;V&gt; V value(Function&lt;String, V&gt; mapper) {
<b class="fc">&nbsp;		return Optional</b>
<b class="fc">&nbsp;				.of(getLabel())</b>
<b class="fc">&nbsp;				.map(requireNonNull(mapper, &quot;null mapper&quot;))</b>
<b class="fc">&nbsp;				.orElseThrow(() -&gt; new IllegalArgumentException(&quot;malformed value&quot;));</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public String stringValue() {
<b class="fc">&nbsp;		return getLabel();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public boolean booleanValue() {
<b class="fc">&nbsp;		return value(BooleanLiteral::parseBoolean);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public byte byteValue() {
<b class="nc">&nbsp;		return value(Byte::parseByte);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public short shortValue() {
<b class="nc">&nbsp;		return value(Short::parseShort);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public int intValue() {
<b class="fc">&nbsp;		return value(Integer::parseInt);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public long longValue() {
<b class="nc">&nbsp;		return value(Long::parseLong);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public float floatValue() {
<b class="fc">&nbsp;		return value(NumberLiteral::parseFloat);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public double doubleValue() {
<b class="fc">&nbsp;		return value(NumberLiteral::parseDouble);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public BigInteger integerValue() {
<b class="fc">&nbsp;		return value(BigInteger::new);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public BigDecimal decimalValue() {
<b class="fc">&nbsp;		return value(BigDecimal::new);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public TemporalAccessor temporalAccessorValue() throws DateTimeException {
<b class="nc">&nbsp;		return value(TemporalAccessorLiteral::parseTemporalAccessor);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public TemporalAmount temporalAmountValue() throws DateTimeException {
<b class="nc">&nbsp;		return value(TemporalAmountLiteral::parseTemporalAmount);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public XMLGregorianCalendar calendarValue() {
<b class="fc">&nbsp;		return value(CalendarLiteral::parseCalendar);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public boolean equals(Object o) {
<b class="pc">&nbsp;		return this == o || o instanceof Literal</b>
<b class="fc">&nbsp;				&amp;&amp; getLabel().equals(((Literal) o).getLabel())</b>
<b class="fc">&nbsp;				&amp;&amp; getDatatype().equals(((Literal) o).getDatatype())</b>
<b class="fc">&nbsp;				&amp;&amp; equals(getLanguage(), ((Literal) o).getLanguage());</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public int hashCode() {
<b class="fc">&nbsp;		return getLabel().hashCode();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public String toString() {
&nbsp;
<b class="fc">&nbsp;		final String label = &#39;&quot;&#39; + getLabel() + &#39;&quot;&#39;;</b>
&nbsp;
<b class="fc">&nbsp;		return getLanguage()</b>
&nbsp;
<b class="fc">&nbsp;				.map(language -&gt; label + &#39;@&#39; + language)</b>
&nbsp;
<b class="fc">&nbsp;				.orElseGet(() -&gt; {</b>
&nbsp;
<b class="fc">&nbsp;					final IRI datatype = getDatatype();</b>
&nbsp;
<b class="pc">&nbsp;					return datatype.equals(CoreDatatype.XSD.STRING) ? label</b>
<b class="fc">&nbsp;							: label + &quot;^^&lt;&quot; + datatype.stringValue() + &quot;&gt;&quot;;</b>
&nbsp;
&nbsp;				});
&nbsp;	}
&nbsp;
&nbsp;	private boolean equals(Optional&lt;String&gt; x, Optional&lt;String&gt; y) {
&nbsp;
<b class="fc">&nbsp;		final boolean px = x.isPresent();</b>
<b class="fc">&nbsp;		final boolean py = y.isPresent();</b>
&nbsp;
<b class="pc">&nbsp;		return px &amp;&amp; py &amp;&amp; x.get().equalsIgnoreCase(y.get()) || !px &amp;&amp; !py;</b>
&nbsp;	}
&nbsp;
<b class="fc">&nbsp;	static class TypedLiteral extends AbstractLiteral {</b>
&nbsp;
&nbsp;		private static final long serialVersionUID = -19640527584237291L;
&nbsp;
&nbsp;		private final String label;
&nbsp;		private final CoreDatatype coreDatatype;
&nbsp;		private final IRI datatype;
&nbsp;
<b class="fc">&nbsp;		TypedLiteral(String label) {</b>
<b class="fc">&nbsp;			this.label = label;</b>
<b class="fc">&nbsp;			this.coreDatatype = CoreDatatype.XSD.STRING;</b>
<b class="fc">&nbsp;			this.datatype = CoreDatatype.XSD.STRING.getIri();</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		TypedLiteral(String label, IRI datatype) {</b>
<b class="fc">&nbsp;			this.label = label;</b>
<b class="pc">&nbsp;			if (datatype == null) {</b>
<b class="nc">&nbsp;				this.datatype = CoreDatatype.XSD.STRING.getIri();</b>
<b class="nc">&nbsp;				this.coreDatatype = CoreDatatype.XSD.STRING;</b>
&nbsp;			} else {
<b class="fc">&nbsp;				this.datatype = datatype;</b>
<b class="fc">&nbsp;				this.coreDatatype = CoreDatatype.from(datatype);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		TypedLiteral(String label, CoreDatatype datatype) {</b>
<b class="fc">&nbsp;			this.label = label;</b>
<b class="fc">&nbsp;			this.coreDatatype = Objects.requireNonNull(datatype);</b>
<b class="fc">&nbsp;			this.datatype = datatype.getIri();</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		TypedLiteral(String label, IRI datatype, CoreDatatype coreDatatype) {</b>
<b class="pc">&nbsp;			assert datatype != null;</b>
<b class="pc">&nbsp;			assert coreDatatype != null;</b>
<b class="pc">&nbsp;			assert coreDatatype == CoreDatatype.NONE || datatype == coreDatatype.getIri();</b>
&nbsp;
<b class="fc">&nbsp;			this.label = label;</b>
<b class="fc">&nbsp;			this.datatype = datatype;</b>
<b class="fc">&nbsp;			this.coreDatatype = coreDatatype;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public String getLabel() {
<b class="fc">&nbsp;			return label;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Optional&lt;String&gt; getLanguage() {
<b class="fc">&nbsp;			return Optional.empty();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public IRI getDatatype() {
<b class="fc">&nbsp;			return datatype;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public CoreDatatype getCoreDatatype() {
<b class="fc">&nbsp;			return coreDatatype;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	static class TaggedLiteral extends AbstractLiteral {
&nbsp;
&nbsp;		private static final long serialVersionUID = -19640527584237291L;
&nbsp;
&nbsp;		private final String label;
&nbsp;		private final String language;
&nbsp;
<b class="fc">&nbsp;		TaggedLiteral(String label, String language) {</b>
<b class="fc">&nbsp;			this.label = label;</b>
<b class="fc">&nbsp;			this.language = language;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public String getLabel() {
<b class="fc">&nbsp;			return label;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Optional&lt;String&gt; getLanguage() {
<b class="fc">&nbsp;			return Optional.of(language);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public IRI getDatatype() {
<b class="fc">&nbsp;			return CoreDatatype.RDF.LANGSTRING.getIri();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public CoreDatatype.RDF getCoreDatatype() {
<b class="fc">&nbsp;			return CoreDatatype.RDF.LANGSTRING;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	static class BooleanLiteral extends AbstractLiteral {
&nbsp;
&nbsp;		private static final long serialVersionUID = -1162147873619834622L;
&nbsp;
&nbsp;		static Boolean parseBoolean(String label) {
<b class="fc">&nbsp;			return Optional.of(label)</b>
&nbsp;
<b class="fc">&nbsp;					.map(String::trim)</b>
&nbsp;
<b class="pc">&nbsp;					.map(normalized -&gt; normalized.equals(&quot;true&quot;) || normalized.equals(&quot;1&quot;) ? Boolean.TRUE</b>
<b class="pc">&nbsp;							: normalized.equals(&quot;false&quot;) || normalized.equals(&quot;0&quot;) ? Boolean.FALSE</b>
<b class="nc">&nbsp;									: null</b>
&nbsp;					)
&nbsp;
<b class="fc">&nbsp;					.orElse(null);</b>
&nbsp;		}
&nbsp;
&nbsp;		private final boolean value;
&nbsp;
<b class="fc">&nbsp;		BooleanLiteral(boolean value) {</b>
<b class="fc">&nbsp;			this.value = value;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public String getLabel() {
<b class="nc">&nbsp;			return value ? &quot;true&quot; : &quot;false&quot;;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Optional&lt;String&gt; getLanguage() {
<b class="nc">&nbsp;			return Optional.empty();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public IRI getDatatype() {
<b class="nc">&nbsp;			return CoreDatatype.XSD.BOOLEAN.getIri();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public CoreDatatype.XSD getCoreDatatype() {
<b class="nc">&nbsp;			return CoreDatatype.XSD.BOOLEAN;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public boolean booleanValue() {
<b class="nc">&nbsp;			return value;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	static class NumberLiteral extends AbstractLiteral {
&nbsp;
&nbsp;		private static final long serialVersionUID = -3201912818064851702L;
&nbsp;
&nbsp;		private static final String POSITIVE_INFINITY = &quot;INF&quot;;
&nbsp;		private static final String NEGATIVE_INFINITY = &quot;-INF&quot;;
&nbsp;		private static final String NAN = &quot;NaN&quot;;
&nbsp;
&nbsp;		static float parseFloat(String label) {
<b class="fc">&nbsp;			return label.equals(POSITIVE_INFINITY) ? Float.POSITIVE_INFINITY</b>
<b class="fc">&nbsp;					: label.equals(NEGATIVE_INFINITY) ? Float.NEGATIVE_INFINITY</b>
<b class="pc">&nbsp;							: label.equals(NAN) ? Float.NaN</b>
<b class="fc">&nbsp;									: Float.parseFloat(label);</b>
&nbsp;		}
&nbsp;
&nbsp;		static double parseDouble(String label) {
<b class="pc">&nbsp;			return label.equals(POSITIVE_INFINITY) ? Double.POSITIVE_INFINITY</b>
<b class="pc">&nbsp;					: label.equals(NEGATIVE_INFINITY) ? Double.NEGATIVE_INFINITY</b>
<b class="pc">&nbsp;							: label.equals(NAN) ? Double.NaN</b>
<b class="fc">&nbsp;									: Double.parseDouble(label);</b>
&nbsp;		}
&nbsp;
&nbsp;		private static String toString(float value) {
<b class="fc">&nbsp;			return value == Float.POSITIVE_INFINITY ? POSITIVE_INFINITY</b>
<b class="pc">&nbsp;					: value == Float.NEGATIVE_INFINITY ? NEGATIVE_INFINITY</b>
<b class="nc">&nbsp;							: Float.isNaN(value) ? NAN</b>
<b class="nc">&nbsp;									: Float.toString(value);</b>
&nbsp;		}
&nbsp;
&nbsp;		private static String toString(double value) {
<b class="pc">&nbsp;			return value == Double.POSITIVE_INFINITY ? POSITIVE_INFINITY</b>
<b class="pc">&nbsp;					: value == Double.NEGATIVE_INFINITY ? NEGATIVE_INFINITY</b>
<b class="pc">&nbsp;							: Double.isNaN(value) ? NAN</b>
<b class="fc">&nbsp;									: Double.toString(value);</b>
&nbsp;		}
&nbsp;
&nbsp;		protected Number value;
&nbsp;
&nbsp;		private final String label;
&nbsp;		private final CoreDatatype.XSD datatype;
&nbsp;
&nbsp;		NumberLiteral(byte value) {
<b class="nc">&nbsp;			this(value, Byte.toString(value), CoreDatatype.XSD.BYTE);</b>
&nbsp;		}
&nbsp;
&nbsp;		NumberLiteral(short value) {
<b class="nc">&nbsp;			this(value, Short.toString(value), CoreDatatype.XSD.SHORT);</b>
&nbsp;		}
&nbsp;
&nbsp;		NumberLiteral(int value) {
<b class="nc">&nbsp;			this(value, Integer.toString(value), CoreDatatype.XSD.INT);</b>
&nbsp;		}
&nbsp;
&nbsp;		NumberLiteral(long value) {
<b class="nc">&nbsp;			this(value, Long.toString(value), CoreDatatype.XSD.LONG);</b>
&nbsp;		}
&nbsp;
&nbsp;		NumberLiteral(float value) {
<b class="fc">&nbsp;			this(value, toString(value), CoreDatatype.XSD.FLOAT);</b>
&nbsp;		}
&nbsp;
&nbsp;		NumberLiteral(double value) {
<b class="fc">&nbsp;			this(value, toString(value), CoreDatatype.XSD.DOUBLE);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		NumberLiteral(Number value, String label, CoreDatatype.XSD datatype) {</b>
<b class="fc">&nbsp;			this.value = value;</b>
<b class="fc">&nbsp;			this.label = label;</b>
<b class="fc">&nbsp;			this.datatype = datatype;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public String getLabel() {
<b class="fc">&nbsp;			return label;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Optional&lt;String&gt; getLanguage() {
<b class="fc">&nbsp;			return Optional.empty();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public IRI getDatatype() {
<b class="fc">&nbsp;			return datatype.getIri();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public byte byteValue() {
<b class="nc">&nbsp;			return value.byteValue();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public short shortValue() {
<b class="nc">&nbsp;			return value.shortValue();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public int intValue() {
<b class="nc">&nbsp;			return value.intValue();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public long longValue() {
<b class="nc">&nbsp;			return value.longValue();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public float floatValue() {
<b class="nc">&nbsp;			return value.floatValue();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public double doubleValue() {
<b class="fc">&nbsp;			return value.doubleValue();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public CoreDatatype getCoreDatatype() {
<b class="fc">&nbsp;			return datatype;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	static class IntegerLiteral extends NumberLiteral {
&nbsp;
&nbsp;		private static final long serialVersionUID = -4274941248972496665L;
&nbsp;
&nbsp;		IntegerLiteral(BigInteger value) {
<b class="nc">&nbsp;			super(value, value.toString(), CoreDatatype.XSD.INTEGER);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public BigInteger integerValue() {
<b class="nc">&nbsp;			return (BigInteger) value;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public BigDecimal decimalValue() {
<b class="nc">&nbsp;			return new BigDecimal((BigInteger) value);</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	static class DecimalLiteral extends NumberLiteral {
&nbsp;
&nbsp;		private static final long serialVersionUID = -4382147098035463886L;
&nbsp;
&nbsp;		DecimalLiteral(BigDecimal value) {
<b class="nc">&nbsp;			super(value, value.toPlainString(), CoreDatatype.XSD.DECIMAL);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public BigInteger integerValue() {
<b class="nc">&nbsp;			return ((BigDecimal) value).toBigInteger();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public BigDecimal decimalValue() {
<b class="nc">&nbsp;			return (BigDecimal) value;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	static class TemporalAccessorLiteral extends AbstractLiteral {
&nbsp;
&nbsp;		private static final long serialVersionUID = -6089251668767105663L;
&nbsp;
<b class="fc">&nbsp;		private static final ChronoField[] FIELDS = {</b>
&nbsp;				YEAR, MONTH_OF_YEAR, DAY_OF_MONTH,
&nbsp;				HOUR_OF_DAY, MINUTE_OF_HOUR, SECOND_OF_MINUTE, NANO_OF_SECOND,
&nbsp;				OFFSET_SECONDS
&nbsp;		};
&nbsp;
<b class="fc">&nbsp;		private static final DateTimeFormatter LOCAL_TIME_FORMATTER = new DateTimeFormatterBuilder()</b>
&nbsp;
<b class="fc">&nbsp;				.appendValue(HOUR_OF_DAY, 2)</b>
<b class="fc">&nbsp;				.appendLiteral(&#39;:&#39;)</b>
<b class="fc">&nbsp;				.appendValue(MINUTE_OF_HOUR, 2)</b>
<b class="fc">&nbsp;				.appendLiteral(&#39;:&#39;)</b>
<b class="fc">&nbsp;				.appendValue(SECOND_OF_MINUTE, 2)</b>
&nbsp;
<b class="fc">&nbsp;				.optionalStart()</b>
<b class="fc">&nbsp;				.appendFraction(NANO_OF_SECOND, 1, 9, true)</b>
&nbsp;
<b class="fc">&nbsp;				.toFormatter();</b>
&nbsp;
<b class="fc">&nbsp;		private static final DateTimeFormatter OFFSET_TIME_FORMATTER = new DateTimeFormatterBuilder()</b>
&nbsp;
<b class="fc">&nbsp;				.append(LOCAL_TIME_FORMATTER)</b>
&nbsp;
<b class="fc">&nbsp;				.optionalStart()</b>
<b class="fc">&nbsp;				.appendOffsetId()</b>
&nbsp;
<b class="fc">&nbsp;				.toFormatter();</b>
&nbsp;
<b class="fc">&nbsp;		private static final DateTimeFormatter LOCAL_DATE_FORMATTER = new DateTimeFormatterBuilder()</b>
&nbsp;
<b class="fc">&nbsp;				.appendValue(YEAR, 4, 10, SignStyle.EXCEEDS_PAD)</b>
&nbsp;
<b class="fc">&nbsp;				.optionalStart()</b>
<b class="fc">&nbsp;				.appendLiteral(&#39;-&#39;)</b>
<b class="fc">&nbsp;				.appendValue(MONTH_OF_YEAR, 2)</b>
&nbsp;
<b class="fc">&nbsp;				.optionalStart()</b>
<b class="fc">&nbsp;				.appendLiteral(&#39;-&#39;)</b>
<b class="fc">&nbsp;				.appendValue(DAY_OF_MONTH, 2)</b>
&nbsp;
<b class="fc">&nbsp;				.toFormatter();</b>
&nbsp;
<b class="fc">&nbsp;		private static final DateTimeFormatter OFFSET_DATE_FORMATTER = new DateTimeFormatterBuilder()</b>
&nbsp;
<b class="fc">&nbsp;				.append(LOCAL_DATE_FORMATTER)</b>
&nbsp;
<b class="fc">&nbsp;				.optionalStart()</b>
<b class="fc">&nbsp;				.appendOffsetId()</b>
&nbsp;
<b class="fc">&nbsp;				.toFormatter();</b>
&nbsp;
<b class="fc">&nbsp;		private static final DateTimeFormatter DATETIME_FORMATTER = new DateTimeFormatterBuilder()</b>
&nbsp;
<b class="fc">&nbsp;				.append(LOCAL_DATE_FORMATTER)</b>
&nbsp;
<b class="fc">&nbsp;				.optionalStart()</b>
<b class="fc">&nbsp;				.appendLiteral(&#39;T&#39;)</b>
<b class="fc">&nbsp;				.append(LOCAL_TIME_FORMATTER)</b>
<b class="fc">&nbsp;				.optionalEnd()</b>
&nbsp;
<b class="fc">&nbsp;				.optionalStart()</b>
<b class="fc">&nbsp;				.appendOffsetId()</b>
&nbsp;
<b class="fc">&nbsp;				.toFormatter();</b>
&nbsp;
<b class="fc">&nbsp;		private static final DateTimeFormatter DASH_FORMATTER = new DateTimeFormatterBuilder()</b>
&nbsp;
<b class="fc">&nbsp;				.appendLiteral(&quot;--&quot;)</b>
&nbsp;
<b class="fc">&nbsp;				.optionalStart()</b>
<b class="fc">&nbsp;				.appendValue(MONTH_OF_YEAR, 2)</b>
<b class="fc">&nbsp;				.optionalEnd()</b>
&nbsp;
<b class="fc">&nbsp;				.optionalStart()</b>
<b class="fc">&nbsp;				.appendLiteral(&#39;-&#39;)</b>
<b class="fc">&nbsp;				.appendValue(DAY_OF_MONTH, 2)</b>
&nbsp;
<b class="fc">&nbsp;				.toFormatter();</b>
&nbsp;
<b class="fc">&nbsp;		private static final Map&lt;Integer, CoreDatatype.XSD&gt; DATATYPES = datatypes();</b>
<b class="fc">&nbsp;		private static final Map&lt;CoreDatatype.XSD, DateTimeFormatter&gt; FORMATTERS = formatters();</b>
&nbsp;
&nbsp;		static TemporalAccessor parseTemporalAccessor(String label) throws DateTimeException {
&nbsp;
<b class="nc">&nbsp;			TemporalAccessor value = formatter(label).parse(label);</b>
&nbsp;
<b class="nc">&nbsp;			if (!DATATYPES.containsKey(key(value))) {</b>
<b class="nc">&nbsp;				throw new DateTimeException(String.format(</b>
&nbsp;						&quot;label &lt;%s&gt; is not a valid lexical representation of an XML Schema date/time datatype&quot;, label
&nbsp;				));
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			return value;</b>
&nbsp;		}
&nbsp;
&nbsp;		private static Map&lt;Integer, CoreDatatype.XSD&gt; datatypes() {
&nbsp;
<b class="fc">&nbsp;			int date = key(YEAR, MONTH_OF_YEAR, DAY_OF_MONTH);</b>
<b class="fc">&nbsp;			int time = key(HOUR_OF_DAY, MINUTE_OF_HOUR, SECOND_OF_MINUTE);</b>
<b class="fc">&nbsp;			int nano = key(NANO_OF_SECOND);</b>
<b class="fc">&nbsp;			int zone = key(OFFSET_SECONDS);</b>
&nbsp;
<b class="fc">&nbsp;			Map&lt;Integer, CoreDatatype.XSD&gt; datatypes = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;			datatypes.put(date + time, CoreDatatype.XSD.DATETIME);</b>
<b class="fc">&nbsp;			datatypes.put(date + time + nano, CoreDatatype.XSD.DATETIME);</b>
<b class="fc">&nbsp;			datatypes.put((date + time + zone), CoreDatatype.XSD.DATETIME);</b>
<b class="fc">&nbsp;			datatypes.put((date + time + nano + zone), CoreDatatype.XSD.DATETIME);</b>
&nbsp;
<b class="fc">&nbsp;			datatypes.put(time, CoreDatatype.XSD.TIME);</b>
<b class="fc">&nbsp;			datatypes.put(time + nano, CoreDatatype.XSD.TIME);</b>
<b class="fc">&nbsp;			datatypes.put(time + zone, CoreDatatype.XSD.TIME);</b>
<b class="fc">&nbsp;			datatypes.put(time + nano + zone, CoreDatatype.XSD.TIME);</b>
&nbsp;
<b class="fc">&nbsp;			datatypes.put(date, CoreDatatype.XSD.DATE);</b>
<b class="fc">&nbsp;			datatypes.put(date + zone, CoreDatatype.XSD.DATE);</b>
&nbsp;
<b class="fc">&nbsp;			datatypes.put(key(YEAR, MONTH_OF_YEAR), CoreDatatype.XSD.GYEARMONTH);</b>
<b class="fc">&nbsp;			datatypes.put(key(YEAR), CoreDatatype.XSD.GYEAR);</b>
<b class="fc">&nbsp;			datatypes.put(key(MONTH_OF_YEAR, DAY_OF_MONTH), CoreDatatype.XSD.GMONTHDAY);</b>
<b class="fc">&nbsp;			datatypes.put(key(DAY_OF_MONTH), CoreDatatype.XSD.GDAY);</b>
<b class="fc">&nbsp;			datatypes.put(key(MONTH_OF_YEAR), CoreDatatype.XSD.GMONTH);</b>
&nbsp;
<b class="fc">&nbsp;			return datatypes;</b>
&nbsp;		}
&nbsp;
&nbsp;		private static Map&lt;CoreDatatype.XSD, DateTimeFormatter&gt; formatters() {
&nbsp;
<b class="fc">&nbsp;			final Map&lt;CoreDatatype.XSD, DateTimeFormatter&gt; formatters = new EnumMap&lt;&gt;(CoreDatatype.XSD.class);</b>
&nbsp;
<b class="fc">&nbsp;			formatters.put(CoreDatatype.XSD.DATETIME, DATETIME_FORMATTER);</b>
<b class="fc">&nbsp;			formatters.put(CoreDatatype.XSD.TIME, OFFSET_TIME_FORMATTER);</b>
<b class="fc">&nbsp;			formatters.put(CoreDatatype.XSD.DATE, OFFSET_DATE_FORMATTER);</b>
&nbsp;
<b class="fc">&nbsp;			formatters.put(CoreDatatype.XSD.GYEARMONTH, LOCAL_DATE_FORMATTER);</b>
<b class="fc">&nbsp;			formatters.put(CoreDatatype.XSD.GYEAR, LOCAL_DATE_FORMATTER);</b>
<b class="fc">&nbsp;			formatters.put(CoreDatatype.XSD.GMONTHDAY, DASH_FORMATTER);</b>
<b class="fc">&nbsp;			formatters.put(CoreDatatype.XSD.GDAY, DASH_FORMATTER);</b>
<b class="fc">&nbsp;			formatters.put(CoreDatatype.XSD.GMONTH, DASH_FORMATTER);</b>
&nbsp;
<b class="fc">&nbsp;			return formatters;</b>
&nbsp;		}
&nbsp;
&nbsp;		private static DateTimeFormatter formatter(String label) {
<b class="nc">&nbsp;			if (label.startsWith(&quot;--&quot;)) {</b>
&nbsp;
<b class="nc">&nbsp;				return DASH_FORMATTER;</b>
&nbsp;
<b class="nc">&nbsp;			} else if (label.length() &gt;= 8 &amp;&amp; label.charAt(2) == &#39;:&#39;) {</b>
&nbsp;
<b class="nc">&nbsp;				return OFFSET_TIME_FORMATTER;</b>
&nbsp;
&nbsp;			} else {
&nbsp;
<b class="nc">&nbsp;				return DATETIME_FORMATTER;</b>
&nbsp;
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		private static int key(TemporalAccessor value) {
<b class="fc">&nbsp;			return key(value::isSupported, FIELDS);</b>
&nbsp;		}
&nbsp;
&nbsp;		private static int key(ChronoField... fields) {
<b class="fc">&nbsp;			return key(field -&gt; true, fields);</b>
&nbsp;		}
&nbsp;
&nbsp;		private static int key(Predicate&lt;ChronoField&gt; include, ChronoField... fields) {
&nbsp;
<b class="fc">&nbsp;			int index = 0;</b>
&nbsp;
<b class="fc">&nbsp;			for (ChronoField field : fields) {</b>
<b class="pc">&nbsp;				if (include.test(field)) {</b>
<b class="fc">&nbsp;					index += 1 &lt;&lt; field.ordinal() + 1;</b>
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			return index;</b>
&nbsp;		}
&nbsp;
&nbsp;		private final TemporalAccessor value;
&nbsp;
&nbsp;		private final String label;
&nbsp;		private final CoreDatatype.XSD datatype;
&nbsp;
<b class="fc">&nbsp;		TemporalAccessorLiteral(TemporalAccessor value) {</b>
&nbsp;
<b class="fc">&nbsp;			this.value = value;</b>
&nbsp;
<b class="fc">&nbsp;			datatype = DATATYPES.get(key(value));</b>
&nbsp;
<b class="pc">&nbsp;			if (datatype == null) {</b>
<b class="nc">&nbsp;				throw new IllegalArgumentException(String.format(</b>
&nbsp;						&quot;value &lt;%s&gt; cannot be represented by an XML Schema date/time datatype&quot;, value
&nbsp;				));
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			this.label = FORMATTERS.get(datatype).format(value);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public String getLabel() {
<b class="fc">&nbsp;			return label;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Optional&lt;String&gt; getLanguage() {
<b class="nc">&nbsp;			return Optional.empty();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public IRI getDatatype() {
<b class="nc">&nbsp;			return datatype.getIri();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public TemporalAccessor temporalAccessorValue() {
<b class="nc">&nbsp;			return value;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public CoreDatatype getCoreDatatype() {
<b class="fc">&nbsp;			return datatype;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	static class TemporalAmountLiteral extends AbstractLiteral {
&nbsp;
&nbsp;		private static final long serialVersionUID = -447302801371093467L;
&nbsp;
<b class="nc">&nbsp;		private static final Collection&lt;ChronoUnit&gt; UNITS = EnumSet.of(</b>
&nbsp;				YEARS, MONTHS, DAYS, HOURS, MINUTES, SECONDS, NANOS
&nbsp;		);
&nbsp;
<b class="nc">&nbsp;		private static final Pattern PATTERN = Pattern.compile(&quot;(?&lt;sign&gt;-)?&quot; +</b>
&nbsp;				&quot;P&quot; +
&nbsp;				&quot;(?:(?&lt;&quot; + YEARS + &quot;&gt;\\d+)Y)?&quot; +
&nbsp;				&quot;(?:(?&lt;&quot; + MONTHS + &quot;&gt;\\d+)M)?&quot; +
&nbsp;				&quot;(?:(?&lt;&quot; + DAYS + &quot;&gt;\\d+)D)?&quot; +
&nbsp;				&quot;(?&lt;time&gt;T)?&quot; +
&nbsp;				&quot;(?:(?&lt;&quot; + HOURS + &quot;&gt;\\d+)H)?&quot; +
&nbsp;				&quot;(?:(?&lt;&quot; + MINUTES + &quot;&gt;\\d+)M)?&quot; +
&nbsp;				&quot;(?:(?&lt;&quot; + SECONDS + &quot;&gt;\\d+)(?:\\.(?&lt;&quot; + NANOS + &quot;&gt;\\d+))?S)?&quot;
&nbsp;		);
&nbsp;
&nbsp;		private final TemporalAmount value;
&nbsp;
&nbsp;		private final String label;
&nbsp;
<b class="nc">&nbsp;		TemporalAmountLiteral(TemporalAmount value) {</b>
&nbsp;
<b class="nc">&nbsp;			final List&lt;TemporalUnit&gt; units = value.getUnits();</b>
&nbsp;
<b class="nc">&nbsp;			if (units.isEmpty() || !UNITS.containsAll(units)) {</b>
<b class="nc">&nbsp;				throw new IllegalArgumentException(String.format(</b>
&nbsp;						&quot;value &lt;%s&gt; cannot be represented by an XML Schema duration datatype&quot;, value
&nbsp;				));
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			this.value = value;</b>
<b class="nc">&nbsp;			this.label = toString(value);</b>
&nbsp;		}
&nbsp;
&nbsp;		static TemporalAmount parseTemporalAmount(CharSequence label) {
&nbsp;
<b class="nc">&nbsp;			final Matcher matcher = PATTERN.matcher(label);</b>
&nbsp;
<b class="nc">&nbsp;			if (!matcher.matches()) {</b>
<b class="nc">&nbsp;				throw new DateTimeException(String.format(</b>
&nbsp;						&quot;label &lt;%s&gt; is not a valid lexical representation of an XML Schema duration datatype&quot;, label
&nbsp;				));
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			final boolean sign = matcher.group(&quot;sign&quot;) != null;</b>
<b class="nc">&nbsp;			final boolean time = matcher.group(&quot;time&quot;) != null;</b>
&nbsp;
<b class="nc">&nbsp;			final Map&lt;ChronoUnit, Long&gt; components = new EnumMap&lt;&gt;(ChronoUnit.class);</b>
&nbsp;
<b class="nc">&nbsp;			for (final ChronoUnit unit : UNITS) {</b>
&nbsp;
<b class="nc">&nbsp;				final String group = matcher.group(unit.toString());</b>
&nbsp;
<b class="nc">&nbsp;				if (group != null) {</b>
&nbsp;					try {
&nbsp;
<b class="nc">&nbsp;						final long value = Long.parseUnsignedLong(unit == NANOS</b>
<b class="nc">&nbsp;								? (group + &quot;000000000&quot;).substring(0, 9)</b>
<b class="nc">&nbsp;								: group</b>
&nbsp;						);
&nbsp;
<b class="nc">&nbsp;						components.put(unit, sign ? -value : value);</b>
&nbsp;
<b class="nc">&nbsp;					} catch (final NumberFormatException e) {</b>
&nbsp;
<b class="nc">&nbsp;						throw new DateTimeParseException(e.getMessage(), group, matcher.start(unit.toString()));</b>
&nbsp;
<b class="nc">&nbsp;					}</b>
&nbsp;				}
&nbsp;
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			if (components.isEmpty() || time &amp;&amp; Stream.of(HOURS, MINUTES, SECONDS).noneMatch(components::containsKey)) {</b>
<b class="nc">&nbsp;				throw new DateTimeException(String.format(</b>
&nbsp;						&quot;label &lt;%s&gt; is not a valid lexical representation of an XML Schema duration datatype&quot;, label
&nbsp;				));
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			return new ComponentTemporalAmount(components);</b>
&nbsp;
&nbsp;		}
&nbsp;
&nbsp;		private static String toString(TemporalAmount value) {
&nbsp;
<b class="nc">&nbsp;			final Collection&lt;TemporalUnit&gt; units = value.getUnits();</b>
&nbsp;
<b class="nc">&nbsp;			final long years = units.contains(YEARS) ? value.get(YEARS) : 0L;</b>
<b class="nc">&nbsp;			final long months = units.contains(MONTHS) ? value.get(MONTHS) : 0L;</b>
<b class="nc">&nbsp;			final long days = units.contains(DAYS) ? value.get(DAYS) : 0L;</b>
&nbsp;
<b class="nc">&nbsp;			final long hours = units.contains(HOURS) ? value.get(HOURS) : 0L;</b>
<b class="nc">&nbsp;			final long minutes = units.contains(MINUTES) ? value.get(MINUTES) : 0L;</b>
<b class="nc">&nbsp;			final long seconds = units.contains(SECONDS) ? value.get(SECONDS) : 0L;</b>
<b class="nc">&nbsp;			final long nanos = units.contains(NANOS) ? value.get(NANOS) : 0L;</b>
&nbsp;
<b class="nc">&nbsp;			final boolean positive = years &gt; 0 || months &gt; 0 || days &gt; 0</b>
&nbsp;					|| hours &gt; 0 || minutes &gt; 0 || seconds &gt; 0 || nanos &gt; 0;
&nbsp;
<b class="nc">&nbsp;			final boolean negative = years &lt; 0 || months &lt; 0 || days &lt; 0</b>
&nbsp;					|| hours &lt; 0 || minutes &lt; 0 || seconds &lt; 0 || nanos &lt; 0;
&nbsp;
<b class="nc">&nbsp;			if (positive &amp;&amp; negative) {</b>
<b class="nc">&nbsp;				throw new IllegalArgumentException(String.format(</b>
&nbsp;						&quot;value &lt;%s&gt; cannot be represented by an XML Schema duration datatype&quot;, value
&nbsp;				));
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			final StringBuilder builder = new StringBuilder(3 * value.getUnits().size());</b>
&nbsp;
<b class="nc">&nbsp;			if (negative) {</b>
<b class="nc">&nbsp;				builder.append(&#39;-&#39;);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			builder.append(&quot;P&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			if (years != 0L) {</b>
<b class="nc">&nbsp;				builder.append(abs(years)).append(&quot;Y&quot;);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (months != 0L) {</b>
<b class="nc">&nbsp;				builder.append(abs(months)).append(&quot;M&quot;);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (days != 0L) {</b>
<b class="nc">&nbsp;				builder.append(abs(days)).append(&quot;D&quot;);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (hours != 0L || minutes != 0L || seconds != 0L || nanos != 0L) {</b>
<b class="nc">&nbsp;				builder.append(&quot;T&quot;);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (hours != 0L) {</b>
<b class="nc">&nbsp;				builder.append(abs(hours)).append(&quot;H&quot;);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (minutes != 0L) {</b>
<b class="nc">&nbsp;				builder.append(abs(minutes)).append(&quot;M&quot;);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (nanos != 0L) {</b>
&nbsp;
<b class="nc">&nbsp;				builder.append(abs(seconds) + abs(nanos) / 1_000_000_000L)</b>
<b class="nc">&nbsp;						.append(&#39;.&#39;)</b>
<b class="nc">&nbsp;						.append(String.format(&quot;%09d&quot;, abs(nanos) % 1_000_000_000L))</b>
<b class="nc">&nbsp;						.append(&quot;S&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			} else if (seconds != 0L) {</b>
&nbsp;
<b class="nc">&nbsp;				builder.append(abs(seconds)).append(&quot;S&quot;);</b>
&nbsp;
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			return builder.toString();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public String getLabel() {
<b class="nc">&nbsp;			return label;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Optional&lt;String&gt; getLanguage() {
<b class="nc">&nbsp;			return Optional.empty();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public IRI getDatatype() {
<b class="nc">&nbsp;			return CoreDatatype.XSD.DURATION.getIri();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public TemporalAmount temporalAmountValue() throws DateTimeException {
<b class="nc">&nbsp;			return value;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public CoreDatatype.XSD getCoreDatatype() {
<b class="nc">&nbsp;			return CoreDatatype.XSD.DURATION;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	static class CalendarLiteral extends AbstractLiteral {
&nbsp;
&nbsp;		private static final long serialVersionUID = 9131700079460615839L;
&nbsp;
<b class="fc">&nbsp;		private static final ThreadLocal&lt;DatatypeFactory&gt; DATATYPE_FACTORY = ThreadLocal.withInitial(() -&gt; {</b>
&nbsp;			try {
&nbsp;
<b class="fc">&nbsp;				return DatatypeFactory.newInstance(); // not guaranteed to be thread-safe</b>
&nbsp;
<b class="nc">&nbsp;			} catch (DatatypeConfigurationException e) {</b>
&nbsp;
<b class="nc">&nbsp;				throw new RuntimeException(&quot;unable to create datatype factory&quot;, e);</b>
&nbsp;
&nbsp;			}
&nbsp;		});
&nbsp;
<b class="fc">&nbsp;		private static final Map&lt;QName, CoreDatatype.XSD&gt; DATATYPES = datatypes();</b>
&nbsp;
&nbsp;		private static Map&lt;QName, CoreDatatype.XSD&gt; datatypes() {
&nbsp;
<b class="fc">&nbsp;			final Map&lt;QName, CoreDatatype.XSD&gt; datatypes = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;			datatypes.put(DatatypeConstants.DATETIME, CoreDatatype.XSD.DATETIME);</b>
<b class="fc">&nbsp;			datatypes.put(DatatypeConstants.TIME, CoreDatatype.XSD.TIME);</b>
<b class="fc">&nbsp;			datatypes.put(DatatypeConstants.DATE, CoreDatatype.XSD.DATE);</b>
&nbsp;
<b class="fc">&nbsp;			datatypes.put(DatatypeConstants.GYEARMONTH, CoreDatatype.XSD.GYEARMONTH);</b>
<b class="fc">&nbsp;			datatypes.put(DatatypeConstants.GYEAR, CoreDatatype.XSD.GYEAR);</b>
<b class="fc">&nbsp;			datatypes.put(DatatypeConstants.GMONTHDAY, CoreDatatype.XSD.GMONTHDAY);</b>
<b class="fc">&nbsp;			datatypes.put(DatatypeConstants.GDAY, CoreDatatype.XSD.GDAY);</b>
<b class="fc">&nbsp;			datatypes.put(DatatypeConstants.GMONTH, CoreDatatype.XSD.GMONTH);</b>
&nbsp;
<b class="fc">&nbsp;			datatypes.put(DatatypeConstants.DURATION, CoreDatatype.XSD.DURATION);</b>
<b class="fc">&nbsp;			datatypes.put(DatatypeConstants.DURATION_DAYTIME, CoreDatatype.XSD.DAYTIMEDURATION);</b>
<b class="fc">&nbsp;			datatypes.put(DatatypeConstants.DURATION_YEARMONTH, CoreDatatype.XSD.YEARMONTHDURATION);</b>
&nbsp;
<b class="fc">&nbsp;			return datatypes;</b>
&nbsp;		}
&nbsp;
&nbsp;		private static XMLGregorianCalendar parseCalendar(String label) {
<b class="fc">&nbsp;			return DATATYPE_FACTORY.get().newXMLGregorianCalendar(label);</b>
&nbsp;		}
&nbsp;
&nbsp;		private final XMLGregorianCalendar value;
&nbsp;
&nbsp;		private final String label;
&nbsp;		private final CoreDatatype.XSD datatype;
&nbsp;
&nbsp;		CalendarLiteral(GregorianCalendar calendar) {
<b class="nc">&nbsp;			this(DATATYPE_FACTORY.get().newXMLGregorianCalendar(calendar));</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		CalendarLiteral(XMLGregorianCalendar calendar) {</b>
&nbsp;
<b class="nc">&nbsp;			this.value = calendar;</b>
&nbsp;
<b class="nc">&nbsp;			this.label = calendar.toXMLFormat();</b>
<b class="nc">&nbsp;			QName qname = calendar.getXMLSchemaType();</b>
&nbsp;
<b class="nc">&nbsp;			datatype = DATATYPES.get(qname);</b>
&nbsp;
<b class="nc">&nbsp;			if (datatype == null) {</b>
<b class="nc">&nbsp;				throw new IllegalArgumentException(String.format(</b>
&nbsp;						&quot;QName &lt;%s&gt; cannot be mapped to an XML Schema date/time datatype&quot;, qname
&nbsp;				));
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public String getLabel() {
<b class="nc">&nbsp;			return label;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Optional&lt;String&gt; getLanguage() {
<b class="nc">&nbsp;			return Optional.empty();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public IRI getDatatype() {
<b class="nc">&nbsp;			return datatype.getIri();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public XMLGregorianCalendar calendarValue() {
<b class="nc">&nbsp;			return value;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public CoreDatatype getCoreDatatype() {
<b class="nc">&nbsp;			return datatype;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:22</div>
</div>
</body>
</html>
