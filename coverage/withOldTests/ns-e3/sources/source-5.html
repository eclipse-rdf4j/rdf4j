


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > SolrIndex</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.sail.solr</a>
</div>

<h1>Coverage Summary for Class: SolrIndex (org.eclipse.rdf4j.sail.solr)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SolrIndex</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/36)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/58)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/183)
  </span>
</td>
</tr>
  <tr>
    <td class="name">SolrIndex$WktPoint</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SolrIndex$WktShape</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/50)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/58)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/199)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;package org.eclipse.rdf4j.sail.solr;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.text.ParseException;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Properties;
&nbsp;import java.util.Set;
&nbsp;
&nbsp;import org.apache.solr.client.solrj.SolrClient;
&nbsp;import org.apache.solr.client.solrj.SolrQuery;
&nbsp;import org.apache.solr.client.solrj.SolrServerException;
&nbsp;import org.apache.solr.client.solrj.response.QueryResponse;
&nbsp;import org.apache.solr.common.SolrDocument;
&nbsp;import org.apache.solr.common.SolrDocumentList;
&nbsp;import org.apache.solr.common.params.CommonParams;
&nbsp;import org.apache.solr.common.params.SpatialParams;
&nbsp;import org.eclipse.rdf4j.model.IRI;
&nbsp;import org.eclipse.rdf4j.model.Resource;
&nbsp;import org.eclipse.rdf4j.model.vocabulary.GEOF;
&nbsp;import org.eclipse.rdf4j.query.MalformedQueryException;
&nbsp;import org.eclipse.rdf4j.query.algebra.Var;
&nbsp;import org.eclipse.rdf4j.sail.SailException;
&nbsp;import org.eclipse.rdf4j.sail.lucene.AbstractSearchIndex;
&nbsp;import org.eclipse.rdf4j.sail.lucene.BulkUpdater;
&nbsp;import org.eclipse.rdf4j.sail.lucene.DocumentDistance;
&nbsp;import org.eclipse.rdf4j.sail.lucene.DocumentResult;
&nbsp;import org.eclipse.rdf4j.sail.lucene.DocumentScore;
&nbsp;import org.eclipse.rdf4j.sail.lucene.LuceneSail;
&nbsp;import org.eclipse.rdf4j.sail.lucene.SearchDocument;
&nbsp;import org.eclipse.rdf4j.sail.lucene.SearchFields;
&nbsp;import org.eclipse.rdf4j.sail.lucene.util.GeoUnits;
&nbsp;import org.locationtech.spatial4j.context.SpatialContext;
&nbsp;import org.locationtech.spatial4j.context.SpatialContextFactory;
&nbsp;import org.locationtech.spatial4j.shape.Point;
&nbsp;import org.locationtech.spatial4j.shape.Rectangle;
&nbsp;import org.locationtech.spatial4j.shape.Shape;
&nbsp;import org.locationtech.spatial4j.shape.SpatialRelation;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;
&nbsp;import com.google.common.base.Function;
&nbsp;import com.google.common.base.Functions;
&nbsp;import com.google.common.collect.Iterables;
&nbsp;
&nbsp;/**
&nbsp; * @see LuceneSail
&nbsp; */
<b class="nc">&nbsp;public class SolrIndex extends AbstractSearchIndex {</b>
&nbsp;
&nbsp;	public static final String SERVER_KEY = &quot;server&quot;;
&nbsp;
&nbsp;	public static final String DISTANCE_FIELD = &quot;_dist&quot;;
&nbsp;
<b class="nc">&nbsp;	private final Logger logger = LoggerFactory.getLogger(getClass());</b>
&nbsp;
&nbsp;	private SolrClient client;
&nbsp;
&nbsp;	private Function&lt;? super String, ? extends SpatialContext&gt; geoContextMapper;
&nbsp;
&nbsp;	@Override
&nbsp;	public void initialize(Properties parameters) throws Exception {
<b class="nc">&nbsp;		super.initialize(parameters);</b>
&nbsp;		// slightly hacky cast to cope with the fact that Properties is
&nbsp;		// Map&lt;Object,Object&gt;
&nbsp;		// even though it is effectively Map&lt;String,String&gt;
<b class="nc">&nbsp;		this.geoContextMapper = createSpatialContextMapper((Map&lt;String, String&gt;) (Map&lt;?, ?&gt;) parameters);</b>
&nbsp;
<b class="nc">&nbsp;		String server = parameters.getProperty(SERVER_KEY);</b>
<b class="nc">&nbsp;		if (server == null) {</b>
<b class="nc">&nbsp;			throw new SailException(&quot;Missing &quot; + SERVER_KEY + &quot; parameter&quot;);</b>
&nbsp;		}
<b class="nc">&nbsp;		int pos = server.indexOf(&#39;:&#39;);</b>
<b class="nc">&nbsp;		if (pos == -1) {</b>
<b class="nc">&nbsp;			throw new SailException(&quot;Missing scheme in &quot; + SERVER_KEY + &quot; parameter: &quot; + server);</b>
&nbsp;		}
<b class="nc">&nbsp;		String scheme = server.substring(0, pos);</b>
<b class="nc">&nbsp;		Class&lt;?&gt; clientFactoryCls = Class.forName(&quot;org.eclipse.rdf4j.sail.solr.client.&quot; + scheme + &quot;.Factory&quot;);</b>
<b class="nc">&nbsp;		SolrClientFactory clientFactory = (SolrClientFactory) clientFactoryCls.newInstance();</b>
<b class="nc">&nbsp;		client = clientFactory.create(server);</b>
&nbsp;	}
&nbsp;
&nbsp;	protected Function&lt;? super String, ? extends SpatialContext&gt; createSpatialContextMapper(
&nbsp;			Map&lt;String, String&gt; parameters) {
&nbsp;		// this should really be based on the schema
<b class="nc">&nbsp;		ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</b>
<b class="nc">&nbsp;		SpatialContext geoContext = SpatialContextFactory.makeSpatialContext(parameters, classLoader);</b>
<b class="nc">&nbsp;		return Functions.constant(geoContext);</b>
&nbsp;	}
&nbsp;
&nbsp;	public SolrClient getClient() {
<b class="nc">&nbsp;		return client;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected SpatialContext getSpatialContext(String property) {
<b class="nc">&nbsp;		return geoContextMapper.apply(property);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void shutDown() throws IOException {
<b class="nc">&nbsp;		if (client != null) {</b>
<b class="nc">&nbsp;			client.close();</b>
<b class="nc">&nbsp;			client = null;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	// //////////////////////////////// Methods for updating the index
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns a Document representing the specified document ID (combination of resource and context), or null when no
&nbsp;	 * such Document exists yet.
&nbsp;	 *
&nbsp;	 * @param id
&nbsp;	 * @return search document
&nbsp;	 * @throws IOException
&nbsp;	 */
&nbsp;	@Override
&nbsp;	protected SearchDocument getDocument(String id) throws IOException {
&nbsp;		SolrDocument doc;
&nbsp;		try {
<b class="nc">&nbsp;			doc = (SolrDocument) client</b>
<b class="nc">&nbsp;					.query(new SolrQuery().setRequestHandler(&quot;/get&quot;).set(SearchFields.ID_FIELD_NAME, id))</b>
<b class="nc">&nbsp;					.getResponse()</b>
<b class="nc">&nbsp;					.get(&quot;doc&quot;);</b>
<b class="nc">&nbsp;		} catch (SolrServerException e) {</b>
<b class="nc">&nbsp;			throw new IOException(e);</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return (doc != null) ? new SolrSearchDocument(doc) : null;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected Iterable&lt;? extends SearchDocument&gt; getDocuments(String resourceId) throws IOException {
<b class="nc">&nbsp;		SolrQuery query = new SolrQuery(termQuery(SearchFields.URI_FIELD_NAME, resourceId));</b>
&nbsp;		SolrDocumentList docs;
&nbsp;		try {
<b class="nc">&nbsp;			docs = getDocuments(query);</b>
<b class="nc">&nbsp;		} catch (SolrServerException e) {</b>
<b class="nc">&nbsp;			throw new IOException(e);</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return Iterables.transform(docs, SolrSearchDocument::new);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected SearchDocument newDocument(String id, String resourceId, String context) {
<b class="nc">&nbsp;		return new SolrSearchDocument(id, resourceId, context);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected SearchDocument copyDocument(SearchDocument doc) {
<b class="nc">&nbsp;		SolrDocument document = ((SolrSearchDocument) doc).getDocument();</b>
<b class="nc">&nbsp;		SolrDocument newDocument = new SolrDocument();</b>
<b class="nc">&nbsp;		newDocument.putAll(document);</b>
<b class="nc">&nbsp;		return new SolrSearchDocument(newDocument);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected void addDocument(SearchDocument doc) throws IOException {
<b class="nc">&nbsp;		SolrDocument document = ((SolrSearchDocument) doc).getDocument();</b>
&nbsp;		try {
<b class="nc">&nbsp;			client.add(SolrUtil.toSolrInputDocument(document));</b>
<b class="nc">&nbsp;		} catch (SolrServerException e) {</b>
<b class="nc">&nbsp;			throw new IOException(e);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected void updateDocument(SearchDocument doc) throws IOException {
<b class="nc">&nbsp;		addDocument(doc);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected void deleteDocument(SearchDocument doc) throws IOException {
&nbsp;		try {
<b class="nc">&nbsp;			client.deleteById(doc.getId());</b>
<b class="nc">&nbsp;		} catch (SolrServerException e) {</b>
<b class="nc">&nbsp;			throw new IOException(e);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected BulkUpdater newBulkUpdate() {
<b class="nc">&nbsp;		return new SolrBulkUpdater(client);</b>
&nbsp;	}
&nbsp;
&nbsp;	static String termQuery(String field, String value) {
<b class="nc">&nbsp;		return field + &quot;:\&quot;&quot; + value + &quot;\&quot;&quot;;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns a list of Documents representing the specified Resource (empty when no such Document exists yet). Each
&nbsp;	 * document represent a set of statements with the specified Resource as a subject, which are stored in a specific
&nbsp;	 * context
&nbsp;	 */
&nbsp;	private SolrDocumentList getDocuments(SolrQuery query) throws SolrServerException, IOException {
<b class="nc">&nbsp;		return search(query).getResults();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns a Document representing the specified Resource and Context combination, or null when no such Document
&nbsp;	 * exists yet.
&nbsp;	 *
&nbsp;	 * @param subject
&nbsp;	 * @param context
&nbsp;	 * @return search document
&nbsp;	 * @throws IOException
&nbsp;	 */
&nbsp;	public SearchDocument getDocument(Resource subject, Resource context) throws IOException {
&nbsp;		// fetch the Document representing this Resource
<b class="nc">&nbsp;		String resourceId = SearchFields.getResourceID(subject);</b>
<b class="nc">&nbsp;		String contextId = SearchFields.getContextID(context);</b>
<b class="nc">&nbsp;		return getDocument(SearchFields.formIdString(resourceId, contextId));</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns a list of Documents representing the specified Resource (empty when no such Document exists yet).Each
&nbsp;	 * document represent a set of statements with the specified Resource as a subject, which are stored in a specific
&nbsp;	 * context
&nbsp;	 *
&nbsp;	 * @param subject
&nbsp;	 * @return list of documents
&nbsp;	 * @throws IOException
&nbsp;	 */
&nbsp;	public Iterable&lt;? extends SearchDocument&gt; getDocuments(Resource subject) throws IOException {
<b class="nc">&nbsp;		String resourceId = SearchFields.getResourceID(subject);</b>
<b class="nc">&nbsp;		return getDocuments(resourceId);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Filters the given list of fields, retaining all property fields.
&nbsp;	 *
&nbsp;	 * @param fields
&nbsp;	 * @return set of fields
&nbsp;	 */
&nbsp;	public static Set&lt;String&gt; getPropertyFields(Set&lt;String&gt; fields) {
<b class="nc">&nbsp;		Set&lt;String&gt; result = new HashSet&lt;&gt;(fields.size());</b>
<b class="nc">&nbsp;		for (String field : fields) {</b>
<b class="nc">&nbsp;			if (SearchFields.isPropertyField(field)) {</b>
<b class="nc">&nbsp;				result.add(field);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return result;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void begin() throws IOException {
<b class="nc">&nbsp;	}</b>
&nbsp;
&nbsp;	@Override
&nbsp;	public void commit() throws IOException {
&nbsp;		try {
<b class="nc">&nbsp;			client.commit();</b>
<b class="nc">&nbsp;		} catch (SolrServerException e) {</b>
<b class="nc">&nbsp;			throw new IOException(e);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void rollback() throws IOException {
&nbsp;		try {
<b class="nc">&nbsp;			client.rollback();</b>
<b class="nc">&nbsp;		} catch (SolrServerException e) {</b>
<b class="nc">&nbsp;			throw new IOException(e);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	// //////////////////////////////// Methods for querying the index
&nbsp;
&nbsp;	/**
&nbsp;	 * Parse the passed query.
&nbsp;	 *
&nbsp;	 * @param subject
&nbsp;	 * @param query       string
&nbsp;	 * @param propertyURI
&nbsp;	 * @param highlight
&nbsp;	 * @return the parsed query
&nbsp;	 * @throws MalformedQueryException
&nbsp;	 * @throws IOException
&nbsp;	 */
&nbsp;	@Override
&nbsp;	protected Iterable&lt;? extends DocumentScore&gt; query(Resource subject, String query, IRI propertyURI,
&nbsp;			boolean highlight) throws MalformedQueryException, IOException {
<b class="nc">&nbsp;		SolrQuery q = prepareQuery(propertyURI, new SolrQuery(query));</b>
<b class="nc">&nbsp;		if (highlight) {</b>
<b class="nc">&nbsp;			q.setHighlight(true);</b>
<b class="nc">&nbsp;			String field = (propertyURI != null) ? SearchFields.getPropertyField(propertyURI) : &quot;*&quot;;</b>
<b class="nc">&nbsp;			q.addHighlightField(field);</b>
<b class="nc">&nbsp;			q.setHighlightSimplePre(SearchFields.HIGHLIGHTER_PRE_TAG);</b>
<b class="nc">&nbsp;			q.setHighlightSimplePost(SearchFields.HIGHLIGHTER_POST_TAG);</b>
<b class="nc">&nbsp;			q.setHighlightSnippets(2);</b>
&nbsp;		}
&nbsp;
&nbsp;		QueryResponse response;
<b class="nc">&nbsp;		if (q.getHighlight()) {</b>
<b class="nc">&nbsp;			q.addField(&quot;*&quot;);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			q.addField(SearchFields.URI_FIELD_NAME);</b>
&nbsp;		}
<b class="nc">&nbsp;		q.addField(&quot;score&quot;);</b>
&nbsp;		try {
<b class="nc">&nbsp;			if (subject != null) {</b>
<b class="nc">&nbsp;				response = search(subject, q);</b>
&nbsp;			} else {
<b class="nc">&nbsp;				response = search(q);</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (SolrServerException e) {</b>
<b class="nc">&nbsp;			throw new IOException(e);</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		SolrDocumentList results = response.getResults();</b>
<b class="nc">&nbsp;		final Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; highlighting = response.getHighlighting();</b>
<b class="nc">&nbsp;		return Iterables.transform(results, (SolrDocument document) -&gt; {</b>
<b class="nc">&nbsp;			SolrSearchDocument doc = new SolrSearchDocument(document);</b>
<b class="nc">&nbsp;			Map&lt;String, List&lt;String&gt;&gt; docHighlighting = (highlighting != null) ? highlighting.get(doc.getId())</b>
<b class="nc">&nbsp;					: null;</b>
<b class="nc">&nbsp;			return new SolrDocumentScore(doc, docHighlighting);</b>
&nbsp;		});
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Evaluates the given query only for the given resource.
&nbsp;	 *
&nbsp;	 * @param resource
&nbsp;	 * @param query
&nbsp;	 * @return response
&nbsp;	 * @throws SolrServerException
&nbsp;	 * @throws IOException
&nbsp;	 */
&nbsp;	public QueryResponse search(Resource resource, SolrQuery query) throws SolrServerException, IOException {
&nbsp;		// rewrite the query
<b class="nc">&nbsp;		String idQuery = termQuery(SearchFields.URI_FIELD_NAME, SearchFields.getResourceID(resource));</b>
<b class="nc">&nbsp;		query.setQuery(query.getQuery() + &quot; AND &quot; + idQuery);</b>
<b class="nc">&nbsp;		return search(query);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected Iterable&lt;? extends DocumentDistance&gt; geoQuery(IRI geoProperty, Point p, final IRI units, double distance,
&nbsp;			String distanceVar, Var contextVar) throws MalformedQueryException, IOException {
<b class="nc">&nbsp;		double kms = GeoUnits.toKilometres(distance, units);</b>
&nbsp;
<b class="nc">&nbsp;		String qstr = &quot;{!geofilt score=recipDistance}&quot;;</b>
<b class="nc">&nbsp;		if (contextVar != null) {</b>
<b class="nc">&nbsp;			Resource ctx = (Resource) contextVar.getValue();</b>
<b class="nc">&nbsp;			String tq = termQuery(SearchFields.CONTEXT_FIELD_NAME, SearchFields.getContextID(ctx));</b>
<b class="nc">&nbsp;			if (ctx != null) {</b>
<b class="nc">&nbsp;				qstr = tq + &quot; AND &quot; + qstr;</b>
&nbsp;			} else {
<b class="nc">&nbsp;				qstr = &quot;-&quot; + tq + &quot; AND &quot; + qstr;</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		SolrQuery q = new SolrQuery(qstr);</b>
<b class="nc">&nbsp;		q.set(SpatialParams.FIELD, SearchFields.getPropertyField(geoProperty));</b>
<b class="nc">&nbsp;		q.set(SpatialParams.POINT, p.getY() + &quot;,&quot; + p.getX());</b>
<b class="nc">&nbsp;		q.set(SpatialParams.DISTANCE, Double.toString(kms));</b>
<b class="nc">&nbsp;		q.addField(SearchFields.URI_FIELD_NAME);</b>
&nbsp;		// &#39;:&#39; is part of the fl parameter syntax so we can&#39;t use the full
&nbsp;		// property field name
&nbsp;		// instead we use wildcard + local part of the property URI
<b class="nc">&nbsp;		q.addField(&quot;*&quot; + geoProperty.getLocalName());</b>
&nbsp;		// always include the distance - needed for sanity checking
<b class="nc">&nbsp;		q.addField(DISTANCE_FIELD + &quot;:geodist()&quot;);</b>
<b class="nc">&nbsp;		boolean requireContext = (contextVar != null &amp;&amp; !contextVar.hasValue());</b>
<b class="nc">&nbsp;		if (requireContext) {</b>
<b class="nc">&nbsp;			q.addField(SearchFields.CONTEXT_FIELD_NAME);</b>
&nbsp;		}
&nbsp;
&nbsp;		QueryResponse response;
&nbsp;		try {
<b class="nc">&nbsp;			response = search(q);</b>
<b class="nc">&nbsp;		} catch (SolrServerException e) {</b>
<b class="nc">&nbsp;			throw new IOException(e);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;
<b class="nc">&nbsp;		SolrDocumentList results = response.getResults();</b>
<b class="nc">&nbsp;		return Iterables.transform(results, (SolrDocument document) -&gt; {</b>
<b class="nc">&nbsp;			SolrSearchDocument doc = new SolrSearchDocument(document);</b>
<b class="nc">&nbsp;			return new SolrDocumentDistance(doc, units);</b>
&nbsp;		});
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected Iterable&lt;? extends DocumentResult&gt; geoRelationQuery(String relation, IRI geoProperty, String wkt,
&nbsp;			Var contextVar) throws MalformedQueryException, IOException {
<b class="nc">&nbsp;		String spatialOp = toSpatialOp(relation);</b>
<b class="nc">&nbsp;		if (spatialOp == null) {</b>
<b class="nc">&nbsp;			return null;</b>
&nbsp;		}
<b class="nc">&nbsp;		String qstr = &quot;\&quot;&quot; + spatialOp + &quot;(&quot; + wkt + &quot;)\&quot;&quot;;</b>
<b class="nc">&nbsp;		if (contextVar != null) {</b>
<b class="nc">&nbsp;			Resource ctx = (Resource) contextVar.getValue();</b>
<b class="nc">&nbsp;			String tq = termQuery(SearchFields.CONTEXT_FIELD_NAME, SearchFields.getContextID(ctx));</b>
<b class="nc">&nbsp;			if (ctx != null) {</b>
<b class="nc">&nbsp;				qstr = tq + &quot; AND &quot; + qstr;</b>
&nbsp;			} else {
<b class="nc">&nbsp;				qstr = &quot;-&quot; + tq + &quot; AND &quot; + qstr;</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		SolrQuery q = new SolrQuery(qstr);</b>
<b class="nc">&nbsp;		q.set(CommonParams.DF, SearchFields.getPropertyField(geoProperty));</b>
<b class="nc">&nbsp;		q.addField(SearchFields.URI_FIELD_NAME);</b>
&nbsp;		// &#39;:&#39; is part of the fl parameter syntax so we can&#39;t use the full
&nbsp;		// property field name
&nbsp;		// instead we use wildcard + local part of the property URI
<b class="nc">&nbsp;		q.addField(&quot;*&quot; + geoProperty.getLocalName());</b>
<b class="nc">&nbsp;		boolean requireContext = (contextVar != null &amp;&amp; !contextVar.hasValue());</b>
<b class="nc">&nbsp;		if (requireContext) {</b>
<b class="nc">&nbsp;			q.addField(SearchFields.CONTEXT_FIELD_NAME);</b>
&nbsp;		}
&nbsp;
&nbsp;		QueryResponse response;
&nbsp;		try {
<b class="nc">&nbsp;			response = search(q);</b>
<b class="nc">&nbsp;		} catch (SolrServerException e) {</b>
<b class="nc">&nbsp;			throw new IOException(e);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;
<b class="nc">&nbsp;		SolrDocumentList results = response.getResults();</b>
<b class="nc">&nbsp;		return Iterables.transform(results, (SolrDocument document) -&gt; {</b>
<b class="nc">&nbsp;			SolrSearchDocument doc = new SolrSearchDocument(document);</b>
<b class="nc">&nbsp;			return new SolrDocumentResult(doc);</b>
&nbsp;		});
&nbsp;	}
&nbsp;
&nbsp;	private String toSpatialOp(String relation) {
<b class="nc">&nbsp;		if (GEOF.SF_INTERSECTS.stringValue().equals(relation)) {</b>
<b class="nc">&nbsp;			return &quot;Intersects&quot;;</b>
&nbsp;		}
<b class="nc">&nbsp;		if (GEOF.SF_DISJOINT.stringValue().equals(relation)) {</b>
<b class="nc">&nbsp;			return &quot;IsDisjointTo&quot;;</b>
&nbsp;		}
<b class="nc">&nbsp;		if (GEOF.EH_COVERED_BY.stringValue().equals(relation)) {</b>
<b class="nc">&nbsp;			return &quot;IsWithin&quot;;</b>
&nbsp;		}
<b class="nc">&nbsp;		return null;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected Shape parseQueryShape(String property, String value) throws ParseException {
<b class="nc">&nbsp;		Shape s = super.parseQueryShape(property, value);</b>
&nbsp;		// workaround to preserve WKT string
<b class="nc">&nbsp;		return (s instanceof Point) ? new WktPoint((Point) s, value) : new WktShape&lt;&gt;(s, value);</b>
&nbsp;	}
&nbsp;
&nbsp;	protected String toWkt(Shape s) {
<b class="nc">&nbsp;		return ((WktShape&lt;?&gt;) s).wkt;</b>
&nbsp;	}
&nbsp;
&nbsp;	private static class WktShape&lt;S extends Shape&gt; implements Shape {
&nbsp;
&nbsp;		final S s;
&nbsp;
&nbsp;		final String wkt;
&nbsp;
<b class="nc">&nbsp;		WktShape(S s, String wkt) {</b>
<b class="nc">&nbsp;			this.s = s;</b>
<b class="nc">&nbsp;			this.wkt = wkt;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public SpatialRelation relate(Shape other) {
<b class="nc">&nbsp;			return s.relate(other);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Rectangle getBoundingBox() {
<b class="nc">&nbsp;			return s.getBoundingBox();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public boolean hasArea() {
<b class="nc">&nbsp;			return s.hasArea();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public double getArea(SpatialContext ctx) {
<b class="nc">&nbsp;			return s.getArea(ctx);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Point getCenter() {
<b class="nc">&nbsp;			return s.getCenter();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Shape getBuffered(double distance, SpatialContext ctx) {
<b class="nc">&nbsp;			return s.getBuffered(distance, ctx);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public boolean isEmpty() {
<b class="nc">&nbsp;			return s.isEmpty();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public boolean equals(Object other) {
<b class="nc">&nbsp;			return s.equals(other);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public SpatialContext getContext() {
<b class="nc">&nbsp;			return s.getContext();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private static class WktPoint extends WktShape&lt;Point&gt; implements Point {
&nbsp;
&nbsp;		WktPoint(Point p, String wkt) {
<b class="nc">&nbsp;			super(p, wkt);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void reset(double x, double y) {
<b class="nc">&nbsp;			s.reset(x, y);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public double getX() {
<b class="nc">&nbsp;			return s.getX();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public double getY() {
<b class="nc">&nbsp;			return s.getY();</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Evaluates the given query and returns the results as a TopDocs instance.
&nbsp;	 *
&nbsp;	 * @param query
&nbsp;	 * @return query response
&nbsp;	 * @throws SolrServerException
&nbsp;	 * @throws IOException
&nbsp;	 */
&nbsp;	public QueryResponse search(SolrQuery query) throws SolrServerException, IOException {
&nbsp;		int nDocs;
<b class="nc">&nbsp;		if (maxDocs &gt; 0) {</b>
<b class="nc">&nbsp;			nDocs = maxDocs;</b>
&nbsp;		} else {
<b class="nc">&nbsp;			long docCount = client.query(query.setRows(0)).getResults().getNumFound();</b>
<b class="nc">&nbsp;			nDocs = Math.max((int) Math.min(docCount, Integer.MAX_VALUE), 1);</b>
&nbsp;		}
<b class="nc">&nbsp;		return client.query(query.setRows(nDocs));</b>
&nbsp;	}
&nbsp;
&nbsp;	private SolrQuery prepareQuery(IRI propertyURI, SolrQuery query) {
&nbsp;		// check out which query parser to use, based on the given property URI
<b class="nc">&nbsp;		if (propertyURI == null)</b>
&nbsp;		// if we have no property given, we create a default query parser which
&nbsp;		// has the TEXT_FIELD_NAME as the default field
&nbsp;		{
<b class="nc">&nbsp;			query.set(CommonParams.DF, SearchFields.TEXT_FIELD_NAME);</b>
&nbsp;		} else
&nbsp;		// otherwise we create a query parser that has the given property as
&nbsp;		// the default field
&nbsp;		{
<b class="nc">&nbsp;			query.set(CommonParams.DF, SearchFields.getPropertyField(propertyURI));</b>
&nbsp;		}
<b class="nc">&nbsp;		return query;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * @param contexts
&nbsp;	 * @throws IOException
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public synchronized void clearContexts(Resource... contexts) throws IOException {
<b class="nc">&nbsp;		logger.debug(&quot;deleting contexts: {}&quot;, Arrays.toString(contexts));</b>
&nbsp;		// these resources have to be read from the underlying rdf store
&nbsp;		// and their triples have to be added to the luceneindex after deletion of
&nbsp;		// documents
&nbsp;
&nbsp;		try {
&nbsp;			// remove all contexts passed
<b class="nc">&nbsp;			for (Resource context : contexts) {</b>
&nbsp;				// attention: context can be NULL!
<b class="nc">&nbsp;				String contextString = SearchFields.getContextID(context);</b>
<b class="nc">&nbsp;				client.deleteByQuery(termQuery(SearchFields.CONTEXT_FIELD_NAME, contextString));</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (SolrServerException e) {</b>
<b class="nc">&nbsp;			throw new IOException(e);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 *
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public synchronized void clear() throws IOException {
&nbsp;		try {
<b class="nc">&nbsp;			client.deleteByQuery(&quot;*:*&quot;);</b>
<b class="nc">&nbsp;		} catch (SolrServerException e) {</b>
<b class="nc">&nbsp;			throw new IOException(e);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:22</div>
</div>
</body>
</html>
