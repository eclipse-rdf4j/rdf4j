


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > QueryStorage</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.workbench.util</a>
</div>

<h1>Coverage Summary for Class: QueryStorage (org.eclipse.rdf4j.workbench.util)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">QueryStorage</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/68)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/105)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;package org.eclipse.rdf4j.workbench.util;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.util.UUID;
&nbsp;
&nbsp;import org.eclipse.rdf4j.common.app.AppConfiguration;
&nbsp;import org.eclipse.rdf4j.common.exception.RDF4JException;
&nbsp;import org.eclipse.rdf4j.model.IRI;
&nbsp;import org.eclipse.rdf4j.query.MalformedQueryException;
&nbsp;import org.eclipse.rdf4j.query.QueryEvaluationException;
&nbsp;import org.eclipse.rdf4j.query.QueryLanguage;
&nbsp;import org.eclipse.rdf4j.query.QueryResultHandlerException;
&nbsp;import org.eclipse.rdf4j.query.TupleQuery;
&nbsp;import org.eclipse.rdf4j.query.TupleQueryResult;
&nbsp;import org.eclipse.rdf4j.query.UpdateExecutionException;
&nbsp;import org.eclipse.rdf4j.repository.Repository;
&nbsp;import org.eclipse.rdf4j.repository.RepositoryConnection;
&nbsp;import org.eclipse.rdf4j.repository.RepositoryException;
&nbsp;import org.eclipse.rdf4j.repository.http.HTTPRepository;
&nbsp;import org.eclipse.rdf4j.repository.sail.SailRepository;
&nbsp;import org.eclipse.rdf4j.sail.nativerdf.NativeStore;
&nbsp;import org.eclipse.rdf4j.workbench.exceptions.BadRequestException;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;
&nbsp;/**
&nbsp; * Provides an interface to the private repository with the saved queries.
&nbsp; *
&nbsp; * @author Dale Visser
&nbsp; */
&nbsp;public class QueryStorage {
&nbsp;
<b class="nc">&nbsp;	private static final Object LOCK = new Object();</b>
&nbsp;
<b class="nc">&nbsp;	private static final QueryEvaluator EVAL = QueryEvaluator.INSTANCE;</b>
&nbsp;
&nbsp;	private static QueryStorage instance;
&nbsp;
&nbsp;	public static QueryStorage getSingletonInstance(final AppConfiguration config)
&nbsp;			throws RepositoryException, IOException {
<b class="nc">&nbsp;		synchronized (LOCK) {</b>
<b class="nc">&nbsp;			if (instance == null || instance.isShutdown()) {</b>
<b class="nc">&nbsp;				instance = new QueryStorage(config);</b>
&nbsp;			}
<b class="nc">&nbsp;			return instance;</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean isShutdown() {
<b class="nc">&nbsp;		return queries == null || !queries.isInitialized();</b>
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	private static final Logger LOGGER = LoggerFactory.getLogger(QueryStorage.class);</b>
&nbsp;
&nbsp;	private static final String PRE = &quot;PREFIX : &lt;https://openrdf.org/workbench/&gt;\n&quot;;
&nbsp;
&nbsp;	// SAVE needs xsd: prefix since explicit XSD data types will be substituted.
&nbsp;	private static final String SAVE = &quot;PREFIX xsd:&lt;http://www.w3.org/2001/XMLSchema#&gt;\n&quot; + PRE
&nbsp;			+ &quot;INSERT DATA { $&lt;query&gt; :userName $&lt;userName&gt; ; :queryName $&lt;queryName&gt; ; &quot;
&nbsp;			+ &quot;:repository $&lt;repository&gt; ; :shared $&lt;shared&gt; ; :queryLanguage $&lt;queryLanguage&gt; ; :query $&lt;queryText&gt; ; &quot;
&nbsp;			+ &quot;:infer $&lt;infer&gt; ; :rowsPerPage $&lt;rowsPerPage&gt; . }&quot;;
&nbsp;
&nbsp;	private static final String ASK_EXISTS = PRE
&nbsp;			+ &quot;ASK { [] :userName $&lt;userName&gt; ; :queryName $&lt;queryName&gt; ; :repository $&lt;repository&gt; . }&quot;;
&nbsp;
&nbsp;	private static final String UPDATE_FILTER = &quot;FILTER (?user = $&lt;userName&gt; || ?user = \&quot;\&quot; ) } &quot;;
&nbsp;
&nbsp;	private static final String READ_FILTER = &quot;FILTER (?user = $&lt;userName&gt; || ?user = \&quot;\&quot; || ?shared) } &quot;;
&nbsp;
&nbsp;	private static final String ASK_UPDATABLE = PRE + &quot;ASK { $&lt;query&gt; :userName ?user . &quot; + UPDATE_FILTER;
&nbsp;
&nbsp;	private static final String ASK_READABLE = PRE + &quot;ASK { $&lt;query&gt; :userName ?user  ; :shared ?shared . &quot;
&nbsp;			+ READ_FILTER;
&nbsp;
&nbsp;	private static final String DELETE = PRE + &quot;DELETE WHERE { $&lt;query&gt; :userName ?user ; ?p ?o . }&quot;;
&nbsp;
&nbsp;	private static final String MATCH = &quot;:shared ?s ; :queryLanguage ?ql ; :query ?q ; :rowsPerPage ?rpp .\n&quot;;
&nbsp;
&nbsp;	private static final String UPDATE = PRE + &quot;DELETE { $&lt;query&gt; &quot; + MATCH
&nbsp;			+ &quot;}\nINSERT { $&lt;query&gt; :shared $&lt;shared&gt; ; :queryLanguage $&lt;queryLanguage&gt; ; :query $&lt;queryText&gt; ; &quot;
&nbsp;			+ &quot;:infer $&lt;infer&gt; ; :rowsPerPage $&lt;rowsPerPage&gt; . } WHERE { $&lt;query&gt; :userName ?user ; &quot; + MATCH
&nbsp;			+ UPDATE_FILTER;
&nbsp;
&nbsp;	private static final String SELECT_URI = PRE
&nbsp;			+ &quot;SELECT ?query { ?query :repository $&lt;repository&gt; ; :userName $&lt;userName&gt; ; :queryName $&lt;queryName&gt; . } &quot;;
&nbsp;
&nbsp;	private static final String SELECT_TEXT = PRE
&nbsp;			+ &quot;SELECT ?queryText { [] :repository $&lt;repository&gt; ; :userName $&lt;userName&gt; ; :queryName $&lt;queryName&gt; ; :query ?queryText . } &quot;;
&nbsp;
&nbsp;	private static final String SELECT = PRE
&nbsp;			+ &quot;SELECT ?query ?user ?queryName ?shared ?queryLn ?queryText ?infer ?rowsPerPage &quot;
&nbsp;			+ &quot;{ ?query :repository $&lt;repository&gt; ; :userName ?user ; :queryName ?queryName ; :shared ?shared ; &quot;
&nbsp;			+ &quot;:queryLanguage ?queryLn ; :query ?queryText ; :infer ?infer ; :rowsPerPage ?rowsPerPage .\n&quot;
&nbsp;			+ READ_FILTER + &quot;ORDER BY ?user ?queryName&quot;;
&nbsp;
&nbsp;	private final Repository queries;
&nbsp;
&nbsp;	private static final String USER_NAME = &quot;$&lt;userName&gt;&quot;;
&nbsp;
&nbsp;	private static final String REPOSITORY = &quot;$&lt;repository&gt;&quot;;
&nbsp;
&nbsp;	private static final String QUERY = &quot;$&lt;query&gt;&quot;;
&nbsp;
&nbsp;	private static final String QUERY_NAME = &quot;$&lt;queryName&gt;&quot;;
&nbsp;
&nbsp;	/**
&nbsp;	 * Create a new object for accessing the store of user queries.
&nbsp;	 *
&nbsp;	 * @param appConfig the application configuration, for obtaining the data directory
&nbsp;	 * @throws RepositoryException if there is an issue creating the object to access the repository
&nbsp;	 * @throws IOException
&nbsp;	 */
<b class="nc">&nbsp;	private QueryStorage(final AppConfiguration appConfig) throws RepositoryException, IOException {</b>
<b class="nc">&nbsp;		queries = new SailRepository(new NativeStore(new File(appConfig.getDataDir(), &quot;queries&quot;)));</b>
<b class="nc">&nbsp;		queries.init();</b>
&nbsp;	}
&nbsp;
&nbsp;	public void shutdown() {
&nbsp;		try {
<b class="nc">&nbsp;			if (queries != null &amp;&amp; queries.isInitialized()) {</b>
<b class="nc">&nbsp;				queries.shutDown();</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (RepositoryException e) {</b>
<b class="nc">&nbsp;			LOGGER.warn(e.getMessage());</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Checks whether the current user/password credentials can really access the current repository.
&nbsp;	 *
&nbsp;	 * @param repository the current repository
&nbsp;	 * @return true, if it is possible to request a statement from the repository with the given credentials
&nbsp;	 * @throws RepositoryException if there is an issue closing the connection
&nbsp;	 */
&nbsp;	public boolean checkAccess(final HTTPRepository repository) throws RepositoryException {
<b class="nc">&nbsp;		LOGGER.info(&quot;repository: {}&quot;, repository.getRepositoryURL());</b>
<b class="nc">&nbsp;		boolean rval = true;</b>
<b class="nc">&nbsp;		try (RepositoryConnection con = repository.getConnection()) {</b>
&nbsp;			// Manufacture an unlikely unique statement to check.
<b class="nc">&nbsp;			IRI uri = con.getValueFactory().createIRI(&quot;urn:uuid:&quot; + UUID.randomUUID());</b>
<b class="nc">&nbsp;			con.hasStatement(uri, uri, uri, false, uri);</b>
<b class="nc">&nbsp;		} catch (RepositoryException re) {</b>
<b class="nc">&nbsp;			rval = false;</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return rval;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Save a query. UNSAFE from an injection point of view. It is the responsibility of the calling code to call
&nbsp;	 * checkAccess() with the full credentials first.
&nbsp;	 *
&nbsp;	 * @param repository    the repository the query is associated with
&nbsp;	 * @param queryName     the name for the query
&nbsp;	 * @param userName      the user saving the query
&nbsp;	 * @param shared        whether the query is to be shared with other users
&nbsp;	 * @param queryLanguage the language of the query (only SPARQL is currently supported)
&nbsp;	 * @param queryText     the actual query text
&nbsp;	 * @param infer
&nbsp;	 * @param rowsPerPage   rows to display per page, may be 0 (all), 10, 50, 100, or 200)
&nbsp;	 * @throws RDF4JException
&nbsp;	 */
&nbsp;	public void saveQuery(final HTTPRepository repository, final String queryName, final String userName,
&nbsp;			final boolean shared, final QueryLanguage queryLanguage, final String queryText, final boolean infer,
&nbsp;			final int rowsPerPage) throws RDF4JException {
<b class="nc">&nbsp;		if (QueryLanguage.SPARQL != queryLanguage) {</b>
<b class="nc">&nbsp;			throw new RepositoryException(&quot;May only save SPARQL queries, not&quot; + queryLanguage.toString());</b>
&nbsp;		}
<b class="nc">&nbsp;		if (0 != rowsPerPage &amp;&amp; 10 != rowsPerPage &amp;&amp; 20 != rowsPerPage &amp;&amp; 50 != rowsPerPage &amp;&amp; 100 != rowsPerPage</b>
&nbsp;				&amp;&amp; 200 != rowsPerPage) {
<b class="nc">&nbsp;			throw new RepositoryException(&quot;Illegal value for rows per page: &quot; + rowsPerPage);</b>
&nbsp;		}
<b class="nc">&nbsp;		this.checkQueryText(queryText);</b>
<b class="nc">&nbsp;		final QueryStringBuilder save = new QueryStringBuilder(SAVE);</b>
<b class="nc">&nbsp;		save.replaceURI(REPOSITORY, repository.getRepositoryURL());</b>
<b class="nc">&nbsp;		save.replaceURI(QUERY, &quot;urn:uuid:&quot; + UUID.randomUUID());</b>
<b class="nc">&nbsp;		save.replaceQuote(QUERY_NAME, queryName);</b>
<b class="nc">&nbsp;		this.replaceUpdateFields(save, userName, shared, queryLanguage, queryText, infer, rowsPerPage);</b>
<b class="nc">&nbsp;		updateQueryRepository(save.toString());</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Determines whether the user with the given userName is allowed to update or delete the given query.
&nbsp;	 *
&nbsp;	 * @param query       the node identifying the query of interest
&nbsp;	 * @param currentUser the user to check access for
&nbsp;	 * @return &lt;var&gt;true&lt;/var&gt; if the given query was saved by the given user or the anonymous user
&nbsp;	 */
&nbsp;	public boolean canChange(final IRI query, final String currentUser)
&nbsp;			throws RepositoryException, QueryEvaluationException, MalformedQueryException {
<b class="nc">&nbsp;		return performAccessQuery(ASK_UPDATABLE, query, currentUser);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Determines whether the user with the given userName is allowed to read the given query.
&nbsp;	 *
&nbsp;	 * @param query       the node identifying the query of interest
&nbsp;	 * @param currentUser the user to check access for
&nbsp;	 * @return &lt;var&gt;true&lt;/var&gt; if the given query was saved by either the given user or the anonymous user, or is shared
&nbsp;	 */
&nbsp;	public boolean canRead(IRI query, String currentUser)
&nbsp;			throws RepositoryException, QueryEvaluationException, MalformedQueryException {
<b class="nc">&nbsp;		return performAccessQuery(ASK_READABLE, query, currentUser);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean performAccessQuery(String accessSPARQL, IRI query, String currentUser)
&nbsp;			throws RepositoryException, QueryEvaluationException, MalformedQueryException {
<b class="nc">&nbsp;		final QueryStringBuilder canDelete = new QueryStringBuilder(accessSPARQL);</b>
<b class="nc">&nbsp;		canDelete.replaceURI(QUERY, query.stringValue());</b>
<b class="nc">&nbsp;		canDelete.replaceQuote(USER_NAME, currentUser);</b>
<b class="nc">&nbsp;		LOGGER.info(&quot;{}&quot;, canDelete);</b>
<b class="nc">&nbsp;		try (RepositoryConnection connection = this.queries.getConnection()) {</b>
<b class="nc">&nbsp;			return connection.prepareBooleanQuery(QueryLanguage.SPARQL, canDelete.toString()).evaluate();</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean askExists(final HTTPRepository repository, final String queryName, final String userName)
&nbsp;			throws QueryEvaluationException, RepositoryException, MalformedQueryException {
<b class="nc">&nbsp;		final QueryStringBuilder ask = new QueryStringBuilder(ASK_EXISTS);</b>
<b class="nc">&nbsp;		ask.replaceURI(REPOSITORY, repository.getRepositoryURL());</b>
<b class="nc">&nbsp;		ask.replaceQuote(QUERY_NAME, queryName);</b>
<b class="nc">&nbsp;		ask.replaceQuote(USER_NAME, userName);</b>
<b class="nc">&nbsp;		LOGGER.info(&quot;{}&quot;, ask);</b>
<b class="nc">&nbsp;		try (RepositoryConnection connection = this.queries.getConnection()) {</b>
<b class="nc">&nbsp;			return connection.prepareBooleanQuery(QueryLanguage.SPARQL, ask.toString()).evaluate();</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Delete the given query for the given user. It is the responsibility of the calling code to call checkAccess() and
&nbsp;	 * canDelete() with the full credentials first.
&nbsp;	 *
&nbsp;	 * @param query
&nbsp;	 * @param userName
&nbsp;	 * @throws RepositoryException
&nbsp;	 * @throws UpdateExecutionException
&nbsp;	 * @throws MalformedQueryException
&nbsp;	 */
&nbsp;	public void deleteQuery(final IRI query, final String userName)
&nbsp;			throws RepositoryException, UpdateExecutionException, MalformedQueryException {
<b class="nc">&nbsp;		final QueryStringBuilder delete = new QueryStringBuilder(DELETE);</b>
<b class="nc">&nbsp;		delete.replaceQuote(QueryStorage.USER_NAME, userName);</b>
<b class="nc">&nbsp;		delete.replaceURI(QUERY, query.stringValue());</b>
<b class="nc">&nbsp;		updateQueryRepository(delete.toString());</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Update the entry for the given query. It is the responsibility of the calling code to call checkAccess() with the
&nbsp;	 * full credentials first.
&nbsp;	 *
&nbsp;	 * @param query         the query to update
&nbsp;	 * @param userName      the user name
&nbsp;	 * @param shared        whether to share with other users
&nbsp;	 * @param queryLanguage the query language
&nbsp;	 * @param queryText     the text of the query
&nbsp;	 * @param infer
&nbsp;	 * @param rowsPerPage   the rows per page to display of the query
&nbsp;	 * @throws RepositoryException      if a problem occurs during the update
&nbsp;	 * @throws UpdateExecutionException if a problem occurs during the update
&nbsp;	 * @throws MalformedQueryException  if a problem occurs during the update
&nbsp;	 */
&nbsp;	public void updateQuery(final IRI query, final String userName, final boolean shared,
&nbsp;			final QueryLanguage queryLanguage, final String queryText, final boolean infer, final int rowsPerPage)
&nbsp;			throws RepositoryException, UpdateExecutionException, MalformedQueryException {
<b class="nc">&nbsp;		final QueryStringBuilder update = new QueryStringBuilder(UPDATE);</b>
<b class="nc">&nbsp;		update.replaceURI(QUERY, query);</b>
<b class="nc">&nbsp;		this.replaceUpdateFields(update, userName, shared, queryLanguage, queryText, infer, rowsPerPage);</b>
<b class="nc">&nbsp;		this.updateQueryRepository(update.toString());</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Prepares a query to retrieve the queries accessible to the given user in the given repository. When evaluated,
&nbsp;	 * the query result will have the following binding names: query, user, queryName, shared, queryLn, queryText,
&nbsp;	 * rowsPerPage. It is the responsibility of the calling code to call checkAccess() with the full credentials first.
&nbsp;	 *
&nbsp;	 * @param repository that the saved queries run against
&nbsp;	 * @param userName   that is requesting the saved queries
&nbsp;	 * @param builder    receives a list of all the saved queries against the given repository and accessible to the
&nbsp;	 *                   given user
&nbsp;	 * @throws RepositoryException         if there&#39;s a problem connecting to the saved queries repository
&nbsp;	 * @throws MalformedQueryException     if the query is not legal SPARQL
&nbsp;	 * @throws QueryEvaluationException    if there is a problem while attempting to evaluate the query
&nbsp;	 * @throws QueryResultHandlerException
&nbsp;	 */
&nbsp;	public void selectSavedQueries(final HTTPRepository repository, final String userName,
&nbsp;			final TupleResultBuilder builder)
&nbsp;			throws RepositoryException, MalformedQueryException, QueryEvaluationException, QueryResultHandlerException {
<b class="nc">&nbsp;		final QueryStringBuilder select = new QueryStringBuilder(SELECT);</b>
<b class="nc">&nbsp;		select.replaceQuote(USER_NAME, userName);</b>
<b class="nc">&nbsp;		select.replaceURI(REPOSITORY, repository.getRepositoryURL());</b>
<b class="nc">&nbsp;		try (RepositoryConnection connection = this.queries.getConnection()) {</b>
<b class="nc">&nbsp;			EVAL.evaluateTupleQuery(builder, connection.prepareTupleQuery(QueryLanguage.SPARQL, select.toString()));</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the URI for the saved query in the given repository with the given name, owned by the given owner.
&nbsp;	 *
&nbsp;	 * @param repository The repository the query is associated with.
&nbsp;	 * @param owner      The user that saved the query.
&nbsp;	 * @param queryName  The name given to the query.
&nbsp;	 * @return if it exists, the URI referring to the specified saved query.
&nbsp;	 * @throws RDF4JException      if issues occur performing the necessary queries.
&nbsp;	 * @throws BadRequestException if the the specified stored query doesn&#39;t exist
&nbsp;	 */
&nbsp;	public IRI selectSavedQuery(final HTTPRepository repository, final String owner, final String queryName)
&nbsp;			throws RDF4JException, BadRequestException {
<b class="nc">&nbsp;		final QueryStringBuilder select = new QueryStringBuilder(SELECT_URI);</b>
<b class="nc">&nbsp;		select.replaceQuote(QueryStorage.USER_NAME, owner);</b>
<b class="nc">&nbsp;		select.replaceURI(REPOSITORY, repository.getRepositoryURL());</b>
<b class="nc">&nbsp;		select.replaceQuote(QUERY_NAME, queryName);</b>
<b class="nc">&nbsp;		try (RepositoryConnection connection = this.queries.getConnection()) {</b>
<b class="nc">&nbsp;			TupleQuery query = connection.prepareTupleQuery(QueryLanguage.SPARQL, select.toString());</b>
<b class="nc">&nbsp;			try (TupleQueryResult result = query.evaluate()) {</b>
<b class="nc">&nbsp;				if (result.hasNext()) {</b>
<b class="nc">&nbsp;					return (IRI) (result.next().getValue(&quot;query&quot;));</b>
&nbsp;				} else {
<b class="nc">&nbsp;					throw new BadRequestException(&quot;Could not find query entry in storage.&quot;);</b>
&nbsp;				}
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Retrieves the specified query text. No security checks are done here. If the saved query exists, its text is
&nbsp;	 * returned.
&nbsp;	 *
&nbsp;	 * @param repository Repository that the saved query is associated with.
&nbsp;	 * @param owner      The user that saved the query.
&nbsp;	 * @param queryName  The name given to the saved query.
&nbsp;	 * @return the text of the saved query, if it exists
&nbsp;	 * @throws RDF4JException      if a problem occurs accessing storage
&nbsp;	 * @throws BadRequestException if the specified query doesn&#39;t exist
&nbsp;	 */
&nbsp;	public String getQueryText(final HTTPRepository repository, final String owner, final String queryName)
&nbsp;			throws RDF4JException, BadRequestException {
<b class="nc">&nbsp;		final QueryStringBuilder select = new QueryStringBuilder(SELECT_TEXT);</b>
<b class="nc">&nbsp;		select.replaceQuote(QueryStorage.USER_NAME, owner);</b>
<b class="nc">&nbsp;		select.replaceURI(REPOSITORY, repository.getRepositoryURL());</b>
<b class="nc">&nbsp;		select.replaceQuote(QUERY_NAME, queryName);</b>
<b class="nc">&nbsp;		try (RepositoryConnection connection = this.queries.getConnection()) {</b>
<b class="nc">&nbsp;			TupleQuery query = connection.prepareTupleQuery(QueryLanguage.SPARQL, select.toString());</b>
<b class="nc">&nbsp;			try (TupleQueryResult result = query.evaluate()) {</b>
<b class="nc">&nbsp;				if (result.hasNext()) {</b>
<b class="nc">&nbsp;					return result.next().getValue(&quot;queryText&quot;).stringValue();</b>
&nbsp;				} else {
<b class="nc">&nbsp;					throw new BadRequestException(&quot;Could not find query entry in storage.&quot;);</b>
&nbsp;				}
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private void updateQueryRepository(final String update)
&nbsp;			throws RepositoryException, UpdateExecutionException, MalformedQueryException {
<b class="nc">&nbsp;		LOGGER.info(&quot;SPARQL/Update of Query Storage:\n--\n{}\n--&quot;, update);</b>
<b class="nc">&nbsp;		try (RepositoryConnection connection = this.queries.getConnection()) {</b>
<b class="nc">&nbsp;			connection.prepareUpdate(QueryLanguage.SPARQL, update).execute();</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Perform replacement on several common fields for update operations.
&nbsp;	 *
&nbsp;	 * @param userName      the name of the current user
&nbsp;	 * @param shared        whether the saved query is to be shared with other users
&nbsp;	 * @param queryLanguage the language of the saved query
&nbsp;	 * @param queryText     the actual text of the query to save
&nbsp;	 * @param infer
&nbsp;	 * @param rowsPerPage   the rows per page to display for results
&nbsp;	 */
&nbsp;	private void replaceUpdateFields(final QueryStringBuilder builder, final String userName, final boolean shared,
&nbsp;			final QueryLanguage queryLanguage, final String queryText, final boolean infer, final int rowsPerPage) {
<b class="nc">&nbsp;		builder.replaceQuote(USER_NAME, userName);</b>
<b class="nc">&nbsp;		builder.replace(&quot;$&lt;shared&gt;&quot;, QueryStringBuilder.xsdQuote(String.valueOf(shared), &quot;boolean&quot;));</b>
<b class="nc">&nbsp;		builder.replaceQuote(&quot;$&lt;queryLanguage&gt;&quot;, queryLanguage.toString());</b>
<b class="nc">&nbsp;		checkQueryText(queryText);</b>
<b class="nc">&nbsp;		builder.replace(&quot;$&lt;queryText&gt;&quot;, QueryStringBuilder.quote(queryText, &quot;&#39;&#39;&#39;&quot;, &quot;&#39;&#39;&#39;&quot;));</b>
<b class="nc">&nbsp;		builder.replace(&quot;$&lt;infer&gt;&quot;, QueryStringBuilder.xsdQuote(String.valueOf(infer), &quot;boolean&quot;));</b>
<b class="nc">&nbsp;		builder.replace(&quot;$&lt;rowsPerPage&gt;&quot;, QueryStringBuilder.xsdQuote(String.valueOf(rowsPerPage), &quot;unsignedByte&quot;));</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Imposes the rule that the query may not contain &#39;&#39;&#39;-quoted string, since that is how we&#39;ll be quoting it in our
&nbsp;	 * SPARQL/Update statements. Quoting the query with &#39;&#39;&#39; assuming all string literals in the query are of the
&nbsp;	 * STRING_LITERAL1, STRING_LITERAL2 or STRING_LITERAL_LONG2 types.
&nbsp;	 *
&nbsp;	 * @param queryText the query text
&nbsp;	 */
&nbsp;	private void checkQueryText(final String queryText) {
<b class="nc">&nbsp;		if (queryText.indexOf(&quot;&#39;&#39;&#39;&quot;) &gt; 0) {</b>
<b class="nc">&nbsp;			throw new IllegalArgumentException(&quot;queryText may not contain &#39;&#39;&#39;-quoted strings.&quot;);</b>
&nbsp;		}
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:22</div>
</div>
</body>
</html>
