


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > ValueStore</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.sail.lmdb</a>
</div>

<h1>Coverage Summary for Class: ValueStore (org.eclipse.rdf4j.sail.lmdb)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ValueStore</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/63)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/200)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/429)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2021 Eclipse RDF4J contributors.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;package org.eclipse.rdf4j.sail.lmdb;
&nbsp;
&nbsp;import static org.eclipse.rdf4j.sail.lmdb.LmdbUtil.E;
&nbsp;import static org.eclipse.rdf4j.sail.lmdb.LmdbUtil.openDatabase;
&nbsp;import static org.lwjgl.system.MemoryStack.stackPush;
&nbsp;import static org.lwjgl.system.MemoryUtil.NULL;
&nbsp;import static org.lwjgl.util.lmdb.LMDB.MDB_CREATE;
&nbsp;import static org.lwjgl.util.lmdb.LMDB.MDB_NEXT;
&nbsp;import static org.lwjgl.util.lmdb.LMDB.MDB_NOMETASYNC;
&nbsp;import static org.lwjgl.util.lmdb.LMDB.MDB_NOSYNC;
&nbsp;import static org.lwjgl.util.lmdb.LMDB.MDB_NOTLS;
&nbsp;import static org.lwjgl.util.lmdb.LMDB.MDB_PREV;
&nbsp;import static org.lwjgl.util.lmdb.LMDB.MDB_RESERVE;
&nbsp;import static org.lwjgl.util.lmdb.LMDB.MDB_SET_RANGE;
&nbsp;import static org.lwjgl.util.lmdb.LMDB.mdb_cursor_close;
&nbsp;import static org.lwjgl.util.lmdb.LMDB.mdb_cursor_get;
&nbsp;import static org.lwjgl.util.lmdb.LMDB.mdb_cursor_open;
&nbsp;import static org.lwjgl.util.lmdb.LMDB.mdb_env_close;
&nbsp;import static org.lwjgl.util.lmdb.LMDB.mdb_env_create;
&nbsp;import static org.lwjgl.util.lmdb.LMDB.mdb_env_info;
&nbsp;import static org.lwjgl.util.lmdb.LMDB.mdb_env_open;
&nbsp;import static org.lwjgl.util.lmdb.LMDB.mdb_env_set_mapsize;
&nbsp;import static org.lwjgl.util.lmdb.LMDB.mdb_get;
&nbsp;import static org.lwjgl.util.lmdb.LMDB.mdb_put;
&nbsp;import static org.lwjgl.util.lmdb.LMDB.mdb_stat;
&nbsp;import static org.lwjgl.util.lmdb.LMDB.mdb_txn_abort;
&nbsp;import static org.lwjgl.util.lmdb.LMDB.mdb_txn_begin;
&nbsp;import static org.lwjgl.util.lmdb.LMDB.mdb_txn_commit;
&nbsp;import static org.lwjgl.util.lmdb.LMDB.mdb_txn_renew;
&nbsp;import static org.lwjgl.util.lmdb.LMDB.mdb_txn_reset;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.nio.ByteBuffer;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Optional;
&nbsp;import java.util.concurrent.locks.ReadWriteLock;
&nbsp;import java.util.concurrent.locks.ReentrantReadWriteLock;
&nbsp;import java.util.zip.CRC32;
&nbsp;
&nbsp;import org.eclipse.rdf4j.common.io.ByteArrayUtil;
&nbsp;import org.eclipse.rdf4j.model.BNode;
&nbsp;import org.eclipse.rdf4j.model.IRI;
&nbsp;import org.eclipse.rdf4j.model.Literal;
&nbsp;import org.eclipse.rdf4j.model.Resource;
&nbsp;import org.eclipse.rdf4j.model.Value;
&nbsp;import org.eclipse.rdf4j.model.base.AbstractValueFactory;
&nbsp;import org.eclipse.rdf4j.model.base.CoreDatatype;
&nbsp;import org.eclipse.rdf4j.model.util.Literals;
&nbsp;import org.eclipse.rdf4j.sail.lmdb.LmdbUtil.Transaction;
&nbsp;import org.eclipse.rdf4j.sail.lmdb.config.LmdbStoreConfig;
&nbsp;import org.eclipse.rdf4j.sail.lmdb.model.LmdbBNode;
&nbsp;import org.eclipse.rdf4j.sail.lmdb.model.LmdbIRI;
&nbsp;import org.eclipse.rdf4j.sail.lmdb.model.LmdbLiteral;
&nbsp;import org.eclipse.rdf4j.sail.lmdb.model.LmdbResource;
&nbsp;import org.eclipse.rdf4j.sail.lmdb.model.LmdbValue;
&nbsp;import org.lwjgl.PointerBuffer;
&nbsp;import org.lwjgl.system.MemoryStack;
&nbsp;import org.lwjgl.util.lmdb.MDBEnvInfo;
&nbsp;import org.lwjgl.util.lmdb.MDBStat;
&nbsp;import org.lwjgl.util.lmdb.MDBVal;
&nbsp;
&nbsp;/**
&nbsp; * LMDB-based indexed storage and retrieval of RDF values. ValueStore maps RDF values to integer IDs and vice-versa.
&nbsp; */
&nbsp;class ValueStore extends AbstractValueFactory {
&nbsp;
&nbsp;	private static final byte URI_VALUE = 0x0; // 00
&nbsp;
&nbsp;	private static final byte LITERAL_VALUE = 0x1; // 01
&nbsp;
&nbsp;	private static final byte BNODE_VALUE = 0x2; // 10
&nbsp;
&nbsp;	private static final byte NAMESPACE_VALUE = 0x3; // 11
&nbsp;
&nbsp;	private static final byte ID_KEY = 0x4;
&nbsp;
&nbsp;	private static final byte HASH_KEY = 0x5;
&nbsp;
&nbsp;	private static final byte HASHID_KEY = 0x6;
&nbsp;
&nbsp;	/***
&nbsp;	 * Maximum size of keys before hashing is used (size of two long values)
&nbsp;	 */
&nbsp;	private static final int MAX_KEY_SIZE = 16;
&nbsp;	/**
&nbsp;	 * Used to do the actual storage of values, once they&#39;re translated to byte arrays.
&nbsp;	 */
&nbsp;	private final File dir;
&nbsp;	/**
&nbsp;	 * A simple cache containing the [VALUE_CACHE_SIZE] most-recently used values stored by their ID.
&nbsp;	 */
&nbsp;	private final LmdbValue[] valueCache;
&nbsp;	/**
&nbsp;	 * A simple cache containing the [ID_CACHE_SIZE] most-recently used value-IDs stored by their value.
&nbsp;	 */
&nbsp;	private final ConcurrentCache&lt;LmdbValue, Long&gt; valueIDCache;
&nbsp;	/**
&nbsp;	 * A simple cache containing the [NAMESPACE_CACHE_SIZE] most-recently used namespaces stored by their ID.
&nbsp;	 */
&nbsp;	private final ConcurrentCache&lt;Long, String&gt; namespaceCache;
&nbsp;	/**
&nbsp;	 * A simple cache containing the [NAMESPACE_ID_CACHE_SIZE] most-recently used namespace-IDs stored by their
&nbsp;	 * namespace.
&nbsp;	 */
&nbsp;	private final ConcurrentCache&lt;String, Long&gt; namespaceIDCache;
&nbsp;	/**
&nbsp;	 * Used to do the actual storage of values, once they&#39;re translated to byte arrays.
&nbsp;	 */
&nbsp;	private long env;
&nbsp;	private int pageSize;
&nbsp;	private long mapSize;
&nbsp;	private int dbi;
&nbsp;	private long writeTxn;
&nbsp;	private final boolean forceSync;
&nbsp;	private final boolean autoGrow;
&nbsp;	/** This lock is required to block transactions while auto-growing the map size. */
<b class="nc">&nbsp;	private final ReadWriteLock txnLock = new ReentrantReadWriteLock();</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * An object that indicates the revision of the value store, which is used to check if cached value IDs are still
&nbsp;	 * valid. In order to be valid, the ValueStoreRevision object of a LmdbValue needs to be equal to this object.
&nbsp;	 */
&nbsp;	private volatile ValueStoreRevision revision;
&nbsp;	/**
&nbsp;	 * The next ID that is associated with a stored value
&nbsp;	 */
&nbsp;	private long nextId;
&nbsp;
<b class="nc">&nbsp;	ValueStore(File dir, LmdbStoreConfig config) throws IOException {</b>
<b class="nc">&nbsp;		this.dir = dir;</b>
<b class="nc">&nbsp;		this.forceSync = config.getForceSync();</b>
<b class="nc">&nbsp;		this.autoGrow = config.getAutoGrow();</b>
<b class="nc">&nbsp;		this.mapSize = config.getValueDBSize();</b>
<b class="nc">&nbsp;		open();</b>
&nbsp;
<b class="nc">&nbsp;		valueCache = new LmdbValue[config.getValueCacheSize()];</b>
<b class="nc">&nbsp;		valueIDCache = new ConcurrentCache&lt;&gt;(config.getValueIDCacheSize());</b>
<b class="nc">&nbsp;		namespaceCache = new ConcurrentCache&lt;&gt;(config.getNamespaceCacheSize());</b>
<b class="nc">&nbsp;		namespaceIDCache = new ConcurrentCache&lt;&gt;(config.getNamespaceIDCacheSize());</b>
&nbsp;
<b class="nc">&nbsp;		setNewRevision();</b>
&nbsp;
&nbsp;		// read maximum id from store
<b class="nc">&nbsp;		readTransaction(env, (stack, txn) -&gt; {</b>
<b class="nc">&nbsp;			long cursor = 0;</b>
&nbsp;			try {
<b class="nc">&nbsp;				PointerBuffer pp = stack.mallocPointer(1);</b>
<b class="nc">&nbsp;				E(mdb_cursor_open(txn, dbi, pp));</b>
<b class="nc">&nbsp;				cursor = pp.get(0);</b>
&nbsp;
<b class="nc">&nbsp;				MDBVal keyData = MDBVal.calloc(stack);</b>
&nbsp;				// set cursor to min key
<b class="nc">&nbsp;				keyData.mv_data(stack.bytes(new byte[] { ID_KEY, (byte) 0xFF }));</b>
<b class="nc">&nbsp;				MDBVal valueData = MDBVal.calloc(stack);</b>
<b class="nc">&nbsp;				if (mdb_cursor_get(cursor, keyData, valueData, MDB_SET_RANGE) == 0 &amp;&amp;</b>
<b class="nc">&nbsp;						mdb_cursor_get(cursor, keyData, valueData, MDB_PREV) == 0) {</b>
&nbsp;					// remove lower 2 type bits
<b class="nc">&nbsp;					nextId = (data2id(keyData.mv_data()) &gt;&gt; 2) + 1;</b>
&nbsp;				} else {
<b class="nc">&nbsp;					nextId = 1;</b>
&nbsp;				}
<b class="nc">&nbsp;				return null;</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				if (cursor != 0) {</b>
<b class="nc">&nbsp;					mdb_cursor_close(cursor);</b>
&nbsp;				}
<b class="nc">&nbsp;			}</b>
&nbsp;		});
&nbsp;	}
&nbsp;
&nbsp;	private void open() throws IOException {
&nbsp;		// create directory if it not exists
<b class="nc">&nbsp;		dir.mkdirs();</b>
&nbsp;
<b class="nc">&nbsp;		try (MemoryStack stack = stackPush()) {</b>
<b class="nc">&nbsp;			PointerBuffer pp = stack.mallocPointer(1);</b>
<b class="nc">&nbsp;			E(mdb_env_create(pp));</b>
<b class="nc">&nbsp;			env = pp.get(0);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;
&nbsp;		// Open environment
<b class="nc">&nbsp;		int flags = MDB_NOTLS;</b>
<b class="nc">&nbsp;		if (!forceSync) {</b>
<b class="nc">&nbsp;			flags |= MDB_NOSYNC | MDB_NOMETASYNC;</b>
&nbsp;		}
<b class="nc">&nbsp;		E(mdb_env_open(env, dir.getAbsolutePath(), flags, 0664));</b>
&nbsp;
&nbsp;		// Open database
<b class="nc">&nbsp;		dbi = openDatabase(env, null, MDB_CREATE, null);</b>
&nbsp;
&nbsp;		// initialize page size and set map size for env
<b class="nc">&nbsp;		readTransaction(env, (stack, txn) -&gt; {</b>
<b class="nc">&nbsp;			MDBStat stat = MDBStat.malloc(stack);</b>
<b class="nc">&nbsp;			mdb_stat(txn, dbi, stat);</b>
&nbsp;
<b class="nc">&nbsp;			boolean isEmpty = stat.ms_entries() == 0;</b>
<b class="nc">&nbsp;			pageSize = stat.ms_psize();</b>
&nbsp;			// align map size with page size
<b class="nc">&nbsp;			long configMapSize = (mapSize / pageSize) * pageSize;</b>
<b class="nc">&nbsp;			if (isEmpty) {</b>
&nbsp;				// this is an empty db, use configured map size
<b class="nc">&nbsp;				mdb_env_set_mapsize(env, configMapSize);</b>
&nbsp;			}
<b class="nc">&nbsp;			MDBEnvInfo info = MDBEnvInfo.malloc(stack);</b>
<b class="nc">&nbsp;			mdb_env_info(env, info);</b>
<b class="nc">&nbsp;			mapSize = info.me_mapsize();</b>
<b class="nc">&nbsp;			if (mapSize &lt; configMapSize) {</b>
&nbsp;				// configured map size is larger than map size stored in env, increase map size
<b class="nc">&nbsp;				mdb_env_set_mapsize(env, configMapSize);</b>
<b class="nc">&nbsp;				mapSize = configMapSize;</b>
&nbsp;			}
<b class="nc">&nbsp;			return null;</b>
&nbsp;		});
&nbsp;	}
&nbsp;
&nbsp;	private long nextId(byte type) throws IOException {
<b class="nc">&nbsp;		long result = nextId;</b>
<b class="nc">&nbsp;		nextId++;</b>
&nbsp;		// encode type in lower 2 bits of id
<b class="nc">&nbsp;		result = (result &lt;&lt; 2) | type;</b>
<b class="nc">&nbsp;		return result;</b>
&nbsp;	}
&nbsp;
&nbsp;	protected ByteBuffer idBuffer(MemoryStack stack) {
<b class="nc">&nbsp;		return stack.malloc(2 + Long.BYTES);</b>
&nbsp;	}
&nbsp;
&nbsp;	protected ByteBuffer id2data(ByteBuffer bb, long id) {
<b class="nc">&nbsp;		bb.put(ID_KEY);</b>
<b class="nc">&nbsp;		Varint.writeUnsigned(bb, id);</b>
<b class="nc">&nbsp;		return bb;</b>
&nbsp;	}
&nbsp;
&nbsp;	protected long data2id(ByteBuffer bb) {
&nbsp;		// skip id marker
<b class="nc">&nbsp;		bb.get();</b>
<b class="nc">&nbsp;		return Varint.readUnsigned(bb);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Creates a new revision object for this value store, invalidating any IDs cached in LmdbValue objects that were
&nbsp;	 * created by this value store.
&nbsp;	 */
&nbsp;	private void setNewRevision() {
<b class="nc">&nbsp;		revision = new ValueStoreRevision(this);</b>
&nbsp;	}
&nbsp;
&nbsp;	public ValueStoreRevision getRevision() {
<b class="nc">&nbsp;		return revision;</b>
&nbsp;	}
&nbsp;
&nbsp;	protected byte[] getData(long id) throws IOException {
<b class="nc">&nbsp;		return readTransaction(env, (stack, txn) -&gt; {</b>
<b class="nc">&nbsp;			MDBVal keyData = MDBVal.calloc(stack);</b>
<b class="nc">&nbsp;			keyData.mv_data(id2data(idBuffer(stack), id).flip());</b>
<b class="nc">&nbsp;			MDBVal valueData = MDBVal.calloc(stack);</b>
<b class="nc">&nbsp;			if (mdb_get(txn, dbi, keyData, valueData) == 0) {</b>
<b class="nc">&nbsp;				byte[] valueBytes = new byte[valueData.mv_data().remaining()];</b>
<b class="nc">&nbsp;				valueData.mv_data().get(valueBytes);</b>
<b class="nc">&nbsp;				return valueBytes;</b>
&nbsp;			}
<b class="nc">&nbsp;			return null;</b>
&nbsp;		});
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Get value from cache by ID.
&nbsp;	 *
&nbsp;	 * Thread-safety with synchronized is not required here.
&nbsp;	 *
&nbsp;	 * @param id ID of a value object
&nbsp;	 * @return the value object or &lt;code&gt;null&lt;/code&gt; if not found
&nbsp;	 */
&nbsp;	LmdbValue cachedValue(long id) {
<b class="nc">&nbsp;		LmdbValue value = valueCache[(int) (id % valueCache.length)];</b>
<b class="nc">&nbsp;		if (value != null &amp;&amp; value.getInternalID() == id) {</b>
<b class="nc">&nbsp;			return value;</b>
&nbsp;		}
<b class="nc">&nbsp;		return null;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Cache value by ID.
&nbsp;	 *
&nbsp;	 * Thread-safety with synchronized is not required here.
&nbsp;	 *
&nbsp;	 * @param id    ID of a value object
&nbsp;	 * @param value ID of a value object
&nbsp;	 * @return the value object or &lt;code&gt;null&lt;/code&gt; if not found
&nbsp;	 */
&nbsp;	void cacheValue(long id, LmdbValue value) {
<b class="nc">&nbsp;		valueCache[(int) (id % valueCache.length)] = value;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets the value for the specified ID which is lazy initialized at a later point in time.
&nbsp;	 *
&nbsp;	 * @param id A value ID.
&nbsp;	 * @return The value for the ID, or &lt;tt&gt;null&lt;/tt&gt; no such value could be found.
&nbsp;	 * @throws IOException If an I/O error occurred.
&nbsp;	 */
&nbsp;	public LmdbValue getLazyValue(long id) throws IOException {
&nbsp;		// Check value cache
<b class="nc">&nbsp;		Long cacheID = id;</b>
<b class="nc">&nbsp;		LmdbValue resultValue = cachedValue(cacheID);</b>
&nbsp;
<b class="nc">&nbsp;		if (resultValue == null) {</b>
<b class="nc">&nbsp;			switch ((byte) (id &amp; 0x3)) {</b>
&nbsp;			case URI_VALUE:
<b class="nc">&nbsp;				resultValue = new LmdbIRI(revision, id);</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			case LITERAL_VALUE:
<b class="nc">&nbsp;				resultValue = new LmdbLiteral(revision, id);</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			case BNODE_VALUE:
<b class="nc">&nbsp;				resultValue = new LmdbBNode(revision, id);</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			default:
<b class="nc">&nbsp;				throw new IOException(&quot;Unsupported value with type id &quot; + (id &amp; 0x3));</b>
&nbsp;			}
&nbsp;			// Store value in cache
<b class="nc">&nbsp;			cacheValue(cacheID, resultValue);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return resultValue;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets the value for the specified ID.
&nbsp;	 *
&nbsp;	 * @param id A value ID.
&nbsp;	 * @return The value for the ID, or &lt;tt&gt;null&lt;/tt&gt; no such value could be found.
&nbsp;	 * @throws IOException If an I/O error occurred.
&nbsp;	 */
&nbsp;	public LmdbValue getValue(long id) throws IOException {
&nbsp;		// Check value cache
<b class="nc">&nbsp;		Long cacheID = id;</b>
<b class="nc">&nbsp;		LmdbValue resultValue = cachedValue(cacheID);</b>
&nbsp;
<b class="nc">&nbsp;		if (resultValue == null) {</b>
&nbsp;			// Value not in cache, fetch it from file
<b class="nc">&nbsp;			byte[] data = getData(id);</b>
&nbsp;
<b class="nc">&nbsp;			if (data != null) {</b>
<b class="nc">&nbsp;				resultValue = data2value(id, data, null);</b>
&nbsp;				// Store value in cache
<b class="nc">&nbsp;				cacheValue(cacheID, resultValue);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return resultValue;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Initializes the value for the specified ID.
&nbsp;	 *
&nbsp;	 * @param id    A value ID.
&nbsp;	 * @param value Existing value that should be resolved.
&nbsp;	 * @return &lt;code&gt;true&lt;/code&gt; if value could be successfully resolved, else &lt;code&gt;false&lt;/code&gt;
&nbsp;	 */
&nbsp;	public boolean resolveValue(long id, LmdbValue value) {
&nbsp;		try {
<b class="nc">&nbsp;			byte[] data = getData(id);</b>
<b class="nc">&nbsp;			if (data != null) {</b>
<b class="nc">&nbsp;				data2value(id, data, value);</b>
<b class="nc">&nbsp;				return true;</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (IOException e) {</b>
&nbsp;			// should not happen
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private void resizeMap(long txn, int requiredSize) throws IOException {
<b class="nc">&nbsp;		if (autoGrow) {</b>
<b class="nc">&nbsp;			if (LmdbUtil.requiresResize(mapSize, pageSize, txn, requiredSize)) {</b>
&nbsp;				// map is full, resize
<b class="nc">&nbsp;				txnLock.readLock().unlock();</b>
<b class="nc">&nbsp;				txnLock.writeLock().lock();</b>
&nbsp;				try {
<b class="nc">&nbsp;					boolean activeWriteTxn = writeTxn != 0;</b>
<b class="nc">&nbsp;					boolean txnIsRead = txn != writeTxn;</b>
<b class="nc">&nbsp;					if (txnIsRead) {</b>
<b class="nc">&nbsp;						mdb_txn_reset(txn);</b>
&nbsp;					}
<b class="nc">&nbsp;					if (activeWriteTxn) {</b>
<b class="nc">&nbsp;						endTransaction(true);</b>
&nbsp;					}
<b class="nc">&nbsp;					mapSize = LmdbUtil.autoGrowMapSize(mapSize, pageSize, requiredSize);</b>
<b class="nc">&nbsp;					E(mdb_env_set_mapsize(env, mapSize));</b>
<b class="nc">&nbsp;					if (activeWriteTxn) {</b>
<b class="nc">&nbsp;						startTransaction();</b>
&nbsp;					}
<b class="nc">&nbsp;					if (txnIsRead) {</b>
<b class="nc">&nbsp;						E(mdb_txn_renew(txn));</b>
&nbsp;					}
&nbsp;				} finally {
<b class="nc">&nbsp;					txnLock.writeLock().unlock();</b>
<b class="nc">&nbsp;					txnLock.readLock().lock();</b>
<b class="nc">&nbsp;				}</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private long findId(byte[] data, boolean create) throws IOException {
<b class="nc">&nbsp;		Long id = readTransaction(env, (stack, txn) -&gt; {</b>
<b class="nc">&nbsp;			if (data.length &lt; MAX_KEY_SIZE) {</b>
<b class="nc">&nbsp;				MDBVal dataVal = MDBVal.calloc(stack);</b>
<b class="nc">&nbsp;				dataVal.mv_data(stack.bytes(data));</b>
<b class="nc">&nbsp;				MDBVal idVal = MDBVal.calloc(stack);</b>
<b class="nc">&nbsp;				if (mdb_get(txn, dbi, dataVal, idVal) == 0) {</b>
<b class="nc">&nbsp;					return data2id(idVal.mv_data());</b>
&nbsp;				}
<b class="nc">&nbsp;				if (!create) {</b>
<b class="nc">&nbsp;					return null;</b>
&nbsp;				}
&nbsp;				// id was not found, create a new one
<b class="nc">&nbsp;				resizeMap(txn, 2 * data.length + 2 * (2 + Long.BYTES));</b>
&nbsp;
<b class="nc">&nbsp;				long newId = nextId(data[0]);</b>
<b class="nc">&nbsp;				writeTransaction((stack2, writeTxn) -&gt; {</b>
<b class="nc">&nbsp;					idVal.mv_data(id2data(idBuffer(stack), newId).flip());</b>
&nbsp;
<b class="nc">&nbsp;					E(mdb_put(writeTxn, dbi, dataVal, idVal, 0));</b>
<b class="nc">&nbsp;					E(mdb_put(writeTxn, dbi, idVal, dataVal, 0));</b>
<b class="nc">&nbsp;					return null;</b>
&nbsp;				});
<b class="nc">&nbsp;				return newId;</b>
&nbsp;			} else {
<b class="nc">&nbsp;				MDBVal idVal = MDBVal.calloc(stack);</b>
&nbsp;
<b class="nc">&nbsp;				ByteBuffer dataBb = ByteBuffer.wrap(data);</b>
<b class="nc">&nbsp;				long dataHash = hash(data);</b>
<b class="nc">&nbsp;				int maxHashKeyLength = 2 + 2 * Long.BYTES + 2;</b>
<b class="nc">&nbsp;				ByteBuffer hashBb = stack.malloc(maxHashKeyLength);</b>
<b class="nc">&nbsp;				hashBb.put(HASH_KEY);</b>
<b class="nc">&nbsp;				Varint.writeUnsigned(hashBb, dataHash);</b>
<b class="nc">&nbsp;				int hashLength = hashBb.position();</b>
<b class="nc">&nbsp;				hashBb.flip();</b>
&nbsp;
<b class="nc">&nbsp;				MDBVal hashVal = MDBVal.calloc(stack);</b>
<b class="nc">&nbsp;				hashVal.mv_data(hashBb);</b>
<b class="nc">&nbsp;				MDBVal dataVal = MDBVal.calloc(stack);</b>
&nbsp;
&nbsp;				// ID of first value is directly stored with hash as key
<b class="nc">&nbsp;				if (mdb_get(txn, dbi, hashVal, dataVal) == 0) {</b>
<b class="nc">&nbsp;					idVal.mv_data(dataVal.mv_data());</b>
<b class="nc">&nbsp;					if (mdb_get(txn, dbi, idVal, dataVal) == 0 &amp;&amp;</b>
<b class="nc">&nbsp;							dataVal.mv_data().compareTo(dataBb) == 0) {</b>
<b class="nc">&nbsp;						return data2id(idVal.mv_data());</b>
&nbsp;					}
&nbsp;				} else {
&nbsp;					// no value for hash exists
<b class="nc">&nbsp;					if (!create) {</b>
<b class="nc">&nbsp;						return null;</b>
&nbsp;					}
&nbsp;
<b class="nc">&nbsp;					resizeMap(txn, 2 * data.length + 2 * (2 + Long.BYTES));</b>
&nbsp;
<b class="nc">&nbsp;					long newId = nextId(data[0]);</b>
<b class="nc">&nbsp;					writeTransaction((stack2, writeTxn) -&gt; {</b>
<b class="nc">&nbsp;						dataVal.mv_size(data.length);</b>
<b class="nc">&nbsp;						idVal.mv_data(id2data(idBuffer(stack), newId).flip());</b>
&nbsp;
&nbsp;						// store mapping of hash -&gt; ID
<b class="nc">&nbsp;						E(mdb_put(txn, dbi, hashVal, idVal, 0));</b>
&nbsp;						// store mapping of ID -&gt; data
<b class="nc">&nbsp;						E(mdb_put(writeTxn, dbi, idVal, dataVal, MDB_RESERVE));</b>
<b class="nc">&nbsp;						dataVal.mv_data().put(data);</b>
<b class="nc">&nbsp;						return null;</b>
&nbsp;					});
<b class="nc">&nbsp;					return newId;</b>
&nbsp;				}
&nbsp;
&nbsp;				// test existing entries for hash key against given value
<b class="nc">&nbsp;				hashBb.put(0, HASHID_KEY);</b>
<b class="nc">&nbsp;				hashVal.mv_data(hashBb);</b>
&nbsp;
<b class="nc">&nbsp;				long cursor = 0;</b>
&nbsp;				try {
<b class="nc">&nbsp;					PointerBuffer pp = stack.mallocPointer(1);</b>
<b class="nc">&nbsp;					E(mdb_cursor_open(txn, dbi, pp));</b>
<b class="nc">&nbsp;					cursor = pp.get(0);</b>
&nbsp;
&nbsp;					// iterate all entries for hash value
<b class="nc">&nbsp;					if (mdb_cursor_get(cursor, hashVal, dataVal, MDB_SET_RANGE) == 0) {</b>
&nbsp;						do {
<b class="nc">&nbsp;							if (compareRegion(hashVal.mv_data(), 0, hashBb, 0, hashLength) != 0) {</b>
<b class="nc">&nbsp;								break;</b>
&nbsp;							}
&nbsp;
&nbsp;							// use only ID part of key for lookup of data
<b class="nc">&nbsp;							ByteBuffer hashIdBb = hashVal.mv_data();</b>
<b class="nc">&nbsp;							hashIdBb.position(hashLength);</b>
<b class="nc">&nbsp;							idVal.mv_data(hashIdBb);</b>
<b class="nc">&nbsp;							if (mdb_get(txn, dbi, idVal, dataVal) == 0 &amp;&amp;</b>
<b class="nc">&nbsp;									dataVal.mv_data().compareTo(dataBb) == 0) {</b>
&nbsp;								// id was found if stored value is equal to requested value
<b class="nc">&nbsp;								return data2id(hashIdBb);</b>
&nbsp;							}
<b class="nc">&nbsp;						} while (mdb_cursor_get(cursor, hashVal, dataVal, MDB_NEXT) == 0);</b>
&nbsp;					}
&nbsp;				} finally {
<b class="nc">&nbsp;					if (cursor != 0) {</b>
<b class="nc">&nbsp;						mdb_cursor_close(cursor);</b>
&nbsp;					}
<b class="nc">&nbsp;				}</b>
&nbsp;
<b class="nc">&nbsp;				if (!create) {</b>
<b class="nc">&nbsp;					return null;</b>
&nbsp;				}
&nbsp;
&nbsp;				// id was not found, create a new one
<b class="nc">&nbsp;				resizeMap(txn, 1 + Long.BYTES + maxHashKeyLength + 2 * data.length);</b>
&nbsp;
<b class="nc">&nbsp;				long newId = nextId(data[0]);</b>
<b class="nc">&nbsp;				writeTransaction((stack2, writeTxn) -&gt; {</b>
&nbsp;					// encode ID
<b class="nc">&nbsp;					ByteBuffer idBb = id2data(idBuffer(stack), newId).flip();</b>
<b class="nc">&nbsp;					idVal.mv_data(idBb);</b>
&nbsp;
&nbsp;					// encode hash and ID
<b class="nc">&nbsp;					hashBb.limit(hashBb.capacity());</b>
<b class="nc">&nbsp;					hashBb.position(hashLength);</b>
<b class="nc">&nbsp;					hashBb.put(idBb);</b>
<b class="nc">&nbsp;					idBb.rewind();</b>
<b class="nc">&nbsp;					hashBb.flip();</b>
<b class="nc">&nbsp;					hashVal.mv_data(hashBb);</b>
&nbsp;
&nbsp;					// store mapping of hash+ID -&gt; []
<b class="nc">&nbsp;					dataVal.mv_data(stack.bytes());</b>
<b class="nc">&nbsp;					E(mdb_put(txn, dbi, hashVal, dataVal, 0));</b>
&nbsp;
<b class="nc">&nbsp;					dataVal.mv_size(data.length);</b>
&nbsp;					// store mapping of ID -&gt; data
<b class="nc">&nbsp;					E(mdb_put(txn, dbi, idVal, dataVal, MDB_RESERVE));</b>
<b class="nc">&nbsp;					dataVal.mv_data().put(data);</b>
<b class="nc">&nbsp;					return null;</b>
&nbsp;				});
<b class="nc">&nbsp;				return newId;</b>
&nbsp;			}
&nbsp;		});
<b class="nc">&nbsp;		return id != null ? id : LmdbValue.UNKNOWN_ID;</b>
&nbsp;	}
&nbsp;
&nbsp;	&lt;T&gt; T readTransaction(long env, Transaction&lt;T&gt; transaction) throws IOException {
<b class="nc">&nbsp;		txnLock.readLock().lock();</b>
&nbsp;		try {
<b class="nc">&nbsp;			return LmdbUtil.readTransaction(env, writeTxn, transaction);</b>
&nbsp;		} finally {
<b class="nc">&nbsp;			txnLock.readLock().unlock();</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	&lt;T&gt; T writeTransaction(Transaction&lt;T&gt; transaction) throws IOException {
<b class="nc">&nbsp;		if (writeTxn != 0) {</b>
<b class="nc">&nbsp;			try (MemoryStack stack = MemoryStack.stackPush()) {</b>
<b class="nc">&nbsp;				return transaction.exec(stack, writeTxn);</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		} else {
<b class="nc">&nbsp;			return LmdbUtil.transaction(env, transaction);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	int compareRegion(ByteBuffer array1, int startIdx1, ByteBuffer array2, int startIdx2, int length) {
<b class="nc">&nbsp;		int result = 0;</b>
<b class="nc">&nbsp;		for (int i = 0; result == 0 &amp;&amp; i &lt; length; i++) {</b>
<b class="nc">&nbsp;			result = (array1.get(startIdx1 + i) &amp; 0xff) - (array2.get(startIdx2 + i) &amp; 0xff);</b>
&nbsp;		}
<b class="nc">&nbsp;		return result;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets the ID for the specified value.
&nbsp;	 *
&nbsp;	 * @param value A value.
&nbsp;	 * @return The ID for the specified value, or {@link LmdbValue#UNKNOWN_ID} if no such ID could be found.
&nbsp;	 * @throws IOException If an I/O error occurred.
&nbsp;	 */
&nbsp;	public long getId(Value value) throws IOException {
<b class="nc">&nbsp;		return getId(value, false);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets the ID for the specified value.
&nbsp;	 *
&nbsp;	 * @param value A value.
&nbsp;	 * @return The ID for the specified value, or {@link LmdbValue#UNKNOWN_ID} if no such ID could be found.
&nbsp;	 * @throws IOException If an I/O error occurred.
&nbsp;	 */
&nbsp;	public long getId(Value value, boolean create) throws IOException {
&nbsp;		// Try to get the internal ID from the value itself
<b class="nc">&nbsp;		boolean isOwnValue = isOwnValue(value);</b>
&nbsp;
<b class="nc">&nbsp;		if (isOwnValue) {</b>
<b class="nc">&nbsp;			LmdbValue lmdbValue = (LmdbValue) value;</b>
&nbsp;
<b class="nc">&nbsp;			if (revisionIsCurrent(lmdbValue)) {</b>
<b class="nc">&nbsp;				long id = lmdbValue.getInternalID();</b>
&nbsp;
<b class="nc">&nbsp;				if (id != LmdbValue.UNKNOWN_ID) {</b>
<b class="nc">&nbsp;					return id;</b>
&nbsp;				}
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		// Check cache
<b class="nc">&nbsp;		Long cachedID = valueIDCache.get(value);</b>
&nbsp;
<b class="nc">&nbsp;		if (cachedID != null) {</b>
<b class="nc">&nbsp;			long id = cachedID;</b>
&nbsp;
<b class="nc">&nbsp;			if (isOwnValue) {</b>
&nbsp;				// Store id in value for fast access in any consecutive calls
<b class="nc">&nbsp;				((LmdbValue) value).setInternalID(id, revision);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			return id;</b>
&nbsp;		}
&nbsp;
&nbsp;		// ID not cached, search in file
<b class="nc">&nbsp;		byte[] data = value2data(value, create);</b>
<b class="nc">&nbsp;		if (data == null &amp;&amp; value instanceof Literal) {</b>
<b class="nc">&nbsp;			data = literal2legacy((Literal) value);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (data != null) {</b>
<b class="nc">&nbsp;			long id = findId(data, create);</b>
&nbsp;
<b class="nc">&nbsp;			if (id != LmdbValue.UNKNOWN_ID) {</b>
<b class="nc">&nbsp;				if (isOwnValue) {</b>
&nbsp;					// Store id in value for fast access in any consecutive calls
<b class="nc">&nbsp;					((LmdbValue) value).setInternalID(id, revision);</b>
&nbsp;					// Store id in cache
<b class="nc">&nbsp;					valueIDCache.put((LmdbValue) value, id);</b>
&nbsp;				} else {
&nbsp;					// Store id in cache
<b class="nc">&nbsp;					LmdbValue nv = getLmdbValue(value);</b>
<b class="nc">&nbsp;					nv.setInternalID(id, revision);</b>
<b class="nc">&nbsp;					valueIDCache.put(nv, id);</b>
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			return id;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return LmdbValue.UNKNOWN_ID;</b>
&nbsp;	}
&nbsp;
&nbsp;	public void startTransaction() throws IOException {
<b class="nc">&nbsp;		try (MemoryStack stack = stackPush()) {</b>
<b class="nc">&nbsp;			PointerBuffer pp = stack.mallocPointer(1);</b>
&nbsp;
<b class="nc">&nbsp;			E(mdb_txn_begin(env, NULL, 0, pp));</b>
<b class="nc">&nbsp;			writeTxn = pp.get(0);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Closes the snapshot and the DB iterator if any was opened in the current transaction
&nbsp;	 */
&nbsp;	void endTransaction(boolean commit) throws IOException {
<b class="nc">&nbsp;		if (writeTxn != 0) {</b>
<b class="nc">&nbsp;			if (commit) {</b>
<b class="nc">&nbsp;				E(mdb_txn_commit(writeTxn));</b>
&nbsp;			} else {
<b class="nc">&nbsp;				mdb_txn_abort(writeTxn);</b>
&nbsp;			}
<b class="nc">&nbsp;			writeTxn = 0;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public void commit() throws IOException {
<b class="nc">&nbsp;		endTransaction(true);</b>
&nbsp;	}
&nbsp;
&nbsp;	public void rollback() throws IOException {
<b class="nc">&nbsp;		endTransaction(false);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Stores the supplied value and returns the ID that has been assigned to it. In case the value was already present,
&nbsp;	 * the value will not be stored again and the ID of the existing value is returned.
&nbsp;	 *
&nbsp;	 * @param value The Value to store.
&nbsp;	 * @return The ID that has been assigned to the value.
&nbsp;	 * @throws IOException If an I/O error occurred.
&nbsp;	 */
&nbsp;	public long storeValue(Value value) throws IOException {
<b class="nc">&nbsp;		return getId(value, true);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Computes a hash code for the supplied data.
&nbsp;	 *
&nbsp;	 * @param data The data to calculate the hash code for.
&nbsp;	 * @return A hash code for the supplied data.
&nbsp;	 */
&nbsp;	private long hash(byte[] data) {
<b class="nc">&nbsp;		CRC32 crc32 = new CRC32();</b>
<b class="nc">&nbsp;		crc32.update(data);</b>
<b class="nc">&nbsp;		return crc32.getValue();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Removes all values from the ValueStore.
&nbsp;	 *
&nbsp;	 * @throws IOException If an I/O error occurred.
&nbsp;	 */
&nbsp;	public void clear() throws IOException {
<b class="nc">&nbsp;		close();</b>
&nbsp;
<b class="nc">&nbsp;		new File(dir, &quot;data.mdb&quot;).delete();</b>
<b class="nc">&nbsp;		new File(dir, &quot;lock.mdb&quot;).delete();</b>
&nbsp;
<b class="nc">&nbsp;		Arrays.fill(valueCache, null);</b>
<b class="nc">&nbsp;		valueIDCache.clear();</b>
<b class="nc">&nbsp;		namespaceCache.clear();</b>
<b class="nc">&nbsp;		namespaceIDCache.clear();</b>
&nbsp;
<b class="nc">&nbsp;		open();</b>
&nbsp;
<b class="nc">&nbsp;		setNewRevision();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Closes the ValueStore, releasing any file references, etc. Once closed, the ValueStore can no longer be used.
&nbsp;	 *
&nbsp;	 * @throws IOException If an I/O error occurred.
&nbsp;	 */
&nbsp;	public void close() throws IOException {
<b class="nc">&nbsp;		if (env != 0) {</b>
<b class="nc">&nbsp;			endTransaction(false);</b>
<b class="nc">&nbsp;			mdb_env_close(env);</b>
<b class="nc">&nbsp;			env = 0;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Checks if the supplied Value object is a LmdbValue object that has been created by this ValueStore.
&nbsp;	 */
&nbsp;	private boolean isOwnValue(Value value) {
<b class="nc">&nbsp;		return value instanceof LmdbValue &amp;&amp; ((LmdbValue) value).getValueStoreRevision().getValueStore() == this;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Checks if the revision of the supplied value object is still current.
&nbsp;	 */
&nbsp;	private boolean revisionIsCurrent(LmdbValue value) {
<b class="nc">&nbsp;		return revision.equals(value.getValueStoreRevision());</b>
&nbsp;	}
&nbsp;
&nbsp;	private byte[] value2data(Value value, boolean create) throws IOException {
<b class="nc">&nbsp;		if (value instanceof IRI) {</b>
<b class="nc">&nbsp;			return uri2data((IRI) value, create);</b>
<b class="nc">&nbsp;		} else if (value instanceof BNode) {</b>
<b class="nc">&nbsp;			return bnode2data((BNode) value, create);</b>
<b class="nc">&nbsp;		} else if (value instanceof Literal) {</b>
<b class="nc">&nbsp;			return literal2data((Literal) value, create);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			throw new IllegalArgumentException(&quot;value parameter should be a URI, BNode or Literal&quot;);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private byte[] uri2data(IRI uri, boolean create) throws IOException {
<b class="nc">&nbsp;		long nsID = getNamespaceID(uri.getNamespace(), create);</b>
&nbsp;
<b class="nc">&nbsp;		if (nsID == -1) {</b>
&nbsp;			// Unknown namespace means unknown URI
<b class="nc">&nbsp;			return null;</b>
&nbsp;		}
&nbsp;
&nbsp;		// Get local name in UTF-8
<b class="nc">&nbsp;		byte[] localNameData = uri.getLocalName().getBytes(StandardCharsets.UTF_8);</b>
&nbsp;
&nbsp;		// Combine parts in a single byte array
<b class="nc">&nbsp;		int nsIDLength = Varint.calcLengthUnsigned(nsID);</b>
<b class="nc">&nbsp;		byte[] uriData = new byte[1 + nsIDLength + localNameData.length];</b>
<b class="nc">&nbsp;		uriData[0] = URI_VALUE;</b>
<b class="nc">&nbsp;		Varint.writeUnsigned(ByteBuffer.wrap(uriData, 1, nsIDLength), nsID);</b>
<b class="nc">&nbsp;		ByteArrayUtil.put(localNameData, uriData, 1 + nsIDLength);</b>
&nbsp;
<b class="nc">&nbsp;		return uriData;</b>
&nbsp;	}
&nbsp;
&nbsp;	private byte[] bnode2data(BNode bNode, boolean create) throws IOException {
<b class="nc">&nbsp;		byte[] idData = bNode.getID().getBytes(StandardCharsets.UTF_8);</b>
&nbsp;
<b class="nc">&nbsp;		byte[] bNodeData = new byte[1 + idData.length];</b>
<b class="nc">&nbsp;		bNodeData[0] = BNODE_VALUE;</b>
<b class="nc">&nbsp;		ByteArrayUtil.put(idData, bNodeData, 1);</b>
&nbsp;
<b class="nc">&nbsp;		return bNodeData;</b>
&nbsp;	}
&nbsp;
&nbsp;	private byte[] literal2data(Literal literal, boolean create) throws IOException {
<b class="nc">&nbsp;		return literal2data(literal.getLabel(), literal.getLanguage(), literal.getDatatype(), create);</b>
&nbsp;	}
&nbsp;
&nbsp;	private byte[] literal2legacy(Literal literal) throws IOException {
<b class="nc">&nbsp;		IRI dt = literal.getDatatype();</b>
<b class="nc">&nbsp;		if (org.eclipse.rdf4j.model.vocabulary.XSD.STRING.equals(dt)</b>
<b class="nc">&nbsp;				|| org.eclipse.rdf4j.model.vocabulary.RDF.LANGSTRING.equals(dt)) {</b>
<b class="nc">&nbsp;			return literal2data(literal.getLabel(), literal.getLanguage(), null, false);</b>
&nbsp;		}
<b class="nc">&nbsp;		return literal2data(literal.getLabel(), literal.getLanguage(), dt, false);</b>
&nbsp;	}
&nbsp;
&nbsp;	private byte[] literal2data(String label, Optional&lt;String&gt; lang, IRI dt, boolean create)
&nbsp;			throws IOException {
&nbsp;		// Get datatype ID
<b class="nc">&nbsp;		long datatypeID = LmdbValue.UNKNOWN_ID;</b>
&nbsp;
<b class="nc">&nbsp;		if (dt != null) {</b>
<b class="nc">&nbsp;			datatypeID = getId(dt, create);</b>
&nbsp;
<b class="nc">&nbsp;			if (datatypeID == LmdbValue.UNKNOWN_ID) {</b>
&nbsp;				// Unknown datatype means unknown literal
<b class="nc">&nbsp;				return null;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		// Get language tag in UTF-8
<b class="nc">&nbsp;		byte[] langData = null;</b>
<b class="nc">&nbsp;		int langDataLength = 0;</b>
<b class="nc">&nbsp;		if (lang.isPresent()) {</b>
<b class="nc">&nbsp;			langData = lang.get().getBytes(StandardCharsets.UTF_8);</b>
<b class="nc">&nbsp;			langDataLength = langData.length;</b>
&nbsp;		}
&nbsp;
&nbsp;		// Get label in UTF-8
<b class="nc">&nbsp;		byte[] labelData = label.getBytes(StandardCharsets.UTF_8);</b>
&nbsp;
&nbsp;		// Combine parts in a single byte array
<b class="nc">&nbsp;		int datatypeIDLength = Varint.calcLengthUnsigned(datatypeID);</b>
<b class="nc">&nbsp;		byte[] literalData = new byte[2 + datatypeIDLength + langDataLength + labelData.length];</b>
<b class="nc">&nbsp;		ByteBuffer bb = ByteBuffer.wrap(literalData);</b>
<b class="nc">&nbsp;		bb.put(LITERAL_VALUE);</b>
<b class="nc">&nbsp;		Varint.writeUnsigned(bb, datatypeID);</b>
<b class="nc">&nbsp;		bb.put((byte) langDataLength);</b>
<b class="nc">&nbsp;		if (langData != null) {</b>
<b class="nc">&nbsp;			bb.put(langData);</b>
&nbsp;		}
<b class="nc">&nbsp;		bb.put(labelData);</b>
&nbsp;
<b class="nc">&nbsp;		return literalData;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean isNamespaceData(byte[] data) {
<b class="nc">&nbsp;		return data[0] == NAMESPACE_VALUE;</b>
&nbsp;	}
&nbsp;
&nbsp;	private LmdbValue data2value(long id, byte[] data, LmdbValue value) throws IOException {
<b class="nc">&nbsp;		switch (data[0]) {</b>
&nbsp;		case URI_VALUE:
<b class="nc">&nbsp;			return data2uri(id, data, (LmdbIRI) value);</b>
&nbsp;		case BNODE_VALUE:
<b class="nc">&nbsp;			return data2bnode(id, data, (LmdbBNode) value);</b>
&nbsp;		case LITERAL_VALUE:
<b class="nc">&nbsp;			return data2literal(id, data, (LmdbLiteral) value);</b>
&nbsp;		default:
<b class="nc">&nbsp;			throw new IllegalArgumentException(&quot;Invalid type &quot; + data[0] + &quot; for value with id &quot; + id);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private LmdbIRI data2uri(long id, byte[] data, LmdbIRI value) throws IOException {
<b class="nc">&nbsp;		ByteBuffer bb = ByteBuffer.wrap(data);</b>
&nbsp;		// skip type marker
<b class="nc">&nbsp;		bb.get();</b>
<b class="nc">&nbsp;		long nsID = Varint.readUnsigned(bb);</b>
<b class="nc">&nbsp;		String namespace = getNamespace(nsID);</b>
<b class="nc">&nbsp;		String localName = new String(data, bb.position(), bb.remaining(), StandardCharsets.UTF_8);</b>
&nbsp;
<b class="nc">&nbsp;		if (value == null) {</b>
<b class="nc">&nbsp;			return new LmdbIRI(revision, namespace, localName, id);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			value.setIRIString(namespace + localName);</b>
<b class="nc">&nbsp;			return value;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private LmdbBNode data2bnode(long id, byte[] data, LmdbBNode value) throws IOException {
<b class="nc">&nbsp;		String nodeID = new String(data, 1, data.length - 1, StandardCharsets.UTF_8);</b>
<b class="nc">&nbsp;		if (value == null) {</b>
<b class="nc">&nbsp;			return new LmdbBNode(revision, nodeID, id);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			value.setID(nodeID);</b>
<b class="nc">&nbsp;			return value;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private LmdbLiteral data2literal(long id, byte[] data, LmdbLiteral value) throws IOException {
<b class="nc">&nbsp;		ByteBuffer bb = ByteBuffer.wrap(data);</b>
&nbsp;		// skip type marker
<b class="nc">&nbsp;		bb.get();</b>
&nbsp;		// Get datatype
<b class="nc">&nbsp;		long datatypeID = Varint.readUnsigned(bb);</b>
<b class="nc">&nbsp;		IRI datatype = null;</b>
<b class="nc">&nbsp;		if (datatypeID != LmdbValue.UNKNOWN_ID) {</b>
<b class="nc">&nbsp;			datatype = (IRI) getValue(datatypeID);</b>
&nbsp;		}
&nbsp;
&nbsp;		// Get language tag
<b class="nc">&nbsp;		String lang = null;</b>
<b class="nc">&nbsp;		int langLength = bb.get() &amp; 0xFF;</b>
<b class="nc">&nbsp;		if (langLength &gt; 0) {</b>
<b class="nc">&nbsp;			lang = new String(data, bb.position(), langLength, StandardCharsets.UTF_8);</b>
&nbsp;		}
&nbsp;
&nbsp;		// Get label
<b class="nc">&nbsp;		String label = new String(data, bb.position() + langLength, data.length - bb.position() - langLength,</b>
&nbsp;				StandardCharsets.UTF_8);
&nbsp;
<b class="nc">&nbsp;		if (value == null) {</b>
<b class="nc">&nbsp;			if (lang != null) {</b>
<b class="nc">&nbsp;				return new LmdbLiteral(revision, label, lang, id);</b>
<b class="nc">&nbsp;			} else if (datatype != null) {</b>
<b class="nc">&nbsp;				return new LmdbLiteral(revision, label, datatype, id);</b>
&nbsp;			} else {
<b class="nc">&nbsp;				return new LmdbLiteral(revision, label, org.eclipse.rdf4j.model.vocabulary.XSD.STRING, id);</b>
&nbsp;			}
&nbsp;		} else {
<b class="nc">&nbsp;			value.setLabel(label);</b>
<b class="nc">&nbsp;			if (lang != null) {</b>
<b class="nc">&nbsp;				value.setLanguage(lang);</b>
<b class="nc">&nbsp;				value.setDatatype(CoreDatatype.RDF.LANGSTRING);</b>
<b class="nc">&nbsp;			} else if (datatype != null) {</b>
<b class="nc">&nbsp;				value.setDatatype(datatype);</b>
&nbsp;			} else {
<b class="nc">&nbsp;				value.setDatatype(CoreDatatype.XSD.STRING);</b>
&nbsp;			}
<b class="nc">&nbsp;			return value;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private String data2namespace(byte[] data) {
<b class="nc">&nbsp;		return new String(data, 1, data.length - 1, StandardCharsets.UTF_8);</b>
&nbsp;	}
&nbsp;
&nbsp;	private long getNamespaceID(String namespace, boolean create) throws IOException {
<b class="nc">&nbsp;		Long cacheID = namespaceIDCache.get(namespace);</b>
<b class="nc">&nbsp;		if (cacheID != null) {</b>
<b class="nc">&nbsp;			return cacheID;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		byte[] namespaceBytes = namespace.getBytes(StandardCharsets.UTF_8);</b>
<b class="nc">&nbsp;		byte[] namespaceData = new byte[namespaceBytes.length + 1];</b>
<b class="nc">&nbsp;		namespaceData[0] = NAMESPACE_VALUE;</b>
<b class="nc">&nbsp;		System.arraycopy(namespaceBytes, 0, namespaceData, 1, namespaceBytes.length);</b>
&nbsp;
<b class="nc">&nbsp;		long id = findId(namespaceData, create);</b>
<b class="nc">&nbsp;		if (id != LmdbValue.UNKNOWN_ID) {</b>
<b class="nc">&nbsp;			namespaceIDCache.put(namespace, id);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return id;</b>
&nbsp;	}
&nbsp;
&nbsp;	/*-------------------------------------*
&nbsp;	 * Methods from interface ValueFactory *
&nbsp;	 *-------------------------------------*/
&nbsp;
&nbsp;	private String getNamespace(long id) throws IOException {
<b class="nc">&nbsp;		Long cacheID = id;</b>
<b class="nc">&nbsp;		String namespace = namespaceCache.get(cacheID);</b>
&nbsp;
<b class="nc">&nbsp;		if (namespace == null) {</b>
<b class="nc">&nbsp;			byte[] namespaceData = getData(id);</b>
<b class="nc">&nbsp;			if (namespaceData != null) {</b>
<b class="nc">&nbsp;				namespace = data2namespace(namespaceData);</b>
<b class="nc">&nbsp;				namespaceCache.put(cacheID, namespace);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return namespace;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public LmdbIRI createIRI(String uri) {
<b class="nc">&nbsp;		return new LmdbIRI(revision, uri);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public LmdbIRI createIRI(String namespace, String localName) {
<b class="nc">&nbsp;		return new LmdbIRI(revision, namespace, localName);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public LmdbBNode createBNode(String nodeID) {
<b class="nc">&nbsp;		return new LmdbBNode(revision, nodeID);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public LmdbLiteral createLiteral(String value) {
<b class="nc">&nbsp;		return new LmdbLiteral(revision, value, CoreDatatype.XSD.STRING);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public LmdbLiteral createLiteral(String value, String language) {
<b class="nc">&nbsp;		return new LmdbLiteral(revision, value, language);</b>
&nbsp;	}
&nbsp;
&nbsp;	/*----------------------------------------------------------------------*
&nbsp;	 * Methods for converting model objects to LmdbStore-specific objects *
&nbsp;	 *----------------------------------------------------------------------*/
&nbsp;
&nbsp;	@Override
&nbsp;	public LmdbLiteral createLiteral(String value, IRI datatype) {
<b class="nc">&nbsp;		return new LmdbLiteral(revision, value, datatype);</b>
&nbsp;	}
&nbsp;
&nbsp;	public LmdbValue getLmdbValue(Value value) {
<b class="nc">&nbsp;		if (value instanceof Resource) {</b>
<b class="nc">&nbsp;			return getLmdbResource((Resource) value);</b>
<b class="nc">&nbsp;		} else if (value instanceof Literal) {</b>
<b class="nc">&nbsp;			return getLmdbLiteral((Literal) value);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			throw new IllegalArgumentException(&quot;Unknown value type: &quot; + value.getClass());</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public LmdbResource getLmdbResource(Resource resource) {
<b class="nc">&nbsp;		if (resource instanceof IRI) {</b>
<b class="nc">&nbsp;			return getLmdbURI((IRI) resource);</b>
<b class="nc">&nbsp;		} else if (resource instanceof BNode) {</b>
<b class="nc">&nbsp;			return getLmdbBNode((BNode) resource);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			throw new IllegalArgumentException(&quot;Unknown resource type: &quot; + resource.getClass());</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Creates a LmdbURI that is equal to the supplied URI. This method returns the supplied URI itself if it is already
&nbsp;	 * a LmdbURI that has been created by this ValueStore, which prevents unnecessary object creations.
&nbsp;	 *
&nbsp;	 * @return A LmdbURI for the specified URI.
&nbsp;	 */
&nbsp;	public LmdbIRI getLmdbURI(IRI uri) {
<b class="nc">&nbsp;		if (isOwnValue(uri)) {</b>
<b class="nc">&nbsp;			return (LmdbIRI) uri;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return new LmdbIRI(revision, uri.toString());</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Creates a LmdbBNode that is equal to the supplied bnode. This method returns the supplied bnode itself if it is
&nbsp;	 * already a LmdbBNode that has been created by this ValueStore, which prevents unnecessary object creations.
&nbsp;	 *
&nbsp;	 * @return A LmdbBNode for the specified bnode.
&nbsp;	 */
&nbsp;	public LmdbBNode getLmdbBNode(BNode bnode) {
<b class="nc">&nbsp;		if (isOwnValue(bnode)) {</b>
<b class="nc">&nbsp;			return (LmdbBNode) bnode;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return new LmdbBNode(revision, bnode.getID());</b>
&nbsp;	}
&nbsp;
&nbsp;	/*--------------------*
&nbsp;	 * Test/debug methods *
&nbsp;	 *--------------------*/
&nbsp;
&nbsp;	/**
&nbsp;	 * Creates an LmdbLiteral that is equal to the supplied literal. This method returns the supplied literal itself if
&nbsp;	 * it is already a LmdbLiteral that has been created by this ValueStore, which prevents unnecessary object
&nbsp;	 * creations.
&nbsp;	 *
&nbsp;	 * @return A LmdbLiteral for the specified literal.
&nbsp;	 */
&nbsp;	public LmdbLiteral getLmdbLiteral(Literal l) {
<b class="nc">&nbsp;		if (isOwnValue(l)) {</b>
<b class="nc">&nbsp;			return (LmdbLiteral) l;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (Literals.isLanguageLiteral(l)) {</b>
<b class="nc">&nbsp;			return new LmdbLiteral(revision, l.getLabel(), l.getLanguage().get());</b>
<b class="nc">&nbsp;		} else if (l.getCoreDatatype() != CoreDatatype.NONE) {</b>
<b class="nc">&nbsp;			return new LmdbLiteral(revision, l.getLabel(), l.getCoreDatatype());</b>
&nbsp;		} else {
<b class="nc">&nbsp;			LmdbIRI datatype = getLmdbURI(l.getDatatype());</b>
<b class="nc">&nbsp;			return new LmdbLiteral(revision, l.getLabel(), datatype, l.getCoreDatatype());</b>
&nbsp;		}
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:56</div>
</div>
</body>
</html>
