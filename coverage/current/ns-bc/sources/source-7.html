


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > ElasticsearchStore</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.sail.elasticsearchstore</a>
</div>

<h1>Coverage Summary for Class: ElasticsearchStore (org.eclipse.rdf4j.sail.elasticsearchstore)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ElasticsearchStore</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/88)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2019 Eclipse RDF4J contributors.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;package org.eclipse.rdf4j.sail.elasticsearchstore;
&nbsp;
&nbsp;import java.lang.ref.PhantomReference;
&nbsp;import java.lang.ref.Reference;
&nbsp;import java.lang.ref.ReferenceQueue;
&nbsp;import java.time.LocalDateTime;
&nbsp;import java.time.temporal.ChronoUnit;
&nbsp;import java.time.temporal.TemporalUnit;
&nbsp;import java.util.concurrent.ExecutorService;
&nbsp;import java.util.concurrent.Executors;
&nbsp;import java.util.concurrent.atomic.AtomicBoolean;
&nbsp;
&nbsp;import org.eclipse.rdf4j.common.annotation.Experimental;
&nbsp;import org.eclipse.rdf4j.sail.NotifyingSailConnection;
&nbsp;import org.eclipse.rdf4j.sail.SailException;
&nbsp;import org.eclipse.rdf4j.sail.extensiblestore.ExtensibleStore;
&nbsp;import org.eclipse.rdf4j.sail.extensiblestore.valuefactory.ExtensibleStatementHelper;
&nbsp;import org.elasticsearch.action.admin.cluster.health.ClusterHealthRequest;
&nbsp;import org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse;
&nbsp;import org.elasticsearch.client.Client;
&nbsp;import org.elasticsearch.cluster.health.ClusterHealthStatus;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;
&nbsp;/**
&nbsp; * &lt;p&gt;
&nbsp; * An RDF4J SailStore persisted to Elasticsearch.
&nbsp; * &lt;/p&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * This is an EXPERIMENTAL feature. Use at your own risk!
&nbsp; * &lt;/p&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * There is no write-ahead logging, so a failure during a transaction may result in partially persisted changes.
&nbsp; * &lt;/p&gt;
&nbsp; *
&nbsp; *
&nbsp; * @author HÃ¥vard Mikkelsen Ottestad
&nbsp; */
&nbsp;@Experimental
&nbsp;public class ElasticsearchStore extends ExtensibleStore&lt;ElasticsearchDataStructure, ElasticsearchNamespaceStore&gt; {
&nbsp;
<b class="nc">&nbsp;	private static final Logger logger = LoggerFactory.getLogger(ElasticsearchStore.class);</b>
&nbsp;
&nbsp;	final ClientProvider clientProvider;
<b class="nc">&nbsp;	private final AtomicBoolean shutdown = new AtomicBoolean(false);</b>
&nbsp;
&nbsp;	private String hostname;
&nbsp;	private int port;
&nbsp;	private String clusterName;
&nbsp;	private String index;
&nbsp;
&nbsp;	public ElasticsearchStore(String hostname, int port, String clusterName, String index) {
<b class="nc">&nbsp;		this(hostname, port, clusterName, index, true);</b>
&nbsp;	}
&nbsp;
&nbsp;	public ElasticsearchStore(String hostname, int port, String clusterName, String index, boolean cacheEnabled) {
<b class="nc">&nbsp;		super(cacheEnabled);</b>
<b class="nc">&nbsp;		this.hostname = hostname;</b>
<b class="nc">&nbsp;		this.port = port;</b>
<b class="nc">&nbsp;		this.clusterName = clusterName;</b>
<b class="nc">&nbsp;		this.index = index;</b>
&nbsp;
<b class="nc">&nbsp;		clientProvider = new SingletonClientProvider(hostname, port, clusterName);</b>
&nbsp;
<b class="nc">&nbsp;		dataStructure = new ElasticsearchDataStructure(clientProvider, index);</b>
<b class="nc">&nbsp;		namespaceStore = new ElasticsearchNamespaceStore(clientProvider, index + &quot;_namespaces&quot;);</b>
&nbsp;
<b class="nc">&nbsp;		ReferenceQueue&lt;ElasticsearchStore&gt; objectReferenceQueue = new ReferenceQueue&lt;&gt;();</b>
<b class="nc">&nbsp;		startGarbageCollectionMonitoring(objectReferenceQueue, new PhantomReference&lt;&gt;(this, objectReferenceQueue),</b>
&nbsp;				clientProvider);
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	public ElasticsearchStore(ClientProvider clientPool, String index) {
<b class="nc">&nbsp;		this(clientPool, index, true);</b>
&nbsp;	}
&nbsp;
&nbsp;	public ElasticsearchStore(ClientProvider clientPool, String index, boolean cacheEnabled) {
<b class="nc">&nbsp;		super(cacheEnabled);</b>
<b class="nc">&nbsp;		this.clientProvider = new UnclosableClientProvider(clientPool);</b>
&nbsp;
<b class="nc">&nbsp;		dataStructure = new ElasticsearchDataStructure(this.clientProvider, index);</b>
<b class="nc">&nbsp;		namespaceStore = new ElasticsearchNamespaceStore(this.clientProvider, index + &quot;_namespaces&quot;);</b>
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	public ElasticsearchStore(Client client, String index) {
<b class="nc">&nbsp;		this(client, index, true);</b>
&nbsp;	}
&nbsp;
&nbsp;	public ElasticsearchStore(Client client, String index, boolean cacheEnabled) {
<b class="nc">&nbsp;		this(new UnclosableClientProvider(new UserProvidedClientProvider(client)), index, cacheEnabled);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected void initializeInternal() throws SailException {
<b class="nc">&nbsp;		if (shutdown.get()) {</b>
<b class="nc">&nbsp;			throw new SailException(&quot;Can not be initialized after calling shutdown!&quot;);</b>
&nbsp;		}
<b class="nc">&nbsp;		waitForElasticsearch(10, ChronoUnit.MINUTES);</b>
&nbsp;
<b class="nc">&nbsp;		super.initializeInternal();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected void shutDownInternal() throws SailException {
<b class="nc">&nbsp;		if (shutdown.compareAndSet(false, true)) {</b>
<b class="nc">&nbsp;			super.shutDownInternal();</b>
&nbsp;			try {
<b class="nc">&nbsp;				clientProvider.close();</b>
<b class="nc">&nbsp;			} catch (Exception e) {</b>
<b class="nc">&nbsp;				throw new SailException(e);</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public void waitForElasticsearch(int time, TemporalUnit timeUnit) {
&nbsp;
<b class="nc">&nbsp;		LocalDateTime tenMinFromNow = LocalDateTime.now().plus(time, timeUnit);</b>
&nbsp;
<b class="nc">&nbsp;		logger.info(&quot;Waiting for Elasticsearch to start&quot;);</b>
&nbsp;
&nbsp;		while (true) {
<b class="nc">&nbsp;			if (LocalDateTime.now().isAfter(tenMinFromNow)) {</b>
<b class="nc">&nbsp;				logger.error(</b>
<b class="nc">&nbsp;						&quot;Could not connect to Elasticsearch after &quot; + time + &quot; &quot; + timeUnit.toString() + &quot; of trying!&quot;);</b>
&nbsp;
&nbsp;				try {
<b class="nc">&nbsp;					clientProvider.close();</b>
<b class="nc">&nbsp;				} catch (Exception e) {</b>
<b class="nc">&nbsp;					throw new RuntimeException(e);</b>
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;				throw new RuntimeException(</b>
<b class="nc">&nbsp;						&quot;Could not connect to Elasticsearch after &quot; + time + &quot; &quot; + timeUnit.toString() + &quot; of trying!&quot;);</b>
&nbsp;
&nbsp;			}
&nbsp;			try {
<b class="nc">&nbsp;				Client client = clientProvider.getClient();</b>
&nbsp;
<b class="nc">&nbsp;				ClusterHealthResponse clusterHealthResponse = client.admin()</b>
<b class="nc">&nbsp;						.cluster()</b>
<b class="nc">&nbsp;						.health(new ClusterHealthRequest())</b>
<b class="nc">&nbsp;						.actionGet();</b>
<b class="nc">&nbsp;				ClusterHealthStatus status = clusterHealthResponse.getStatus();</b>
<b class="nc">&nbsp;				logger.info(&quot;Cluster status: {}&quot;, status.name());</b>
&nbsp;
<b class="nc">&nbsp;				if (status.equals(ClusterHealthStatus.GREEN) || status.equals(ClusterHealthStatus.YELLOW)) {</b>
<b class="nc">&nbsp;					logger.info(&quot;Elasticsearch started!&quot;);</b>
&nbsp;
&nbsp;					return;
&nbsp;
&nbsp;				}
&nbsp;
<b class="nc">&nbsp;			} catch (Throwable e) {</b>
<b class="nc">&nbsp;				logger.info(&quot;Unable to connect to elasticsearch cluster due to {}&quot;, e.getClass().getSimpleName());</b>
&nbsp;
&nbsp;				try {
<b class="nc">&nbsp;					clientProvider.close();</b>
<b class="nc">&nbsp;				} catch (Exception e2) {</b>
<b class="nc">&nbsp;					throw new RuntimeException(e2);</b>
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;				e.printStackTrace();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			logger.info(&quot;.&quot;);</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				Thread.sleep(1000);</b>
<b class="nc">&nbsp;			} catch (InterruptedException ignored) {</b>
&nbsp;
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	// this code does some final safety cleanup when the user&#39;s ElasticsearchStore gets garbage collected
&nbsp;	private void startGarbageCollectionMonitoring(ReferenceQueue&lt;ElasticsearchStore&gt; referenceQueue,
&nbsp;			Reference&lt;ElasticsearchStore&gt; ref, ClientProvider clientProvider) {
&nbsp;
<b class="nc">&nbsp;		ExecutorService ex = Executors.newSingleThreadExecutor(r -&gt; {</b>
<b class="nc">&nbsp;			Thread t = Executors.defaultThreadFactory().newThread(r);</b>
&nbsp;			// this thread pool does not need to stick around if the all other threads are done
<b class="nc">&nbsp;			t.setDaemon(true);</b>
<b class="nc">&nbsp;			return t;</b>
&nbsp;		});
&nbsp;
<b class="nc">&nbsp;		ex.execute(() -&gt; {</b>
<b class="nc">&nbsp;			while (referenceQueue.poll() != ref) {</b>
&nbsp;				// don&#39;t hang forever
&nbsp;				try {
<b class="nc">&nbsp;					Thread.sleep(100);</b>
<b class="nc">&nbsp;				} catch (InterruptedException e) {</b>
&nbsp;					// should never be interrupted
<b class="nc">&nbsp;					break;</b>
<b class="nc">&nbsp;				}</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (ref.get() != null) {</b>
&nbsp;				// we were apparently interrupted before the object was set to be finalized
&nbsp;				return;
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (!clientProvider.isClosed()) {</b>
<b class="nc">&nbsp;				logger.warn(</b>
&nbsp;						&quot;Closing ClientPool in ElasticsearchStore due to store having no references and shutdown() never being called()&quot;);
&nbsp;			}
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				clientProvider.close();</b>
<b class="nc">&nbsp;			} catch (Exception ignored) {</b>
&nbsp;				// ignoring any exception, since this cleanup is best effort
<b class="nc">&nbsp;			}</b>
&nbsp;
&nbsp;		});
&nbsp;		// this is a soft operation, the thread pool will actually wait until the task above has completed
<b class="nc">&nbsp;		ex.shutdown();</b>
&nbsp;	}
&nbsp;
&nbsp;	public void setElasticsearchScrollTimeout(int timeout) {
<b class="nc">&nbsp;		dataStructure.setElasticsearchScrollTimeout(timeout);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected NotifyingSailConnection getConnectionInternal() throws SailException {
<b class="nc">&nbsp;		return new ElasticsearchStoreConnection(this);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public boolean isWritable() throws SailException {
<b class="nc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	public String getHostname() {
<b class="nc">&nbsp;		return hostname;</b>
&nbsp;	}
&nbsp;
&nbsp;	public int getPort() {
<b class="nc">&nbsp;		return port;</b>
&nbsp;	}
&nbsp;
&nbsp;	public String getClusterName() {
<b class="nc">&nbsp;		return clusterName;</b>
&nbsp;	}
&nbsp;
&nbsp;	public String getIndex() {
<b class="nc">&nbsp;		return index;</b>
&nbsp;	}
&nbsp;
&nbsp;	public void setElasticsearchBulkSize(int size) {
<b class="nc">&nbsp;		dataStructure.setElasticsearchBulkSize(size);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public ExtensibleStatementHelper getExtensibleStatementHelper() {
<b class="nc">&nbsp;		return (ExtensibleStatementHelper) ElasticsearchValueFactory.getInstance();</b>
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:20</div>
</div>
</body>
</html>
