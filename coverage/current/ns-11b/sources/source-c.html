


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > SPARQLQueryTest</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.testsuite.query.parser.sparql.manifest</a>
</div>

<h1>Coverage Summary for Class: SPARQLQueryTest (org.eclipse.rdf4j.testsuite.query.parser.sparql.manifest)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SPARQLQueryTest</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/144)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/316)
  </span>
</td>
</tr>
  <tr>
    <td class="name">SPARQLQueryTest$Factory</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/144)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/316)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;package org.eclipse.rdf4j.testsuite.query.parser.sparql.manifest;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.InputStreamReader;
&nbsp;import java.net.URL;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.LinkedHashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Optional;
&nbsp;import java.util.Set;
&nbsp;
&nbsp;import org.eclipse.rdf4j.common.io.IOUtil;
&nbsp;import org.eclipse.rdf4j.common.iteration.Iterations;
&nbsp;import org.eclipse.rdf4j.common.text.StringUtil;
&nbsp;import org.eclipse.rdf4j.model.IRI;
&nbsp;import org.eclipse.rdf4j.model.Resource;
&nbsp;import org.eclipse.rdf4j.model.Statement;
&nbsp;import org.eclipse.rdf4j.model.Value;
&nbsp;import org.eclipse.rdf4j.model.util.Models;
&nbsp;import org.eclipse.rdf4j.query.BindingSet;
&nbsp;import org.eclipse.rdf4j.query.BooleanQuery;
&nbsp;import org.eclipse.rdf4j.query.Dataset;
&nbsp;import org.eclipse.rdf4j.query.GraphQuery;
&nbsp;import org.eclipse.rdf4j.query.GraphQueryResult;
&nbsp;import org.eclipse.rdf4j.query.MalformedQueryException;
&nbsp;import org.eclipse.rdf4j.query.Query;
&nbsp;import org.eclipse.rdf4j.query.QueryEvaluationException;
&nbsp;import org.eclipse.rdf4j.query.QueryLanguage;
&nbsp;import org.eclipse.rdf4j.query.QueryResults;
&nbsp;import org.eclipse.rdf4j.query.TupleQuery;
&nbsp;import org.eclipse.rdf4j.query.TupleQueryResult;
&nbsp;import org.eclipse.rdf4j.query.dawg.DAWGTestResultSetUtil;
&nbsp;import org.eclipse.rdf4j.query.impl.MutableTupleQueryResult;
&nbsp;import org.eclipse.rdf4j.query.impl.SimpleDataset;
&nbsp;import org.eclipse.rdf4j.query.impl.TupleQueryResultBuilder;
&nbsp;import org.eclipse.rdf4j.query.resultio.BooleanQueryResultParserRegistry;
&nbsp;import org.eclipse.rdf4j.query.resultio.QueryResultFormat;
&nbsp;import org.eclipse.rdf4j.query.resultio.QueryResultIO;
&nbsp;import org.eclipse.rdf4j.query.resultio.TupleQueryResultParser;
&nbsp;import org.eclipse.rdf4j.repository.Repository;
&nbsp;import org.eclipse.rdf4j.repository.RepositoryConnection;
&nbsp;import org.eclipse.rdf4j.repository.RepositoryException;
&nbsp;import org.eclipse.rdf4j.repository.sail.SailRepository;
&nbsp;import org.eclipse.rdf4j.repository.util.RDFInserter;
&nbsp;import org.eclipse.rdf4j.rio.RDFFormat;
&nbsp;import org.eclipse.rdf4j.rio.RDFParser;
&nbsp;import org.eclipse.rdf4j.rio.Rio;
&nbsp;import org.eclipse.rdf4j.rio.helpers.BasicParserSettings;
&nbsp;import org.eclipse.rdf4j.rio.helpers.StatementCollector;
&nbsp;import org.eclipse.rdf4j.sail.memory.MemoryStore;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;
&nbsp;import junit.framework.TestCase;
&nbsp;import junit.framework.TestSuite;
&nbsp;
&nbsp;/**
&nbsp; * A SPARQL query test suite, created by reading in a W3C working-group style manifest.
&nbsp; *
&nbsp; * @author Jeen Broekstra
&nbsp; * @deprecated since 3.3.0. Use {@link SPARQL11QueryComplianceTest} instead.
&nbsp; */
&nbsp;@Deprecated
&nbsp;public abstract class SPARQLQueryTest extends TestCase {
&nbsp;
&nbsp;	/*-----------*
&nbsp;	 * Constants *
&nbsp;	 *-----------*/
&nbsp;
&nbsp;	// Logger for non-static tests, so these results can be isolated based on
&nbsp;	// where they are run
<b class="nc">&nbsp;	protected final Logger logger = LoggerFactory.getLogger(this.getClass());</b>
&nbsp;
&nbsp;	// Logger for static methods which are not overridden
<b class="nc">&nbsp;	private final static Logger LOGGER = LoggerFactory.getLogger(SPARQLQueryTest.class);</b>
&nbsp;
&nbsp;	protected final String testURI;
&nbsp;
&nbsp;	protected final String queryFileURL;
&nbsp;
&nbsp;	protected final String resultFileURL;
&nbsp;
&nbsp;	protected final Dataset dataset;
&nbsp;
&nbsp;	protected final boolean laxCardinality;
&nbsp;
&nbsp;	protected final boolean checkOrder;
&nbsp;
&nbsp;	protected final String[] ignoredTests;
&nbsp;
&nbsp;	/*-----------*
&nbsp;	 * Variables *
&nbsp;	 *-----------*/
&nbsp;
&nbsp;	protected Repository dataRep;
&nbsp;
&nbsp;	/*--------------*
&nbsp;	 * Constructors *
&nbsp;	 *--------------*/
&nbsp;
&nbsp;	public SPARQLQueryTest(String testURI, String name, String queryFileURL, String resultFileURL, Dataset dataSet,
&nbsp;			boolean laxCardinality, String... ignoredTests) {
<b class="nc">&nbsp;		this(testURI, name, queryFileURL, resultFileURL, dataSet, laxCardinality, false);</b>
&nbsp;	}
&nbsp;
&nbsp;	public SPARQLQueryTest(String testURI, String name, String queryFileURL, String resultFileURL, Dataset dataSet,
&nbsp;			boolean laxCardinality, boolean checkOrder, String... ignoredTests) {
<b class="nc">&nbsp;		super(name.replaceAll(&quot;\\(&quot;, &quot; &quot;).replaceAll(&quot;\\)&quot;, &quot; &quot;));</b>
&nbsp;
<b class="nc">&nbsp;		this.testURI = testURI;</b>
<b class="nc">&nbsp;		this.queryFileURL = queryFileURL;</b>
<b class="nc">&nbsp;		this.resultFileURL = resultFileURL;</b>
<b class="nc">&nbsp;		this.dataset = dataSet;</b>
<b class="nc">&nbsp;		this.laxCardinality = laxCardinality;</b>
<b class="nc">&nbsp;		this.checkOrder = checkOrder;</b>
<b class="nc">&nbsp;		this.ignoredTests = ignoredTests;</b>
&nbsp;	}
&nbsp;
&nbsp;	/*---------*
&nbsp;	 * Methods *
&nbsp;	 *---------*/
&nbsp;
&nbsp;	@Override
&nbsp;	protected void setUp() throws Exception {
<b class="nc">&nbsp;		dataRep = createRepository();</b>
&nbsp;
<b class="nc">&nbsp;		if (dataset != null) {</b>
&nbsp;			try {
<b class="nc">&nbsp;				uploadDataset(dataset);</b>
<b class="nc">&nbsp;			} catch (Exception exc) {</b>
&nbsp;				try {
<b class="nc">&nbsp;					dataRep.shutDown();</b>
<b class="nc">&nbsp;					dataRep = null;</b>
<b class="nc">&nbsp;				} catch (Exception e2) {</b>
<b class="nc">&nbsp;					logger.error(e2.toString(), e2);</b>
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;				throw exc;</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	protected final Repository createRepository() throws Exception {
<b class="nc">&nbsp;		Repository repo = newRepository();</b>
<b class="nc">&nbsp;		try (RepositoryConnection con = repo.getConnection()) {</b>
<b class="nc">&nbsp;			con.clear();</b>
<b class="nc">&nbsp;			con.clearNamespaces();</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return repo;</b>
&nbsp;	}
&nbsp;
&nbsp;	protected abstract Repository newRepository() throws Exception;
&nbsp;
&nbsp;	@Override
&nbsp;	protected void tearDown() throws Exception {
<b class="nc">&nbsp;		if (dataRep != null) {</b>
<b class="nc">&nbsp;			dataRep.shutDown();</b>
<b class="nc">&nbsp;			dataRep = null;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected void runTest() throws Exception {
&nbsp;		// FIXME this reports a test error because we still rely on JUnit 3 here.
&nbsp;		// org.junit.Assume.assumeFalse(Arrays.asList(ignoredTests).contains(this.getName()));
&nbsp;		// FIXME temporary fix is to report as succeeded and just ignore.
<b class="nc">&nbsp;		if (Arrays.asList(ignoredTests).contains(this.getName())) {</b>
<b class="nc">&nbsp;			logger.warn(&quot;Query test ignored: &quot; + this.getName());</b>
&nbsp;			return;
&nbsp;		}
&nbsp;
&nbsp;		// Some SPARQL Tests have non-XSD datatypes that must pass for the test
&nbsp;		// suite to complete successfully
<b class="nc">&nbsp;		try (RepositoryConnection con = dataRep.getConnection()) {</b>
<b class="nc">&nbsp;			con.getParserConfig().set(BasicParserSettings.VERIFY_DATATYPE_VALUES, Boolean.FALSE);</b>
<b class="nc">&nbsp;			con.getParserConfig().set(BasicParserSettings.FAIL_ON_UNKNOWN_DATATYPES, Boolean.FALSE);</b>
<b class="nc">&nbsp;			String queryString = readQueryString();</b>
<b class="nc">&nbsp;			Query query = con.prepareQuery(QueryLanguage.SPARQL, queryString, queryFileURL);</b>
<b class="nc">&nbsp;			if (dataset != null) {</b>
<b class="nc">&nbsp;				query.setDataset(dataset);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			String name = this.getName();</b>
&nbsp;
<b class="nc">&nbsp;			if (name.contains(&quot;pp34&quot;)) {</b>
<b class="nc">&nbsp;				System.out.println(name);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (query instanceof TupleQuery) {</b>
<b class="nc">&nbsp;				TupleQueryResult queryResult = ((TupleQuery) query).evaluate();</b>
&nbsp;
<b class="nc">&nbsp;				TupleQueryResult expectedResult = readExpectedTupleQueryResult();</b>
&nbsp;
<b class="nc">&nbsp;				compareTupleQueryResults(queryResult, expectedResult);</b>
&nbsp;
&nbsp;				// Graph queryGraph = RepositoryUtil.asGraph(queryResult);
&nbsp;				// Graph expectedGraph = readExpectedTupleQueryResult();
&nbsp;				// compareGraphs(queryGraph, expectedGraph);
<b class="nc">&nbsp;			} else if (query instanceof GraphQuery) {</b>
<b class="nc">&nbsp;				GraphQueryResult gqr = ((GraphQuery) query).evaluate();</b>
<b class="nc">&nbsp;				Set&lt;Statement&gt; queryResult = Iterations.asSet(gqr);</b>
&nbsp;
<b class="nc">&nbsp;				Set&lt;Statement&gt; expectedResult = readExpectedGraphQueryResult();</b>
&nbsp;
<b class="nc">&nbsp;				compareGraphs(queryResult, expectedResult);</b>
<b class="nc">&nbsp;			} else if (query instanceof BooleanQuery) {</b>
<b class="nc">&nbsp;				boolean queryResult = ((BooleanQuery) query).evaluate();</b>
<b class="nc">&nbsp;				boolean expectedResult = readExpectedBooleanQueryResult();</b>
<b class="nc">&nbsp;				assertEquals(expectedResult, queryResult);</b>
<b class="nc">&nbsp;			} else {</b>
<b class="nc">&nbsp;				throw new RuntimeException(&quot;Unexpected query type: &quot; + query.getClass());</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	protected final void compareTupleQueryResults(TupleQueryResult queryResult, TupleQueryResult expectedResult)
&nbsp;			throws Exception {
&nbsp;		// Create MutableTupleQueryResult to be able to re-iterate over the
&nbsp;		// results
<b class="nc">&nbsp;		MutableTupleQueryResult queryResultTable = new MutableTupleQueryResult(queryResult);</b>
<b class="nc">&nbsp;		MutableTupleQueryResult expectedResultTable = new MutableTupleQueryResult(expectedResult);</b>
&nbsp;
&nbsp;		boolean resultsEqual;
<b class="nc">&nbsp;		if (laxCardinality) {</b>
<b class="nc">&nbsp;			resultsEqual = QueryResults.isSubset(queryResultTable, expectedResultTable);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			resultsEqual = QueryResults.equals(queryResultTable, expectedResultTable);</b>
&nbsp;
<b class="nc">&nbsp;			if (checkOrder) {</b>
&nbsp;				// also check the order in which solutions occur.
<b class="nc">&nbsp;				queryResultTable.beforeFirst();</b>
<b class="nc">&nbsp;				expectedResultTable.beforeFirst();</b>
&nbsp;
<b class="nc">&nbsp;				while (queryResultTable.hasNext()) {</b>
<b class="nc">&nbsp;					BindingSet bs = queryResultTable.next();</b>
<b class="nc">&nbsp;					BindingSet expectedBs = expectedResultTable.next();</b>
&nbsp;
<b class="nc">&nbsp;					if (!bs.equals(expectedBs)) {</b>
<b class="nc">&nbsp;						resultsEqual = false;</b>
<b class="nc">&nbsp;						break;</b>
&nbsp;					}
<b class="nc">&nbsp;				}</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (!resultsEqual) {</b>
<b class="nc">&nbsp;			queryResultTable.beforeFirst();</b>
<b class="nc">&nbsp;			expectedResultTable.beforeFirst();</b>
&nbsp;
&nbsp;			/*
&nbsp;			 * StringBuilder message = new StringBuilder(128); message.append(&quot;\n============ &quot;);
&nbsp;			 * message.append(getName()); message.append(&quot; =======================\n&quot;); message.append(
&nbsp;			 * &quot;Expected result: \n&quot;); while (expectedResultTable.hasNext()) {
&nbsp;			 * message.append(expectedResultTable.next()); message.append(&quot;\n&quot;); } message.append(&quot;=============&quot;);
&nbsp;			 * StringUtil.appendN(&#39;=&#39;, getName().length(), message); message.append(&quot;========================\n&quot;);
&nbsp;			 * message.append(&quot;Query result: \n&quot;); while (queryResultTable.hasNext()) {
&nbsp;			 * message.append(queryResultTable.next()); message.append(&quot;\n&quot;); } message.append(&quot;=============&quot;);
&nbsp;			 * StringUtil.appendN(&#39;=&#39;, getName().length(), message); message.append(&quot;========================\n&quot;);
&nbsp;			 */
&nbsp;
<b class="nc">&nbsp;			List&lt;BindingSet&gt; queryBindings = Iterations.asList(queryResultTable);</b>
&nbsp;
<b class="nc">&nbsp;			List&lt;BindingSet&gt; expectedBindings = Iterations.asList(expectedResultTable);</b>
&nbsp;
<b class="nc">&nbsp;			List&lt;BindingSet&gt; missingBindings = new ArrayList&lt;&gt;(expectedBindings);</b>
<b class="nc">&nbsp;			missingBindings.removeAll(queryBindings);</b>
&nbsp;
<b class="nc">&nbsp;			List&lt;BindingSet&gt; unexpectedBindings = new ArrayList&lt;&gt;(queryBindings);</b>
<b class="nc">&nbsp;			unexpectedBindings.removeAll(expectedBindings);</b>
&nbsp;
<b class="nc">&nbsp;			StringBuilder message = new StringBuilder(128);</b>
<b class="nc">&nbsp;			message.append(&quot;\n============ &quot;);</b>
<b class="nc">&nbsp;			message.append(getName());</b>
<b class="nc">&nbsp;			message.append(&quot; =======================\n&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			if (!missingBindings.isEmpty()) {</b>
&nbsp;
<b class="nc">&nbsp;				message.append(&quot;Missing bindings: \n&quot;);</b>
<b class="nc">&nbsp;				for (BindingSet bs : missingBindings) {</b>
<b class="nc">&nbsp;					printBindingSet(bs, message);</b>
<b class="nc">&nbsp;				}</b>
&nbsp;
<b class="nc">&nbsp;				message.append(&quot;=============&quot;);</b>
<b class="nc">&nbsp;				StringUtil.appendN(&#39;=&#39;, getName().length(), message);</b>
<b class="nc">&nbsp;				message.append(&quot;========================\n&quot;);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (!unexpectedBindings.isEmpty()) {</b>
<b class="nc">&nbsp;				message.append(&quot;Unexpected bindings: \n&quot;);</b>
<b class="nc">&nbsp;				for (BindingSet bs : unexpectedBindings) {</b>
<b class="nc">&nbsp;					printBindingSet(bs, message);</b>
<b class="nc">&nbsp;				}</b>
&nbsp;
<b class="nc">&nbsp;				message.append(&quot;=============&quot;);</b>
<b class="nc">&nbsp;				StringUtil.appendN(&#39;=&#39;, getName().length(), message);</b>
<b class="nc">&nbsp;				message.append(&quot;========================\n&quot;);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (checkOrder &amp;&amp; missingBindings.isEmpty() &amp;&amp; unexpectedBindings.isEmpty()) {</b>
<b class="nc">&nbsp;				message.append(&quot;Results are not in expected order.\n&quot;);</b>
<b class="nc">&nbsp;				message.append(&quot; =======================\n&quot;);</b>
<b class="nc">&nbsp;				message.append(&quot;query result: \n&quot;);</b>
<b class="nc">&nbsp;				for (BindingSet bs : queryBindings) {</b>
<b class="nc">&nbsp;					printBindingSet(bs, message);</b>
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;				message.append(&quot; =======================\n&quot;);</b>
<b class="nc">&nbsp;				message.append(&quot;expected result: \n&quot;);</b>
<b class="nc">&nbsp;				for (BindingSet bs : expectedBindings) {</b>
<b class="nc">&nbsp;					printBindingSet(bs, message);</b>
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;				message.append(&quot; =======================\n&quot;);</b>
&nbsp;
<b class="nc">&nbsp;				System.out.print(message.toString());</b>
<b class="nc">&nbsp;			} else if (missingBindings.isEmpty() &amp;&amp; unexpectedBindings.isEmpty()) {</b>
<b class="nc">&nbsp;				message.append(&quot;unexpected duplicate in result.\n&quot;);</b>
<b class="nc">&nbsp;				message.append(&quot; =======================\n&quot;);</b>
<b class="nc">&nbsp;				message.append(&quot;query result: \n&quot;);</b>
<b class="nc">&nbsp;				for (BindingSet bs : queryBindings) {</b>
<b class="nc">&nbsp;					printBindingSet(bs, message);</b>
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;				message.append(&quot; =======================\n&quot;);</b>
<b class="nc">&nbsp;				message.append(&quot;expected result: \n&quot;);</b>
<b class="nc">&nbsp;				for (BindingSet bs : expectedBindings) {</b>
<b class="nc">&nbsp;					printBindingSet(bs, message);</b>
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;				message.append(&quot; =======================\n&quot;);</b>
&nbsp;
<b class="nc">&nbsp;				System.out.print(message.toString());</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			logger.error(message.toString());</b>
<b class="nc">&nbsp;			fail(message.toString());</b>
&nbsp;		}
&nbsp;		/*
&nbsp;		 * debugging only: print out result when test succeeds else { queryResultTable.beforeFirst(); List&lt;BindingSet&gt;
&nbsp;		 * queryBindings = Iterations.asList(queryResultTable); StringBuilder message = new StringBuilder(128);
&nbsp;		 * message.append(&quot;\n============ &quot;); message.append(getName()); message.append( &quot; =======================\n&quot;);
&nbsp;		 * message.append(&quot; =======================\n&quot;); message.append( &quot;query result: \n&quot;); for (BindingSet bs:
&nbsp;		 * queryBindings) { message.append(bs); message.append(&quot;\n&quot;); } System.out.print(message.toString()); }
&nbsp;		 */
&nbsp;	}
&nbsp;
&nbsp;	protected final void printBindingSet(BindingSet bs, StringBuilder appendable) {
<b class="nc">&nbsp;		List&lt;String&gt; names = new ArrayList&lt;&gt;(bs.getBindingNames());</b>
<b class="nc">&nbsp;		Collections.sort(names);</b>
&nbsp;
<b class="nc">&nbsp;		for (String name : names) {</b>
<b class="nc">&nbsp;			if (bs.hasBinding(name)) {</b>
<b class="nc">&nbsp;				appendable.append(bs.getBinding(name));</b>
<b class="nc">&nbsp;				appendable.append(&#39; &#39;);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		appendable.append(&quot;\n&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	protected final void compareGraphs(Set&lt;Statement&gt; queryResult, Set&lt;Statement&gt; expectedResult) throws Exception {
<b class="nc">&nbsp;		if (!Models.isomorphic(expectedResult, queryResult)) {</b>
&nbsp;			// Don&#39;t use RepositoryUtil.difference, it reports incorrect diffs
&nbsp;			/*
&nbsp;			 * Collection&lt;? extends Statement&gt; unexpectedStatements = RepositoryUtil.difference(queryResult,
&nbsp;			 * expectedResult); Collection&lt;? extends Statement&gt; missingStatements =
&nbsp;			 * RepositoryUtil.difference(expectedResult, queryResult); StringBuilder message = new StringBuilder(128);
&nbsp;			 * message.append(&quot;\n=======Diff: &quot;); message.append(getName());
&nbsp;			 * message.append(&quot;========================\n&quot;); if (!unexpectedStatements.isEmpty()) {
&nbsp;			 * message.append(&quot;Unexpected statements in result: \n&quot;); for (Statement st : unexpectedStatements) {
&nbsp;			 * message.append(st.toString()); message.append(&quot;\n&quot;); } message.append(&quot;=============&quot;); for (int i = 0; i
&nbsp;			 * &lt; getName().length(); i++) { message.append(&quot;=&quot;); } message.append(&quot;========================\n&quot;); } if
&nbsp;			 * (!missingStatements.isEmpty()) { message.append(&quot;Statements missing in result: \n&quot;); for (Statement st :
&nbsp;			 * missingStatements) { message.append(st.toString()); message.append(&quot;\n&quot;); }
&nbsp;			 * message.append(&quot;=============&quot;); for (int i = 0; i &lt; getName().length(); i++) { message.append(&quot;=&quot;); }
&nbsp;			 * message.append(&quot;========================\n&quot;); }
&nbsp;			 */
<b class="nc">&nbsp;			StringBuilder message = new StringBuilder(128);</b>
<b class="nc">&nbsp;			message.append(&quot;\n============ &quot;);</b>
<b class="nc">&nbsp;			message.append(getName());</b>
<b class="nc">&nbsp;			message.append(&quot; =======================\n&quot;);</b>
<b class="nc">&nbsp;			message.append(&quot;Expected result: \n&quot;);</b>
<b class="nc">&nbsp;			for (Statement st : expectedResult) {</b>
<b class="nc">&nbsp;				message.append(st.toString());</b>
<b class="nc">&nbsp;				message.append(&quot;\n&quot;);</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			message.append(&quot;=============&quot;);</b>
<b class="nc">&nbsp;			StringUtil.appendN(&#39;=&#39;, getName().length(), message);</b>
<b class="nc">&nbsp;			message.append(&quot;========================\n&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			message.append(&quot;Query result: \n&quot;);</b>
<b class="nc">&nbsp;			for (Statement st : queryResult) {</b>
<b class="nc">&nbsp;				message.append(st.toString());</b>
<b class="nc">&nbsp;				message.append(&quot;\n&quot;);</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			message.append(&quot;=============&quot;);</b>
<b class="nc">&nbsp;			StringUtil.appendN(&#39;=&#39;, getName().length(), message);</b>
<b class="nc">&nbsp;			message.append(&quot;========================\n&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			logger.error(message.toString());</b>
<b class="nc">&nbsp;			fail(message.toString());</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	protected final void uploadDataset(Dataset dataset) throws Exception {
&nbsp;		// Merge default and named graphs to filter duplicates
<b class="nc">&nbsp;		Set&lt;IRI&gt; graphURIs = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;		graphURIs.addAll(dataset.getDefaultGraphs());</b>
<b class="nc">&nbsp;		graphURIs.addAll(dataset.getNamedGraphs());</b>
&nbsp;
<b class="nc">&nbsp;		for (IRI graphURI : graphURIs) {</b>
<b class="nc">&nbsp;			upload(graphURI, graphURI);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private void upload(IRI graphURI, Resource context) throws Exception {
<b class="nc">&nbsp;		try (RepositoryConnection con = dataRep.getConnection()) {</b>
&nbsp;			try {
<b class="nc">&nbsp;				con.begin();</b>
<b class="nc">&nbsp;				RDFFormat rdfFormat = Rio.getParserFormatForFileName(graphURI.toString()).orElse(RDFFormat.TURTLE);</b>
<b class="nc">&nbsp;				RDFParser rdfParser = Rio.createParser(rdfFormat, dataRep.getValueFactory());</b>
&nbsp;				// rdfParser.setPreserveBNodeIDs(true);
&nbsp;
<b class="nc">&nbsp;				RDFInserter rdfInserter = new RDFInserter(con);</b>
<b class="nc">&nbsp;				rdfInserter.enforceContext(context);</b>
<b class="nc">&nbsp;				rdfParser.setRDFHandler(rdfInserter);</b>
&nbsp;
<b class="nc">&nbsp;				URL graphURL = new URL(graphURI.toString());</b>
<b class="nc">&nbsp;				try (InputStream in = graphURL.openStream()) {</b>
<b class="nc">&nbsp;					rdfParser.parse(in, graphURI.toString());</b>
<b class="nc">&nbsp;				}</b>
&nbsp;
<b class="nc">&nbsp;				con.commit();</b>
<b class="nc">&nbsp;			} catch (Exception e) {</b>
<b class="nc">&nbsp;				if (con.isActive()) {</b>
<b class="nc">&nbsp;					con.rollback();</b>
&nbsp;				}
<b class="nc">&nbsp;				throw e;</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	protected final String readQueryString() throws IOException {
<b class="nc">&nbsp;		try (InputStream stream = new URL(queryFileURL).openStream()) {</b>
<b class="nc">&nbsp;			return IOUtil.readString(new InputStreamReader(stream, StandardCharsets.UTF_8));</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	protected final TupleQueryResult readExpectedTupleQueryResult() throws Exception {
<b class="nc">&nbsp;		Optional&lt;QueryResultFormat&gt; tqrFormat = QueryResultIO.getParserFormatForFileName(resultFileURL);</b>
&nbsp;
<b class="nc">&nbsp;		if (tqrFormat.isPresent()) {</b>
<b class="nc">&nbsp;			try (InputStream in = new URL(resultFileURL).openStream()) {</b>
<b class="nc">&nbsp;				TupleQueryResultParser parser = QueryResultIO.createTupleParser(tqrFormat.get());</b>
<b class="nc">&nbsp;				parser.setValueFactory(dataRep.getValueFactory());</b>
&nbsp;
<b class="nc">&nbsp;				TupleQueryResultBuilder qrBuilder = new TupleQueryResultBuilder();</b>
<b class="nc">&nbsp;				parser.setQueryResultHandler(qrBuilder);</b>
&nbsp;
<b class="nc">&nbsp;				parser.parseQueryResult(in);</b>
<b class="nc">&nbsp;				return qrBuilder.getQueryResult();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		} else {
<b class="nc">&nbsp;			Set&lt;Statement&gt; resultGraph = readExpectedGraphQueryResult();</b>
<b class="nc">&nbsp;			return DAWGTestResultSetUtil.toTupleQueryResult(resultGraph);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	protected final boolean readExpectedBooleanQueryResult() throws Exception {
<b class="nc">&nbsp;		Optional&lt;QueryResultFormat&gt; bqrFormat = BooleanQueryResultParserRegistry.getInstance()</b>
<b class="nc">&nbsp;				.getFileFormatForFileName(resultFileURL);</b>
&nbsp;
<b class="nc">&nbsp;		if (bqrFormat.isPresent()) {</b>
<b class="nc">&nbsp;			try (InputStream in = new URL(resultFileURL).openStream()) {</b>
<b class="nc">&nbsp;				return QueryResultIO.parseBoolean(in, bqrFormat.get());</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		} else {
<b class="nc">&nbsp;			Set&lt;Statement&gt; resultGraph = readExpectedGraphQueryResult();</b>
<b class="nc">&nbsp;			return DAWGTestResultSetUtil.toBooleanQueryResult(resultGraph);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	protected final Set&lt;Statement&gt; readExpectedGraphQueryResult() throws Exception {
<b class="nc">&nbsp;		RDFFormat rdfFormat = Rio.getParserFormatForFileName(resultFileURL)</b>
<b class="nc">&nbsp;				.orElseThrow(Rio.unsupportedFormat(resultFileURL));</b>
&nbsp;
<b class="nc">&nbsp;		RDFParser parser = Rio.createParser(rdfFormat);</b>
<b class="nc">&nbsp;		parser.setPreserveBNodeIDs(true);</b>
<b class="nc">&nbsp;		parser.setValueFactory(dataRep.getValueFactory());</b>
&nbsp;
<b class="nc">&nbsp;		Set&lt;Statement&gt; result = new LinkedHashSet&lt;&gt;();</b>
<b class="nc">&nbsp;		parser.setRDFHandler(new StatementCollector(result));</b>
&nbsp;
<b class="nc">&nbsp;		try (InputStream in = new URL(resultFileURL).openStream()) {</b>
<b class="nc">&nbsp;			parser.parse(in, resultFileURL);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;
<b class="nc">&nbsp;		return result;</b>
&nbsp;	}
&nbsp;
&nbsp;	public interface Factory {
&nbsp;
&nbsp;		SPARQLQueryTest createSPARQLQueryTest(String testURI, String name, String queryFileURL, String resultFileURL,
&nbsp;				Dataset dataSet, boolean laxCardinality);
&nbsp;
&nbsp;		SPARQLQueryTest createSPARQLQueryTest(String testURI, String name, String queryFileURL, String resultFileURL,
&nbsp;				Dataset dataSet, boolean laxCardinality, boolean checkOrder);
&nbsp;	}
&nbsp;
&nbsp;	public static TestSuite suite(String manifestFileURL, Factory factory) throws Exception {
<b class="nc">&nbsp;		return suite(manifestFileURL, factory, true);</b>
&nbsp;	}
&nbsp;
&nbsp;	public static TestSuite suite(String manifestFileURL, Factory factory, boolean approvedOnly) throws Exception {
<b class="nc">&nbsp;		LOGGER.info(&quot;Building test suite for {}&quot;, manifestFileURL);</b>
&nbsp;
<b class="nc">&nbsp;		TestSuite suite = new TestSuite(factory.getClass().getName());</b>
&nbsp;
&nbsp;		// Read manifest and create declared test cases
<b class="nc">&nbsp;		Repository manifestRep = new SailRepository(new MemoryStore());</b>
<b class="nc">&nbsp;		try (RepositoryConnection con = manifestRep.getConnection()) {</b>
&nbsp;
<b class="nc">&nbsp;			SPARQL11ManifestTest.addTurtle(con, new URL(manifestFileURL), manifestFileURL);</b>
&nbsp;
<b class="nc">&nbsp;			suite.setName(getManifestName(manifestRep, con, manifestFileURL));</b>
&nbsp;
&nbsp;			// Extract test case information from the manifest file. Note that we only
&nbsp;			// select those test cases that are mentioned in the list.
<b class="nc">&nbsp;			StringBuilder query = new StringBuilder(512);</b>
<b class="nc">&nbsp;			query.append(&quot; PREFIX mf: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#&gt; \n&quot;);</b>
<b class="nc">&nbsp;			query.append(&quot; PREFIX dawgt: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-dawg#&gt; \n&quot;);</b>
<b class="nc">&nbsp;			query.append(&quot; PREFIX qt: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-query#&gt; \n&quot;);</b>
<b class="nc">&nbsp;			query.append(&quot; PREFIX sd: &lt;http://www.w3.org/ns/sparql-service-description#&gt; \n&quot;);</b>
<b class="nc">&nbsp;			query.append(&quot; PREFIX ent: &lt;http://www.w3.org/ns/entailment/&gt; \n&quot;);</b>
<b class="nc">&nbsp;			query.append(</b>
&nbsp;					&quot; SELECT DISTINCT ?testURI ?testName ?resultFile ?action ?queryFile ?defaultGraph ?ordered \n&quot;);
<b class="nc">&nbsp;			query.append(&quot; WHERE { [] rdf:first ?testURI . \n&quot;);</b>
<b class="nc">&nbsp;			if (approvedOnly) {</b>
<b class="nc">&nbsp;				query.append(&quot; ?testURI dawgt:approval dawgt:Approved . \n&quot;);</b>
&nbsp;			}
<b class="nc">&nbsp;			query.append(&quot; ?testURI mf:name ?testName; \n&quot;);</b>
<b class="nc">&nbsp;			query.append(&quot;          mf:result ?resultFile . \n&quot;);</b>
<b class="nc">&nbsp;			query.append(&quot; OPTIONAL { ?testURI mf:checkOrder ?ordered } \n&quot;);</b>
<b class="nc">&nbsp;			query.append(&quot; OPTIONAL { ?testURI  mf:requires ?requirement } \n&quot;);</b>
<b class="nc">&nbsp;			query.append(&quot; ?testURI mf:action ?action. \n&quot;);</b>
<b class="nc">&nbsp;			query.append(&quot; ?action qt:query ?queryFile . \n&quot;);</b>
<b class="nc">&nbsp;			query.append(&quot; OPTIONAL { ?action qt:data ?defaultGraph } \n&quot;);</b>
<b class="nc">&nbsp;			query.append(&quot; OPTIONAL { ?action sd:entailmentRegime ?regime } \n&quot;);</b>
&nbsp;			// skip tests involving CSV result files, these are not query tests
<b class="nc">&nbsp;			query.append(&quot; FILTER(!STRENDS(STR(?resultFile), \&quot;csv\&quot;)) \n&quot;);</b>
&nbsp;			// skip tests involving entailment regimes
<b class="nc">&nbsp;			query.append(&quot; FILTER(!BOUND(?regime)) \n&quot;);</b>
&nbsp;			// skip test involving basic federation, these are tested separately.
<b class="nc">&nbsp;			query.append(&quot; FILTER (!BOUND(?requirement) || (?requirement != mf:BasicFederation)) \n&quot;);</b>
<b class="nc">&nbsp;			query.append(&quot; }\n&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			TupleQuery testCaseQuery = con.prepareTupleQuery(query.toString());</b>
&nbsp;
<b class="nc">&nbsp;			query.setLength(0);</b>
<b class="nc">&nbsp;			query.append(&quot; PREFIX qt: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-query#&gt; \n&quot;);</b>
<b class="nc">&nbsp;			query.append(&quot; SELECT ?graph \n&quot;);</b>
<b class="nc">&nbsp;			query.append(&quot; WHERE { ?action qt:graphData ?graph } \n&quot;);</b>
<b class="nc">&nbsp;			TupleQuery namedGraphsQuery = con.prepareTupleQuery(query.toString());</b>
&nbsp;
<b class="nc">&nbsp;			query.setLength(0);</b>
<b class="nc">&nbsp;			query.append(&quot; PREFIX mf: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#&gt; \n&quot;);</b>
<b class="nc">&nbsp;			query.append(&quot;ASK \n&quot;);</b>
<b class="nc">&nbsp;			query.append(&quot; WHERE { ?testURI  mf:resultCardinality mf:LaxCardinality .} \n&quot;);</b>
<b class="nc">&nbsp;			BooleanQuery laxCardinalityQuery = con.prepareBooleanQuery(query.toString());</b>
&nbsp;
<b class="nc">&nbsp;			LOGGER.debug(&quot;evaluating query..&quot;);</b>
<b class="nc">&nbsp;			try (TupleQueryResult testCases = testCaseQuery.evaluate()) {</b>
<b class="nc">&nbsp;				for (BindingSet testCase : testCases) {</b>
<b class="nc">&nbsp;					IRI testURI = (IRI) testCase.getValue(&quot;testURI&quot;);</b>
<b class="nc">&nbsp;					String testName = testCase.getValue(&quot;testName&quot;).stringValue();</b>
<b class="nc">&nbsp;					String resultFile = testCase.getValue(&quot;resultFile&quot;).stringValue();</b>
<b class="nc">&nbsp;					String queryFile = testCase.getValue(&quot;queryFile&quot;).stringValue();</b>
<b class="nc">&nbsp;					IRI defaultGraphURI = (IRI) testCase.getValue(&quot;defaultGraph&quot;);</b>
<b class="nc">&nbsp;					Value action = testCase.getValue(&quot;action&quot;);</b>
<b class="nc">&nbsp;					Value ordered = testCase.getValue(&quot;ordered&quot;);</b>
&nbsp;
<b class="nc">&nbsp;					LOGGER.debug(&quot;found test case : {}&quot;, testName);</b>
&nbsp;
<b class="nc">&nbsp;					SimpleDataset dataset = null;</b>
&nbsp;
&nbsp;					// Query named graphs
<b class="nc">&nbsp;					namedGraphsQuery.setBinding(&quot;action&quot;, action);</b>
<b class="nc">&nbsp;					try (TupleQueryResult namedGraphs = namedGraphsQuery.evaluate()) {</b>
<b class="nc">&nbsp;						if (defaultGraphURI != null || namedGraphs.hasNext()) {</b>
<b class="nc">&nbsp;							dataset = new SimpleDataset();</b>
<b class="nc">&nbsp;							if (defaultGraphURI != null) {</b>
<b class="nc">&nbsp;								dataset.addDefaultGraph(defaultGraphURI);</b>
&nbsp;							}
<b class="nc">&nbsp;							while (namedGraphs.hasNext()) {</b>
<b class="nc">&nbsp;								BindingSet graphBindings = namedGraphs.next();</b>
<b class="nc">&nbsp;								IRI namedGraphURI = (IRI) graphBindings.getValue(&quot;graph&quot;);</b>
<b class="nc">&nbsp;								LOGGER.debug(&quot; adding named graph : {}&quot;, namedGraphURI);</b>
<b class="nc">&nbsp;								dataset.addNamedGraph(namedGraphURI);</b>
<b class="nc">&nbsp;							}</b>
&nbsp;						}
<b class="nc">&nbsp;					}</b>
&nbsp;
&nbsp;					// Check for lax-cardinality conditions
&nbsp;					boolean laxCardinality;
<b class="nc">&nbsp;					laxCardinalityQuery.setBinding(&quot;testURI&quot;, testURI);</b>
<b class="nc">&nbsp;					laxCardinality = laxCardinalityQuery.evaluate();</b>
&nbsp;
&nbsp;					// if this is enabled, RDF4J passes all tests, showing that the only
&nbsp;					// difference is the semantics of arbitrary-length
&nbsp;					// paths
&nbsp;					/*
&nbsp;					 * if (!laxCardinality) { // property-path tests always with lax cardinality because Sesame filters
&nbsp;					 * out duplicates by design if (testURI.stringValue().contains(&quot;property-path&quot;)) { laxCardinality =
&nbsp;					 * true; } }
&nbsp;					 */
&nbsp;
&nbsp;					// Two SPARQL distinctness tests fail in RDF-1.1 if the only difference
&nbsp;					// is in the number of results
<b class="nc">&nbsp;					if (!laxCardinality) {</b>
<b class="nc">&nbsp;						if (testURI.stringValue().contains(&quot;distinct/manifest#distinct-2&quot;)</b>
<b class="nc">&nbsp;								|| testURI.stringValue().contains(&quot;distinct/manifest#distinct-9&quot;)) {</b>
<b class="nc">&nbsp;							laxCardinality = true;</b>
&nbsp;						}
&nbsp;					}
&nbsp;
<b class="nc">&nbsp;					LOGGER.debug(&quot;testURI={} name={} queryFile={}&quot;, testURI.stringValue(), testName, queryFile);</b>
&nbsp;
&nbsp;					// check if we should test for query result ordering
<b class="nc">&nbsp;					boolean checkOrder = false;</b>
<b class="nc">&nbsp;					if (ordered != null) {</b>
<b class="nc">&nbsp;						checkOrder = Boolean.parseBoolean(ordered.stringValue());</b>
&nbsp;					}
&nbsp;
<b class="nc">&nbsp;					SPARQLQueryTest test = factory.createSPARQLQueryTest(testURI.stringValue(), testName, queryFile,</b>
&nbsp;							resultFile, dataset, laxCardinality, checkOrder);
<b class="nc">&nbsp;					if (test != null) {</b>
<b class="nc">&nbsp;						suite.addTest(test);</b>
&nbsp;					}
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		manifestRep.shutDown();</b>
<b class="nc">&nbsp;		LOGGER.info(&quot;Created test suite with &quot; + suite.countTestCases() + &quot; test cases.&quot;);</b>
<b class="nc">&nbsp;		return suite;</b>
&nbsp;	}
&nbsp;
&nbsp;	protected static String getManifestName(Repository manifestRep, RepositoryConnection con, String manifestFileURL)
&nbsp;			throws QueryEvaluationException, RepositoryException, MalformedQueryException {
&nbsp;		// Try to extract suite name from manifest file
<b class="nc">&nbsp;		TupleQuery manifestNameQuery = con</b>
<b class="nc">&nbsp;				.prepareTupleQuery(&quot;SELECT ?ManifestName WHERE { ?ManifestURL rdfs:label ?ManifestName .}&quot;);</b>
<b class="nc">&nbsp;		manifestNameQuery.setBinding(&quot;ManifestURL&quot;, manifestRep.getValueFactory().createIRI(manifestFileURL));</b>
<b class="nc">&nbsp;		try (TupleQueryResult manifestNames = manifestNameQuery.evaluate()) {</b>
<b class="nc">&nbsp;			if (manifestNames.hasNext()) {</b>
<b class="nc">&nbsp;				return manifestNames.next().getValue(&quot;ManifestName&quot;).stringValue();</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;
&nbsp;		// Derive name from manifest URL
<b class="nc">&nbsp;		int lastSlashIdx = manifestFileURL.lastIndexOf(&#39;/&#39;);</b>
<b class="nc">&nbsp;		int secLastSlashIdx = manifestFileURL.lastIndexOf(&#39;/&#39;, lastSlashIdx - 1);</b>
<b class="nc">&nbsp;		return manifestFileURL.substring(secLastSlashIdx + 1, lastSlashIdx);</b>
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:56</div>
</div>
</body>
</html>
