


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > Service</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.query.algebra</a>
</div>

<h1>Coverage Summary for Class: Service (org.eclipse.rdf4j.query.algebra)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Service</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/74)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Service$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/29)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/82)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;package org.eclipse.rdf4j.query.algebra;
&nbsp;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.regex.Pattern;
&nbsp;
&nbsp;import org.eclipse.rdf4j.query.algebra.helpers.AbstractQueryModelVisitor;
&nbsp;
&nbsp;/**
&nbsp; * The SERVICE keyword as defined in &lt;a href=&quot;http://www.w3.org/TR/sparql11-federated- query/#defn_service&quot; &gt;SERVICE
&nbsp; * definition&lt;/a&gt;. The service expression is evaluated at the specified service URI. If the service reference is a
&nbsp; * variable, a value for this variable must be available at evaluation time (e.g. from earlier computations).
&nbsp; *
&nbsp; * @author Andreas Schwarte
&nbsp; */
&nbsp;public class Service extends UnaryTupleOperator {
&nbsp;
&nbsp;	/*-----------*
&nbsp;	 * Variables *
&nbsp;	 *-----------*/
&nbsp;
&nbsp;	private Var serviceRef;
&nbsp;
&nbsp;	/* a string representation of the inner expression (e.g. extracted during parsing) */
&nbsp;	private String serviceExpressionString;
&nbsp;
&nbsp;	private final Set&lt;String&gt; serviceVars;
&nbsp;
&nbsp;	/* the prefix declarations, potentially null */
&nbsp;	private Map&lt;String, String&gt; prefixDeclarations;
&nbsp;
&nbsp;	private String baseURI;
&nbsp;
&nbsp;	/*
&nbsp;	 * prepared queries, including prefix. Contains %PROJECTION_VARS% to be replaced at evaluation time. see
&nbsp;	 */
&nbsp;	private String preparedSelectQueryString;
&nbsp;
&nbsp;	private String preparedAskQueryString;
&nbsp;
&nbsp;	private final boolean silent;
&nbsp;
&nbsp;	/*--------------*
&nbsp;	 * Constructors *
&nbsp;	 *--------------*/
&nbsp;
&nbsp;	public Service(Var serviceRef, TupleExpr serviceExpr, String serviceExpressionString,
&nbsp;			Map&lt;String, String&gt; prefixDeclarations, String baseURI, boolean silent) {
<b class="nc">&nbsp;		super(serviceExpr);</b>
<b class="nc">&nbsp;		setServiceRef(serviceRef);</b>
<b class="nc">&nbsp;		setExpressionString(serviceExpressionString);</b>
<b class="nc">&nbsp;		this.serviceVars = computeServiceVars(serviceExpr);</b>
<b class="nc">&nbsp;		setPrefixDeclarations(prefixDeclarations);</b>
<b class="nc">&nbsp;		setBaseURI(baseURI);</b>
<b class="nc">&nbsp;		initPreparedQueryString();</b>
<b class="nc">&nbsp;		this.silent = silent;</b>
&nbsp;	}
&nbsp;
&nbsp;	/*---------*
&nbsp;	 * Methods *
&nbsp;	 *---------*/
&nbsp;
&nbsp;	public Var getServiceRef() {
<b class="nc">&nbsp;		return this.serviceRef;</b>
&nbsp;	}
&nbsp;
&nbsp;	public TupleExpr getServiceExpr() {
<b class="nc">&nbsp;		return this.arg;</b>
&nbsp;	}
&nbsp;
&nbsp;	public void setServiceRef(Var serviceRef) {
<b class="nc">&nbsp;		this.serviceRef = serviceRef;</b>
<b class="nc">&nbsp;		this.serviceRef.setParentNode(this);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * @return Returns the silent.
&nbsp;	 */
&nbsp;	public boolean isSilent() {
<b class="nc">&nbsp;		return silent;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * @return Returns the prefixDeclarations.
&nbsp;	 */
&nbsp;	public Map&lt;String, String&gt; getPrefixDeclarations() {
<b class="nc">&nbsp;		return prefixDeclarations;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * @param prefixDeclarations The prefixDeclarations to set.
&nbsp;	 */
&nbsp;	public void setPrefixDeclarations(Map&lt;String, String&gt; prefixDeclarations) {
<b class="nc">&nbsp;		this.prefixDeclarations = prefixDeclarations;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * The SERVICE expression, either complete or just the expression e.g. &quot;SERVICE &lt;url&gt; { ... }&quot; becomes &quot; ... &quot;
&nbsp;	 *
&nbsp;	 * @param serviceExpressionString the inner expression as SPARQL String representation
&nbsp;	 */
&nbsp;	public void setExpressionString(String serviceExpressionString) {
<b class="nc">&nbsp;		this.serviceExpressionString = parseServiceExpression(serviceExpressionString);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * @return Returns the serviceExpressionString.
&nbsp;	 */
&nbsp;	public String getServiceExpressionString() {
<b class="nc">&nbsp;		return serviceExpressionString;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns an ASK query string using no projection vars.
&nbsp;	 *
&nbsp;	 * @return an ASK query string
&nbsp;	 */
&nbsp;	public String getAskQueryString() {
<b class="nc">&nbsp;		return preparedAskQueryString;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns a SELECT query string using the provided projection vars. The variables are inserted into the
&nbsp;	 * preparedSelectQueryString in the SELECT clause.
&nbsp;	 *
&nbsp;	 * @param projectionVars
&nbsp;	 * @return SELECT query string, utilizing the given projection variables
&nbsp;	 */
&nbsp;	public String getSelectQueryString(Set&lt;String&gt; projectionVars) {
<b class="nc">&nbsp;		if (projectionVars.isEmpty()) {</b>
<b class="nc">&nbsp;			return preparedSelectQueryString.replace(&quot;%PROJECTION_VARS%&quot;, &quot;*&quot;);</b>
&nbsp;		}
<b class="nc">&nbsp;		StringBuilder sb = new StringBuilder();</b>
<b class="nc">&nbsp;		for (String var : projectionVars) {</b>
<b class="nc">&nbsp;			sb.append(&quot; ?&quot;).append(var);</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return preparedSelectQueryString.replace(&quot;%PROJECTION_VARS%&quot;, sb.toString());</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * @return Returns the serviceVars.
&nbsp;	 */
&nbsp;	public Set&lt;String&gt; getServiceVars() {
<b class="nc">&nbsp;		return serviceVars;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public &lt;X extends Exception&gt; void visit(QueryModelVisitor&lt;X&gt; visitor) throws X {
<b class="nc">&nbsp;		visitor.meet(this);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public &lt;X extends Exception&gt; void visitChildren(QueryModelVisitor&lt;X&gt; visitor) throws X {
<b class="nc">&nbsp;		serviceRef.visit(visitor);</b>
<b class="nc">&nbsp;		super.visitChildren(visitor);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void replaceChildNode(QueryModelNode current, QueryModelNode replacement) {
<b class="nc">&nbsp;		if (serviceRef == current) {</b>
<b class="nc">&nbsp;			setServiceRef((Var) replacement);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			super.replaceChildNode(current, replacement);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public boolean equals(Object other) {
<b class="nc">&nbsp;		if (other instanceof Service &amp;&amp; super.equals(other)) {</b>
<b class="nc">&nbsp;			Service o = (Service) other;</b>
<b class="nc">&nbsp;			return serviceRef.equals(o.getServiceRef());</b>
&nbsp;		}
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public int hashCode() {
<b class="nc">&nbsp;		return super.hashCode() ^ serviceRef.hashCode();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Service clone() {
<b class="nc">&nbsp;		Service clone = (Service) super.clone();</b>
<b class="nc">&nbsp;		clone.setServiceRef(serviceRef.clone());</b>
<b class="nc">&nbsp;		return clone;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Compute the variable names occurring in the service expression using tree traversal, since these are necessary
&nbsp;	 * for building the SPARQL query.
&nbsp;	 *
&nbsp;	 * @return the set of variable names in the given service expression
&nbsp;	 */
&nbsp;	private Set&lt;String&gt; computeServiceVars(TupleExpr serviceExpression) {
<b class="nc">&nbsp;		final Set&lt;String&gt; res = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;		serviceExpression.visit(new AbstractQueryModelVisitor&lt;RuntimeException&gt;() {</b>
&nbsp;
&nbsp;			@Override
&nbsp;			public void meet(Var node) throws RuntimeException {
&nbsp;				// take only real vars, i.e. ignore blank nodes
<b class="nc">&nbsp;				if (!node.hasValue() &amp;&amp; !node.isAnonymous()) {</b>
<b class="nc">&nbsp;					res.add(node.getName());</b>
&nbsp;				}
&nbsp;			}
&nbsp;
&nbsp;			@Override
&nbsp;			public void meet(BindingSetAssignment bsa) {
<b class="nc">&nbsp;				res.addAll(bsa.getAssuredBindingNames());</b>
&nbsp;			}
&nbsp;
&nbsp;			@Override
&nbsp;			public void meet(Extension e) {
<b class="nc">&nbsp;				super.meet(e);</b>
<b class="nc">&nbsp;				for (ExtensionElem elem : e.getElements()) {</b>
<b class="nc">&nbsp;					res.add(elem.getName());</b>
<b class="nc">&nbsp;				}</b>
&nbsp;			}
&nbsp;			// TODO maybe stop tree traversal in nested SERVICE?
&nbsp;		});
<b class="nc">&nbsp;		return res;</b>
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	private static final Pattern subselectPattern = Pattern.compile(&quot;SELECT.*&quot;,</b>
&nbsp;			Pattern.CASE_INSENSITIVE | Pattern.DOTALL);
&nbsp;
&nbsp;	private void initPreparedQueryString() {
&nbsp;
<b class="nc">&nbsp;		serviceExpressionString = serviceExpressionString.trim();</b>
<b class="nc">&nbsp;		String prefixString = computePrefixString(prefixDeclarations);</b>
&nbsp;
&nbsp;		// build the raw SELECT query string
<b class="nc">&nbsp;		StringBuilder sb = new StringBuilder();</b>
<b class="nc">&nbsp;		sb.append(prefixString);</b>
<b class="nc">&nbsp;		if (subselectPattern.matcher(serviceExpressionString).matches()) {</b>
<b class="nc">&nbsp;			sb.append(serviceExpressionString);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			sb.append(&quot;SELECT %PROJECTION_VARS% WHERE { &quot;);</b>
<b class="nc">&nbsp;			sb.append(serviceExpressionString);</b>
<b class="nc">&nbsp;			sb.append(&quot;\n}&quot;);</b>
&nbsp;		}
<b class="nc">&nbsp;		preparedSelectQueryString = sb.toString();</b>
&nbsp;
&nbsp;		// build the raw ASK query string
<b class="nc">&nbsp;		sb = new StringBuilder();</b>
<b class="nc">&nbsp;		sb.append(prefixString);</b>
<b class="nc">&nbsp;		sb.append(&quot;ASK {&quot;);</b>
<b class="nc">&nbsp;		sb.append(serviceExpressionString);</b>
<b class="nc">&nbsp;		sb.append(&quot; }&quot;);</b>
<b class="nc">&nbsp;		preparedAskQueryString = sb.toString();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Compute the prefix string only once to avoid computation overhead during evaluation.
&nbsp;	 *
&nbsp;	 * @param prefixDeclarations
&nbsp;	 * @return a Prefix String or an empty string if there are no prefixes
&nbsp;	 */
&nbsp;	private String computePrefixString(Map&lt;String, String&gt; prefixDeclarations) {
<b class="nc">&nbsp;		if (prefixDeclarations == null) {</b>
<b class="nc">&nbsp;			return &quot;&quot;;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		StringBuilder sb = new StringBuilder();</b>
<b class="nc">&nbsp;		for (String prefix : prefixDeclarations.keySet()) {</b>
<b class="nc">&nbsp;			String uri = prefixDeclarations.get(prefix);</b>
<b class="nc">&nbsp;			sb.append(&quot;PREFIX &quot;).append(prefix).append(&quot;:&quot;).append(&quot; &lt;&quot;).append(uri).append(&quot;&gt; &quot;);</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return sb.toString();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Parses a service expression to just have the inner expression, e.g. from something like &quot;SERVICE &amp;lt;url&amp;gt; {
&nbsp;	 * ... }&quot; becomes &quot; ... &quot;, also applies {@link String#trim()} to remove leading/tailing space
&nbsp;	 *
&nbsp;	 * @param serviceExpression
&nbsp;	 * @return the inner expression of the given service expression
&nbsp;	 */
&nbsp;	private String parseServiceExpression(String serviceExpression) {
&nbsp;
<b class="nc">&nbsp;		if (serviceExpression.toLowerCase().startsWith(&quot;service&quot;)) {</b>
<b class="nc">&nbsp;			return serviceExpression.substring(serviceExpression.indexOf(&#39;{&#39;) + 1, serviceExpression.lastIndexOf(&#39;}&#39;))</b>
<b class="nc">&nbsp;					.trim();</b>
&nbsp;		}
<b class="nc">&nbsp;		return serviceExpression;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * @param baseURI The baseURI to set.
&nbsp;	 */
&nbsp;	public void setBaseURI(String baseURI) {
<b class="nc">&nbsp;		this.baseURI = baseURI;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * @return Returns the baseURI.
&nbsp;	 */
&nbsp;	public String getBaseURI() {
<b class="nc">&nbsp;		return baseURI;</b>
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:20</div>
</div>
</body>
</html>
