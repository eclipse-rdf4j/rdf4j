


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > ShaclSail</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.sail.shacl</a>
</div>

<h1>Coverage Summary for Class: ShaclSail (org.eclipse.rdf4j.sail.shacl)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ShaclSail</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/74)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/136)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ShaclSail$CleanableState</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ShaclSail$RevivableExecutorService</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/54)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/31)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ShaclSail$TransactionSettings</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ShaclSail$TransactionSettings$PerformanceHint</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ShaclSail$TransactionSettings$ValidationApproach</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/56)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/142)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/202)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2018 Eclipse RDF4J contributors.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;
&nbsp;package org.eclipse.rdf4j.sail.shacl;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.List;
&nbsp;import java.util.Set;
&nbsp;import java.util.concurrent.Callable;
&nbsp;import java.util.concurrent.ExecutionException;
&nbsp;import java.util.concurrent.ExecutorService;
&nbsp;import java.util.concurrent.Executors;
&nbsp;import java.util.concurrent.Future;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.concurrent.TimeoutException;
&nbsp;import java.util.concurrent.atomic.AtomicBoolean;
&nbsp;import java.util.concurrent.atomic.AtomicLong;
&nbsp;import java.util.function.Supplier;
&nbsp;
&nbsp;import org.eclipse.rdf4j.common.annotation.Experimental;
&nbsp;import org.eclipse.rdf4j.common.annotation.InternalUseOnly;
&nbsp;import org.eclipse.rdf4j.common.concurrent.locks.ReadPrefReadWriteLockManager;
&nbsp;import org.eclipse.rdf4j.common.concurrent.locks.StampedLockManager;
&nbsp;import org.eclipse.rdf4j.common.concurrent.locks.diagnostics.ConcurrentCleaner;
&nbsp;import org.eclipse.rdf4j.common.transaction.IsolationLevels;
&nbsp;import org.eclipse.rdf4j.common.transaction.TransactionSetting;
&nbsp;import org.eclipse.rdf4j.model.IRI;
&nbsp;import org.eclipse.rdf4j.model.vocabulary.DASH;
&nbsp;import org.eclipse.rdf4j.model.vocabulary.RDF4J;
&nbsp;import org.eclipse.rdf4j.model.vocabulary.RSX;
&nbsp;import org.eclipse.rdf4j.model.vocabulary.SHACL;
&nbsp;import org.eclipse.rdf4j.repository.Repository;
&nbsp;import org.eclipse.rdf4j.repository.RepositoryConnection;
&nbsp;import org.eclipse.rdf4j.repository.sail.SailRepository;
&nbsp;import org.eclipse.rdf4j.repository.sail.SailRepositoryConnection;
&nbsp;import org.eclipse.rdf4j.sail.NotifyingSail;
&nbsp;import org.eclipse.rdf4j.sail.NotifyingSailConnection;
&nbsp;import org.eclipse.rdf4j.sail.Sail;
&nbsp;import org.eclipse.rdf4j.sail.SailConnection;
&nbsp;import org.eclipse.rdf4j.sail.SailException;
&nbsp;import org.eclipse.rdf4j.sail.memory.MemoryStore;
&nbsp;import org.eclipse.rdf4j.sail.memory.MemoryStoreConnection;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.ContextWithShapes;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.Shape;
&nbsp;import org.eclipse.rdf4j.sail.shacl.wrapper.shape.CombinedShapeSource;
&nbsp;import org.eclipse.rdf4j.sail.shacl.wrapper.shape.ForwardChainingShapeSource;
&nbsp;import org.eclipse.rdf4j.sail.shacl.wrapper.shape.ShapeSource;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;
&nbsp;//@formatter:off
&nbsp;
&nbsp;/**
&nbsp; * A {@link Sail} implementation that adds support for the Shapes Constraint Language (SHACL).
&nbsp; * &lt;p&gt;
&nbsp; * The ShaclSail looks for SHACL shape data in a special named graph {@link RDF4J#SHACL_SHAPE_GRAPH}.
&nbsp; * &lt;h4&gt;Working example&lt;/h4&gt;
&nbsp; * &lt;p&gt;
&nbsp; *
&nbsp; * &lt;pre&gt;
&nbsp; * import java.io.IOException;
&nbsp; * import java.io.StringReader;
&nbsp; *
&nbsp; * import org.eclipse.rdf4j.common.exception.ValidationException;
&nbsp; * import org.eclipse.rdf4j.model.Model;
&nbsp; * import org.eclipse.rdf4j.model.vocabulary.RDF4J;
&nbsp; * import org.eclipse.rdf4j.repository.RepositoryException;
&nbsp; * import org.eclipse.rdf4j.repository.sail.SailRepository;
&nbsp; * import org.eclipse.rdf4j.repository.sail.SailRepositoryConnection;
&nbsp; * import org.eclipse.rdf4j.rio.RDFFormat;
&nbsp; * import org.eclipse.rdf4j.rio.Rio;
&nbsp; * import org.eclipse.rdf4j.rio.WriterConfig;
&nbsp; * import org.eclipse.rdf4j.rio.helpers.BasicWriterSettings;
&nbsp; * import org.eclipse.rdf4j.sail.memory.MemoryStore;
&nbsp; * import org.eclipse.rdf4j.sail.shacl.ShaclSail;
&nbsp; *
&nbsp; * public class ShaclSampleCode {
&nbsp; *
&nbsp; *     public static void main(String[] args) throws IOException {
&nbsp; *
&nbsp; *         ShaclSail shaclSail = new ShaclSail(new MemoryStore());
&nbsp; *
&nbsp; *         SailRepository sailRepository = new SailRepository(shaclSail);
&nbsp; *         sailRepository.init();
&nbsp; *
&nbsp; *         try (SailRepositoryConnection connection = sailRepository.getConnection()) {
&nbsp; *
&nbsp; *             connection.begin();
&nbsp; *
&nbsp; *             StringReader shaclRules = new StringReader(String.join(&quot;\n&quot;, &quot;&quot;,
&nbsp; *                     &quot;@prefix ex: &amp;#x3C;http://example.com/ns#&amp;#x3E; .&quot;,
&nbsp; *                     &quot;@prefix sh: &amp;#x3C;http://www.w3.org/ns/shacl#&amp;#x3E; .&quot;,
&nbsp; *                     &quot;@prefix xsd: &amp;#x3C;http://www.w3.org/2001/XMLSchema#&amp;#x3E; .&quot;,
&nbsp; *                     &quot;@prefix foaf: &amp;#x3C;http://xmlns.com/foaf/0.1/&amp;#x3E;.&quot;,
&nbsp; *
&nbsp; *                     &quot;ex:PersonShape&quot;,
&nbsp; *                     &quot;    a sh:NodeShape  ;&quot;,
&nbsp; *                     &quot;    sh:targetClass foaf:Person ;&quot;,
&nbsp; *                     &quot;    sh:property ex:PersonShapeProperty .&quot;,
&nbsp; *
&nbsp; *                     &quot;ex:PersonShapeProperty &quot;,
&nbsp; *                     &quot;    sh:path foaf:age ;&quot;,
&nbsp; *                     &quot;    sh:datatype xsd:int ;&quot;,
&nbsp; *                     &quot;    sh:maxCount 1 ;&quot;,
&nbsp; *                     &quot;    sh:minCount 1 .&quot;
&nbsp; *             ));
&nbsp; *
&nbsp; *             connection.add(shaclRules, &quot;&quot;, RDFFormat.TURTLE, RDF4J.SHACL_SHAPE_GRAPH);
&nbsp; *             connection.commit();
&nbsp; *
&nbsp; *             connection.begin();
&nbsp; *
&nbsp; *             StringReader invalidSampleData = new StringReader(String.join(&quot;\n&quot;, &quot;&quot;,
&nbsp; *                     &quot;@prefix ex: &amp;#x3C;http://example.com/ns#&amp;#x3E; .&quot;,
&nbsp; *                     &quot;@prefix foaf: &amp;#x3C;http://xmlns.com/foaf/0.1/&amp;#x3E;.&quot;,
&nbsp; *                     &quot;@prefix xsd: &amp;#x3C;http://www.w3.org/2001/XMLSchema#&amp;#x3E; .&quot;,
&nbsp; *
&nbsp; *                     &quot;ex:peter a foaf:Person ;&quot;,
&nbsp; *                     &quot;    foaf:age 20, \&quot;30\&quot;^^xsd:int  .&quot;
&nbsp; *
&nbsp; *             ));
&nbsp; *
&nbsp; *             connection.add(invalidSampleData, &quot;&quot;, RDFFormat.TURTLE);
&nbsp; *             try {
&nbsp; *                 connection.commit();
&nbsp; *             } catch (RepositoryException exception) {
&nbsp; *                 Throwable cause = exception.getCause();
&nbsp; *                 if (cause instanceof ValidationException) {
&nbsp; *
&nbsp; *                     // use the validationReportModel to understand validation violations
&nbsp; *                     Model validationReportModel = ((ValidationException) cause).validationReportAsModel();
&nbsp; *
&nbsp; *                     // Pretty print the validation report
&nbsp; *                     WriterConfig writerConfig = new WriterConfig()
&nbsp; *                             .set(BasicWriterSettings.PRETTY_PRINT, true)
&nbsp; *                             .set(BasicWriterSettings.INLINE_BLANK_NODES, true);
&nbsp; *
&nbsp; *                     Rio.write(validationReportModel, System.out, RDFFormat.TURTLE, writerConfig);
&nbsp; *                     System.out.println();
&nbsp; *                 }
&nbsp; *
&nbsp; *                 throw exception;
&nbsp; *             }
&nbsp; *         }
&nbsp; *     }
&nbsp; * }
&nbsp; * &lt;/pre&gt;
&nbsp; *
&nbsp; * @author Heshan Jayasinghe
&nbsp; * @author HÃ¥vard Ottestad
&nbsp; * @see &lt;a href=&quot;https://www.w3.org/TR/shacl/&quot;&gt;SHACL W3C Recommendation&lt;/a&gt;
&nbsp; */
&nbsp;//@formatter:on
<b class="nc">&nbsp;public class ShaclSail extends ShaclSailBaseConfiguration {</b>
&nbsp;
<b class="nc">&nbsp;	private static final int AVAILABLE_PROCESSORS = Runtime.getRuntime().availableProcessors();</b>
&nbsp;
<b class="nc">&nbsp;	private static final Logger logger = LoggerFactory.getLogger(ShaclSail.class);</b>
<b class="nc">&nbsp;	private static final ConcurrentCleaner cleaner = new ConcurrentCleaner();</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * an initialized {@link Repository} for storing/retrieving Shapes data
&nbsp;	 */
&nbsp;	private SailRepository shapesRepo;
&nbsp;
&nbsp;	// lockManager used for read/write locks used to synchronize validation so that SNAPSHOT isolation is sufficient to
&nbsp;	// achieve SERIALIZABLE isolation wrt. validation
<b class="nc">&nbsp;	final ReadPrefReadWriteLockManager serializableValidationLock = new ReadPrefReadWriteLockManager();</b>
&nbsp;
&nbsp;	// shapesCacheLockManager used to keep track of changes to the cache
&nbsp;	private StampedLockManager.Cache&lt;List&lt;ContextWithShapes&gt;&gt; cachedShapes;
&nbsp;
&nbsp;	// true if the base sail supports IsolationLevels.SNAPSHOT
&nbsp;	private boolean supportsSnapshotIsolation;
&nbsp;
&nbsp;	// This is used to keep track of the current connection, if the opening and closing of connections is done serially.
&nbsp;	// If it is done in parallel, then this will catch that and the multipleConcurrentConnections == true.
<b class="nc">&nbsp;	private final transient AtomicLong singleConnectionCounter = new AtomicLong();</b>
<b class="nc">&nbsp;	final Object singleConnectionMonitor = new Object();</b>
&nbsp;
<b class="nc">&nbsp;	private final AtomicBoolean initialized = new AtomicBoolean(false);</b>
&nbsp;
&nbsp;	private final RevivableExecutorService executorService;
&nbsp;
&nbsp;	@InternalUseOnly
&nbsp;	StampedLockManager.Cache&lt;List&lt;ContextWithShapes&gt;&gt;.WritableState getCachedShapesForWriting()
&nbsp;			throws InterruptedException {
<b class="nc">&nbsp;		return cachedShapes.getWriteState();</b>
&nbsp;	}
&nbsp;
&nbsp;	@InternalUseOnly
&nbsp;	public StampedLockManager.Cache&lt;List&lt;ContextWithShapes&gt;&gt;.ReadableState getCachedShapes()
&nbsp;			throws InterruptedException {
<b class="nc">&nbsp;		return cachedShapes.getReadState();</b>
&nbsp;	}
&nbsp;
&nbsp;	static class CleanableState implements Runnable {
&nbsp;
&nbsp;		private final AtomicBoolean initialized;
&nbsp;		private final ExecutorService executorService;
&nbsp;
<b class="nc">&nbsp;		CleanableState(AtomicBoolean initialized, ExecutorService executorService) {</b>
<b class="nc">&nbsp;			this.initialized = initialized;</b>
<b class="nc">&nbsp;			this.executorService = executorService;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void run() {
<b class="nc">&nbsp;			if (initialized.get()) {</b>
<b class="nc">&nbsp;				logger.error(&quot;ShaclSail was garbage collected without shutdown() having been called first.&quot;);</b>
&nbsp;			}
<b class="nc">&nbsp;			executorService.shutdownNow();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public ShaclSail(NotifyingSail baseSail) {
<b class="nc">&nbsp;		super(baseSail);</b>
<b class="nc">&nbsp;		executorService = getExecutorService();</b>
<b class="nc">&nbsp;		cleaner.register(this, new CleanableState(initialized, executorService));</b>
<b class="nc">&nbsp;		this.supportsSnapshotIsolation = baseSail.getSupportedIsolationLevels().contains(IsolationLevels.SNAPSHOT);</b>
&nbsp;	}
&nbsp;
&nbsp;	public ShaclSail() {
<b class="nc">&nbsp;		super();</b>
<b class="nc">&nbsp;		executorService = getExecutorService();</b>
<b class="nc">&nbsp;		cleaner.register(this, new CleanableState(initialized, executorService));</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void setBaseSail(Sail baseSail) {
<b class="nc">&nbsp;		super.setBaseSail(baseSail);</b>
<b class="nc">&nbsp;		this.supportsSnapshotIsolation = baseSail.getSupportedIsolationLevels().contains(IsolationLevels.SNAPSHOT);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * @return
&nbsp;	 * @implNote This is an extension point for configuring a different executor service for parallel validation. The
&nbsp;	 *           code is marked as experimental because it may change from one minor release to another.
&nbsp;	 */
&nbsp;	@Experimental
&nbsp;	protected RevivableExecutorService getExecutorService() {
<b class="nc">&nbsp;		return new RevivableExecutorService(</b>
<b class="nc">&nbsp;				() -&gt; Executors.newFixedThreadPool(AVAILABLE_PROCESSORS,</b>
&nbsp;						r -&gt; {
<b class="nc">&nbsp;							Thread t = Executors.defaultThreadFactory().newThread(r);</b>
&nbsp;							// this thread pool does not need to stick around if the all other threads are done, because
&nbsp;							// it is only used for SHACL validation and if all other threads have ended then there would
&nbsp;							// be no thread to receive the validation results.
<b class="nc">&nbsp;							t.setDaemon(true);</b>
<b class="nc">&nbsp;							t.setName(&quot;ShaclSail validation thread &quot; + t.getId());</b>
<b class="nc">&nbsp;							return t;</b>
&nbsp;						}));
&nbsp;	}
&nbsp;
&nbsp;	void closeConnection() {
&nbsp;		// closing a connection will set the to zero if there are currently no other connections open
<b class="nc">&nbsp;		singleConnectionCounter.compareAndSet(1, 0);</b>
&nbsp;	}
&nbsp;
&nbsp;	boolean usesSingleConnection() {
&nbsp;//		return false; // if this method returns false, then the connection will always use the new serializable validation
<b class="nc">&nbsp;		assert singleConnectionCounter.get() != 0;</b>
<b class="nc">&nbsp;		return singleConnectionCounter.get() == 1;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Lists the predicates that have been implemented in the ShaclSail. All of these, and all combinations,
&nbsp;	 * &lt;i&gt;should&lt;/i&gt; work, please report any bugs. For sh:path, only single predicate paths, or single predicate inverse
&nbsp;	 * paths are supported. DASH and RSX features may need to be enabled.
&nbsp;	 *
&nbsp;	 * @return List of IRIs (SHACL predicates)
&nbsp;	 */
&nbsp;	public static List&lt;IRI&gt; getSupportedShaclPredicates() {
<b class="nc">&nbsp;		return Arrays.asList(</b>
&nbsp;				SHACL.TARGET_CLASS,
&nbsp;				SHACL.PATH,
&nbsp;				SHACL.PROPERTY,
&nbsp;				SHACL.OR,
&nbsp;				SHACL.AND,
&nbsp;				SHACL.MIN_COUNT,
&nbsp;				SHACL.MAX_COUNT,
&nbsp;				SHACL.MIN_LENGTH,
&nbsp;				SHACL.MAX_LENGTH,
&nbsp;				SHACL.PATTERN,
&nbsp;				SHACL.FLAGS,
&nbsp;				SHACL.NODE_KIND_PROP,
&nbsp;				SHACL.LANGUAGE_IN,
&nbsp;				SHACL.DATATYPE,
&nbsp;				SHACL.MIN_EXCLUSIVE,
&nbsp;				SHACL.MIN_INCLUSIVE,
&nbsp;				SHACL.MAX_EXCLUSIVE,
&nbsp;				SHACL.MAX_INCLUSIVE,
&nbsp;				SHACL.CLASS,
&nbsp;				SHACL.TARGET_NODE,
&nbsp;				SHACL.DEACTIVATED,
&nbsp;				SHACL.TARGET_SUBJECTS_OF,
&nbsp;				SHACL.IN,
&nbsp;				SHACL.UNIQUE_LANG,
&nbsp;				SHACL.NOT,
&nbsp;				SHACL.TARGET_OBJECTS_OF,
&nbsp;				SHACL.HAS_VALUE,
&nbsp;				SHACL.TARGET_PROP,
&nbsp;				SHACL.INVERSE_PATH,
&nbsp;				SHACL.NODE,
&nbsp;				SHACL.QUALIFIED_MAX_COUNT,
&nbsp;				SHACL.QUALIFIED_MIN_COUNT,
&nbsp;				SHACL.QUALIFIED_VALUE_SHAPE,
&nbsp;				SHACL.SHAPES_GRAPH,
&nbsp;				DASH.hasValueIn,
&nbsp;				RSX.targetShape
&nbsp;		);
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void init() throws SailException {
<b class="nc">&nbsp;		if (!initialized.compareAndSet(false, true)) {</b>
&nbsp;			// already initialized
&nbsp;			return;
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		super.init();</b>
&nbsp;
<b class="nc">&nbsp;		executorService.init();</b>
&nbsp;
<b class="nc">&nbsp;		if (shapesRepo != null) {</b>
<b class="nc">&nbsp;			shapesRepo.shutDown();</b>
<b class="nc">&nbsp;			shapesRepo = null;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (super.getBaseSail().getDataDir() != null) {</b>
<b class="nc">&nbsp;			String path = super.getBaseSail().getDataDir().getPath();</b>
<b class="nc">&nbsp;			if (path.endsWith(&quot;/&quot;)) {</b>
<b class="nc">&nbsp;				path = path.substring(0, path.length() - 1);</b>
&nbsp;			}
<b class="nc">&nbsp;			path = path + &quot;/shapes-graph/&quot;;</b>
&nbsp;
<b class="nc">&nbsp;			logger.info(&quot;Shapes will be persisted in: &quot; + path);</b>
&nbsp;
<b class="nc">&nbsp;			shapesRepo = new SailRepository(new MemoryStore(new File(path)));</b>
<b class="nc">&nbsp;		} else {</b>
<b class="nc">&nbsp;			shapesRepo = new SailRepository(new MemoryStore());</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		shapesRepo.init();</b>
&nbsp;
<b class="nc">&nbsp;		try (SailRepositoryConnection shapesRepoConnection = shapesRepo.getConnection()) {</b>
<b class="nc">&nbsp;			shapesRepoConnection.begin(IsolationLevels.NONE);</b>
<b class="nc">&nbsp;			shapesRepoConnection.commit();</b>
<b class="nc">&nbsp;		}</b>
&nbsp;
<b class="nc">&nbsp;		cachedShapes = new StampedLockManager.Cache&lt;&gt;(new StampedLockManager(), () -&gt; {</b>
<b class="nc">&nbsp;			IRI[] shapesGraphs = getShapesGraphs().stream()</b>
<b class="nc">&nbsp;					.map(g -&gt; {</b>
<b class="nc">&nbsp;						if (g.equals(RDF4J.NIL)) {</b>
<b class="nc">&nbsp;							return null;</b>
&nbsp;						}
<b class="nc">&nbsp;						return g;</b>
&nbsp;					})
<b class="nc">&nbsp;					.toArray(IRI[]::new);</b>
&nbsp;
<b class="nc">&nbsp;			boolean onlyRdf4jShaclShapeGraph = shapesGraphs.length == 1</b>
<b class="nc">&nbsp;					&amp;&amp; RDF4J.SHACL_SHAPE_GRAPH.equals(shapesGraphs[0]);</b>
&nbsp;
<b class="nc">&nbsp;			return getShapes(shapesGraphs, onlyRdf4jShaclShapeGraph);</b>
&nbsp;		});
&nbsp;
&nbsp;		try {
<b class="nc">&nbsp;			cachedShapes.warmUp();</b>
<b class="nc">&nbsp;		} catch (InterruptedException e) {</b>
<b class="nc">&nbsp;			throw convertToSailException(e);</b>
&nbsp;
<b class="nc">&nbsp;		}</b>
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	@InternalUseOnly
&nbsp;	public List&lt;ContextWithShapes&gt; getShapes(RepositoryConnection shapesRepoConnection, SailConnection sailConnection,
&nbsp;			IRI[] shapesGraphs) throws SailException {
&nbsp;
<b class="nc">&nbsp;		try (ShapeSource shapeSource = new CombinedShapeSource(shapesRepoConnection, sailConnection)</b>
<b class="nc">&nbsp;				.withContext(shapesGraphs)) {</b>
<b class="nc">&nbsp;			return Shape.Factory.getShapes(shapeSource, this);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	@InternalUseOnly
&nbsp;	public List&lt;ContextWithShapes&gt; getShapes(RepositoryConnection shapesRepoConnection, IRI[] shapesGraphs)
&nbsp;			throws SailException {
&nbsp;
<b class="nc">&nbsp;		try (ShapeSource shapeSource = new ForwardChainingShapeSource(shapesRepoConnection).withContext(shapesGraphs)) {</b>
<b class="nc">&nbsp;			return Shape.Factory.getShapes(shapeSource, this);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public synchronized void shutDown() throws SailException {
<b class="nc">&nbsp;		if (shapesRepo != null) {</b>
<b class="nc">&nbsp;			shapesRepo.shutDown();</b>
<b class="nc">&nbsp;			shapesRepo = null;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		cachedShapes = null;</b>
&nbsp;
<b class="nc">&nbsp;		boolean terminated = shutdownExecutorService(false);</b>
&nbsp;
<b class="nc">&nbsp;		initialized.set(false);</b>
<b class="nc">&nbsp;		super.shutDown();</b>
&nbsp;
<b class="nc">&nbsp;		if (!terminated) {</b>
<b class="nc">&nbsp;			shutdownExecutorService(true);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private boolean shutdownExecutorService(boolean forced) {
<b class="nc">&nbsp;		boolean terminated = false;</b>
&nbsp;
<b class="nc">&nbsp;		executorService.shutdown();</b>
&nbsp;		try {
<b class="nc">&nbsp;			terminated = executorService.awaitTermination(200, TimeUnit.MILLISECONDS);</b>
<b class="nc">&nbsp;		} catch (InterruptedException ignored) {</b>
<b class="nc">&nbsp;			Thread.currentThread().interrupt();</b>
<b class="nc">&nbsp;		}</b>
&nbsp;
<b class="nc">&nbsp;		if (forced &amp;&amp; !terminated) {</b>
<b class="nc">&nbsp;			executorService.shutdownNow();</b>
<b class="nc">&nbsp;			logger.error(&quot;Shutdown ShaclSail while validation is still running.&quot;);</b>
<b class="nc">&nbsp;			terminated = true;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return terminated;</b>
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	&lt;T&gt; Future&lt;T&gt; submitToExecutorService(Callable&lt;T&gt; runnable) {
<b class="nc">&nbsp;		return executorService.submit(runnable);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public NotifyingSailConnection getConnection() throws SailException {
<b class="nc">&nbsp;		init();</b>
&nbsp;
<b class="nc">&nbsp;		synchronized (singleConnectionMonitor) {</b>
<b class="nc">&nbsp;			singleConnectionCounter.incrementAndGet();</b>
<b class="nc">&nbsp;		}</b>
&nbsp;
&nbsp;		try {
<b class="nc">&nbsp;			NotifyingSailConnection connection = super.getConnection();</b>
<b class="nc">&nbsp;			if (connection instanceof MemoryStoreConnection) {</b>
<b class="nc">&nbsp;				if (isSerializableValidation()) {</b>
<b class="nc">&nbsp;					return new ShaclSailConnection(this, connection, super.getConnection(), shapesRepo.getConnection(),</b>
<b class="nc">&nbsp;							super.getConnection());</b>
&nbsp;				} else {
<b class="nc">&nbsp;					return new ShaclSailConnection(this, connection, super.getConnection(), shapesRepo.getConnection());</b>
&nbsp;				}
<b class="nc">&nbsp;			} else if (isSerializableValidation()) {</b>
<b class="nc">&nbsp;				return new ShaclSailConnection(this, connection, shapesRepo.getConnection(), super.getConnection());</b>
&nbsp;			} else {
<b class="nc">&nbsp;				return new ShaclSailConnection(this, connection, shapesRepo.getConnection());</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable t) {</b>
<b class="nc">&nbsp;			singleConnectionCounter.decrementAndGet();</b>
<b class="nc">&nbsp;			throw t;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	@InternalUseOnly
&nbsp;	public List&lt;ContextWithShapes&gt; getShapes(IRI[] shapesGraphs, boolean onlyRdf4jShaclShapeGraph) {
&nbsp;
<b class="nc">&nbsp;		try (SailRepositoryConnection shapesRepoConnection = shapesRepo.getConnection()) {</b>
<b class="nc">&nbsp;			shapesRepoConnection.begin(IsolationLevels.READ_COMMITTED);</b>
&nbsp;			try {
<b class="nc">&nbsp;				if (onlyRdf4jShaclShapeGraph) {</b>
<b class="nc">&nbsp;					return getShapes(shapesRepoConnection, shapesGraphs);</b>
&nbsp;				} else {
<b class="nc">&nbsp;					try (NotifyingSailConnection sailConnection = getBaseSail().getConnection()) {</b>
<b class="nc">&nbsp;						sailConnection.begin(IsolationLevels.READ_COMMITTED);</b>
&nbsp;						try {
<b class="nc">&nbsp;							return getShapes(shapesRepoConnection, sailConnection, shapesGraphs);</b>
&nbsp;						} finally {
<b class="nc">&nbsp;							sailConnection.rollback();</b>
<b class="nc">&nbsp;						}</b>
<b class="nc">&nbsp;					}</b>
&nbsp;				}
&nbsp;			} finally {
<b class="nc">&nbsp;				shapesRepoConnection.rollback();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	public void setShapesGraphs(Set&lt;IRI&gt; shapesGraphs) {
<b class="nc">&nbsp;		if (initialized.get()) {</b>
&nbsp;			try {
<b class="nc">&nbsp;				try (StampedLockManager.Cache&lt;List&lt;ContextWithShapes&gt;&gt;.WritableState writeState = cachedShapes</b>
<b class="nc">&nbsp;						.getWriteState()) {</b>
<b class="nc">&nbsp;					super.setShapesGraphs(shapesGraphs);</b>
<b class="nc">&nbsp;					writeState.purge();</b>
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;			} catch (InterruptedException e) {</b>
<b class="nc">&nbsp;				throw convertToSailException(e);</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		} else {
<b class="nc">&nbsp;			super.setShapesGraphs(shapesGraphs);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public boolean isSerializableValidation() {
<b class="nc">&nbsp;		if (!supportsSnapshotIsolation &amp;&amp; super.isSerializableValidation()) {</b>
<b class="nc">&nbsp;			if (logger.isDebugEnabled()) {</b>
<b class="nc">&nbsp;				logger.debug(</b>
&nbsp;						&quot;Serializable validation is enabled but can not be used because the base sail does not support IsolationLevels.SNAPSHOT!&quot;);
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return supportsSnapshotIsolation &amp;&amp; super.isSerializableValidation();</b>
&nbsp;	}
&nbsp;
&nbsp;	static SailException convertToSailException(InterruptedException e) {
<b class="nc">&nbsp;		Thread.currentThread().interrupt();</b>
<b class="nc">&nbsp;		return new SailException(e);</b>
&nbsp;	}
&nbsp;
&nbsp;	public static class TransactionSettings {
&nbsp;
<b class="nc">&nbsp;		@Experimental</b>
&nbsp;		public enum PerformanceHint implements TransactionSetting {
&nbsp;
&nbsp;			/**
&nbsp;			 * Run validation is parallel (multithreaded).
&nbsp;			 */
<b class="nc">&nbsp;			ParallelValidation(&quot;ParallelValidation&quot;),</b>
&nbsp;			/**
&nbsp;			 * Run validation serially (single threaded)
&nbsp;			 */
<b class="nc">&nbsp;			SerialValidation(&quot;SerialValidation&quot;),</b>
&nbsp;			/**
&nbsp;			 * Cache intermediate results. Uses more memory but can reduce validation time.
&nbsp;			 */
<b class="nc">&nbsp;			CacheEnabled(&quot;CacheEnabled&quot;),</b>
&nbsp;			/**
&nbsp;			 * Do not cache intermediate results.
&nbsp;			 */
<b class="nc">&nbsp;			CacheDisabled(&quot;CacheDisabled&quot;);</b>
&nbsp;
&nbsp;			private final String value;
&nbsp;
<b class="nc">&nbsp;			PerformanceHint(String value) {</b>
<b class="nc">&nbsp;				this.value = value;</b>
&nbsp;			}
&nbsp;
&nbsp;			@Override
&nbsp;			public String getName() {
<b class="nc">&nbsp;				return PerformanceHint.class.getCanonicalName();</b>
&nbsp;			}
&nbsp;
&nbsp;			@Override
&nbsp;			public String getValue() {
<b class="nc">&nbsp;				return value;</b>
&nbsp;			}
&nbsp;
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public enum ValidationApproach implements TransactionSetting {</b>
&nbsp;
&nbsp;			/**
&nbsp;			 * Do not run any validation. This could potentially lead to your database becoming invalid.
&nbsp;			 */
<b class="nc">&nbsp;			Disabled(&quot;Disabled&quot;, 0),</b>
&nbsp;
&nbsp;			/**
&nbsp;			 * Use a validation approach that is optimized for bulk operations such as adding or removing large amounts
&nbsp;			 * of data. This will automatically disable parallel validation and turn off caching. Add performance hints
&nbsp;			 * to enable parallel validation or caching if you have enough resources (RAM).
&nbsp;			 */
<b class="nc">&nbsp;			Bulk(&quot;Bulk&quot;, 1),</b>
&nbsp;
&nbsp;			/**
&nbsp;			 * Let the SHACL engine decide on the best approach for validating. This typically means that it will use
&nbsp;			 * transactional validation except when changing the SHACL Shape.
&nbsp;			 */
<b class="nc">&nbsp;			Auto(&quot;Auto&quot;, 2);</b>
&nbsp;
&nbsp;			private final String value;
&nbsp;
&nbsp;			// lowest priority wins
&nbsp;			private final int priority;
&nbsp;
<b class="nc">&nbsp;			ValidationApproach(String value, int priority) {</b>
<b class="nc">&nbsp;				this.value = value;</b>
<b class="nc">&nbsp;				this.priority = priority;</b>
&nbsp;			}
&nbsp;
&nbsp;			@Override
&nbsp;			public String getName() {
<b class="nc">&nbsp;				return ValidationApproach.class.getCanonicalName();</b>
&nbsp;			}
&nbsp;
&nbsp;			@Override
&nbsp;			public String getValue() {
<b class="nc">&nbsp;				return value;</b>
&nbsp;			}
&nbsp;
&nbsp;			public static ValidationApproach getHighestPriority(ValidationApproach v1, ValidationApproach v2) {
<b class="nc">&nbsp;				assert v1 != null || v2 != null;</b>
<b class="nc">&nbsp;				if (v1 == null) {</b>
<b class="nc">&nbsp;					return v2;</b>
&nbsp;				}
<b class="nc">&nbsp;				if (v2 == null) {</b>
<b class="nc">&nbsp;					return v1;</b>
&nbsp;				}
&nbsp;
<b class="nc">&nbsp;				if (v1.priority &lt; v2.priority) {</b>
<b class="nc">&nbsp;					return v1;</b>
&nbsp;				}
&nbsp;
<b class="nc">&nbsp;				return v2;</b>
&nbsp;			}
&nbsp;
&nbsp;		}
&nbsp;
&nbsp;		private final String value;
&nbsp;
<b class="nc">&nbsp;		TransactionSettings(String value) {</b>
<b class="nc">&nbsp;			this.value = value;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getValue() {
<b class="nc">&nbsp;			return value;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * @implNote This is an extension point for configuring a different executor service for parallel validation. The
&nbsp;	 *           code is marked as experimental because it may change from one minor release to another.
&nbsp;	 * @return
&nbsp;	 */
<b class="nc">&nbsp;	@Experimental</b>
&nbsp;	@SuppressWarnings(&quot;NullableProblems&quot;)
&nbsp;	protected static class RevivableExecutorService implements ExecutorService {
&nbsp;		private final Supplier&lt;ExecutorService&gt; supplier;
&nbsp;		ExecutorService delegate;
<b class="nc">&nbsp;		boolean initialized = false;</b>
&nbsp;
<b class="nc">&nbsp;		public RevivableExecutorService(Supplier&lt;ExecutorService&gt; supplier) {</b>
<b class="nc">&nbsp;			this.supplier = supplier;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void init() {
<b class="nc">&nbsp;			assert delegate == null || delegate.isTerminated();</b>
<b class="nc">&nbsp;			delegate = supplier.get();</b>
<b class="nc">&nbsp;			initialized = true;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void shutdown() {
<b class="nc">&nbsp;			if (initialized) {</b>
<b class="nc">&nbsp;				delegate.shutdown();</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public List&lt;Runnable&gt; shutdownNow() {
<b class="nc">&nbsp;			if (initialized) {</b>
<b class="nc">&nbsp;				return delegate.shutdownNow();</b>
&nbsp;			} else {
<b class="nc">&nbsp;				return Collections.emptyList();</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public boolean isShutdown() {
<b class="nc">&nbsp;			return !initialized || delegate.isShutdown();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public boolean isTerminated() {
<b class="nc">&nbsp;			return !initialized || delegate.isTerminated();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
<b class="nc">&nbsp;			return !initialized || delegate.awaitTermination(timeout, unit);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {
<b class="nc">&nbsp;			assert initialized;</b>
<b class="nc">&nbsp;			return delegate.submit(task);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {
<b class="nc">&nbsp;			assert initialized;</b>
<b class="nc">&nbsp;			return delegate.submit(task, result);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Future&lt;?&gt; submit(Runnable task) {
<b class="nc">&nbsp;			assert initialized;</b>
<b class="nc">&nbsp;			return delegate.submit(task);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException {
<b class="nc">&nbsp;			assert initialized;</b>
<b class="nc">&nbsp;			return delegate.invokeAll(tasks);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)
&nbsp;				throws InterruptedException {
<b class="nc">&nbsp;			assert initialized;</b>
<b class="nc">&nbsp;			return delegate.invokeAll(tasks, timeout, unit);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
&nbsp;				throws InterruptedException, ExecutionException {
<b class="nc">&nbsp;			assert initialized;</b>
<b class="nc">&nbsp;			return delegate.invokeAny(tasks);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)
&nbsp;				throws InterruptedException, ExecutionException, TimeoutException {
<b class="nc">&nbsp;			assert initialized;</b>
<b class="nc">&nbsp;			return delegate.invokeAny(tasks, timeout, unit);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void execute(Runnable command) {
<b class="nc">&nbsp;			assert initialized;</b>
<b class="nc">&nbsp;			delegate.execute(command);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:56</div>
</div>
</body>
</html>
