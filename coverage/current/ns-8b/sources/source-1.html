


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > RepositoryConnection</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.repository</a>
</div>

<h1>Coverage Summary for Class: RepositoryConnection (org.eclipse.rdf4j.repository)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">RepositoryConnection</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    26.3%
  </span>
  <span class="absValue">
    (5/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    21.7%
  </span>
  <span class="absValue">
    (5/23)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;package org.eclipse.rdf4j.repository;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.Reader;
&nbsp;import java.net.URL;
&nbsp;
&nbsp;import org.eclipse.rdf4j.common.iteration.CloseableIteration;
&nbsp;import org.eclipse.rdf4j.common.iteration.Iteration;
&nbsp;import org.eclipse.rdf4j.common.transaction.IsolationLevel;
&nbsp;import org.eclipse.rdf4j.common.transaction.TransactionSetting;
&nbsp;import org.eclipse.rdf4j.model.IRI;
&nbsp;import org.eclipse.rdf4j.model.Namespace;
&nbsp;import org.eclipse.rdf4j.model.Resource;
&nbsp;import org.eclipse.rdf4j.model.Statement;
&nbsp;import org.eclipse.rdf4j.model.Value;
&nbsp;import org.eclipse.rdf4j.model.ValueFactory;
&nbsp;import org.eclipse.rdf4j.query.BooleanQuery;
&nbsp;import org.eclipse.rdf4j.query.GraphQuery;
&nbsp;import org.eclipse.rdf4j.query.MalformedQueryException;
&nbsp;import org.eclipse.rdf4j.query.Query;
&nbsp;import org.eclipse.rdf4j.query.QueryLanguage;
&nbsp;import org.eclipse.rdf4j.query.TupleQuery;
&nbsp;import org.eclipse.rdf4j.query.UnsupportedQueryLanguageException;
&nbsp;import org.eclipse.rdf4j.query.Update;
&nbsp;import org.eclipse.rdf4j.repository.util.Repositories;
&nbsp;import org.eclipse.rdf4j.rio.ParserConfig;
&nbsp;import org.eclipse.rdf4j.rio.RDFFormat;
&nbsp;import org.eclipse.rdf4j.rio.RDFHandler;
&nbsp;import org.eclipse.rdf4j.rio.RDFHandlerException;
&nbsp;import org.eclipse.rdf4j.rio.RDFParseException;
&nbsp;import org.eclipse.rdf4j.rio.UnsupportedRDFormatException;
&nbsp;
&nbsp;/**
&nbsp; * Main interface for updating data in and performing queries on an RDF4J {@link Repository}.
&nbsp; * &lt;p&gt;
&nbsp; * By default, a RepositoryConnection is in auto-commit mode, meaning that each operation corresponds to a single
&nbsp; * transaction on the underlying store. Multiple operations can be bundled in a single transaction by using
&nbsp; * {@link #begin()} and {@link #commit() commit}/ {@link #rollback() rollback}, which may improve performance
&nbsp; * considerably when dealing with many thousands of statements. Care should be taking to always properly close a
&nbsp; * RepositoryConnection after one is finished with it, to free up resources and avoid unnecessary locks.
&nbsp; * &lt;p&gt;
&nbsp; * RepositoryConnection is not guaranteed to be thread-safe. The recommended access pattern in a multithreaded
&nbsp; * application is to ensure that each thread creates/uses its own RepositoryConnections (which can be obtained from a
&nbsp; * shared {@link Repository}).
&nbsp; * &lt;p&gt;
&nbsp; * Several methods take a vararg argument that optionally specifies one or more contexts (named graphs) on which the
&nbsp; * method should operate. A vararg parameter is optional, it can be completely left out of the method call, in which
&nbsp; * case a method either operates on a provided statements context (if one of the method parameters is a statement or
&nbsp; * collection of statements), or operates on the repository as a whole, completely ignoring context. A vararg argument
&nbsp; * may also be &#39;null&#39; (cast to Resource) meaning that the method operates on those statements which have no associated
&nbsp; * context only.
&nbsp; * &lt;p&gt;
&nbsp; * Examples:
&nbsp; *
&nbsp; * &lt;pre&gt;
&nbsp; * {@code
&nbsp; * // Ex 1: this method retrieves all statements that appear in either context1 or
&nbsp; * // context2, or both.
&nbsp; * RepositoryConnection.getStatements(null, null, null, true, context1, context2);
&nbsp; *
&nbsp; * // Ex 2: this method retrieves all statements that appear in the repository
&nbsp; * // (regardless of context).
&nbsp; * RepositoryConnection.getStatements(null, null, null, true);
&nbsp; *
&nbsp; * // Ex 3: this method retrieves all statements that have no associated context in
&nbsp; * // the repository.
&nbsp; * // Observe that this is not equivalent to the previous method call.
&nbsp; * RepositoryConnection.getStatements(null, null, null, true, (Resource)null);
&nbsp; *
&nbsp; * // Ex 4: this method adds a statement to the store. If the statement object
&nbsp; * // itself has a context (i.e. statement.getContext() != null) the statement is added
&nbsp; * // to that context. Otherwise, it is added without any associated context.
&nbsp; * RepositoryConnection.add(statement);
&nbsp; *
&nbsp; * // Ex 5: this method adds a statement to context1 in the store. It completely
&nbsp; * // ignores any context the statement itself has.
&nbsp; * RepositoryConnection.add(statement, context1);
&nbsp; * }
&nbsp; * &lt;/pre&gt;
&nbsp; *
&nbsp; * @author Arjohn Kampman
&nbsp; * @author Jeen Broekstra
&nbsp; * @see Repositories
&nbsp; */
&nbsp;public interface RepositoryConnection extends AutoCloseable {
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the Repository object to which this connection belongs.
&nbsp;	 */
&nbsp;	Repository getRepository();
&nbsp;
&nbsp;	/**
&nbsp;	 * Set the parser configuration this connection should use for RDFParser-based operations.
&nbsp;	 *
&nbsp;	 * @param config a Rio RDF Parser configuration.
&nbsp;	 */
&nbsp;	void setParserConfig(ParserConfig config);
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the parser configuration this connection uses for Rio-based operations.
&nbsp;	 *
&nbsp;	 * @return a Rio RDF parser configuration.
&nbsp;	 */
&nbsp;	ParserConfig getParserConfig();
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets a ValueFactory for this RepositoryConnection.
&nbsp;	 *
&nbsp;	 * @return A repository-specific ValueFactory.
&nbsp;	 */
&nbsp;	ValueFactory getValueFactory();
&nbsp;
&nbsp;	/**
&nbsp;	 * Checks whether this connection is open. A connection is open from the moment it is created until it is closed.
&nbsp;	 *
&nbsp;	 * @see #close()
&nbsp;	 */
&nbsp;	boolean isOpen() throws RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Closes the connection, freeing resources. If a {@link #begin() transaction} is {@link #isActive() active} on the
&nbsp;	 * connection, all non-committed operations will be lost by actively calling {@link #rollback()} on any active
&nbsp;	 * transactions.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * Implementation note: All implementations must override this method if they have any resources that they need to
&nbsp;	 * free.
&nbsp;	 *
&nbsp;	 * @throws RepositoryException If the connection could not be closed.
&nbsp;	 */
&nbsp;	@Override
&nbsp;	default void close() throws RepositoryException {
<b class="nc">&nbsp;		if (isOpen() &amp;&amp; isActive()) {</b>
<b class="nc">&nbsp;			rollback();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Prepares a SPARQL query for evaluation on this repository (optional operation). In case the query contains
&nbsp;	 * relative URIs that need to be resolved against an external base URI, one should use
&nbsp;	 * {@link #prepareQuery(QueryLanguage, String, String)} instead.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * If you already know the type of query, using the more specific {@link #prepareTupleQuery},
&nbsp;	 * {@link #prepareGraphQuery} or {@link #prepareBooleanQuery} is likely to be more efficient.
&nbsp;	 *
&nbsp;	 * @param query The query string, in SPARQL syntax.
&nbsp;	 * @return A query ready to be evaluated on this repository.
&nbsp;	 * @throws MalformedQueryException       If the supplied query is malformed.
&nbsp;	 * @throws UnsupportedOperationException If the &lt;var&gt;prepareQuery&lt;/var&gt; method is not supported by this repository.
&nbsp;	 * @see #prepareQuery(QueryLanguage, String)
&nbsp;	 */
&nbsp;	default Query prepareQuery(String query) throws RepositoryException, MalformedQueryException {
<b class="nc">&nbsp;		return prepareQuery(QueryLanguage.SPARQL, query);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Prepares a query for evaluation on this repository (optional operation). In case the query contains relative URIs
&nbsp;	 * that need to be resolved against an external base URI, one should use
&nbsp;	 * {@link #prepareQuery(QueryLanguage, String, String)} instead.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * If you already know the type of query, using the more specific {@link #prepareTupleQuery},
&nbsp;	 * {@link #prepareGraphQuery} or {@link #prepareBooleanQuery} is likely to be more efficient.
&nbsp;	 *
&nbsp;	 * @param ql    The {@link QueryLanguage query language} in which the query is formulated.
&nbsp;	 * @param query The query string.
&nbsp;	 * @return A query ready to be evaluated on this repository.
&nbsp;	 * @throws MalformedQueryException           If the supplied query is malformed.
&nbsp;	 * @throws UnsupportedQueryLanguageException If the supplied query language is not supported.
&nbsp;	 * @throws UnsupportedOperationException     If the &lt;var&gt;prepareQuery&lt;/var&gt; method is not supported by this
&nbsp;	 *                                           repository.
&nbsp;	 */
&nbsp;	Query prepareQuery(QueryLanguage ql, String query) throws RepositoryException, MalformedQueryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Prepares a query for evaluation on this repository (optional operation).
&nbsp;	 * &lt;p&gt;
&nbsp;	 * If you already know the type of query, using the more specific {@link #prepareTupleQuery},
&nbsp;	 * {@link #prepareGraphQuery} or {@link #prepareBooleanQuery} is likely to be more efficient.
&nbsp;	 *
&nbsp;	 * @param ql      The {@link QueryLanguage query language} in which the query is formulated.
&nbsp;	 * @param query   The query string.
&nbsp;	 * @param baseURI The base URI to resolve any relative URIs that are in the query against, can be &lt;var&gt;null&lt;/var&gt; if
&nbsp;	 *                the query does not contain any relative URIs.
&nbsp;	 * @return A query ready to be evaluated on this repository.
&nbsp;	 * @throws MalformedQueryException           If the supplied query is malformed.
&nbsp;	 * @throws UnsupportedQueryLanguageException If the supplied query language is not supported.
&nbsp;	 * @throws UnsupportedOperationException     If the &lt;var&gt;prepareQuery&lt;/var&gt; method is not supported by this
&nbsp;	 *                                           repository.
&nbsp;	 */
&nbsp;	Query prepareQuery(QueryLanguage ql, String query, String baseURI)
&nbsp;			throws RepositoryException, MalformedQueryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Prepares a SPARQL query that produces sets of value tuples, that is a SPARQL SELECT query. In case the query
&nbsp;	 * contains relative URIs that need to be resolved against an external base URI, one should use
&nbsp;	 * {@link #prepareTupleQuery(QueryLanguage, String, String)} instead.
&nbsp;	 *
&nbsp;	 * @param query The query string, in SPARQL syntax.
&nbsp;	 * @return a {@link TupleQuery} ready to be evaluated on this {@link RepositoryConnection}.
&nbsp;	 * @throws IllegalArgumentException If the supplied query is not a tuple query.
&nbsp;	 * @throws MalformedQueryException  If the supplied query is malformed.
&nbsp;	 * @see #prepareTupleQuery(QueryLanguage, String)
&nbsp;	 */
&nbsp;	default TupleQuery prepareTupleQuery(String query) throws RepositoryException, MalformedQueryException {
<b class="fc">&nbsp;		return prepareTupleQuery(QueryLanguage.SPARQL, query);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Prepares a query that produces sets of value tuples. In case the query contains relative URIs that need to be
&nbsp;	 * resolved against an external base URI, one should use {@link #prepareTupleQuery(QueryLanguage, String, String)}
&nbsp;	 * instead.
&nbsp;	 *
&nbsp;	 * @param ql    The {@link QueryLanguage query language} in which the query is formulated.
&nbsp;	 * @param query The query string.
&nbsp;	 * @return a {@link TupleQuery} ready to be evaluated on this {@link RepositoryConnection}.
&nbsp;	 * @throws IllegalArgumentException          If the supplied query is not a tuple query.
&nbsp;	 * @throws MalformedQueryException           If the supplied query is malformed.
&nbsp;	 * @throws UnsupportedQueryLanguageException If the supplied query language is not supported.
&nbsp;	 */
&nbsp;	TupleQuery prepareTupleQuery(QueryLanguage ql, String query)
&nbsp;			throws RepositoryException, MalformedQueryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Prepares a query that produces sets of value tuples.
&nbsp;	 *
&nbsp;	 * @param ql      The {@link QueryLanguage query language} in which the query is formulated.
&nbsp;	 * @param query   The query string.
&nbsp;	 * @param baseURI The base URI to resolve any relative URIs that are in the query against, can be &lt;var&gt;null&lt;/var&gt; if
&nbsp;	 *                the query does not contain any relative URIs.
&nbsp;	 * @return a {@link TupleQuery} ready to be evaluated on this {@link RepositoryConnection}.
&nbsp;	 * @throws IllegalArgumentException          If the supplied query is not a tuple query.
&nbsp;	 * @throws MalformedQueryException           If the supplied query is malformed.
&nbsp;	 * @throws UnsupportedQueryLanguageException If the supplied query language is not supported.
&nbsp;	 */
&nbsp;	TupleQuery prepareTupleQuery(QueryLanguage ql, String query, String baseURI)
&nbsp;			throws RepositoryException, MalformedQueryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Prepares SPARQL queries that produce RDF graphs, that is, SPARQL CONSTRUCT or DESCRIBE queries. In case the query
&nbsp;	 * contains relative URIs that need to be resolved against an external base URI, one should use
&nbsp;	 * {@link #prepareGraphQuery(QueryLanguage, String, String)} instead.
&nbsp;	 *
&nbsp;	 * @param query The query string, in SPARQL syntax.
&nbsp;	 * @return a {@link GraphQuery} ready to be evaluated on this {@link RepositoryConnection}.
&nbsp;	 * @throws IllegalArgumentException If the supplied query is not a graph query.
&nbsp;	 * @throws MalformedQueryException  If the supplied query is malformed.
&nbsp;	 * @see #prepareGraphQuery(QueryLanguage, String)
&nbsp;	 */
&nbsp;	default GraphQuery prepareGraphQuery(String query) throws RepositoryException, MalformedQueryException {
<b class="fc">&nbsp;		return prepareGraphQuery(QueryLanguage.SPARQL, query);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Prepares queries that produce RDF graphs. In case the query contains relative URIs that need to be resolved
&nbsp;	 * against an external base URI, one should use {@link #prepareGraphQuery(QueryLanguage, String, String)} instead.
&nbsp;	 *
&nbsp;	 * @param ql    The {@link QueryLanguage query language} in which the query is formulated.
&nbsp;	 * @param query The query string.
&nbsp;	 * @return a {@link GraphQuery} ready to be evaluated on this {@link RepositoryConnection}.
&nbsp;	 * @throws IllegalArgumentException          If the supplied query is not a graph query.
&nbsp;	 * @throws MalformedQueryException           If the supplied query is malformed.
&nbsp;	 * @throws UnsupportedQueryLanguageException If the supplied query language is not supported.
&nbsp;	 */
&nbsp;	GraphQuery prepareGraphQuery(QueryLanguage ql, String query)
&nbsp;			throws RepositoryException, MalformedQueryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Prepares queries that produce RDF graphs.
&nbsp;	 *
&nbsp;	 * @param ql      The {@link QueryLanguage query language} in which the query is formulated.
&nbsp;	 * @param query   The query string.
&nbsp;	 * @param baseURI The base URI to resolve any relative URIs that are in the query against, can be &lt;var&gt;null&lt;/var&gt; if
&nbsp;	 *                the query does not contain any relative URIs.
&nbsp;	 * @return a {@link GraphQuery} ready to be evaluated on this {@link RepositoryConnection}.
&nbsp;	 * @throws IllegalArgumentException          If the supplied query is not a graph query.
&nbsp;	 * @throws MalformedQueryException           If the supplied query is malformed.
&nbsp;	 * @throws UnsupportedQueryLanguageException If the supplied query language is not supported.
&nbsp;	 */
&nbsp;	GraphQuery prepareGraphQuery(QueryLanguage ql, String query, String baseURI)
&nbsp;			throws RepositoryException, MalformedQueryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Prepares SPARQL queries that return &lt;var&gt;true&lt;/var&gt; or &lt;var&gt;false&lt;/var&gt;, that is, SPARQL ASK queries. In case the
&nbsp;	 * query contains relative URIs that need to be resolved against an external base URI, one should use
&nbsp;	 * {@link #prepareBooleanQuery(QueryLanguage, String, String)} instead.
&nbsp;	 *
&nbsp;	 * @param query The query string, in SPARQL syntax.
&nbsp;	 * @return a {@link BooleanQuery} ready to be evaluated on this {@link RepositoryConnection}.
&nbsp;	 * @throws IllegalArgumentException If the supplied query is not a boolean query.
&nbsp;	 * @throws MalformedQueryException  If the supplied SPARQL query is malformed.
&nbsp;	 * @see #prepareBooleanQuery(QueryLanguage, String)
&nbsp;	 */
&nbsp;	default BooleanQuery prepareBooleanQuery(String query) throws RepositoryException, MalformedQueryException {
<b class="fc">&nbsp;		return prepareBooleanQuery(QueryLanguage.SPARQL, query);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Prepares queries that return &lt;var&gt;true&lt;/var&gt; or &lt;var&gt;false&lt;/var&gt;. In case the query contains relative URIs that
&nbsp;	 * need to be resolved against an external base URI, one should use
&nbsp;	 * {@link #prepareBooleanQuery(QueryLanguage, String, String)} instead.
&nbsp;	 *
&nbsp;	 * @param ql    The {@link QueryLanguage query language} in which the query is formulated.
&nbsp;	 * @param query The query string.
&nbsp;	 * @return a {@link BooleanQuery} ready to be evaluated on this {@link RepositoryConnection}.
&nbsp;	 * @throws IllegalArgumentException          If the supplied query is not a boolean query.
&nbsp;	 * @throws MalformedQueryException           If the supplied query is malformed.
&nbsp;	 * @throws UnsupportedQueryLanguageException If the supplied query language is not supported.
&nbsp;	 */
&nbsp;	BooleanQuery prepareBooleanQuery(QueryLanguage ql, String query)
&nbsp;			throws RepositoryException, MalformedQueryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Prepares queries that return &lt;var&gt;true&lt;/var&gt; or &lt;var&gt;false&lt;/var&gt;.
&nbsp;	 *
&nbsp;	 * @param ql      The {@link QueryLanguage query language} in which the query is formulated.
&nbsp;	 * @param query   The query string.
&nbsp;	 * @param baseURI The base URI to resolve any relative URIs that are in the query against, can be &lt;var&gt;null&lt;/var&gt; if
&nbsp;	 *                the query does not contain any relative URIs.
&nbsp;	 * @return a {@link BooleanQuery} ready to be evaluated on this {@link RepositoryConnection}.
&nbsp;	 * @throws IllegalArgumentException          If the supplied query is not a boolean query.
&nbsp;	 * @throws MalformedQueryException           If the supplied query is malformed.
&nbsp;	 * @throws UnsupportedQueryLanguageException If the supplied query language is not supported.
&nbsp;	 */
&nbsp;	BooleanQuery prepareBooleanQuery(QueryLanguage ql, String query, String baseURI)
&nbsp;			throws RepositoryException, MalformedQueryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Prepares a SPARQL Update operation. In case the update string contains relative URIs that need to be resolved
&nbsp;	 * against an external base URI, one should use {@link #prepareUpdate(QueryLanguage, String, String)} instead.
&nbsp;	 *
&nbsp;	 * @param update The update operation string, in SPARQL syntax.
&nbsp;	 * @return a {@link Update} ready to be executed on this {@link RepositoryConnection}.
&nbsp;	 * @throws MalformedQueryException If the supplied update operation string is malformed.
&nbsp;	 * @see #prepareUpdate(QueryLanguage, String)
&nbsp;	 */
&nbsp;	default Update prepareUpdate(String update) throws RepositoryException, MalformedQueryException {
<b class="fc">&nbsp;		return prepareUpdate(QueryLanguage.SPARQL, update);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Prepares an Update operation. In case the update string contains relative URIs that need to be resolved against
&nbsp;	 * an external base URI, one should use {@link #prepareUpdate(QueryLanguage, String, String)} instead.
&nbsp;	 *
&nbsp;	 * @param ql     The {@link QueryLanguage query language} in which the update operation is formulated.
&nbsp;	 * @param update The update operation string.
&nbsp;	 * @return a {@link Update} ready to be executed on this {@link RepositoryConnection}.
&nbsp;	 * @throws MalformedQueryException If the supplied update operation string is malformed.
&nbsp;	 */
&nbsp;	Update prepareUpdate(QueryLanguage ql, String update) throws RepositoryException, MalformedQueryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Prepares an Update operation.
&nbsp;	 *
&nbsp;	 * @param ql      The {@link QueryLanguage query language} in which the update operation is formulated.
&nbsp;	 * @param update  The update operation string.
&nbsp;	 * @param baseURI The base URI to resolve any relative URIs that are in the update against, can be &lt;var&gt;null&lt;/var&gt;
&nbsp;	 *                if the update does not contain any relative URIs.
&nbsp;	 * @return a {@link Update} ready to be executed on this {@link RepositoryConnection}.
&nbsp;	 * @throws MalformedQueryException If the supplied update operation string is malformed.
&nbsp;	 */
&nbsp;	Update prepareUpdate(QueryLanguage ql, String update, String baseURI)
&nbsp;			throws RepositoryException, MalformedQueryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets all resources that are used as content identifiers. Care should be taken that the returned
&nbsp;	 * {@link RepositoryResult} is closed to free any resources that it keeps hold of.
&nbsp;	 *
&nbsp;	 * @return a RepositoryResult object containing Resources that are used as context identifiers.
&nbsp;	 */
&nbsp;	RepositoryResult&lt;Resource&gt; getContextIDs() throws RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets all statements with a specific subject, predicate and/or object from the repository. The result is
&nbsp;	 * optionally restricted to the specified set of named contexts. If the repository supports inferencing, inferred
&nbsp;	 * statements will be included in the result.
&nbsp;	 *
&nbsp;	 * @param subj     A Resource specifying the subject, or &lt;var&gt;null&lt;/var&gt; for a wildcard.
&nbsp;	 * @param pred     A URI specifying the predicate, or &lt;var&gt;null&lt;/var&gt; for a wildcard.
&nbsp;	 * @param obj      A Value specifying the object, or &lt;var&gt;null&lt;/var&gt; for a wildcard.
&nbsp;	 * @param contexts The context(s) to get the data from. Note that this parameter is a vararg and as such is
&nbsp;	 *                 optional. If no contexts are supplied the method operates on the entire repository.
&nbsp;	 * @return The statements matching the specified pattern. The result object is a {@link RepositoryResult} object, a
&nbsp;	 *         lazy Iterator-like object containing {@link Statement}s and optionally throwing a
&nbsp;	 *         {@link RepositoryException} when an error when a problem occurs during retrieval.
&nbsp;	 */
&nbsp;	default RepositoryResult&lt;Statement&gt; getStatements(Resource subj, IRI pred, Value obj, Resource... contexts)
&nbsp;			throws RepositoryException {
<b class="nc">&nbsp;		return getStatements(subj, pred, obj, true, contexts);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets all statements with a specific subject, predicate and/or object from the repository. The result is
&nbsp;	 * optionally restricted to the specified set of named contexts.
&nbsp;	 *
&nbsp;	 * @param subj            A Resource specifying the subject, or &lt;var&gt;null&lt;/var&gt; for a wildcard.
&nbsp;	 * @param pred            An IRI specifying the predicate, or &lt;var&gt;null&lt;/var&gt; for a wildcard.
&nbsp;	 * @param obj             A Value specifying the object, or &lt;var&gt;null&lt;/var&gt; for a wildcard.
&nbsp;	 * @param contexts        The context(s) to get the data from. Note that this parameter is a vararg and as such is
&nbsp;	 *                        optional. If no contexts are supplied the method operates on the entire repository.
&nbsp;	 * @param includeInferred if false, no inferred statements are returned; if true, inferred statements are returned
&nbsp;	 *                        if available. The default is true.
&nbsp;	 * @return The statements matching the specified pattern. The result object is a {@link RepositoryResult} object, a
&nbsp;	 *         lazy Iterator-like object containing {@link Statement}s and optionally throwing a
&nbsp;	 *         {@link RepositoryException} when an error when a problem occurs during retrieval.
&nbsp;	 */
&nbsp;	RepositoryResult&lt;Statement&gt; getStatements(Resource subj, IRI pred, Value obj, boolean includeInferred,
&nbsp;			Resource... contexts) throws RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Checks whether the repository contains statements with a specific subject, predicate and/or object, optionally in
&nbsp;	 * the specified contexts.
&nbsp;	 *
&nbsp;	 * @param subj            A Resource specifying the subject, or &lt;var&gt;null&lt;/var&gt; for a wildcard.
&nbsp;	 * @param pred            An IRI specifying the predicate, or &lt;var&gt;null&lt;/var&gt; for a wildcard.
&nbsp;	 * @param obj             A Value specifying the object, or &lt;var&gt;null&lt;/var&gt; for a wildcard.
&nbsp;	 * @param contexts        The context(s) the need to be searched. Note that this parameter is a vararg and as such
&nbsp;	 *                        is optional. If no contexts are supplied the method operates on the entire repository.
&nbsp;	 * @param includeInferred if false, no inferred statements are considered; if true, inferred statements are
&nbsp;	 *                        considered if available
&nbsp;	 * @return true If a matching statement is in the repository in the specified context, false otherwise.
&nbsp;	 */
&nbsp;	boolean hasStatement(Resource subj, IRI pred, Value obj, boolean includeInferred, Resource... contexts)
&nbsp;			throws RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Checks whether the repository contains the specified statement, optionally in the specified contexts.
&nbsp;	 *
&nbsp;	 * @param st              The statement to look for. Context information in the statement is ignored.
&nbsp;	 * @param contexts        The context(s) to get the data from. Note that this parameter is a vararg and as such is
&nbsp;	 *                        optional. If no contexts are supplied the method operates on the entire repository.
&nbsp;	 * @param includeInferred if false, no inferred statements are considered; if true, inferred statements are
&nbsp;	 *                        considered if available
&nbsp;	 * @return true If the repository contains the specified statement, false otherwise.
&nbsp;	 */
&nbsp;	boolean hasStatement(Statement st, boolean includeInferred, Resource... contexts) throws RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Exports all statements with a specific subject, predicate and/or object from the repository, optionally from the
&nbsp;	 * specified contexts. This method supplies the RDFHandler with all namespace declarations available in the
&nbsp;	 * repository.
&nbsp;	 *
&nbsp;	 * @param subj            The subject, or null if the subject doesn&#39;t matter.
&nbsp;	 * @param pred            The predicate, or null if the predicate doesn&#39;t matter.
&nbsp;	 * @param obj             The object, or null if the object doesn&#39;t matter.
&nbsp;	 * @param contexts        The context(s) to get the data from. Note that this parameter is a vararg and as such is
&nbsp;	 *                        optional. If no contexts are supplied the method operates on the entire repository.
&nbsp;	 * @param handler         The handler that will handle the RDF data.
&nbsp;	 * @param includeInferred if false, no inferred statements are returned; if true, inferred statements are returned
&nbsp;	 *                        if available
&nbsp;	 * @throws RDFHandlerException If the handler encounters an unrecoverable error.
&nbsp;	 */
&nbsp;	void exportStatements(Resource subj, IRI pred, Value obj, boolean includeInferred, RDFHandler handler,
&nbsp;			Resource... contexts) throws RepositoryException, RDFHandlerException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Exports all explicit statements in the specified contexts to the supplied RDFHandler. This method supplies the
&nbsp;	 * RDFHandler with all namespace declarations available in the repository.
&nbsp;	 *
&nbsp;	 * @param contexts The context(s) to get the data from. Note that this parameter is a vararg and as such is
&nbsp;	 *                 optional. If no contexts are supplied the method operates on the entire repository.
&nbsp;	 * @param handler  The handler that will handle the RDF data.
&nbsp;	 * @throws RDFHandlerException If the handler encounters an unrecoverable error.
&nbsp;	 */
&nbsp;	void export(RDFHandler handler, Resource... contexts) throws RepositoryException, RDFHandlerException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the number of (explicit) statements that are in the specified contexts in this repository.
&nbsp;	 *
&nbsp;	 * @param contexts The context(s) to get the data from. Note that this parameter is a vararg and as such is
&nbsp;	 *                 optional. If no contexts are supplied the method operates on the entire repository.
&nbsp;	 * @return The number of explicit statements from the specified contexts in this repository.
&nbsp;	 */
&nbsp;	long size(Resource... contexts) throws RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns &lt;var&gt;true&lt;/var&gt; if this repository does not contain any (explicit) statements.
&nbsp;	 *
&nbsp;	 * @return &lt;var&gt;true&lt;/var&gt; if this repository is empty, &lt;var&gt;false&lt;/var&gt; otherwise.
&nbsp;	 * @throws RepositoryException If the repository could not be checked to be empty.
&nbsp;	 */
&nbsp;	boolean isEmpty() throws RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Enables or disables auto-commit mode for the connection. If a connection is in auto-commit mode, then all updates
&nbsp;	 * will be executed and committed as individual transactions. Otherwise, the updates are grouped into transactions
&nbsp;	 * that are terminated by a call to either {@link #commit} or {@link #rollback}. By default, new connections are in
&nbsp;	 * auto-commit mode.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * &lt;b&gt;NOTE:&lt;/b&gt; If this connection is switched to auto-commit mode during a transaction, the transaction is
&nbsp;	 * committed.
&nbsp;	 *
&nbsp;	 * @deprecated As of release 2.7.0, use {@link #begin()} instead.
&nbsp;	 * @throws RepositoryException In case the mode switch failed, for example because a currently active transaction
&nbsp;	 *                             failed to commit.
&nbsp;	 * @see #commit()
&nbsp;	 */
&nbsp;	@Deprecated
&nbsp;	void setAutoCommit(boolean autoCommit) throws RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Indicates if the connection is in auto-commit mode. The connection is in auto-commit mode when no transaction is
&nbsp;	 * currently active, that is, when:
&nbsp;	 * &lt;ol&gt;
&nbsp;	 * &lt;li&gt;{@link #begin()} has not been called or;
&nbsp;	 * &lt;li&gt;{@link #commit()} or {@link #rollback()} have been called to finish the transaction.
&nbsp;	 * &lt;/ol&gt;
&nbsp;	 *
&nbsp;	 * @deprecated since 2.0. Use {@link #isActive()} instead.
&nbsp;	 * @throws RepositoryException If a repository access error occurs.
&nbsp;	 */
&nbsp;	@Deprecated
&nbsp;	boolean isAutoCommit() throws RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Indicates if a transaction is currently active on the connection. A transaction is active if {@link #begin()} has
&nbsp;	 * been called, and becomes inactive after {@link #commit()} or {@link #rollback()} has been called.
&nbsp;	 *
&nbsp;	 * @return &lt;code&gt;true&lt;/code&gt; iff a transaction is active, &lt;code&gt;false&lt;/code&gt; iff no transaction is active.
&nbsp;	 * @throws UnknownTransactionStateException if the transaction state can not be determined. This can happen for
&nbsp;	 *                                          instance when communication with a repository fails or times out.
&nbsp;	 * @throws RepositoryException
&nbsp;	 */
&nbsp;	boolean isActive() throws UnknownTransactionStateException, RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets the transaction isolation level for the next transaction(s) on this connection. If the level is set to a
&nbsp;	 * value that is not supported by the underlying repository, this method will still succeed but a subsequent call to
&nbsp;	 * {@link #begin()} will result in an exception.
&nbsp;	 *
&nbsp;	 * @param level the transaction isolation level to set.
&nbsp;	 * @throws IllegalStateException if the method is called while a transaction is already active.
&nbsp;	 */
&nbsp;	void setIsolationLevel(IsolationLevel level) throws IllegalStateException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Retrieves the current {@link IsolationLevel transaction isolation level} of the connection.
&nbsp;	 *
&nbsp;	 * @return the current transaction isolation level.
&nbsp;	 */
&nbsp;	IsolationLevel getIsolationLevel();
&nbsp;
&nbsp;	/**
&nbsp;	 * Begins a new transaction, requiring {@link #commit()} or {@link #rollback()} to be called to end the transaction.
&nbsp;	 * The transaction will use the currently set {@link IsolationLevel isolation level} for this connection.
&nbsp;	 *
&nbsp;	 * @throws RepositoryException If the connection could not start the transaction. One possible reason this may
&nbsp;	 *                             happen is if a transaction is already {@link #isActive() active} on the current
&nbsp;	 *                             connection.
&nbsp;	 * @see #begin(IsolationLevel)
&nbsp;	 * @see #isActive()
&nbsp;	 * @see #commit()
&nbsp;	 * @see #rollback()
&nbsp;	 * @see #setIsolationLevel(IsolationLevel)
&nbsp;	 */
&nbsp;	void begin() throws RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Begins a new transaction with the supplied {@link IsolationLevel}, requiring {@link #commit()} or
&nbsp;	 * {@link #rollback()} to be called to end the transaction.
&nbsp;	 *
&nbsp;	 * @param level The {@link IsolationLevel} at which this transaction will operate. If set to &lt;code&gt;null&lt;/code&gt; the
&nbsp;	 *              default isolation level of the underlying store will be used. If the specified isolation level is
&nbsp;	 *              not supported by the underlying store, it will attempt to use a supported
&nbsp;	 *              {@link IsolationLevel#isCompatibleWith(IsolationLevel) compatible level} instead.
&nbsp;	 * @throws RepositoryException If the connection could not start the transaction. Possible reasons this may happen
&nbsp;	 *                             are:
&nbsp;	 *                             &lt;ul&gt;
&nbsp;	 *                             &lt;li&gt;a transaction is already {@link #isActive() active} on the current connection.
&nbsp;	 *                             &lt;li&gt;the specified {@link IsolationLevel} is not supported by the store, and no
&nbsp;	 *                             compatible level could be found.
&nbsp;	 *                             &lt;/ul&gt;
&nbsp;	 * @see #begin()
&nbsp;	 * @see #isActive()
&nbsp;	 * @see #commit()
&nbsp;	 * @see #rollback()
&nbsp;	 * @see #setIsolationLevel(IsolationLevel)
&nbsp;	 */
&nbsp;	void begin(IsolationLevel level) throws RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Begins a new transaction with the supplied {@link TransactionSetting}, requiring {@link #commit()} or
&nbsp;	 * {@link #rollback()} to be called to end the transaction.
&nbsp;	 *
&nbsp;	 * @param settings The {@link TransactionSetting} (zero or more) for this transaction. If an isolation level is
&nbsp;	 *                 provided in the settings this will be used for the transaction. If none is provided then the
&nbsp;	 *                 default will be used. Behaviour of this method is undefined if more than one isolation level is
&nbsp;	 *                 provided. Behaviour of this method is undefined if one or more settings is null.
&nbsp;	 * @throws RepositoryException If the connection could not start the transaction. Possible reasons this may happen
&nbsp;	 *                             are:
&nbsp;	 *                             &lt;ul&gt;
&nbsp;	 *                             &lt;li&gt;a transaction is already {@link #isActive() active} on the current connection.
&nbsp;	 *                             &lt;li&gt;the specified {@link IsolationLevel} is not supported by the store, and no
&nbsp;	 *                             compatible level could be found.
&nbsp;	 *                             &lt;/ul&gt;
&nbsp;	 * @see #begin()
&nbsp;	 * @see #isActive()
&nbsp;	 * @see #commit()
&nbsp;	 * @see #rollback()
&nbsp;	 * @see #setIsolationLevel(IsolationLevel)
&nbsp;	 * @since 3.3.0
&nbsp;	 */
&nbsp;	default void begin(TransactionSetting... settings) {
<b class="nc">&nbsp;		for (TransactionSetting setting : settings) {</b>
<b class="nc">&nbsp;			if (setting instanceof IsolationLevel) {</b>
<b class="nc">&nbsp;				begin(((IsolationLevel) setting));</b>
&nbsp;				return;
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		begin();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Checks for an error state in the active transaction that would force the transaction to be rolled back. This is
&nbsp;	 * an optional call; calling or not calling this method should have no effect on the outcome of {@link #commit()} or
&nbsp;	 * {@link #rollback()}. A call to this method must be followed by (in the same thread) with a call to
&nbsp;	 * {@link #prepare()} , {@link #commit()}, {@link #rollback()}, or {@link #close()} . This method may be called
&nbsp;	 * multiple times within the same transaction by the same thread. If this method returns normally, the caller can
&nbsp;	 * reasonably expect that a subsequent call to {@link #commit()} will also return normally. If this method returns
&nbsp;	 * with an exception the caller should treat the exception as if it came from a call to {@link #commit()}.
&nbsp;	 *
&nbsp;	 * @throws UnknownTransactionStateException If the transaction state can not be determined (this can happen for
&nbsp;	 *                                          instance when communication between client and server fails or
&nbsp;	 *                                          times-out). It does not indicate a problem with the integrity of the
&nbsp;	 *                                          store.
&nbsp;	 * @throws RepositoryException              If there is an active transaction and it cannot be committed.
&nbsp;	 * @throws IllegalStateException            If the connection has been closed or prepare was already called by
&nbsp;	 *                                          another thread.
&nbsp;	 *
&nbsp;	 * @implNote this default method throws an {@link UnsupportedOperationException} and is a temporary measure to
&nbsp;	 *           ensure backward compatibility only. Implementing classes should override.
&nbsp;	 *
&nbsp;	 * @since 3.5.0
&nbsp;	 * @see #commit()
&nbsp;	 * @see #begin()
&nbsp;	 * @see #rollback()
&nbsp;	 */
&nbsp;	default void prepare() throws RepositoryException {
<b class="nc">&nbsp;		throw new UnsupportedOperationException();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Commits the active transaction. This operation ends the active transaction.
&nbsp;	 *
&nbsp;	 * @throws UnknownTransactionStateException if the transaction state can not be determined. This can happen for
&nbsp;	 *                                          instance when communication with a repository fails or times out.
&nbsp;	 * @throws RepositoryException              If the connection could not be committed, or if the connection does not
&nbsp;	 *                                          have an active transaction.
&nbsp;	 * @see #isActive()
&nbsp;	 * @see #begin()
&nbsp;	 * @see #rollback()
&nbsp;	 * @see #prepare()
&nbsp;	 */
&nbsp;	void commit() throws RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Rolls back all updates in the active transaction. This operation ends the active transaction.
&nbsp;	 *
&nbsp;	 * @throws UnknownTransactionStateException if the transaction state can not be determined. This can happen for
&nbsp;	 *                                          instance when communication with a repository fails or times out.
&nbsp;	 * @throws RepositoryException              If the transaction could not be rolled back, or if the connection does
&nbsp;	 *                                          not have an active transaction.
&nbsp;	 * @see #isActive()
&nbsp;	 * @see #begin()
&nbsp;	 * @see #commit()
&nbsp;	 */
&nbsp;	void rollback() throws RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Adds RDF data from an InputStream to the repository, optionally to one or more named contexts.
&nbsp;	 *
&nbsp;	 * @param in         An InputStream from which RDF data can be read.
&nbsp;	 * @param dataFormat The serialization format of the data.
&nbsp;	 * @param contexts   The contexts to add the data to. If one or more contexts are supplied the method ignores
&nbsp;	 *                   contextual information in the actual data. If no contexts are supplied the contextual
&nbsp;	 *                   information in the input stream is used, if no context information is available the data is
&nbsp;	 *                   added without any context.
&nbsp;	 * @throws IOException                  If an I/O error occurred while reading from the input stream.
&nbsp;	 * @throws UnsupportedRDFormatException If no parser is available for the specified RDF format.
&nbsp;	 * @throws RDFParseException            If an error was found while parsing the RDF data.
&nbsp;	 * @throws RepositoryException          If the data could not be added to the repository, for example because the
&nbsp;	 *                                      repository is not writable.
&nbsp;	 * @since 3.5.0
&nbsp;	 */
&nbsp;	default void add(InputStream in, RDFFormat dataFormat, Resource... contexts)
&nbsp;			throws IOException, RDFParseException, RepositoryException {
<b class="nc">&nbsp;		add(in, null, dataFormat, contexts);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Adds RDF data from an InputStream to the repository, optionally to one or more named contexts.
&nbsp;	 *
&nbsp;	 * @param in         An InputStream from which RDF data can be read.
&nbsp;	 * @param baseURI    The base URI to resolve any relative URIs that are in the data against. May be
&nbsp;	 *                   &lt;code&gt;null&lt;/code&gt;.
&nbsp;	 *                   &lt;p&gt;
&nbsp;	 *                   Note that if the data contains an embedded base URI, that embedded base URI will overrule the
&nbsp;	 *                   value supplied here (see &lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt; section
&nbsp;	 *                   5.1 for details).
&nbsp;	 * @param dataFormat The serialization format of the data.
&nbsp;	 * @param contexts   The contexts to add the data to. If one or more contexts are supplied the method ignores
&nbsp;	 *                   contextual information in the actual data. If no contexts are supplied the contextual
&nbsp;	 *                   information in the input stream is used, if no context information is available the data is
&nbsp;	 *                   added without any context.
&nbsp;	 *
&nbsp;	 * @throws IOException                  If an I/O error occurred while reading from the input stream.
&nbsp;	 * @throws UnsupportedRDFormatException If no parser is available for the specified RDF format.
&nbsp;	 * @throws RDFParseException            If an error was found while parsing the RDF data.
&nbsp;	 * @throws RepositoryException          If the data could not be added to the repository, for example because the
&nbsp;	 *                                      repository is not writable.
&nbsp;	 */
&nbsp;	void add(InputStream in, String baseURI, RDFFormat dataFormat, Resource... contexts)
&nbsp;			throws IOException, RDFParseException, RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Adds RDF data from a Reader to the repository, optionally to one or more named contexts. &lt;b&gt;Note: using a Reader
&nbsp;	 * to upload byte-based data means that you have to be careful not to destroy the data&#39;s character encoding by
&nbsp;	 * enforcing a default character encoding upon the bytes. If possible, adding such data using an InputStream is to
&nbsp;	 * be preferred.&lt;/b&gt;
&nbsp;	 *
&nbsp;	 * @param reader     A Reader from which RDF data can be read.
&nbsp;	 * @param dataFormat The serialization format of the data.
&nbsp;	 * @param contexts   The contexts to add the data to. If one or more contexts are specified the data is added to
&nbsp;	 *                   these contexts, ignoring any context information in the data itself.
&nbsp;	 *
&nbsp;	 * @throws IOException                  If an I/O error occurred while reading from the reader.
&nbsp;	 * @throws UnsupportedRDFormatException If no parser is available for the specified RDF format.
&nbsp;	 * @throws RDFParseException            If an error was found while parsing the RDF data.
&nbsp;	 * @throws RepositoryException          If the data could not be added to the repository, for example because the
&nbsp;	 *                                      repository is not writable.
&nbsp;	 *
&nbsp;	 * @since 3.5.0
&nbsp;	 */
&nbsp;	default void add(Reader reader, RDFFormat dataFormat, Resource... contexts)
&nbsp;			throws IOException, RDFParseException, RepositoryException {
<b class="fc">&nbsp;		add(reader, null, dataFormat, contexts);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Adds RDF data from a Reader to the repository, optionally to one or more named contexts. &lt;b&gt;Note: using a Reader
&nbsp;	 * to upload byte-based data means that you have to be careful not to destroy the data&#39;s character encoding by
&nbsp;	 * enforcing a default character encoding upon the bytes. If possible, adding such data using an InputStream is to
&nbsp;	 * be preferred.&lt;/b&gt;
&nbsp;	 *
&nbsp;	 * @param reader     A Reader from which RDF data can be read.
&nbsp;	 * @param baseURI    The base URI to resolve any relative URIs that are in the data against. May be
&nbsp;	 *                   &lt;code&gt;null&lt;/code&gt;.
&nbsp;	 *                   &lt;p&gt;
&nbsp;	 *                   Note that if the data contains an embedded base URI, that embedded base URI will overrule the
&nbsp;	 *                   value supplied here (see &lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt; section
&nbsp;	 *                   5.1 for details).
&nbsp;	 * @param dataFormat The serialization format of the data.
&nbsp;	 * @param contexts   The contexts to add the data to. If one or more contexts are specified the data is added to
&nbsp;	 *                   these contexts, ignoring any context information in the data itself.
&nbsp;	 * @throws IOException                  If an I/O error occurred while reading from the reader.
&nbsp;	 * @throws UnsupportedRDFormatException If no parser is available for the specified RDF format.
&nbsp;	 * @throws RDFParseException            If an error was found while parsing the RDF data.
&nbsp;	 * @throws RepositoryException          If the data could not be added to the repository, for example because the
&nbsp;	 *                                      repository is not writable.
&nbsp;	 */
&nbsp;	void add(Reader reader, String baseURI, RDFFormat dataFormat, Resource... contexts)
&nbsp;			throws IOException, RDFParseException, RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Adds the RDF data that can be found at the specified URL to the repository, optionally to one or more named
&nbsp;	 * contexts.
&nbsp;	 *
&nbsp;	 * @param url      The URL of the RDF data.
&nbsp;	 * @param contexts The contexts to add the data to. If one or more contexts are specified the data is added to these
&nbsp;	 *                 contexts, ignoring any context information in the data itself.
&nbsp;	 *
&nbsp;	 * @throws IOException                  If an I/O error occurred while reading from the URL.
&nbsp;	 * @throws UnsupportedRDFormatException If the RDF format could not be recognized.
&nbsp;	 * @throws RDFParseException            If an error was found while parsing the RDF data.
&nbsp;	 * @throws RepositoryException          If the data could not be added to the repository, for example because the
&nbsp;	 *                                      repository is not writable.
&nbsp;	 *
&nbsp;	 * @since 3.5.0
&nbsp;	 */
&nbsp;	default void add(URL url, Resource... contexts)
&nbsp;			throws IOException, RDFParseException, RepositoryException {
<b class="nc">&nbsp;		add(url, null, null, contexts);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Adds the RDF data that can be found at the specified URL to the repository, optionally to one or more named
&nbsp;	 * contexts.
&nbsp;	 *
&nbsp;	 * @param url        The URL of the RDF data.
&nbsp;	 * @param dataFormat The serialization format of the data. If set to &lt;var&gt;null&lt;/var&gt;, the format will be
&nbsp;	 *                   automatically determined by examining the content type in the HTTP response header, and failing
&nbsp;	 *                   that, the file name extension of the supplied URL.
&nbsp;	 * @param contexts   The contexts to add the data to. If one or more contexts are specified the data is added to
&nbsp;	 *                   these contexts, ignoring any context information in the data itself.
&nbsp;	 *
&nbsp;	 * @throws IOException                  If an I/O error occurred while reading from the URL.
&nbsp;	 * @throws UnsupportedRDFormatException If no parser is available for the specified RDF format, or the RDF format
&nbsp;	 *                                      could not be automatically determined.
&nbsp;	 * @throws RDFParseException            If an error was found while parsing the RDF data.
&nbsp;	 * @throws RepositoryException          If the data could not be added to the repository, for example because the
&nbsp;	 *                                      repository is not writable.
&nbsp;	 *
&nbsp;	 * @since 3.5.0
&nbsp;	 */
&nbsp;	default void add(URL url, RDFFormat dataFormat, Resource... contexts)
&nbsp;			throws IOException, RDFParseException, RepositoryException {
<b class="nc">&nbsp;		add(url, null, dataFormat, contexts);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Adds the RDF data that can be found at the specified URL to the repository, optionally to one or more named
&nbsp;	 * contexts.
&nbsp;	 *
&nbsp;	 * @param url        The URL of the RDF data.
&nbsp;	 * @param baseURI    The base URI to resolve any relative URIs that are in the data against. This defaults to the
&nbsp;	 *                   value of {@link java.net.URL#toExternalForm() url.toExternalForm()} if the value is set to
&nbsp;	 *                   &lt;var&gt;null&lt;/var&gt;.
&nbsp;	 *                   &lt;p&gt;
&nbsp;	 *                   Note that if the data contains an embedded base URI, that embedded base URI will overrule the
&nbsp;	 *                   value supplied here (see &lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt; section
&nbsp;	 *                   5.1 for details).
&nbsp;	 * @param dataFormat The serialization format of the data. If set to &lt;var&gt;null&lt;/var&gt;, the format will be
&nbsp;	 *                   automatically determined by examining the content type in the HTTP response header, and failing
&nbsp;	 *                   that, the file name extension of the supplied URL.
&nbsp;	 * @param contexts   The contexts to add the data to. If one or more contexts are specified the data is added to
&nbsp;	 *                   these contexts, ignoring any context information in the data itself.
&nbsp;	 * @throws IOException                  If an I/O error occurred while reading from the URL.
&nbsp;	 * @throws UnsupportedRDFormatException If no parser is available for the specified RDF format, or the RDF format
&nbsp;	 *                                      could not be automatically determined.
&nbsp;	 * @throws RDFParseException            If an error was found while parsing the RDF data.
&nbsp;	 * @throws RepositoryException          If the data could not be added to the repository, for example because the
&nbsp;	 *                                      repository is not writable.
&nbsp;	 */
&nbsp;	void add(URL url, String baseURI, RDFFormat dataFormat, Resource... contexts)
&nbsp;			throws IOException, RDFParseException, RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Adds RDF data from the specified file to a specific contexts in the repository.
&nbsp;	 *
&nbsp;	 * @param file     A file containing RDF data.
&nbsp;	 * @param contexts The contexts to add the data to. Note that this parameter is a vararg and as such is optional. If
&nbsp;	 *                 no contexts are specified, the data is added to any context specified in the actual data file, or
&nbsp;	 *                 if the data contains no context, it is added without context. If one or more contexts are
&nbsp;	 *                 specified the data is added to these contexts, ignoring any context information in the data
&nbsp;	 *                 itself.
&nbsp;	 *
&nbsp;	 * @throws IOException                  If an I/O error occurred while reading from the file.
&nbsp;	 * @throws UnsupportedRDFormatException If the RDF format of the supplied file could not be recognized.
&nbsp;	 * @throws RDFParseException            If an error was found while parsing the RDF data.
&nbsp;	 * @throws RepositoryException          If the data could not be added to the repository, for example because the
&nbsp;	 *                                      repository is not writable.
&nbsp;	 *
&nbsp;	 * @since 3.5.0
&nbsp;	 */
&nbsp;	default void add(File file, Resource... contexts)
&nbsp;			throws IOException, RDFParseException, RepositoryException {
<b class="nc">&nbsp;		add(file, null, null, contexts);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Adds RDF data from the specified file to a specific contexts in the repository.
&nbsp;	 *
&nbsp;	 * @param file       A file containing RDF data.
&nbsp;	 * @param dataFormat The serialization format of the data. If set to &lt;var&gt;null&lt;/var&gt;, the format will be
&nbsp;	 *                   automatically determined by examining the file name extension of the supplied File.
&nbsp;	 * @param contexts   The contexts to add the data to. Note that this parameter is a vararg and as such is optional.
&nbsp;	 *                   If no contexts are specified, the data is added to any context specified in the actual data
&nbsp;	 *                   file, or if the data contains no context, it is added without context. If one or more contexts
&nbsp;	 *                   are specified the data is added to these contexts, ignoring any context information in the data
&nbsp;	 *                   itself.
&nbsp;	 *
&nbsp;	 * @throws IOException                  If an I/O error occurred while reading from the file.
&nbsp;	 * @throws UnsupportedRDFormatException If no parser is available for the specified RDF format.
&nbsp;	 * @throws RDFParseException            If an error was found while parsing the RDF data.
&nbsp;	 * @throws RepositoryException          If the data could not be added to the repository, for example because the
&nbsp;	 *                                      repository is not writable.
&nbsp;	 *
&nbsp;	 * @since 3.5.0
&nbsp;	 */
&nbsp;	default void add(File file, RDFFormat dataFormat, Resource... contexts)
&nbsp;			throws IOException, RDFParseException, RepositoryException {
<b class="nc">&nbsp;		add(file, null, dataFormat, contexts);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Adds RDF data from the specified file to a specific contexts in the repository.
&nbsp;	 *
&nbsp;	 * @param file       A file containing RDF data.
&nbsp;	 * @param baseURI    The base URI to resolve any relative URIs that are in the data against. This defaults to the
&nbsp;	 *                   value of {@link java.io.File#toURI() file.toURI()} if the value is set to &lt;var&gt;null&lt;/var&gt;.
&nbsp;	 *                   &lt;p&gt;
&nbsp;	 *                   Note that if the data contains an embedded base URI, that embedded base URI will overrule the
&nbsp;	 *                   value supplied here (see &lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt; section
&nbsp;	 *                   5.1 for details).
&nbsp;	 * @param dataFormat The serialization format of the data. If set to &lt;var&gt;null&lt;/var&gt;, the format will be
&nbsp;	 *                   automatically determined by examining the file name extension of the supplied File.
&nbsp;	 * @param contexts   The contexts to add the data to. Note that this parameter is a vararg and as such is optional.
&nbsp;	 *                   If no contexts are specified, the data is added to any context specified in the actual data
&nbsp;	 *                   file, or if the data contains no context, it is added without context. If one or more contexts
&nbsp;	 *                   are specified the data is added to these contexts, ignoring any context information in the data
&nbsp;	 *                   itself.
&nbsp;	 * @throws IOException                  If an I/O error occurred while reading from the file.
&nbsp;	 * @throws UnsupportedRDFormatException If no parser is available for the specified RDF format.
&nbsp;	 * @throws RDFParseException            If an error was found while parsing the RDF data.
&nbsp;	 * @throws RepositoryException          If the data could not be added to the repository, for example because the
&nbsp;	 *                                      repository is not writable.
&nbsp;	 */
&nbsp;	void add(File file, String baseURI, RDFFormat dataFormat, Resource... contexts)
&nbsp;			throws IOException, RDFParseException, RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Adds a statement with the specified subject, predicate and object to this repository, optionally to one or more
&nbsp;	 * named contexts.
&nbsp;	 *
&nbsp;	 * @param subject   The statement&#39;s subject.
&nbsp;	 * @param predicate The statement&#39;s predicate.
&nbsp;	 * @param object    The statement&#39;s object.
&nbsp;	 * @param contexts  The contexts to add the data to. Note that this parameter is a vararg and as such is optional.
&nbsp;	 *                  If no contexts are specified, the data is added to any context specified in the actual data
&nbsp;	 *                  file, or if the data contains no context, it is added without context. If one or more contexts
&nbsp;	 *                  are specified the data is added to these contexts, ignoring any context information in the data
&nbsp;	 *                  itself.
&nbsp;	 * @throws RepositoryException If the data could not be added to the repository, for example because the repository
&nbsp;	 *                             is not writable.
&nbsp;	 */
&nbsp;	void add(Resource subject, IRI predicate, Value object, Resource... contexts) throws RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Adds the supplied statement to this repository, optionally to one or more named contexts.
&nbsp;	 *
&nbsp;	 * @param st       The statement to add.
&nbsp;	 * @param contexts The contexts to add the statements to. Note that this parameter is a vararg and as such is
&nbsp;	 *                 optional. If no contexts are specified, the statement is added to any context specified in each
&nbsp;	 *                 statement, or if the statement contains no context, it is added without context. If one or more
&nbsp;	 *                 contexts are specified the statement is added to these contexts, ignoring any context information
&nbsp;	 *                 in the statement itself.
&nbsp;	 * @throws RepositoryException If the statement could not be added to the repository, for example because the
&nbsp;	 *                             repository is not writable.
&nbsp;	 */
&nbsp;	void add(Statement st, Resource... contexts) throws RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Adds the supplied statements to this repository, optionally to one or more named contexts.
&nbsp;	 *
&nbsp;	 * @param statements The statements that should be added.
&nbsp;	 * @param contexts   The contexts to add the statements to. Note that this parameter is a vararg and as such is
&nbsp;	 *                   optional. If no contexts are specified, each statement is added to any context specified in the
&nbsp;	 *                   statement, or if the statement contains no context, it is added without context. If one or more
&nbsp;	 *                   contexts are specified each statement is added to these contexts, ignoring any context
&nbsp;	 *                   information in the statement itself. ignored.
&nbsp;	 * @throws RepositoryException If the statements could not be added to the repository, for example because the
&nbsp;	 *                             repository is not writable.
&nbsp;	 */
&nbsp;	void add(Iterable&lt;? extends Statement&gt; statements, Resource... contexts) throws RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Adds the supplied statements to this repository, optionally to one or more named contexts.
&nbsp;	 *
&nbsp;	 * @param statements The statements to add. In case the iteration is a
&nbsp;	 *                   {@link org.eclipse.rdf4j.common.iteration.CloseableIteration}, it will be closed before this
&nbsp;	 *                   method returns.
&nbsp;	 * @param contexts   The contexts to add the statements to. Note that this parameter is a vararg and as such is
&nbsp;	 *                   optional. If no contexts are specified, each statement is added to any context specified in the
&nbsp;	 *                   statement, or if the statement contains no context, it is added without context. If one or more
&nbsp;	 *                   contexts are specified each statement is added to these contexts, ignoring any context
&nbsp;	 *                   information in the statement itself. ignored.
&nbsp;	 * @throws RepositoryException If the statements could not be added to the repository, for example because the
&nbsp;	 *                             repository is not writable.
&nbsp;	 */
&nbsp;	@Deprecated(since = &quot;4.1.0&quot;, forRemoval = true)
&nbsp;	&lt;E extends Exception&gt; void add(Iteration&lt;? extends Statement, E&gt; statements, Resource... contexts)
&nbsp;			throws RepositoryException, E;
&nbsp;
&nbsp;	/**
&nbsp;	 * Adds the supplied statements to this repository, optionally to one or more named contexts.
&nbsp;	 *
&nbsp;	 * @param statements The statements to add. The iteration will be closed.
&nbsp;	 * @param contexts   The contexts to add the statements to. Note that this parameter is a vararg and as such is
&nbsp;	 *                   optional. If no contexts are specified, each statement is added to any context specified in the
&nbsp;	 *                   statement, or if the statement contains no context, it is added without context. If one or more
&nbsp;	 *                   contexts are specified each statement is added to these contexts, ignoring any context
&nbsp;	 *                   information in the statement itself. ignored.
&nbsp;	 * @throws RepositoryException If the statements could not be added to the repository, for example because the
&nbsp;	 *                             repository is not writable.
&nbsp;	 */
&nbsp;	default &lt;E extends Exception&gt; void add(CloseableIteration&lt;? extends Statement, E&gt; statements, Resource... contexts)
&nbsp;			throws RepositoryException, E {
<b class="nc">&nbsp;		add(((Iteration&lt;? extends Statement, E&gt;) statements), contexts);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Adds the supplied statements to this repository, optionally to one or more named contexts.
&nbsp;	 *
&nbsp;	 * @param statements The statements to add. The @{link RepositoryResult} will be closed before this method returns.
&nbsp;	 * @param contexts   The contexts to add the statements to. Note that this parameter is a vararg and as such is
&nbsp;	 *                   optional. If no contexts are specified, each statement is added to any context specified in the
&nbsp;	 *                   statement, or if the statement contains no context, it is added without context. If one or more
&nbsp;	 *                   contexts are specified each statement is added to these contexts, ignoring any context
&nbsp;	 *                   information in the statement itself. ignored.
&nbsp;	 * @throws RepositoryException If the statements could not be added to the repository, for example because the
&nbsp;	 *                             repository is not writable.
&nbsp;	 */
&nbsp;	default void add(RepositoryResult&lt;Statement&gt; statements, Resource... contexts)
&nbsp;			throws RepositoryException {
<b class="nc">&nbsp;		add((CloseableIteration&lt;Statement, RepositoryException&gt;) statements, contexts);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Removes the statement(s) with the specified subject, predicate and object from the repository, optionally
&nbsp;	 * restricted to the specified contexts.
&nbsp;	 *
&nbsp;	 * @param subject   The statement&#39;s subject, or &lt;var&gt;null&lt;/var&gt; for a wildcard.
&nbsp;	 * @param predicate The statement&#39;s predicate, or &lt;var&gt;null&lt;/var&gt; for a wildcard.
&nbsp;	 * @param object    The statement&#39;s object, or &lt;var&gt;null&lt;/var&gt; for a wildcard.
&nbsp;	 * @param contexts  The context(s) to remove the data from. Note that this parameter is a vararg and as such is
&nbsp;	 *                  optional. If no contexts are supplied the method operates on the entire repository.
&nbsp;	 * @throws RepositoryException If the statement(s) could not be removed from the repository, for example because the
&nbsp;	 *                             repository is not writable.
&nbsp;	 */
&nbsp;	void remove(Resource subject, IRI predicate, Value object, Resource... contexts) throws RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Removes the supplied statement from the specified contexts in the repository.
&nbsp;	 *
&nbsp;	 * @param st       The statement to remove.
&nbsp;	 * @param contexts The context(s) to remove the data from. Note that this parameter is a vararg and as such is
&nbsp;	 *                 optional. If no contexts are supplied the method operates on the contexts associated with the
&nbsp;	 *                 statement itself, and if no context is associated with the statement, on the entire repository.
&nbsp;	 * @throws RepositoryException If the statement could not be removed from the repository, for example because the
&nbsp;	 *                             repository is not writable.
&nbsp;	 */
&nbsp;	void remove(Statement st, Resource... contexts) throws RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Removes the supplied statements from the specified contexts in this repository.
&nbsp;	 *
&nbsp;	 * @param statements The statements that should be added.
&nbsp;	 * @param contexts   The context(s) to remove the data from. Note that this parameter is a vararg and as such is
&nbsp;	 *                   optional. If no contexts are supplied the method operates on the contexts associated with the
&nbsp;	 *                   statement itself, and if no context is associated with the statement, on the entire repository.
&nbsp;	 * @throws RepositoryException If the statements could not be added to the repository, for example because the
&nbsp;	 *                             repository is not writable.
&nbsp;	 */
&nbsp;	void remove(Iterable&lt;? extends Statement&gt; statements, Resource... contexts) throws RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Removes the supplied statements from a specific context in this repository, ignoring any context information
&nbsp;	 * carried by the statements themselves.
&nbsp;	 *
&nbsp;	 * @param statements The statements to remove. In case the iteration is a
&nbsp;	 *                   {@link org.eclipse.rdf4j.common.iteration.CloseableIteration}, it will be closed before this
&nbsp;	 *                   method returns.
&nbsp;	 * @param contexts   The context(s) to remove the data from. Note that this parameter is a vararg and as such is
&nbsp;	 *                   optional. If no contexts are supplied the method operates on the contexts associated with the
&nbsp;	 *                   statement itself, and if no context is associated with the statement, on the entire repository.
&nbsp;	 * @throws RepositoryException If the statements could not be removed from the repository, for example because the
&nbsp;	 *                             repository is not writable.
&nbsp;	 */
&nbsp;	@Deprecated(since = &quot;4.1.0&quot;, forRemoval = true)
&nbsp;	&lt;E extends Exception&gt; void remove(Iteration&lt;? extends Statement, E&gt; statements, Resource... contexts)
&nbsp;			throws RepositoryException, E;
&nbsp;
&nbsp;	/**
&nbsp;	 * Removes the supplied statements from a specific context in this repository, ignoring any context information
&nbsp;	 * carried by the statements themselves.
&nbsp;	 *
&nbsp;	 * @param statements The statements to remove. The iteration will be closed.
&nbsp;	 * @param contexts   The context(s) to remove the data from. Note that this parameter is a vararg and as such is
&nbsp;	 *                   optional. If no contexts are supplied the method operates on the contexts associated with the
&nbsp;	 *                   statement itself, and if no context is associated with the statement, on the entire repository.
&nbsp;	 * @throws RepositoryException If the statements could not be removed from the repository, for example because the
&nbsp;	 *                             repository is not writable.
&nbsp;	 */
&nbsp;	default &lt;E extends Exception&gt; void remove(CloseableIteration&lt;? extends Statement, E&gt; statements,
&nbsp;			Resource... contexts)
&nbsp;			throws RepositoryException, E {
<b class="nc">&nbsp;		remove((Iteration&lt;Statement, RepositoryException&gt;) statements, contexts);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Removes the supplied statements from a specific context in this repository, ignoring any context information
&nbsp;	 * carried by the statements themselves.
&nbsp;	 *
&nbsp;	 * @param statements The statements to remove. The {@link RepositoryResult} will be closed before this method
&nbsp;	 *                   returns.
&nbsp;	 * @param contexts   The context(s) to remove the data from. Note that this parameter is a vararg and as such is
&nbsp;	 *                   optional. If no contexts are supplied the method operates on the contexts associated with the
&nbsp;	 *                   statement itself, and if no context is associated with the statement, on the entire repository.
&nbsp;	 * @throws RepositoryException If the statements could not be removed from the repository, for example because the
&nbsp;	 *                             repository is not writable.
&nbsp;	 */
&nbsp;	default void remove(RepositoryResult&lt;Statement&gt; statements, Resource... contexts)
&nbsp;			throws RepositoryException {
<b class="nc">&nbsp;		remove((CloseableIteration&lt;Statement, RepositoryException&gt;) statements, contexts);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Removes all statements from a specific contexts in the repository.
&nbsp;	 *
&nbsp;	 * @param contexts The context(s) to remove the data from. Note that this parameter is a vararg and as such is
&nbsp;	 *                 optional. If no contexts are supplied the method operates on the entire repository.
&nbsp;	 * @throws RepositoryException If the statements could not be removed from the repository, for example because the
&nbsp;	 *                             repository is not writable.
&nbsp;	 */
&nbsp;	void clear(Resource... contexts) throws RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets all declared namespaces as a RepositoryResult of {@link Namespace} objects. Each Namespace object consists
&nbsp;	 * of a prefix and a namespace name.
&nbsp;	 *
&nbsp;	 * @return A RepositoryResult containing Namespace objects. Care should be taken to close the RepositoryResult after
&nbsp;	 *         use.
&nbsp;	 * @throws RepositoryException If the namespaces could not be read from the repository.
&nbsp;	 */
&nbsp;	RepositoryResult&lt;Namespace&gt; getNamespaces() throws RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets the namespace that is associated with the specified prefix, if any.
&nbsp;	 *
&nbsp;	 * @param prefix A namespace prefix, or an empty string in case of the default namespace.
&nbsp;	 * @return The namespace name that is associated with the specified prefix, or &lt;var&gt;null&lt;/var&gt; if there is no such
&nbsp;	 *         namespace.
&nbsp;	 * @throws RepositoryException  If the namespace could not be read from the repository.
&nbsp;	 * @throws NullPointerException In case &lt;var&gt;prefix&lt;/var&gt; is &lt;var&gt;null&lt;/var&gt;.
&nbsp;	 */
&nbsp;	String getNamespace(String prefix) throws RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets the prefix for a namespace.
&nbsp;	 *
&nbsp;	 * @param prefix The new prefix, or an empty string in case of the default namespace.
&nbsp;	 * @param name   The namespace name that the prefix maps to.
&nbsp;	 * @throws RepositoryException  If the namespace could not be set in the repository, for example because the
&nbsp;	 *                              repository is not writable.
&nbsp;	 * @throws NullPointerException In case &lt;var&gt;prefix&lt;/var&gt; or &lt;var&gt;name&lt;/var&gt; is &lt;var&gt;null&lt;/var&gt;.
&nbsp;	 */
&nbsp;	void setNamespace(String prefix, String name) throws RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Removes a namespace declaration by removing the association between a prefix and a namespace name.
&nbsp;	 *
&nbsp;	 * @param prefix The namespace prefix, or an empty string in case of the default namespace.
&nbsp;	 * @throws RepositoryException  If the namespace prefix could not be removed.
&nbsp;	 * @throws NullPointerException In case &lt;var&gt;prefix&lt;/var&gt; is &lt;var&gt;null&lt;/var&gt;.
&nbsp;	 */
&nbsp;	void removeNamespace(String prefix) throws RepositoryException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Removes all namespace declarations from the repository.
&nbsp;	 *
&nbsp;	 * @throws RepositoryException If the namespace declarations could not be removed.
&nbsp;	 */
&nbsp;	void clearNamespaces() throws RepositoryException;
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:56</div>
</div>
</body>
</html>
