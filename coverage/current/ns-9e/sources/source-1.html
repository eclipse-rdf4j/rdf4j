


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > SPARQLConnection</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.repository.sparql</a>
</div>

<h1>Coverage Summary for Class: SPARQLConnection (org.eclipse.rdf4j.repository.sparql)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SPARQLConnection</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/59)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/214)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/447)
  </span>
</td>
</tr>
  <tr>
    <td class="name">SPARQLConnection$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SPARQLConnection$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SPARQLConnection$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SPARQLConnection$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SPARQLConnection$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/69)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/220)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/461)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;package org.eclipse.rdf4j.repository.sparql;
&nbsp;
&nbsp;import static org.eclipse.rdf4j.query.QueryLanguage.SPARQL;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.Reader;
&nbsp;import java.net.URL;
&nbsp;import java.util.Objects;
&nbsp;
&nbsp;import org.apache.http.client.HttpClient;
&nbsp;import org.eclipse.rdf4j.common.iteration.CloseableIteration;
&nbsp;import org.eclipse.rdf4j.common.iteration.ConvertingIteration;
&nbsp;import org.eclipse.rdf4j.common.iteration.EmptyIteration;
&nbsp;import org.eclipse.rdf4j.common.iteration.ExceptionConvertingIteration;
&nbsp;import org.eclipse.rdf4j.common.iteration.Iteration;
&nbsp;import org.eclipse.rdf4j.common.iteration.SingletonIteration;
&nbsp;import org.eclipse.rdf4j.http.client.HttpClientDependent;
&nbsp;import org.eclipse.rdf4j.http.client.SPARQLProtocolSession;
&nbsp;import org.eclipse.rdf4j.model.BNode;
&nbsp;import org.eclipse.rdf4j.model.IRI;
&nbsp;import org.eclipse.rdf4j.model.Literal;
&nbsp;import org.eclipse.rdf4j.model.Model;
&nbsp;import org.eclipse.rdf4j.model.ModelFactory;
&nbsp;import org.eclipse.rdf4j.model.Namespace;
&nbsp;import org.eclipse.rdf4j.model.Resource;
&nbsp;import org.eclipse.rdf4j.model.Statement;
&nbsp;import org.eclipse.rdf4j.model.Value;
&nbsp;import org.eclipse.rdf4j.model.impl.DynamicModelFactory;
&nbsp;import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
&nbsp;import org.eclipse.rdf4j.model.util.Literals;
&nbsp;import org.eclipse.rdf4j.query.BindingSet;
&nbsp;import org.eclipse.rdf4j.query.BooleanQuery;
&nbsp;import org.eclipse.rdf4j.query.GraphQuery;
&nbsp;import org.eclipse.rdf4j.query.GraphQueryResult;
&nbsp;import org.eclipse.rdf4j.query.MalformedQueryException;
&nbsp;import org.eclipse.rdf4j.query.Query;
&nbsp;import org.eclipse.rdf4j.query.QueryEvaluationException;
&nbsp;import org.eclipse.rdf4j.query.QueryLanguage;
&nbsp;import org.eclipse.rdf4j.query.TupleQuery;
&nbsp;import org.eclipse.rdf4j.query.TupleQueryResult;
&nbsp;import org.eclipse.rdf4j.query.UnsupportedQueryLanguageException;
&nbsp;import org.eclipse.rdf4j.query.Update;
&nbsp;import org.eclipse.rdf4j.query.UpdateExecutionException;
&nbsp;import org.eclipse.rdf4j.query.impl.SimpleDataset;
&nbsp;import org.eclipse.rdf4j.query.parser.QueryParserUtil;
&nbsp;import org.eclipse.rdf4j.query.parser.sparql.SPARQLQueries;
&nbsp;import org.eclipse.rdf4j.repository.RepositoryConnection;
&nbsp;import org.eclipse.rdf4j.repository.RepositoryException;
&nbsp;import org.eclipse.rdf4j.repository.RepositoryResult;
&nbsp;import org.eclipse.rdf4j.repository.UnknownTransactionStateException;
&nbsp;import org.eclipse.rdf4j.repository.base.AbstractRepositoryConnection;
&nbsp;import org.eclipse.rdf4j.repository.sparql.query.SPARQLBooleanQuery;
&nbsp;import org.eclipse.rdf4j.repository.sparql.query.SPARQLGraphQuery;
&nbsp;import org.eclipse.rdf4j.repository.sparql.query.SPARQLTupleQuery;
&nbsp;import org.eclipse.rdf4j.repository.sparql.query.SPARQLUpdate;
&nbsp;import org.eclipse.rdf4j.repository.util.RDFLoader;
&nbsp;import org.eclipse.rdf4j.rio.ParserConfig;
&nbsp;import org.eclipse.rdf4j.rio.RDFFormat;
&nbsp;import org.eclipse.rdf4j.rio.RDFHandler;
&nbsp;import org.eclipse.rdf4j.rio.RDFHandlerException;
&nbsp;import org.eclipse.rdf4j.rio.RDFParseException;
&nbsp;import org.eclipse.rdf4j.rio.helpers.StatementCollector;
&nbsp;
&nbsp;/**
&nbsp; * Provides a {@link RepositoryConnection} interface to any SPARQL endpoint.
&nbsp; *
&nbsp; * @author James Leigh
&nbsp; */
&nbsp;public class SPARQLConnection extends AbstractRepositoryConnection implements HttpClientDependent {
&nbsp;
&nbsp;	private static final String EVERYTHING = &quot;CONSTRUCT { ?s ?p ?o } WHERE { ?s ?p ?o }&quot;;
&nbsp;
&nbsp;	private static final String EVERYTHING_WITH_GRAPH = &quot;SELECT * WHERE {  ?s ?p ?o . OPTIONAL { GRAPH ?ctx { ?s ?p ?o } } }&quot;;
&nbsp;
&nbsp;	private static final String SOMETHING = &quot;ASK { ?s ?p ?o }&quot;;
&nbsp;
&nbsp;	private static final String SOMETHING_WITH_GRAPH = &quot;ASK { { GRAPH ?g { ?s ?p ?o } } UNION { ?s ?p ?o } }&quot;;
&nbsp;
&nbsp;	private static final String NAMEDGRAPHS = &quot;SELECT DISTINCT ?_ WHERE { GRAPH ?_ { ?s ?p ?o } }&quot;;
&nbsp;
&nbsp;	private static final int DEFAULT_MAX_PENDING_SIZE = 1000000;
&nbsp;
&nbsp;	private final SPARQLProtocolSession client;
&nbsp;
<b class="nc">&nbsp;	private final ModelFactory modelFactory = new DynamicModelFactory();</b>
&nbsp;
&nbsp;	private StringBuilder sparqlTransaction;
&nbsp;
<b class="nc">&nbsp;	private final Object transactionLock = new Object();</b>
&nbsp;
&nbsp;	private Model pendingAdds;
&nbsp;	private Model pendingRemoves;
&nbsp;
<b class="nc">&nbsp;	private final int maxPendingSize = DEFAULT_MAX_PENDING_SIZE;</b>
&nbsp;
&nbsp;	private final boolean quadMode;
&nbsp;	private boolean silentClear;
&nbsp;
&nbsp;	public SPARQLConnection(SPARQLRepository repository, SPARQLProtocolSession client) {
<b class="nc">&nbsp;		this(repository, client, false); // in triple mode by default</b>
&nbsp;	}
&nbsp;
&nbsp;	public SPARQLConnection(SPARQLRepository repository, SPARQLProtocolSession client, boolean quadMode) {
<b class="nc">&nbsp;		super(repository);</b>
<b class="nc">&nbsp;		this.client = client;</b>
<b class="nc">&nbsp;		this.quadMode = quadMode;</b>
<b class="nc">&nbsp;		this.silentClear = false;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public String toString() {
<b class="nc">&nbsp;		return client.getQueryURL();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Configure the connection to execute {@link #clear(Resource...)} operations silently: the remote endpoint will not
&nbsp;	 * respond with an error if the supplied named graph does not exist on the endpoint.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * By default, the SPARQL connection executes the {@link #clear(Resource...)} API operation by converting it to a
&nbsp;	 * SPARQL `CLEAR GRAPH` update operation. This operation has an optional &lt;code&gt;SILENT&lt;/code&gt; modifier, which can be
&nbsp;	 * enabled by setting this flag to &lt;code&gt;true&lt;/code&gt;. The behavior of this modifier is speficied as follows in the
&nbsp;	 * SPARQL 1.1 Recommendation:
&nbsp;	 *
&nbsp;	 * &lt;blockquote&gt; If the store records the existence of empty graphs, then the SPARQL 1.1 Update service, by default,
&nbsp;	 * SHOULD return failure if the specified graph does not exist. If SILENT is present, the result of the operation
&nbsp;	 * will always be success.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * Stores that do not record empty graphs will always return success. &lt;/blockquote&gt;
&nbsp;	 *
&nbsp;	 * Note that in most SPARQL endpoint implementations not recording empty graphs is the default behavior, and setting
&nbsp;	 * this flag to &lt;code&gt;true&lt;/code&gt; will have no effect. Setting this flag will have no effect on any other errors or
&nbsp;	 * other API or SPARQL operations: &lt;strong&gt;only&lt;/strong&gt; the behavior of the {@link #clear(Resource...)} API
&nbsp;	 * operation is modified to respond with a success message when removing a non-existent named graph.
&nbsp;	 *
&nbsp;	 * @param silent the value to set this to.
&nbsp;	 * @see https://www.w3.org/TR/sparql11-update/#clear
&nbsp;	 */
&nbsp;	public void setSilentClear(boolean silent) {
<b class="nc">&nbsp;		this.silentClear = silent;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Configure the connection to execute {@link #clear(Resource...)} operations silently: the remote endpoint will not
&nbsp;	 * respond with an error if the supplied named graph does not exist on the endpoint.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * By default, the SPARQL connection executes the {@link #clear(Resource...)} API operation by converting it to a
&nbsp;	 * SPARQL `CLEAR GRAPH` update operation. This operation has an optional &lt;code&gt;SILENT&lt;/code&gt; modifier, which can be
&nbsp;	 * enabled by setting this flag to &lt;code&gt;true&lt;/code&gt;. The behavior of this modifier is speficied as follows in the
&nbsp;	 * SPARQL 1.1 Recommendation:
&nbsp;	 *
&nbsp;	 * &lt;blockquote&gt; If the store records the existence of empty graphs, then the SPARQL 1.1 Update service, by default,
&nbsp;	 * SHOULD return failure if the specified graph does not exist. If SILENT is present, the result of the operation
&nbsp;	 * will always be success.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * Stores that do not record empty graphs will always return success. &lt;/blockquote&gt;
&nbsp;	 *
&nbsp;	 * Note that in most SPARQL endpoint implementations not recording empty graphs is the default behavior, and setting
&nbsp;	 * this flag to &lt;code&gt;true&lt;/code&gt; will have no effect. Setting this flag will have no effect on any other errors or
&nbsp;	 * other API or SPARQL operations: &lt;strong&gt;only&lt;/strong&gt; the behavior of the {@link #clear(Resource...)} API
&nbsp;	 * operation is modified to respond with a success message when removing a non-existent named graph.
&nbsp;	 *
&nbsp;	 * @param flag the value to set this to.
&nbsp;	 * @see https://www.w3.org/TR/sparql11-update/#clear
&nbsp;	 * @deprecated since 3.6.0 - use {@link #setSilentClear(boolean)} instead.
&nbsp;	 */
&nbsp;	@Deprecated
&nbsp;	public void enableSilentMode(boolean flag) {
<b class="nc">&nbsp;		setSilentClear(flag);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void setParserConfig(ParserConfig parserConfig) {
<b class="nc">&nbsp;		client.setParserConfig(parserConfig);</b>
<b class="nc">&nbsp;		super.setParserConfig(parserConfig);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public final HttpClient getHttpClient() {
<b class="nc">&nbsp;		return client.getHttpClient();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void setHttpClient(HttpClient httpClient) {
<b class="nc">&nbsp;		client.setHttpClient(httpClient);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void close() throws RepositoryException {
&nbsp;		try {
<b class="nc">&nbsp;			super.close();</b>
&nbsp;		} finally {
<b class="nc">&nbsp;			client.close();</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void exportStatements(Resource subj, IRI pred, Value obj, boolean includeInferred, RDFHandler handler,
&nbsp;			Resource... contexts) throws RepositoryException, RDFHandlerException {
&nbsp;		try {
<b class="nc">&nbsp;			GraphQuery query = prepareGraphQuery(SPARQL, EVERYTHING, &quot;&quot;);</b>
<b class="nc">&nbsp;			setBindings(query, subj, pred, obj, contexts);</b>
<b class="nc">&nbsp;			query.evaluate(handler);</b>
<b class="nc">&nbsp;		} catch (MalformedQueryException | QueryEvaluationException e) {</b>
<b class="nc">&nbsp;			throw new RepositoryException(e);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public RepositoryResult&lt;Resource&gt; getContextIDs() throws RepositoryException {
<b class="nc">&nbsp;		TupleQueryResult iter = null;</b>
<b class="nc">&nbsp;		RepositoryResult&lt;Resource&gt; result = null;</b>
&nbsp;
<b class="nc">&nbsp;		boolean allGood = false;</b>
&nbsp;		try {
<b class="nc">&nbsp;			TupleQuery query = prepareTupleQuery(SPARQL, NAMEDGRAPHS, &quot;&quot;);</b>
<b class="nc">&nbsp;			iter = query.evaluate();</b>
<b class="nc">&nbsp;			result = new RepositoryResult&lt;&gt;(new ExceptionConvertingIteration&lt;Resource, RepositoryException&gt;(</b>
<b class="nc">&nbsp;					new ConvertingIteration&lt;BindingSet, Resource, QueryEvaluationException&gt;(iter) {</b>
&nbsp;
&nbsp;						@Override
&nbsp;						protected Resource convert(BindingSet bindings) throws QueryEvaluationException {
<b class="nc">&nbsp;							return (Resource) bindings.getValue(&quot;_&quot;);</b>
&nbsp;						}
<b class="nc">&nbsp;					}) {</b>
&nbsp;
&nbsp;				@Override
&nbsp;				protected RepositoryException convert(Exception e) {
<b class="nc">&nbsp;					return new RepositoryException(e);</b>
&nbsp;				}
&nbsp;			});
<b class="nc">&nbsp;			allGood = true;</b>
<b class="nc">&nbsp;			return result;</b>
<b class="nc">&nbsp;		} catch (MalformedQueryException |</b>
&nbsp;
&nbsp;				QueryEvaluationException e) {
<b class="nc">&nbsp;			throw new RepositoryException(e);</b>
&nbsp;		} finally {
<b class="nc">&nbsp;			if (!allGood) {</b>
&nbsp;				try {
<b class="nc">&nbsp;					if (result != null) {</b>
<b class="nc">&nbsp;						result.close();</b>
&nbsp;					}
&nbsp;				} finally {
<b class="nc">&nbsp;					if (iter != null) {</b>
<b class="nc">&nbsp;						iter.close();</b>
&nbsp;					}
<b class="nc">&nbsp;				}</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public String getNamespace(String prefix) throws RepositoryException {
<b class="nc">&nbsp;		return null;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public RepositoryResult&lt;Namespace&gt; getNamespaces() throws RepositoryException {
<b class="nc">&nbsp;		return new RepositoryResult&lt;&gt;(new EmptyIteration&lt;&gt;());</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public boolean isEmpty() throws RepositoryException {
&nbsp;		try {
&nbsp;			BooleanQuery query;
<b class="nc">&nbsp;			if (isQuadMode()) {</b>
<b class="nc">&nbsp;				query = prepareBooleanQuery(SPARQL, SOMETHING_WITH_GRAPH);</b>
&nbsp;			} else {
<b class="nc">&nbsp;				query = prepareBooleanQuery(SPARQL, SOMETHING);</b>
&nbsp;			}
<b class="nc">&nbsp;			return !query.evaluate();</b>
<b class="nc">&nbsp;		} catch (MalformedQueryException | QueryEvaluationException e) {</b>
<b class="nc">&nbsp;			throw new RepositoryException(e);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public long size(Resource... contexts) throws RepositoryException {
<b class="nc">&nbsp;		try (RepositoryResult&lt;Statement&gt; stmts = getStatements(null, null, null, true, contexts)) {</b>
<b class="nc">&nbsp;			long i = 0;</b>
<b class="nc">&nbsp;			while (stmts.hasNext()) {</b>
<b class="nc">&nbsp;				stmts.next();</b>
<b class="nc">&nbsp;				i++;</b>
&nbsp;			}
<b class="nc">&nbsp;			return i;</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public RepositoryResult&lt;Statement&gt; getStatements(Resource subj, IRI pred, Value obj, boolean includeInferred,
&nbsp;			Resource... contexts) throws RepositoryException {
&nbsp;		try {
<b class="nc">&nbsp;			if (isQuadMode()) {</b>
<b class="nc">&nbsp;				return getStatementsQuadMode(subj, pred, obj, includeInferred, contexts);</b>
<b class="nc">&nbsp;			} else if (subj != null &amp;&amp; pred != null &amp;&amp; obj != null) {</b>
<b class="nc">&nbsp;				return getStatementsSingleTriple(subj, pred, obj, includeInferred, contexts);</b>
&nbsp;			} else {
<b class="nc">&nbsp;				return getStatementGeneral(subj, pred, obj, includeInferred, contexts);</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (MalformedQueryException | QueryEvaluationException e) {</b>
<b class="nc">&nbsp;			throw new RepositoryException(e);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private RepositoryResult&lt;Statement&gt; getStatementsQuadMode(Resource subj, IRI pred, Value obj,
&nbsp;			boolean includeInferred, Resource... contexts)
&nbsp;			throws MalformedQueryException, RepositoryException, QueryEvaluationException {
<b class="nc">&nbsp;		TupleQueryResult qRes = null;</b>
<b class="nc">&nbsp;		RepositoryResult&lt;Statement&gt; result = null;</b>
&nbsp;
<b class="nc">&nbsp;		boolean allGood = false;</b>
&nbsp;		try {
<b class="nc">&nbsp;			TupleQuery tupleQuery = prepareTupleQuery(SPARQL, EVERYTHING_WITH_GRAPH);</b>
<b class="nc">&nbsp;			setBindings(tupleQuery, subj, pred, obj, contexts);</b>
<b class="nc">&nbsp;			tupleQuery.setIncludeInferred(includeInferred);</b>
<b class="nc">&nbsp;			qRes = tupleQuery.evaluate();</b>
<b class="nc">&nbsp;			result = new RepositoryResult&lt;&gt;(new ExceptionConvertingIteration&lt;&gt;(</b>
<b class="nc">&nbsp;					toStatementIteration(qRes, subj, pred, obj)) {</b>
&nbsp;
&nbsp;				@Override
&nbsp;				protected RepositoryException convert(Exception e) {
<b class="nc">&nbsp;					return new RepositoryException(e);</b>
&nbsp;				}
&nbsp;			});
<b class="nc">&nbsp;			allGood = true;</b>
<b class="nc">&nbsp;			return result;</b>
&nbsp;		} finally {
<b class="nc">&nbsp;			if (!allGood) {</b>
&nbsp;				try {
<b class="nc">&nbsp;					if (result != null) {</b>
<b class="nc">&nbsp;						result.close();</b>
&nbsp;					}
&nbsp;				} finally {
<b class="nc">&nbsp;					if (qRes != null) {</b>
<b class="nc">&nbsp;						qRes.close();</b>
&nbsp;					}
<b class="nc">&nbsp;				}</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private RepositoryResult&lt;Statement&gt; getStatementsSingleTriple(Resource subj, IRI pred, Value obj,
&nbsp;			boolean includeInferred, Resource... contexts) throws RepositoryException {
<b class="nc">&nbsp;		if (hasStatement(subj, pred, obj, includeInferred, contexts)) {</b>
<b class="nc">&nbsp;			Statement st = getValueFactory().createStatement(subj, pred, obj);</b>
&nbsp;			CloseableIteration&lt;Statement, RepositoryException&gt; cursor;
<b class="nc">&nbsp;			cursor = new SingletonIteration&lt;&gt;(st);</b>
<b class="nc">&nbsp;			return new RepositoryResult&lt;&gt;(cursor);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			return new RepositoryResult&lt;&gt;(new EmptyIteration&lt;&gt;());</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private RepositoryResult&lt;Statement&gt; getStatementGeneral(Resource subj, IRI pred, Value obj, boolean includeInferred,
&nbsp;			Resource... contexts) throws RepositoryException, MalformedQueryException, QueryEvaluationException {
<b class="nc">&nbsp;		GraphQueryResult gRes = null;</b>
<b class="nc">&nbsp;		RepositoryResult&lt;Statement&gt; result = null;</b>
&nbsp;
<b class="nc">&nbsp;		boolean allGood = false;</b>
&nbsp;		try {
<b class="nc">&nbsp;			GraphQuery query = prepareGraphQuery(SPARQL, EVERYTHING, &quot;&quot;);</b>
<b class="nc">&nbsp;			query.setIncludeInferred(includeInferred);</b>
<b class="nc">&nbsp;			setBindings(query, subj, pred, obj, contexts);</b>
<b class="nc">&nbsp;			gRes = query.evaluate();</b>
<b class="nc">&nbsp;			result = new RepositoryResult&lt;&gt;(</b>
<b class="nc">&nbsp;					new ExceptionConvertingIteration&lt;&gt;(gRes) {</b>
&nbsp;						@Override
&nbsp;						protected RepositoryException convert(Exception e) {
<b class="nc">&nbsp;							return new RepositoryException(e);</b>
&nbsp;						}
&nbsp;					});
<b class="nc">&nbsp;			allGood = true;</b>
<b class="nc">&nbsp;			return result;</b>
&nbsp;		} finally {
<b class="nc">&nbsp;			if (!allGood) {</b>
&nbsp;				try {
<b class="nc">&nbsp;					if (result != null) {</b>
<b class="nc">&nbsp;						result.close();</b>
&nbsp;					}
&nbsp;				} finally {
<b class="nc">&nbsp;					if (gRes != null) {</b>
<b class="nc">&nbsp;						gRes.close();</b>
&nbsp;					}
<b class="nc">&nbsp;				}</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public boolean hasStatement(Resource subj, IRI pred, Value obj, boolean includeInferred, Resource... contexts)
&nbsp;			throws RepositoryException {
&nbsp;		try {
<b class="nc">&nbsp;			BooleanQuery query = prepareBooleanQuery(SPARQL, SOMETHING, &quot;&quot;);</b>
<b class="nc">&nbsp;			setBindings(query, subj, pred, obj, contexts);</b>
<b class="nc">&nbsp;			return query.evaluate();</b>
<b class="nc">&nbsp;		} catch (MalformedQueryException | QueryEvaluationException e) {</b>
<b class="nc">&nbsp;			throw new RepositoryException(e);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public SPARQLRepository getRepository() {
<b class="nc">&nbsp;		return (SPARQLRepository) super.getRepository();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Query prepareQuery(QueryLanguage ql, String query, String base)
&nbsp;			throws RepositoryException, MalformedQueryException {
<b class="nc">&nbsp;		if (SPARQL.equals(ql)) {</b>
<b class="nc">&nbsp;			String strippedQuery = QueryParserUtil.removeSPARQLQueryProlog(query).toUpperCase();</b>
<b class="nc">&nbsp;			if (strippedQuery.startsWith(&quot;SELECT&quot;)) {</b>
<b class="nc">&nbsp;				return prepareTupleQuery(ql, query, base);</b>
<b class="nc">&nbsp;			} else if (strippedQuery.startsWith(&quot;ASK&quot;)) {</b>
<b class="nc">&nbsp;				return prepareBooleanQuery(ql, query, base);</b>
&nbsp;			} else {
<b class="nc">&nbsp;				return prepareGraphQuery(ql, query, base);</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		throw new UnsupportedOperationException(&quot;Unsupported query language &quot; + ql);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public BooleanQuery prepareBooleanQuery(QueryLanguage ql, String query, String base)
&nbsp;			throws RepositoryException, MalformedQueryException {
<b class="nc">&nbsp;		if (SPARQL.equals(ql)) {</b>
<b class="nc">&nbsp;			return new SPARQLBooleanQuery(client, base, query);</b>
&nbsp;		}
<b class="nc">&nbsp;		throw new UnsupportedQueryLanguageException(&quot;Unsupported query language &quot; + ql);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public GraphQuery prepareGraphQuery(QueryLanguage ql, String query, String base)
&nbsp;			throws RepositoryException, MalformedQueryException {
<b class="nc">&nbsp;		if (SPARQL.equals(ql)) {</b>
<b class="nc">&nbsp;			return new SPARQLGraphQuery(client, base, query);</b>
&nbsp;		}
<b class="nc">&nbsp;		throw new UnsupportedQueryLanguageException(&quot;Unsupported query language &quot; + ql);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public TupleQuery prepareTupleQuery(QueryLanguage ql, String query, String base)
&nbsp;			throws RepositoryException, MalformedQueryException {
<b class="nc">&nbsp;		if (SPARQL.equals(ql)) {</b>
<b class="nc">&nbsp;			return new SPARQLTupleQuery(client, base, query);</b>
&nbsp;		}
<b class="nc">&nbsp;		throw new UnsupportedQueryLanguageException(&quot;Unsupported query language &quot; + ql);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void prepare() throws RepositoryException {
<b class="nc">&nbsp;		throw new UnsupportedOperationException(&quot;SPARQL protocol has no support for 2-phase commit&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void commit() throws RepositoryException {
<b class="nc">&nbsp;		synchronized (transactionLock) {</b>
<b class="nc">&nbsp;			if (isActive()) {</b>
<b class="nc">&nbsp;				synchronized (transactionLock) {</b>
<b class="nc">&nbsp;					flushPendingAdds();</b>
<b class="nc">&nbsp;					flushPendingRemoves();</b>
&nbsp;					// treat commit as a no-op if transaction string is empty
<b class="nc">&nbsp;					if (sparqlTransaction.length() &gt; 0) {</b>
<b class="nc">&nbsp;						SPARQLUpdate transaction = new SPARQLUpdate(client, null, sparqlTransaction.toString());</b>
&nbsp;						try {
<b class="nc">&nbsp;							transaction.execute();</b>
<b class="nc">&nbsp;						} catch (UpdateExecutionException e) {</b>
<b class="nc">&nbsp;							throw new RepositoryException(&quot;error executing transaction&quot;, e);</b>
<b class="nc">&nbsp;						}</b>
&nbsp;					}
&nbsp;
<b class="nc">&nbsp;					sparqlTransaction = null;</b>
<b class="nc">&nbsp;				}</b>
&nbsp;			} else {
<b class="nc">&nbsp;				throw new RepositoryException(&quot;no transaction active.&quot;);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void rollback() throws RepositoryException {
<b class="nc">&nbsp;		synchronized (transactionLock) {</b>
<b class="nc">&nbsp;			if (isActive()) {</b>
<b class="nc">&nbsp;				synchronized (transactionLock) {</b>
<b class="nc">&nbsp;					sparqlTransaction = null;</b>
<b class="nc">&nbsp;					pendingAdds = getModelFactory().createEmptyModel();</b>
<b class="nc">&nbsp;					pendingRemoves = getModelFactory().createEmptyModel();</b>
<b class="nc">&nbsp;				}</b>
&nbsp;			} else {
<b class="nc">&nbsp;				throw new RepositoryException(&quot;no transaction active.&quot;);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void begin() throws RepositoryException {
<b class="nc">&nbsp;		synchronized (transactionLock) {</b>
<b class="nc">&nbsp;			if (!isActive()) {</b>
<b class="nc">&nbsp;				synchronized (transactionLock) {</b>
<b class="nc">&nbsp;					sparqlTransaction = new StringBuilder();</b>
<b class="nc">&nbsp;					this.pendingAdds = getModelFactory().createEmptyModel();</b>
<b class="nc">&nbsp;					this.pendingRemoves = getModelFactory().createEmptyModel();</b>
<b class="nc">&nbsp;				}</b>
&nbsp;			} else {
<b class="nc">&nbsp;				throw new RepositoryException(&quot;active transaction already exists&quot;);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void add(File file, String baseURI, RDFFormat dataFormat, Resource... contexts)
&nbsp;			throws IOException, RDFParseException, RepositoryException {
<b class="nc">&nbsp;		Objects.requireNonNull(contexts,</b>
&nbsp;				&quot;contexts argument may not be null; either the value should be cast to Resource or an empty array should be supplied&quot;);
&nbsp;
&nbsp;		// to preserve bnode identity, we need to make sure all statements are
&nbsp;		// processed in a single INSERT DATA command
<b class="nc">&nbsp;		StatementCollector collector = new StatementCollector();</b>
&nbsp;
<b class="nc">&nbsp;		boolean localTransaction = startLocalTransaction();</b>
&nbsp;
&nbsp;		try {
<b class="nc">&nbsp;			RDFLoader loader = new RDFLoader(getParserConfig(), getValueFactory());</b>
<b class="nc">&nbsp;			loader.load(file, baseURI, dataFormat, collector);</b>
<b class="nc">&nbsp;			add(collector.getStatements(), contexts);</b>
<b class="nc">&nbsp;			conditionalCommit(localTransaction);</b>
<b class="nc">&nbsp;		} catch (RDFHandlerException e) {</b>
<b class="nc">&nbsp;			conditionalRollback(localTransaction);</b>
&nbsp;
&nbsp;			// RDFInserter only throws wrapped RepositoryExceptions
<b class="nc">&nbsp;			throw (RepositoryException) e.getCause();</b>
<b class="nc">&nbsp;		} catch (RDFParseException e) {</b>
<b class="nc">&nbsp;			conditionalRollback(localTransaction);</b>
<b class="nc">&nbsp;			throw e;</b>
<b class="nc">&nbsp;		} catch (IOException | RuntimeException e) {</b>
<b class="nc">&nbsp;			conditionalRollback(localTransaction);</b>
<b class="nc">&nbsp;			throw e;</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void add(URL url, String baseURI, RDFFormat dataFormat, Resource... contexts)
&nbsp;			throws IOException, RDFParseException, RepositoryException {
<b class="nc">&nbsp;		Objects.requireNonNull(contexts,</b>
&nbsp;				&quot;contexts argument may not be null; either the value should be cast to Resource or an empty array should be supplied&quot;);
&nbsp;
&nbsp;		// to preserve bnode identity, we need to make sure all statements are
&nbsp;		// processed in a single INSERT DATA command
<b class="nc">&nbsp;		StatementCollector collector = new StatementCollector();</b>
<b class="nc">&nbsp;		boolean localTransaction = startLocalTransaction();</b>
&nbsp;
&nbsp;		try {
<b class="nc">&nbsp;			RDFLoader loader = new RDFLoader(getParserConfig(), getValueFactory());</b>
<b class="nc">&nbsp;			loader.load(url, baseURI, dataFormat, collector);</b>
<b class="nc">&nbsp;			add(collector.getStatements(), contexts);</b>
<b class="nc">&nbsp;			conditionalCommit(localTransaction);</b>
<b class="nc">&nbsp;		} catch (RDFHandlerException e) {</b>
<b class="nc">&nbsp;			conditionalRollback(localTransaction);</b>
&nbsp;
&nbsp;			// RDFInserter only throws wrapped RepositoryExceptions
<b class="nc">&nbsp;			throw (RepositoryException) e.getCause();</b>
<b class="nc">&nbsp;		} catch (RDFParseException e) {</b>
<b class="nc">&nbsp;			conditionalRollback(localTransaction);</b>
<b class="nc">&nbsp;			throw e;</b>
<b class="nc">&nbsp;		} catch (IOException | RuntimeException e) {</b>
<b class="nc">&nbsp;			conditionalRollback(localTransaction);</b>
<b class="nc">&nbsp;			throw e;</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void add(InputStream in, String baseURI, RDFFormat dataFormat, Resource... contexts)
&nbsp;			throws IOException, RDFParseException, RepositoryException {
<b class="nc">&nbsp;		Objects.requireNonNull(contexts,</b>
&nbsp;				&quot;contexts argument may not be null; either the value should be cast to Resource or an empty array should be supplied&quot;);
&nbsp;
&nbsp;		// to preserve bnode identity, we need to make sure all statements are
&nbsp;		// processed in a single INSERT DATA command
<b class="nc">&nbsp;		StatementCollector collector = new StatementCollector();</b>
&nbsp;
<b class="nc">&nbsp;		boolean localTransaction = startLocalTransaction();</b>
&nbsp;
&nbsp;		try {
<b class="nc">&nbsp;			RDFLoader loader = new RDFLoader(getParserConfig(), getValueFactory());</b>
<b class="nc">&nbsp;			loader.load(in, baseURI, dataFormat, collector);</b>
<b class="nc">&nbsp;			add(collector.getStatements(), contexts);</b>
<b class="nc">&nbsp;			conditionalCommit(localTransaction);</b>
<b class="nc">&nbsp;		} catch (RDFHandlerException e) {</b>
<b class="nc">&nbsp;			conditionalRollback(localTransaction);</b>
&nbsp;
&nbsp;			// RDFInserter only throws wrapped RepositoryExceptions
<b class="nc">&nbsp;			throw (RepositoryException) e.getCause();</b>
<b class="nc">&nbsp;		} catch (RDFParseException e) {</b>
<b class="nc">&nbsp;			conditionalRollback(localTransaction);</b>
<b class="nc">&nbsp;			throw e;</b>
<b class="nc">&nbsp;		} catch (IOException | RuntimeException e) {</b>
<b class="nc">&nbsp;			conditionalRollback(localTransaction);</b>
<b class="nc">&nbsp;			throw e;</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void add(Reader reader, String baseURI, RDFFormat dataFormat, Resource... contexts)
&nbsp;			throws IOException, RDFParseException, RepositoryException {
<b class="nc">&nbsp;		Objects.requireNonNull(contexts,</b>
&nbsp;				&quot;contexts argument may not be null; either the value should be cast to Resource or an empty array should be supplied&quot;);
&nbsp;
&nbsp;		// to preserve bnode identity, we need to make sure all statements are
&nbsp;		// processed in a single INSERT DATA command
<b class="nc">&nbsp;		StatementCollector collector = new StatementCollector();</b>
&nbsp;
<b class="nc">&nbsp;		boolean localTransaction = startLocalTransaction();</b>
&nbsp;
&nbsp;		try {
<b class="nc">&nbsp;			RDFLoader loader = new RDFLoader(getParserConfig(), getValueFactory());</b>
<b class="nc">&nbsp;			loader.load(reader, baseURI, dataFormat, collector);</b>
&nbsp;
<b class="nc">&nbsp;			add(collector.getStatements(), contexts);</b>
<b class="nc">&nbsp;			conditionalCommit(localTransaction);</b>
<b class="nc">&nbsp;		} catch (RDFHandlerException e) {</b>
<b class="nc">&nbsp;			conditionalRollback(localTransaction);</b>
&nbsp;
&nbsp;			// RDFInserter only throws wrapped RepositoryExceptions
<b class="nc">&nbsp;			throw (RepositoryException) e.getCause();</b>
<b class="nc">&nbsp;		} catch (RDFParseException e) {</b>
<b class="nc">&nbsp;			conditionalRollback(localTransaction);</b>
<b class="nc">&nbsp;			throw e;</b>
<b class="nc">&nbsp;		} catch (IOException | RuntimeException e) {</b>
<b class="nc">&nbsp;			conditionalRollback(localTransaction);</b>
<b class="nc">&nbsp;			throw e;</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void add(Statement st, Resource... contexts) throws RepositoryException {
<b class="nc">&nbsp;		boolean localTransaction = startLocalTransaction();</b>
<b class="nc">&nbsp;		addWithoutCommit(st, contexts);</b>
&nbsp;		try {
<b class="nc">&nbsp;			conditionalCommit(localTransaction);</b>
<b class="nc">&nbsp;		} catch (RepositoryException e) {</b>
<b class="nc">&nbsp;			conditionalRollback(localTransaction);</b>
<b class="nc">&nbsp;			throw e;</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void add(Iterable&lt;? extends Statement&gt; statements, Resource... contexts) throws RepositoryException {
<b class="nc">&nbsp;		boolean localTransaction = startLocalTransaction();</b>
<b class="nc">&nbsp;		for (Statement st : statements) {</b>
<b class="nc">&nbsp;			addWithoutCommit(st, contexts);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;		try {
<b class="nc">&nbsp;			conditionalCommit(localTransaction);</b>
<b class="nc">&nbsp;		} catch (RepositoryException e) {</b>
<b class="nc">&nbsp;			conditionalRollback(localTransaction);</b>
<b class="nc">&nbsp;			throw e;</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void clear(Resource... contexts) throws RepositoryException {
<b class="nc">&nbsp;		Objects.requireNonNull(contexts,</b>
&nbsp;				&quot;contexts argument may not be null; either the value should be cast to Resource or an empty array should be supplied&quot;);
<b class="nc">&nbsp;		boolean localTransaction = startLocalTransaction();</b>
&nbsp;
<b class="nc">&nbsp;		String clearMode = &quot;CLEAR&quot;;</b>
<b class="nc">&nbsp;		if (this.isSilentClear()) {</b>
<b class="nc">&nbsp;			clearMode = &quot;CLEAR SILENT&quot;;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (contexts.length == 0) {</b>
<b class="nc">&nbsp;			sparqlTransaction.append(clearMode + &quot; ALL &quot;);</b>
<b class="nc">&nbsp;			sparqlTransaction.append(&quot;; &quot;);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			for (Resource context : contexts) {</b>
<b class="nc">&nbsp;				if (context == null) {</b>
<b class="nc">&nbsp;					sparqlTransaction.append(clearMode + &quot; DEFAULT &quot;);</b>
<b class="nc">&nbsp;					sparqlTransaction.append(&quot;; &quot;);</b>
<b class="nc">&nbsp;				} else if (context instanceof IRI) {</b>
<b class="nc">&nbsp;					sparqlTransaction.append(clearMode + &quot; GRAPH &lt;&quot; + context.stringValue() + &quot;&gt; &quot;);</b>
<b class="nc">&nbsp;					sparqlTransaction.append(&quot;; &quot;);</b>
&nbsp;				} else {
<b class="nc">&nbsp;					throw new RepositoryException(&quot;SPARQL does not support named graphs identified by blank nodes.&quot;);</b>
&nbsp;				}
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		try {
<b class="nc">&nbsp;			conditionalCommit(localTransaction);</b>
<b class="nc">&nbsp;		} catch (RepositoryException e) {</b>
<b class="nc">&nbsp;			conditionalRollback(localTransaction);</b>
<b class="nc">&nbsp;			throw e;</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void clearNamespaces() throws RepositoryException {
&nbsp;		// silently ignore
&nbsp;
&nbsp;		// throw new UnsupportedOperationException();
<b class="nc">&nbsp;	}</b>
&nbsp;
&nbsp;	@Override
&nbsp;	public void remove(Statement st, Resource... contexts) throws RepositoryException {
<b class="nc">&nbsp;		boolean localTransaction = startLocalTransaction();</b>
<b class="nc">&nbsp;		removeWithoutCommit(st, contexts);</b>
&nbsp;		try {
<b class="nc">&nbsp;			conditionalCommit(localTransaction);</b>
<b class="nc">&nbsp;		} catch (RepositoryException e) {</b>
<b class="nc">&nbsp;			conditionalRollback(localTransaction);</b>
<b class="nc">&nbsp;			throw e;</b>
<b class="nc">&nbsp;		}</b>
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void remove(Iterable&lt;? extends Statement&gt; statements, Resource... contexts) throws RepositoryException {
<b class="nc">&nbsp;		boolean localTransaction = startLocalTransaction();</b>
<b class="nc">&nbsp;		for (Statement st : statements) {</b>
<b class="nc">&nbsp;			removeWithoutCommit(st, contexts);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;
&nbsp;		try {
<b class="nc">&nbsp;			conditionalCommit(localTransaction);</b>
<b class="nc">&nbsp;		} catch (RepositoryException e) {</b>
<b class="nc">&nbsp;			conditionalRollback(localTransaction);</b>
<b class="nc">&nbsp;			throw e;</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void removeNamespace(String prefix) throws RepositoryException {
&nbsp;		// no-op, ignore silently
&nbsp;		// throw new UnsupportedOperationException();
<b class="nc">&nbsp;	}</b>
&nbsp;
&nbsp;	@Override
&nbsp;	public void setNamespace(String prefix, String name) throws RepositoryException {
&nbsp;		// no-op, ignore silently
&nbsp;		// throw new UnsupportedOperationException();
<b class="nc">&nbsp;	}</b>
&nbsp;
&nbsp;	@Override
&nbsp;	public Update prepareUpdate(QueryLanguage ql, String update, String baseURI)
&nbsp;			throws RepositoryException, MalformedQueryException {
<b class="nc">&nbsp;		if (SPARQL.equals(ql)) {</b>
<b class="nc">&nbsp;			return new SPARQLUpdate(client, baseURI, update);</b>
&nbsp;		}
<b class="nc">&nbsp;		throw new UnsupportedQueryLanguageException(&quot;Unsupported query language &quot; + ql);</b>
&nbsp;	}
&nbsp;
&nbsp;	/* protected/private methods */
&nbsp;
&nbsp;	private void setBindings(Query query, Resource subj, IRI pred, Value obj, Resource... contexts)
&nbsp;			throws RepositoryException {
<b class="nc">&nbsp;		if (subj != null) {</b>
<b class="nc">&nbsp;			query.setBinding(&quot;s&quot;, subj);</b>
&nbsp;		}
<b class="nc">&nbsp;		if (pred != null) {</b>
<b class="nc">&nbsp;			query.setBinding(&quot;p&quot;, pred);</b>
&nbsp;		}
<b class="nc">&nbsp;		if (obj != null) {</b>
<b class="nc">&nbsp;			query.setBinding(&quot;o&quot;, obj);</b>
&nbsp;		}
<b class="nc">&nbsp;		if (contexts != null &amp;&amp; contexts.length &gt; 0) {</b>
<b class="nc">&nbsp;			SimpleDataset dataset = new SimpleDataset();</b>
<b class="nc">&nbsp;			for (Resource ctx : contexts) {</b>
<b class="nc">&nbsp;				if (ctx == null || ctx instanceof IRI) {</b>
<b class="nc">&nbsp;					dataset.addDefaultGraph((IRI) ctx);</b>
&nbsp;				} else {
<b class="nc">&nbsp;					throw new RepositoryException(&quot;Contexts must be URIs&quot;);</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			query.setDataset(dataset);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private String createInsertDataCommand(Iterable&lt;? extends Statement&gt; statements, Resource... contexts) {
<b class="nc">&nbsp;		StringBuilder qb = new StringBuilder();</b>
<b class="nc">&nbsp;		qb.append(&quot;INSERT DATA \n&quot;);</b>
<b class="nc">&nbsp;		qb.append(&quot;{ \n&quot;);</b>
<b class="nc">&nbsp;		if (contexts.length &gt; 0) {</b>
<b class="nc">&nbsp;			for (Resource context : contexts) {</b>
<b class="nc">&nbsp;				if (context != null) {</b>
<b class="nc">&nbsp;					String namedGraph = context.stringValue();</b>
<b class="nc">&nbsp;					if (context instanceof BNode) {</b>
&nbsp;						// SPARQL does not allow blank nodes as named graph
&nbsp;						// identifiers, so we need to skolemize
&nbsp;						// the blank node id.
<b class="nc">&nbsp;						namedGraph = &quot;urn:nodeid:&quot; + context.stringValue();</b>
&nbsp;					}
<b class="nc">&nbsp;					qb.append(&quot;    GRAPH &lt;&quot; + namedGraph + &quot;&gt; { \n&quot;);</b>
&nbsp;				}
<b class="nc">&nbsp;				createDataBody(qb, statements, true);</b>
<b class="nc">&nbsp;				if (context != null) {</b>
<b class="nc">&nbsp;					qb.append(&quot; } \n&quot;);</b>
&nbsp;				}
&nbsp;			}
&nbsp;		} else {
<b class="nc">&nbsp;			createDataBody(qb, statements, false);</b>
&nbsp;		}
<b class="nc">&nbsp;		qb.append(&quot;}&quot;);</b>
&nbsp;
<b class="nc">&nbsp;		return qb.toString();</b>
&nbsp;	}
&nbsp;
&nbsp;	private String createDeleteDataCommand(Iterable&lt;? extends Statement&gt; statements, Resource... contexts) {
<b class="nc">&nbsp;		StringBuilder qb = new StringBuilder();</b>
<b class="nc">&nbsp;		qb.append(&quot;DELETE DATA \n&quot;);</b>
<b class="nc">&nbsp;		qb.append(&quot;{ \n&quot;);</b>
<b class="nc">&nbsp;		if (contexts.length &gt; 0) {</b>
<b class="nc">&nbsp;			for (Resource context : contexts) {</b>
<b class="nc">&nbsp;				if (context != null) {</b>
<b class="nc">&nbsp;					String namedGraph = context.stringValue();</b>
<b class="nc">&nbsp;					if (context instanceof BNode) {</b>
&nbsp;						// SPARQL does not allow blank nodes as named graph
&nbsp;						// identifiers, so we need to skolemize
&nbsp;						// the blank node id.
<b class="nc">&nbsp;						namedGraph = &quot;urn:nodeid:&quot; + context.stringValue();</b>
&nbsp;					}
<b class="nc">&nbsp;					qb.append(&quot;    GRAPH &lt;&quot; + namedGraph + &quot;&gt; { \n&quot;);</b>
&nbsp;				}
<b class="nc">&nbsp;				createDataBody(qb, statements, true);</b>
<b class="nc">&nbsp;				if (context != null) {</b>
<b class="nc">&nbsp;					qb.append(&quot; } \n&quot;);</b>
&nbsp;				}
&nbsp;			}
&nbsp;		} else {
<b class="nc">&nbsp;			createDataBody(qb, statements, false);</b>
&nbsp;		}
<b class="nc">&nbsp;		qb.append(&quot;}&quot;);</b>
&nbsp;
<b class="nc">&nbsp;		return qb.toString();</b>
&nbsp;	}
&nbsp;
&nbsp;	private void createDataBody(StringBuilder qb, Iterable&lt;? extends Statement&gt; statements, boolean ignoreContext) {
<b class="nc">&nbsp;		for (Statement st : statements) {</b>
<b class="nc">&nbsp;			final Resource context = st.getContext();</b>
<b class="nc">&nbsp;			if (!ignoreContext) {</b>
<b class="nc">&nbsp;				if (context != null) {</b>
<b class="nc">&nbsp;					String namedGraph = context.stringValue();</b>
<b class="nc">&nbsp;					if (context instanceof BNode) {</b>
&nbsp;						// SPARQL does not allow blank nodes as named graph
&nbsp;						// identifiers, so we need to skolemize
&nbsp;						// the blank node id.
<b class="nc">&nbsp;						namedGraph = &quot;urn:nodeid:&quot; + context.stringValue();</b>
&nbsp;					}
<b class="nc">&nbsp;					qb.append(&quot;    GRAPH &lt;&quot; + namedGraph + &quot;&gt; { \n&quot;);</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (st.getSubject() instanceof BNode) {</b>
<b class="nc">&nbsp;				qb.append(&quot;_:&quot; + st.getSubject().stringValue() + &quot; &quot;);</b>
&nbsp;			} else {
<b class="nc">&nbsp;				qb.append(&quot;&lt;&quot; + st.getSubject().stringValue() + &quot;&gt; &quot;);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			qb.append(&quot;&lt;&quot; + st.getPredicate().stringValue() + &quot;&gt; &quot;);</b>
&nbsp;
<b class="nc">&nbsp;			if (st.getObject() instanceof Literal) {</b>
<b class="nc">&nbsp;				Literal lit = (Literal) st.getObject();</b>
<b class="nc">&nbsp;				qb.append(&quot;\&quot;&quot;);</b>
<b class="nc">&nbsp;				qb.append(SPARQLQueries.escape(lit.getLabel()));</b>
<b class="nc">&nbsp;				qb.append(&quot;\&quot;&quot;);</b>
&nbsp;
<b class="nc">&nbsp;				if (Literals.isLanguageLiteral(lit)) {</b>
<b class="nc">&nbsp;					qb.append(&quot;@&quot;);</b>
<b class="nc">&nbsp;					qb.append(lit.getLanguage().get());</b>
&nbsp;				} else {
<b class="nc">&nbsp;					qb.append(&quot;^^&lt;&quot; + lit.getDatatype().stringValue() + &quot;&gt;&quot;);</b>
&nbsp;				}
<b class="nc">&nbsp;				qb.append(&quot; &quot;);</b>
<b class="nc">&nbsp;			} else if (st.getObject() instanceof BNode) {</b>
<b class="nc">&nbsp;				qb.append(&quot;_:&quot; + st.getObject().stringValue() + &quot; &quot;);</b>
&nbsp;			} else {
<b class="nc">&nbsp;				qb.append(&quot;&lt;&quot; + st.getObject().stringValue() + &quot;&gt; &quot;);</b>
&nbsp;			}
<b class="nc">&nbsp;			qb.append(&quot;. \n&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			if (!ignoreContext &amp;&amp; context != null) {</b>
<b class="nc">&nbsp;				qb.append(&quot;    }\n&quot;);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public boolean isActive() throws UnknownTransactionStateException, RepositoryException {
<b class="nc">&nbsp;		synchronized (transactionLock) {</b>
<b class="nc">&nbsp;			return sparqlTransaction != null;</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected void addWithoutCommit(Statement st, Resource... contexts)
&nbsp;			throws RepositoryException {
<b class="nc">&nbsp;		flushPendingRemoves();</b>
<b class="nc">&nbsp;		if (pendingAdds.size() &gt;= maxPendingSize) {</b>
<b class="nc">&nbsp;			flushPendingAdds();</b>
&nbsp;		}
<b class="nc">&nbsp;		if (contexts.length == 0) {</b>
<b class="nc">&nbsp;			pendingAdds.add(st);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			pendingAdds.add(st.getSubject(), st.getPredicate(), st.getObject(), contexts);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected void addWithoutCommit(Resource subject, IRI predicate, Value object, Resource... contexts)
&nbsp;			throws RepositoryException {
<b class="nc">&nbsp;		flushPendingRemoves();</b>
<b class="nc">&nbsp;		if (pendingAdds.size() &gt;= maxPendingSize) {</b>
<b class="nc">&nbsp;			flushPendingAdds();</b>
&nbsp;		}
<b class="nc">&nbsp;		pendingAdds.add(subject, predicate, object, contexts);</b>
&nbsp;	}
&nbsp;
&nbsp;	private void flushPendingRemoves() {
<b class="nc">&nbsp;		if (!pendingRemoves.isEmpty()) {</b>
<b class="nc">&nbsp;			for (Resource context : pendingRemoves.contexts()) {</b>
<b class="nc">&nbsp;				String sparqlCommand = createDeleteDataCommand(pendingRemoves.getStatements(null, null, null, context),</b>
&nbsp;						context);
<b class="nc">&nbsp;				sparqlTransaction.append(sparqlCommand);</b>
<b class="nc">&nbsp;				sparqlTransaction.append(&quot;; &quot;);</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			pendingRemoves = getModelFactory().createEmptyModel();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private void flushPendingAdds() {
<b class="nc">&nbsp;		if (!pendingAdds.isEmpty()) {</b>
<b class="nc">&nbsp;			for (Resource context : pendingAdds.contexts()) {</b>
<b class="nc">&nbsp;				String sparqlCommand = createInsertDataCommand(pendingAdds.getStatements(null, null, null, context),</b>
&nbsp;						context);
<b class="nc">&nbsp;				sparqlTransaction.append(sparqlCommand);</b>
<b class="nc">&nbsp;				sparqlTransaction.append(&quot;; &quot;);</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			pendingAdds = getModelFactory().createEmptyModel();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected void removeWithoutCommit(Statement st, Resource... contexts) throws RepositoryException {
<b class="nc">&nbsp;		flushPendingAdds();</b>
<b class="nc">&nbsp;		if (pendingRemoves.size() &gt;= maxPendingSize) {</b>
<b class="nc">&nbsp;			flushPendingRemoves();</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (contexts.length == 0) {</b>
<b class="nc">&nbsp;			pendingRemoves.add(st);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			pendingRemoves.add(st.getSubject(), st.getPredicate(), st.getObject(), contexts);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected void removeWithoutCommit(Resource subject, IRI predicate, Value object, Resource... contexts)
&nbsp;			throws RepositoryException {
<b class="nc">&nbsp;		flushPendingAdds();</b>
<b class="nc">&nbsp;		if (pendingRemoves.size() &gt;= maxPendingSize) {</b>
<b class="nc">&nbsp;			flushPendingRemoves();</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (subject != null &amp;&amp; predicate != null &amp;&amp; object != null) {</b>
<b class="nc">&nbsp;			pendingRemoves.add(subject, predicate, object, contexts);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			flushPendingRemoves();</b>
<b class="nc">&nbsp;			String sparqlCommand = createDeletePatternCommand(subject, predicate, object, contexts);</b>
<b class="nc">&nbsp;			sparqlTransaction.append(sparqlCommand);</b>
<b class="nc">&nbsp;			sparqlTransaction.append(&quot;; &quot;);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private String createDeletePatternCommand(Resource subject, IRI predicate, Value object, Resource[] contexts) {
<b class="nc">&nbsp;		StringBuilder qb = new StringBuilder();</b>
<b class="nc">&nbsp;		qb.append(&quot;DELETE WHERE \n&quot;);</b>
<b class="nc">&nbsp;		qb.append(&quot;{ \n&quot;);</b>
<b class="nc">&nbsp;		if (contexts.length &gt; 0) {</b>
<b class="nc">&nbsp;			for (Resource context : contexts) {</b>
<b class="nc">&nbsp;				if (context != null) {</b>
<b class="nc">&nbsp;					String namedGraph = context.stringValue();</b>
<b class="nc">&nbsp;					if (context instanceof BNode) {</b>
&nbsp;						// SPARQL does not allow blank nodes as named graph
&nbsp;						// identifiers, so we need to skolemize
&nbsp;						// the blank node id.
<b class="nc">&nbsp;						namedGraph = &quot;urn:nodeid:&quot; + context.stringValue();</b>
&nbsp;					}
<b class="nc">&nbsp;					qb.append(&quot;    GRAPH &lt;&quot; + namedGraph + &quot;&gt; { \n&quot;);</b>
&nbsp;				}
<b class="nc">&nbsp;				createBGP(qb, subject, predicate, object);</b>
<b class="nc">&nbsp;				if (context != null &amp;&amp; context instanceof IRI) {</b>
<b class="nc">&nbsp;					qb.append(&quot; } \n&quot;);</b>
&nbsp;				}
&nbsp;			}
&nbsp;		} else {
<b class="nc">&nbsp;			createBGP(qb, subject, predicate, object);</b>
&nbsp;		}
<b class="nc">&nbsp;		qb.append(&quot;}&quot;);</b>
&nbsp;
<b class="nc">&nbsp;		return qb.toString();</b>
&nbsp;	}
&nbsp;
&nbsp;	private void createBGP(StringBuilder qb, Resource subject, IRI predicate, Value object) {
<b class="nc">&nbsp;		if (subject != null) {</b>
<b class="nc">&nbsp;			if (subject instanceof BNode) {</b>
<b class="nc">&nbsp;				qb.append(&quot;_:&quot; + subject.stringValue() + &quot; &quot;);</b>
&nbsp;			} else {
<b class="nc">&nbsp;				qb.append(&quot;&lt;&quot; + subject.stringValue() + &quot;&gt; &quot;);</b>
&nbsp;			}
&nbsp;		} else {
<b class="nc">&nbsp;			qb.append(&quot;?subj&quot;);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (predicate != null) {</b>
<b class="nc">&nbsp;			qb.append(&quot;&lt;&quot; + predicate.stringValue() + &quot;&gt; &quot;);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			qb.append(&quot;?pred&quot;);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (object != null) {</b>
<b class="nc">&nbsp;			if (object instanceof Literal) {</b>
<b class="nc">&nbsp;				Literal lit = (Literal) object;</b>
<b class="nc">&nbsp;				qb.append(&quot;\&quot;&quot;);</b>
<b class="nc">&nbsp;				qb.append(SPARQLQueries.escape(lit.getLabel()));</b>
<b class="nc">&nbsp;				qb.append(&quot;\&quot;&quot;);</b>
&nbsp;
<b class="nc">&nbsp;				if (lit.getLanguage().isPresent()) {</b>
<b class="nc">&nbsp;					qb.append(&quot;@&quot;);</b>
<b class="nc">&nbsp;					qb.append(lit.getLanguage().get());</b>
&nbsp;				} else {
<b class="nc">&nbsp;					qb.append(&quot;^^&lt;&quot; + lit.getDatatype().stringValue() + &quot;&gt;&quot;);</b>
&nbsp;				}
<b class="nc">&nbsp;				qb.append(&quot; &quot;);</b>
<b class="nc">&nbsp;			} else if (object instanceof BNode) {</b>
<b class="nc">&nbsp;				qb.append(&quot;_:&quot; + object.stringValue() + &quot; &quot;);</b>
&nbsp;			} else {
<b class="nc">&nbsp;				qb.append(&quot;&lt;&quot; + object.stringValue() + &quot;&gt; &quot;);</b>
&nbsp;			}
&nbsp;		} else {
<b class="nc">&nbsp;			qb.append(&quot;?obj&quot;);</b>
&nbsp;		}
<b class="nc">&nbsp;		qb.append(&quot;. \n&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Shall graph information also be retrieved, e.g. for
&nbsp;	 * {@link #getStatements(Resource, IRI, Value, boolean, Resource...)}
&nbsp;	 *
&nbsp;	 * @return true if in quad mode
&nbsp;	 */
&nbsp;	protected boolean isQuadMode() {
<b class="nc">&nbsp;		return quadMode;</b>
&nbsp;	}
&nbsp;
&nbsp;	protected boolean isSilentClear() {
<b class="nc">&nbsp;		return silentClear;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Converts a {@link TupleQueryResult} resulting from the {@link #EVERYTHING_WITH_GRAPH} to a statement by using the
&nbsp;	 * respective values from the {@link BindingSet} or (if provided) the ones from the arguments.
&nbsp;	 *
&nbsp;	 * @param iter the {@link TupleQueryResult}
&nbsp;	 * @param subj the subject {@link Resource} used as input or &lt;code&gt;null&lt;/code&gt; if wildcard was used
&nbsp;	 * @param pred the predicate {@link IRI} used as input or &lt;code&gt;null&lt;/code&gt; if wildcard was used
&nbsp;	 * @param obj  the object {@link Value} used as input or &lt;code&gt;null&lt;/code&gt; if wildcard was used
&nbsp;	 * @return the converted iteration
&nbsp;	 */
&nbsp;	@Deprecated(since = &quot;4.1.0&quot;, forRemoval = true)
&nbsp;	protected Iteration&lt;Statement, QueryEvaluationException&gt; toStatementIteration(TupleQueryResult iter,
&nbsp;			final Resource subj, final IRI pred, final Value obj) {
&nbsp;
<b class="nc">&nbsp;		return new ConvertingIteration&lt;&gt;(iter) {</b>
&nbsp;
&nbsp;			@Override
&nbsp;			protected Statement convert(BindingSet b) throws QueryEvaluationException {
&nbsp;
<b class="nc">&nbsp;				Resource s = subj == null ? (Resource) b.getValue(&quot;s&quot;) : subj;</b>
<b class="nc">&nbsp;				IRI p = pred == null ? (IRI) b.getValue(&quot;p&quot;) : pred;</b>
<b class="nc">&nbsp;				Value o = obj == null ? b.getValue(&quot;o&quot;) : obj;</b>
<b class="nc">&nbsp;				Resource ctx = (Resource) b.getValue(&quot;ctx&quot;);</b>
&nbsp;
<b class="nc">&nbsp;				return SimpleValueFactory.getInstance().createStatement(s, p, o, ctx);</b>
&nbsp;			}
&nbsp;
&nbsp;		};
&nbsp;	}
&nbsp;
&nbsp;	private ModelFactory getModelFactory() {
<b class="nc">&nbsp;		return modelFactory;</b>
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:20</div>
</div>
</body>
</html>
