


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > MemStatementIterator</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.sail.memory.model</a>
</div>

<h1>Coverage Summary for Class: MemStatementIterator (org.eclipse.rdf4j.sail.memory.model)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MemStatementIterator</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (9/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    37%
  </span>
  <span class="absValue">
    (37/100)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    52.4%
  </span>
  <span class="absValue">
    (54/103)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MemStatementIterator$Stats</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    52.9%
  </span>
  <span class="absValue">
    (9/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    37%
  </span>
  <span class="absValue">
    (37/100)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50.5%
  </span>
  <span class="absValue">
    (54/107)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;package org.eclipse.rdf4j.sail.memory.model;
&nbsp;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.NoSuchElementException;
&nbsp;
&nbsp;import org.eclipse.rdf4j.common.iteration.CloseableIteration;
&nbsp;import org.eclipse.rdf4j.sail.SailException;
&nbsp;
&nbsp;/**
&nbsp; * A StatementIterator that can iterate over a list of Statement objects. This iterator compares Resource and Literal
&nbsp; * objects using the &#39;==&#39; operator, which is possible thanks to the extensive sharing of these objects in the
&nbsp; * MemoryStore.
&nbsp; */
<b class="fc">&nbsp;public class MemStatementIterator implements CloseableIteration&lt;MemStatement, SailException&gt; {</b>
&nbsp;	public static final int MIN_SIZE_TO_CONSIDER_FOR_CACHE = 1000;
&nbsp;
&nbsp;	/*-----------*
&nbsp;	 * Variables *
&nbsp;	 *-----------*/
&nbsp;
&nbsp;	/**
&nbsp;	 * The lists of statements over which to iterate, and its size (different from length). Always set the size before
&nbsp;	 * the array. If we get the array first and the size after, then the MemStatementList object could have resized the
&nbsp;	 * array in between so that the size &gt; length.
&nbsp;	 */
&nbsp;	private final int statementListSize;
&nbsp;	private MemStatement[] statementList;
&nbsp;
&nbsp;	/**
&nbsp;	 * The subject of statements to return, or null if any subject is OK.
&nbsp;	 */
&nbsp;	private final MemResource subject;
&nbsp;
&nbsp;	/**
&nbsp;	 * The predicate of statements to return, or null if any predicate is OK.
&nbsp;	 */
&nbsp;	private final MemIRI predicate;
&nbsp;
&nbsp;	/**
&nbsp;	 * The object of statements to return, or null if any object is OK.
&nbsp;	 */
&nbsp;	private final MemValue object;
&nbsp;
&nbsp;	/**
&nbsp;	 * The context of statements to return, or null if any context is OK.
&nbsp;	 */
&nbsp;	private final MemResource[] contexts;
&nbsp;
&nbsp;	/**
&nbsp;	 * Flag indicating whether this iterator should only return explicitly added statements or only return inferred
&nbsp;	 * statements.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * If this has not been specified (null) and we should return both explicit and inferred statements, then the flag
&nbsp;	 * below will be set to true.
&nbsp;	 */
&nbsp;	private final boolean explicit;
&nbsp;	private final boolean explicitNotSpecified;
&nbsp;
&nbsp;	/**
&nbsp;	 * Indicates which snapshot should be iterated over.
&nbsp;	 */
&nbsp;	private final int snapshot;
&nbsp;	private final boolean noIsolation;
&nbsp;
&nbsp;	/**
&nbsp;	 * The index of the last statement that has been returned.
&nbsp;	 */
&nbsp;	private int statementIndex;
&nbsp;
&nbsp;	/**
&nbsp;	 * The number of returned statements
&nbsp;	 */
&nbsp;	private int matchingStatements;
&nbsp;	private MemStatement nextElement;
&nbsp;	/**
&nbsp;	 * Flag indicating whether this iteration has been closed.
&nbsp;	 */
<b class="fc">&nbsp;	private boolean closed = false;</b>
&nbsp;
&nbsp;	private final MemStatementIteratorCache iteratorCache;
&nbsp;
&nbsp;	/*--------------*
&nbsp;	 * Constructors *
&nbsp;	 *--------------*/
&nbsp;
&nbsp;	/**
&nbsp;	 * Creates a new MemStatementIterator that will iterate over the statements contained in the supplied
&nbsp;	 * MemStatementList searching for statements that match the specified pattern of subject, predicate, object and
&nbsp;	 * context(s).
&nbsp;	 *
&nbsp;	 * @param statementList the statements over which to iterate.
&nbsp;	 * @param subject       subject of pattern.
&nbsp;	 * @param predicate     predicate of pattern.
&nbsp;	 * @param object        object of pattern.
&nbsp;	 * @param contexts      context(s) of pattern.
&nbsp;	 */
&nbsp;	public MemStatementIterator(MemStatementList statementList, MemResource subject, MemIRI predicate, MemValue object,
&nbsp;			Boolean explicit, int snapshot, MemStatementIteratorCache iteratorCache, MemResource... contexts)
<b class="fc">&nbsp;			throws InterruptedException {</b>
<b class="fc">&nbsp;		this.statementList = statementList.getStatements();</b>
<b class="fc">&nbsp;		this.statementListSize = statementList.getGuaranteedLastIndexInUse() + 1;</b>
<b class="pc">&nbsp;		assert this.statementListSize &lt;= this.statementList.length;</b>
<b class="fc">&nbsp;		this.subject = subject;</b>
<b class="fc">&nbsp;		this.predicate = predicate;</b>
<b class="fc">&nbsp;		this.object = object;</b>
<b class="fc">&nbsp;		this.iteratorCache = iteratorCache;</b>
<b class="fc">&nbsp;		this.contexts = contexts;</b>
<b class="fc">&nbsp;		if (explicit == null) {</b>
<b class="fc">&nbsp;			this.explicitNotSpecified = true;</b>
<b class="fc">&nbsp;			this.explicit = false;</b>
&nbsp;		} else {
<b class="fc">&nbsp;			this.explicitNotSpecified = false;</b>
<b class="fc">&nbsp;			this.explicit = explicit;</b>
&nbsp;		}
<b class="fc">&nbsp;		this.snapshot = snapshot;</b>
<b class="pc">&nbsp;		this.noIsolation = snapshot &lt; 0;</b>
<b class="fc">&nbsp;		this.statementIndex = 0;</b>
&nbsp;	}
&nbsp;
&nbsp;	public static CloseableIteration&lt;MemStatement, SailException&gt; cacheAwareInstance(MemStatementList smallestList,
&nbsp;			MemResource subj, MemIRI pred, MemValue obj, Boolean explicit, int snapshot, MemResource[] memContexts,
&nbsp;			MemStatementIteratorCache iteratorCache) throws InterruptedException {
&nbsp;
<b class="pc">&nbsp;		if (smallestList.size() &gt; MemStatementIterator.MIN_SIZE_TO_CONSIDER_FOR_CACHE) {</b>
<b class="nc">&nbsp;			MemStatementIterator memStatementIterator = null;</b>
&nbsp;			try {
<b class="nc">&nbsp;				memStatementIterator = new MemStatementIterator(smallestList, subj, pred, obj, explicit, snapshot,</b>
&nbsp;						iteratorCache, memContexts);
<b class="nc">&nbsp;				if (iteratorCache.shouldBeCached(memStatementIterator)) {</b>
<b class="nc">&nbsp;					return iteratorCache.getCachedIterator(memStatementIterator);</b>
&nbsp;				} else {
<b class="nc">&nbsp;					return memStatementIterator;</b>
&nbsp;				}
<b class="nc">&nbsp;			} catch (Throwable t) {</b>
<b class="nc">&nbsp;				if (memStatementIterator != null) {</b>
<b class="nc">&nbsp;					memStatementIterator.close();</b>
&nbsp;				}
<b class="nc">&nbsp;				throw t;</b>
&nbsp;			}
&nbsp;		} else {
<b class="fc">&nbsp;			return new MemStatementIterator(smallestList, subj, pred, obj, explicit, snapshot, null, memContexts);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/*---------*
&nbsp;	 * Methods *
&nbsp;	 *---------*/
&nbsp;
&nbsp;	/**
&nbsp;	 * Searches through statementList, starting from index &lt;var&gt;_nextStatementIdx + 1&lt;/var&gt;, for statements that match
&nbsp;	 * the constraints that have been set for this iterator. If a matching statement has been found it will be stored in
&nbsp;	 * &lt;var&gt;_nextStatement&lt;/var&gt; and &lt;var&gt;_nextStatementIdx&lt;/var&gt; points to the index of this statement in
&nbsp;	 * &lt;var&gt;_statementList&lt;/var&gt;. Otherwise, &lt;var&gt;_nextStatement&lt;/var&gt; will set to &lt;var&gt;null&lt;/var&gt;.
&nbsp;	 */
&nbsp;	private MemStatement getNextElement() {
&nbsp;
<b class="fc">&nbsp;		while (statementIndex &lt; statementListSize) {</b>
&nbsp;			// First getting the size to check if we are out-of-bounds is more expensive (cache wise) than having a
&nbsp;			// method in MemStatementList that does this for us.
&nbsp;
<b class="fc">&nbsp;			MemStatement statement = statementList[statementIndex++];</b>
&nbsp;
&nbsp;			// First check if we match the specified SPO, then check the context, then finally check the
&nbsp;			// explicit/inferred and snapshot. Checking explicit/inferred and snapshot requires reading a volatile
&nbsp;			// field, which is fairly slow and the reason we check this last.
<b class="pc">&nbsp;			if (statement != null &amp;&amp; (statement.matchesSPO(subject, predicate, object))) {</b>
<b class="fc">&nbsp;				if (contexts.length &gt; 0) {</b>
<b class="fc">&nbsp;					if (statement.matchesContext(contexts)</b>
<b class="fc">&nbsp;							&amp;&amp; matchesExplicitAndSnapshot(statement)) {</b>
&nbsp;
<b class="fc">&nbsp;						matchingStatements++;</b>
<b class="fc">&nbsp;						return statement;</b>
&nbsp;					}
&nbsp;				} else {
<b class="pc">&nbsp;					if (matchesExplicitAndSnapshot(statement)) {</b>
<b class="fc">&nbsp;						matchingStatements++;</b>
<b class="fc">&nbsp;						return statement;</b>
&nbsp;					}
&nbsp;				}
&nbsp;
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;		}</b>
&nbsp;
<b class="fc">&nbsp;		return null;</b>
&nbsp;	}
&nbsp;
&nbsp;	boolean matchesExplicitAndSnapshot(MemStatement st) {
<b class="pc">&nbsp;		return (explicitNotSpecified || explicit == st.isExplicit()) &amp;&amp;</b>
<b class="fc">&nbsp;				(noIsolation || st.isInSnapshot(snapshot));</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns true if this iterator was particularly costly and should be considered for caching
&nbsp;	 *
&nbsp;	 * @return true if it should be cached
&nbsp;	 */
&nbsp;	private boolean isCandidateForCache() {
<b class="nc">&nbsp;		if (statementIndex == statementListSize) { // we will only consider caching if the iterator has been completely</b>
&nbsp;			// consumed
<b class="nc">&nbsp;			if (statementIndex &gt; MIN_SIZE_TO_CONSIDER_FOR_CACHE) { // minimum 1000 statements need to have been checked</b>
&nbsp;				// by the iterator
<b class="nc">&nbsp;				if (matchingStatements == 0) { // if the iterator was effectively empty we can always cache it</b>
<b class="nc">&nbsp;					return true;</b>
<b class="nc">&nbsp;				} else if (matchingStatements &lt; 100) { // we will not cache iterators that returned more than 99</b>
&nbsp;					// statements
<b class="nc">&nbsp;					double ratio = (statementIndex + 0.0) / matchingStatements;</b>
<b class="nc">&nbsp;					return ratio &gt; 100; // for every returned statement we need to have checked 100 non-matching</b>
&nbsp;					// statements
&nbsp;				}
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public boolean equals(Object o) {
<b class="nc">&nbsp;		if (this == o) {</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;		}
<b class="nc">&nbsp;		if (!(o instanceof MemStatementIterator)) {</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;		}
<b class="nc">&nbsp;		MemStatementIterator that = (MemStatementIterator) o;</b>
<b class="nc">&nbsp;		return explicit == that.explicit &amp;&amp; explicitNotSpecified == that.explicitNotSpecified</b>
&nbsp;				&amp;&amp; snapshot == that.snapshot &amp;&amp; noIsolation == that.noIsolation
&nbsp;				&amp;&amp; subject == that.subject
&nbsp;				&amp;&amp; predicate == that.predicate &amp;&amp; object == that.object
<b class="nc">&nbsp;				&amp;&amp; Arrays.equals(contexts, that.contexts);</b>
&nbsp;	}
&nbsp;
<b class="fc">&nbsp;	private int cachedHashCode = 0;</b>
&nbsp;
&nbsp;	@Override
&nbsp;	public int hashCode() {
<b class="nc">&nbsp;		if (cachedHashCode == 0) {</b>
&nbsp;
&nbsp;			// Inlined Objects.hash(subject, predicate, object, explicit, explicitNotSpecified, snapshot, noIsolation)
&nbsp;			// to avoid array creation.
<b class="nc">&nbsp;			int cachedHashCode = 1;</b>
<b class="nc">&nbsp;			cachedHashCode = 31 * cachedHashCode + (subject == null ? 0 : subject.hashCode());</b>
<b class="nc">&nbsp;			cachedHashCode = 31 * cachedHashCode + (predicate == null ? 0 : predicate.hashCode());</b>
<b class="nc">&nbsp;			cachedHashCode = 31 * cachedHashCode + (object == null ? 0 : object.hashCode());</b>
<b class="nc">&nbsp;			cachedHashCode = 31 * cachedHashCode + Boolean.hashCode(explicit);</b>
<b class="nc">&nbsp;			cachedHashCode = 31 * cachedHashCode + Boolean.hashCode(explicitNotSpecified);</b>
<b class="nc">&nbsp;			cachedHashCode = 31 * cachedHashCode + snapshot;</b>
<b class="nc">&nbsp;			cachedHashCode = 31 * cachedHashCode + Boolean.hashCode(noIsolation);</b>
&nbsp;
<b class="nc">&nbsp;			if (contexts != null) {</b>
<b class="nc">&nbsp;				if (contexts.length == 1) {</b>
<b class="nc">&nbsp;					if (contexts[0] == null) {</b>
<b class="nc">&nbsp;						cachedHashCode += 23;</b>
&nbsp;					} else {
<b class="nc">&nbsp;						cachedHashCode = 29 * cachedHashCode + contexts[0].hashCode();</b>
&nbsp;					}
<b class="nc">&nbsp;				} else if (contexts.length &gt; 0) {</b>
<b class="nc">&nbsp;					cachedHashCode = 31 * cachedHashCode + Arrays.hashCode(contexts);</b>
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			this.cachedHashCode = cachedHashCode;</b>
&nbsp;		}
<b class="nc">&nbsp;		return cachedHashCode;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public String toString() {
<b class="nc">&nbsp;		return &quot;MemStatementIterator{&quot; +</b>
&nbsp;				&quot;subject=&quot; + subject +
&nbsp;				&quot;, predicate=&quot; + predicate +
&nbsp;				&quot;, object=&quot; + object +
<b class="nc">&nbsp;				&quot;, contexts=&quot; + Arrays.toString(contexts) +</b>
&nbsp;				&quot;, explicit=&quot; + explicit +
&nbsp;				&quot;, explicitNotSpecified=&quot; + explicitNotSpecified +
&nbsp;				&quot;, snapshot=&quot; + snapshot +
&nbsp;				&quot;, noIsolation=&quot; + noIsolation +
&nbsp;				&#39;}&#39;;
&nbsp;	}
&nbsp;
&nbsp;	public Stats getStats() {
<b class="nc">&nbsp;		return new Stats(statementIndex, matchingStatements);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public final boolean hasNext() {
<b class="fc">&nbsp;		if (closed) {</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return lookAhead() != null;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public final MemStatement next() {
<b class="pc">&nbsp;		if (closed) {</b>
<b class="nc">&nbsp;			throw new NoSuchElementException(&quot;The iteration has been closed.&quot;);</b>
&nbsp;		}
<b class="fc">&nbsp;		MemStatement result = lookAhead();</b>
&nbsp;
<b class="pc">&nbsp;		if (result != null) {</b>
<b class="fc">&nbsp;			nextElement = null;</b>
<b class="fc">&nbsp;			return result;</b>
&nbsp;		} else {
<b class="nc">&nbsp;			throw new NoSuchElementException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Fetches the next element if it hasn&#39;t been fetched yet and stores it in {@link #nextElement}.
&nbsp;	 *
&nbsp;	 * @return The next element, or null if there are no more results. @ If there is an issue getting the next element
&nbsp;	 *         or closing the iteration.
&nbsp;	 */
&nbsp;	private MemStatement lookAhead() {
<b class="fc">&nbsp;		if (nextElement == null) {</b>
<b class="fc">&nbsp;			nextElement = getNextElement();</b>
&nbsp;
<b class="fc">&nbsp;			if (nextElement == null) {</b>
<b class="fc">&nbsp;				close();</b>
&nbsp;			}
&nbsp;		}
<b class="fc">&nbsp;		return nextElement;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Throws an {@link UnsupportedOperationException}.
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public void remove() {
<b class="nc">&nbsp;		throw new UnsupportedOperationException();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public final void close() {
<b class="fc">&nbsp;		if (!closed) {</b>
<b class="fc">&nbsp;			closed = true;</b>
<b class="fc">&nbsp;			statementList = null;</b>
<b class="pc">&nbsp;			if (iteratorCache != null &amp;&amp; isCandidateForCache()) {</b>
<b class="nc">&nbsp;				iteratorCache.incrementIteratorFrequencyMap(this);</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	static class Stats {
&nbsp;		private final int checkedStatements;
&nbsp;		private final int matchingStatements;
&nbsp;
<b class="nc">&nbsp;		public Stats(int checkStatements, int matchingStatements) {</b>
<b class="nc">&nbsp;			this.checkedStatements = checkStatements;</b>
<b class="nc">&nbsp;			this.matchingStatements = matchingStatements;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public String toString() {
<b class="nc">&nbsp;			return &quot;Stats{&quot; +</b>
&nbsp;					&quot;checkedStatements=&quot; + checkedStatements +
&nbsp;					&quot;, matchingStatements=&quot; + matchingStatements +
&nbsp;					&#39;}&#39;;
&nbsp;		}
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:20</div>
</div>
</body>
</html>
