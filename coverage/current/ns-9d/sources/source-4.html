


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > SailUpdateExecutor</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.repository.sail.helpers</a>
</div>

<h1>Coverage Summary for Class: SailUpdateExecutor (org.eclipse.rdf4j.repository.sail.helpers)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SailUpdateExecutor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (17/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    56.2%
  </span>
  <span class="absValue">
    (146/260)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    76.8%
  </span>
  <span class="absValue">
    (228/297)
  </span>
</td>
</tr>
  <tr>
    <td class="name">SailUpdateExecutor$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SailUpdateExecutor$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SailUpdateExecutor$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SailUpdateExecutor$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SailUpdateExecutor$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SailUpdateExecutor$6</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    12.5%
  </span>
  <span class="absValue">
    (2/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    30%
  </span>
  <span class="absValue">
    (6/20)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    65.5%
  </span>
  <span class="absValue">
    (19/29)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    53.6%
  </span>
  <span class="absValue">
    (148/276)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.6%
  </span>
  <span class="absValue">
    (234/327)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;package org.eclipse.rdf4j.repository.sail.helpers;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.io.StringReader;
&nbsp;import java.net.URL;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Set;
&nbsp;
&nbsp;import org.eclipse.rdf4j.common.iteration.CloseableIteration;
&nbsp;import org.eclipse.rdf4j.common.iteration.ConvertingIteration;
&nbsp;import org.eclipse.rdf4j.common.iteration.TimeLimitIteration;
&nbsp;import org.eclipse.rdf4j.model.BNode;
&nbsp;import org.eclipse.rdf4j.model.IRI;
&nbsp;import org.eclipse.rdf4j.model.Resource;
&nbsp;import org.eclipse.rdf4j.model.Statement;
&nbsp;import org.eclipse.rdf4j.model.Value;
&nbsp;import org.eclipse.rdf4j.model.ValueFactory;
&nbsp;import org.eclipse.rdf4j.model.vocabulary.RDF4J;
&nbsp;import org.eclipse.rdf4j.model.vocabulary.SESAME;
&nbsp;import org.eclipse.rdf4j.query.Binding;
&nbsp;import org.eclipse.rdf4j.query.BindingSet;
&nbsp;import org.eclipse.rdf4j.query.Dataset;
&nbsp;import org.eclipse.rdf4j.query.QueryEvaluationException;
&nbsp;import org.eclipse.rdf4j.query.QueryInterruptedException;
&nbsp;import org.eclipse.rdf4j.query.algebra.Add;
&nbsp;import org.eclipse.rdf4j.query.algebra.Clear;
&nbsp;import org.eclipse.rdf4j.query.algebra.Copy;
&nbsp;import org.eclipse.rdf4j.query.algebra.Create;
&nbsp;import org.eclipse.rdf4j.query.algebra.DeleteData;
&nbsp;import org.eclipse.rdf4j.query.algebra.InsertData;
&nbsp;import org.eclipse.rdf4j.query.algebra.Load;
&nbsp;import org.eclipse.rdf4j.query.algebra.Modify;
&nbsp;import org.eclipse.rdf4j.query.algebra.Move;
&nbsp;import org.eclipse.rdf4j.query.algebra.QueryRoot;
&nbsp;import org.eclipse.rdf4j.query.algebra.SingletonSet;
&nbsp;import org.eclipse.rdf4j.query.algebra.StatementPattern;
&nbsp;import org.eclipse.rdf4j.query.algebra.StatementPattern.Scope;
&nbsp;import org.eclipse.rdf4j.query.algebra.TupleExpr;
&nbsp;import org.eclipse.rdf4j.query.algebra.UpdateExpr;
&nbsp;import org.eclipse.rdf4j.query.algebra.ValueConstant;
&nbsp;import org.eclipse.rdf4j.query.algebra.Var;
&nbsp;import org.eclipse.rdf4j.query.algebra.helpers.collectors.StatementPatternCollector;
&nbsp;import org.eclipse.rdf4j.query.impl.EmptyBindingSet;
&nbsp;import org.eclipse.rdf4j.query.impl.MapBindingSet;
&nbsp;import org.eclipse.rdf4j.query.parser.sparql.SPARQLUpdateDataBlockParser;
&nbsp;import org.eclipse.rdf4j.repository.sail.SailUpdate;
&nbsp;import org.eclipse.rdf4j.repository.util.RDFLoader;
&nbsp;import org.eclipse.rdf4j.rio.ParserConfig;
&nbsp;import org.eclipse.rdf4j.rio.RDFHandler;
&nbsp;import org.eclipse.rdf4j.rio.RDFHandlerException;
&nbsp;import org.eclipse.rdf4j.rio.RDFParseException;
&nbsp;import org.eclipse.rdf4j.rio.helpers.BasicParserSettings;
&nbsp;import org.eclipse.rdf4j.rio.helpers.TimeLimitRDFHandler;
&nbsp;import org.eclipse.rdf4j.sail.SailConnection;
&nbsp;import org.eclipse.rdf4j.sail.SailException;
&nbsp;import org.eclipse.rdf4j.sail.UpdateContext;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;
&nbsp;/**
&nbsp; * Implementation of {@link SailUpdate#execute()} using
&nbsp; * {@link SailConnection#evaluate(TupleExpr, Dataset, BindingSet, boolean)} and other {@link SailConnection} methods.
&nbsp; * LOAD is handled at the Repository API level because it requires access to the Rio parser.
&nbsp; *
&nbsp; * @author jeen
&nbsp; * @author James Leigh
&nbsp; * @see SailConnection#startUpdate(UpdateContext)
&nbsp; * @see SailConnection#endUpdate(UpdateContext)
&nbsp; * @see SailConnection#addStatement(UpdateContext, Resource, IRI, Value, Resource...)
&nbsp; * @see SailConnection#removeStatement(UpdateContext, Resource, IRI, Value, Resource...)
&nbsp; * @see SailConnection#clear(Resource...)
&nbsp; * @see SailConnection#getContextIDs()
&nbsp; * @see SailConnection#getStatements(Resource, IRI, Value, boolean, Resource...)
&nbsp; * @see SailConnection#evaluate(TupleExpr, Dataset, BindingSet, boolean)
&nbsp; */
&nbsp;public class SailUpdateExecutor {
&nbsp;
<b class="fc">&nbsp;	private final Logger logger = LoggerFactory.getLogger(SailUpdateExecutor.class);</b>
&nbsp;
&nbsp;	private final SailConnection con;
&nbsp;
&nbsp;	private final ValueFactory vf;
&nbsp;
&nbsp;	private final RDFLoader loader;
&nbsp;
&nbsp;	/**
&nbsp;	 * Implementation of {@link SailUpdate#execute()} using
&nbsp;	 * {@link SailConnection#evaluate(TupleExpr, Dataset, BindingSet, boolean)} and other {@link SailConnection}
&nbsp;	 * methods.
&nbsp;	 *
&nbsp;	 * @param con        Used to read data from and write data to.
&nbsp;	 * @param vf         Used to create {@link BNode}s
&nbsp;	 * @param loadConfig
&nbsp;	 */
<b class="fc">&nbsp;	public SailUpdateExecutor(SailConnection con, ValueFactory vf, ParserConfig loadConfig) {</b>
<b class="fc">&nbsp;		this.con = con;</b>
<b class="fc">&nbsp;		this.vf = vf;</b>
<b class="fc">&nbsp;		this.loader = new RDFLoader(loadConfig, vf);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * @param maxExecutionTime in seconds.
&nbsp;	 */
&nbsp;	public void executeUpdate(UpdateExpr updateExpr, Dataset dataset, BindingSet bindings, boolean includeInferred,
&nbsp;			int maxExecutionTime) throws SailException, RDFParseException, IOException {
<b class="fc">&nbsp;		UpdateContext uc = new UpdateContext(updateExpr, dataset, bindings, includeInferred);</b>
<b class="fc">&nbsp;		logger.trace(&quot;Incoming update expression:\n{}&quot;, uc);</b>
&nbsp;
<b class="fc">&nbsp;		con.startUpdate(uc);</b>
&nbsp;		try {
<b class="fc">&nbsp;			if (updateExpr instanceof Load) {</b>
<b class="fc">&nbsp;				executeLoad((Load) updateExpr, uc);</b>
<b class="fc">&nbsp;			} else if (updateExpr instanceof Modify) {</b>
<b class="fc">&nbsp;				executeModify((Modify) updateExpr, uc, maxExecutionTime);</b>
<b class="fc">&nbsp;			} else if (updateExpr instanceof InsertData) {</b>
<b class="fc">&nbsp;				executeInsertData((InsertData) updateExpr, uc, maxExecutionTime);</b>
<b class="fc">&nbsp;			} else if (updateExpr instanceof DeleteData) {</b>
<b class="fc">&nbsp;				executeDeleteData((DeleteData) updateExpr, uc, maxExecutionTime);</b>
<b class="fc">&nbsp;			} else if (updateExpr instanceof Clear) {</b>
<b class="fc">&nbsp;				executeClear((Clear) updateExpr, uc, maxExecutionTime);</b>
<b class="fc">&nbsp;			} else if (updateExpr instanceof Create) {</b>
<b class="fc">&nbsp;				executeCreate((Create) updateExpr, uc);</b>
<b class="fc">&nbsp;			} else if (updateExpr instanceof Copy) {</b>
<b class="fc">&nbsp;				executeCopy((Copy) updateExpr, uc, maxExecutionTime);</b>
<b class="fc">&nbsp;			} else if (updateExpr instanceof Add) {</b>
<b class="fc">&nbsp;				executeAdd((Add) updateExpr, uc, maxExecutionTime);</b>
<b class="pc">&nbsp;			} else if (updateExpr instanceof Move) {</b>
<b class="fc">&nbsp;				executeMove((Move) updateExpr, uc, maxExecutionTime);</b>
<b class="nc">&nbsp;			} else if (updateExpr instanceof Load) {</b>
<b class="nc">&nbsp;				throw new SailException(&quot;load operations can not be handled directly by the SAIL&quot;);</b>
&nbsp;			}
&nbsp;		} finally {
<b class="fc">&nbsp;			con.endUpdate(uc);</b>
<b class="fc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	protected void executeLoad(Load load, UpdateContext uc) throws IOException, RDFParseException, SailException {
<b class="fc">&nbsp;		Value source = load.getSource().getValue();</b>
<b class="fc">&nbsp;		Value graph = load.getGraph() != null ? load.getGraph().getValue() : null;</b>
&nbsp;
<b class="fc">&nbsp;		URL sourceURL = new URL(source.stringValue());</b>
&nbsp;
<b class="nc">&nbsp;		RDFSailInserter rdfInserter = new RDFSailInserter(con, vf, uc);</b>
<b class="nc">&nbsp;		if (graph != null) {</b>
<b class="nc">&nbsp;			rdfInserter.enforceContext((Resource) graph);</b>
&nbsp;		}
&nbsp;		try {
<b class="nc">&nbsp;			loader.load(sourceURL, source.stringValue(), null, rdfInserter);</b>
<b class="nc">&nbsp;		} catch (RDFHandlerException e) {</b>
&nbsp;			// RDFSailInserter only throws wrapped SailExceptions
<b class="nc">&nbsp;			throw (SailException) e.getCause();</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	protected void executeCreate(Create create, UpdateContext uc) throws SailException {
&nbsp;		// check if named graph exists, if so, we have to return an error.
&nbsp;		// Otherwise, we simply do nothing.
<b class="fc">&nbsp;		Value graphValue = create.getGraph().getValue();</b>
&nbsp;
<b class="pc">&nbsp;		if (graphValue instanceof Resource) {</b>
<b class="fc">&nbsp;			Resource namedGraph = (Resource) graphValue;</b>
&nbsp;
<b class="pc">&nbsp;			try (CloseableIteration&lt;? extends Resource, SailException&gt; contextIDs = con.getContextIDs()) {</b>
<b class="pc">&nbsp;				while (contextIDs.hasNext()) {</b>
<b class="fc">&nbsp;					Resource contextID = contextIDs.next();</b>
&nbsp;
<b class="pc">&nbsp;					if (namedGraph.equals(contextID)) {</b>
<b class="fc">&nbsp;						throw new SailException(&quot;Named graph &quot; + namedGraph + &quot; already exists. &quot;);</b>
&nbsp;					}
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * @param copy
&nbsp;	 * @param uc
&nbsp;	 * @throws SailException
&nbsp;	 */
&nbsp;	protected void executeCopy(Copy copy, UpdateContext uc, int maxExecutionTime) throws SailException {
<b class="fc">&nbsp;		ValueConstant sourceGraph = copy.getSourceGraph();</b>
<b class="fc">&nbsp;		ValueConstant destinationGraph = copy.getDestinationGraph();</b>
&nbsp;
<b class="fc">&nbsp;		Resource source = sourceGraph != null ? (Resource) sourceGraph.getValue() : null;</b>
<b class="fc">&nbsp;		Resource destination = destinationGraph != null ? (Resource) destinationGraph.getValue() : null;</b>
&nbsp;
<b class="pc">&nbsp;		if (source == null &amp;&amp; destination == null || (source != null &amp;&amp; source.equals(destination))) {</b>
&nbsp;			// source and destination are the same, copy is a null-operation.
&nbsp;			return;
&nbsp;		}
&nbsp;
&nbsp;		// clear destination
<b class="fc">&nbsp;		final long start = System.currentTimeMillis();</b>
<b class="fc">&nbsp;		con.clear((Resource) destination);</b>
<b class="fc">&nbsp;		final long clearTime = (System.currentTimeMillis() - start) / 1000;</b>
&nbsp;
<b class="pc">&nbsp;		if (maxExecutionTime &gt; 0) {</b>
<b class="nc">&nbsp;			if (clearTime &gt; maxExecutionTime) {</b>
<b class="nc">&nbsp;				throw new SailException(&quot;execution took too long&quot;);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		// get all statements from source and add them to destination
<b class="fc">&nbsp;		CloseableIteration&lt;? extends Statement, SailException&gt; statements = null;</b>
&nbsp;		try {
<b class="fc">&nbsp;			statements = con.getStatements(null, null, null, uc.isIncludeInferred(), (Resource) source);</b>
&nbsp;
<b class="pc">&nbsp;			if (maxExecutionTime &gt; 0) {</b>
<b class="nc">&nbsp;				statements = new TimeLimitIteration&lt;Statement, SailException&gt;(statements,</b>
<b class="nc">&nbsp;						1000L * (maxExecutionTime - clearTime)) {</b>
&nbsp;
&nbsp;					@Override
&nbsp;					protected void throwInterruptedException() throws SailException {
<b class="nc">&nbsp;						throw new SailException(&quot;execution took too long&quot;);</b>
&nbsp;					}
&nbsp;				};
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			while (statements.hasNext()) {</b>
<b class="fc">&nbsp;				Statement st = statements.next();</b>
<b class="fc">&nbsp;				con.addStatement(uc, st.getSubject(), st.getPredicate(), st.getObject(), (Resource) destination);</b>
<b class="fc">&nbsp;			}</b>
&nbsp;		} finally {
<b class="pc">&nbsp;			if (statements != null) {</b>
<b class="fc">&nbsp;				statements.close();</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * @param add
&nbsp;	 * @param uc
&nbsp;	 * @throws SailException
&nbsp;	 */
&nbsp;	protected void executeAdd(Add add, UpdateContext uc, int maxExecTime) throws SailException {
<b class="fc">&nbsp;		ValueConstant sourceGraph = add.getSourceGraph();</b>
<b class="fc">&nbsp;		ValueConstant destinationGraph = add.getDestinationGraph();</b>
&nbsp;
<b class="fc">&nbsp;		Resource source = sourceGraph != null ? (Resource) sourceGraph.getValue() : null;</b>
<b class="fc">&nbsp;		Resource destination = destinationGraph != null ? (Resource) destinationGraph.getValue() : null;</b>
&nbsp;
<b class="pc">&nbsp;		if (source == null &amp;&amp; destination == null || (source != null &amp;&amp; source.equals(destination))) {</b>
&nbsp;			// source and destination are the same, copy is a null-operation.
&nbsp;			return;
&nbsp;		}
&nbsp;
&nbsp;		// get all statements from source and add them to destination
<b class="fc">&nbsp;		CloseableIteration&lt;? extends Statement, SailException&gt; statements = null;</b>
&nbsp;		try {
<b class="fc">&nbsp;			statements = con.getStatements(null, null, null, uc.isIncludeInferred(), (Resource) source);</b>
&nbsp;
<b class="pc">&nbsp;			if (maxExecTime &gt; 0) {</b>
<b class="nc">&nbsp;				statements = new TimeLimitIteration&lt;Statement, SailException&gt;(statements, 1000L * maxExecTime) {</b>
&nbsp;
&nbsp;					@Override
&nbsp;					protected void throwInterruptedException() throws SailException {
<b class="nc">&nbsp;						throw new SailException(&quot;execution took too long&quot;);</b>
&nbsp;					}
&nbsp;				};
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			while (statements.hasNext()) {</b>
<b class="fc">&nbsp;				Statement st = statements.next();</b>
<b class="fc">&nbsp;				con.addStatement(uc, st.getSubject(), st.getPredicate(), st.getObject(), (Resource) destination);</b>
<b class="fc">&nbsp;			}</b>
&nbsp;		} finally {
<b class="pc">&nbsp;			if (statements != null) {</b>
<b class="fc">&nbsp;				statements.close();</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * @param move
&nbsp;	 * @param uc
&nbsp;	 * @throws SailException
&nbsp;	 */
&nbsp;	protected void executeMove(Move move, UpdateContext uc, int maxExecutionTime) throws SailException {
<b class="fc">&nbsp;		ValueConstant sourceGraph = move.getSourceGraph();</b>
<b class="fc">&nbsp;		ValueConstant destinationGraph = move.getDestinationGraph();</b>
&nbsp;
<b class="fc">&nbsp;		Resource source = sourceGraph != null ? (Resource) sourceGraph.getValue() : null;</b>
<b class="fc">&nbsp;		Resource destination = destinationGraph != null ? (Resource) destinationGraph.getValue() : null;</b>
&nbsp;
<b class="pc">&nbsp;		if (source == null &amp;&amp; destination == null || (source != null &amp;&amp; source.equals(destination))) {</b>
&nbsp;			// source and destination are the same, move is a null-operation.
&nbsp;			return;
&nbsp;		}
&nbsp;
&nbsp;		// clear destination
<b class="fc">&nbsp;		final long start = System.currentTimeMillis();</b>
<b class="fc">&nbsp;		con.clear((Resource) destination);</b>
<b class="fc">&nbsp;		final long clearTime = (System.currentTimeMillis() - start) / 1000;</b>
&nbsp;
<b class="pc">&nbsp;		if (maxExecutionTime &gt; 0 &amp;&amp; clearTime &gt; maxExecutionTime) {</b>
<b class="nc">&nbsp;			throw new SailException(&quot;execution took too long&quot;);</b>
&nbsp;		}
&nbsp;
&nbsp;		// remove all statements from source and add them to destination
<b class="fc">&nbsp;		CloseableIteration&lt;? extends Statement, SailException&gt; statements = null;</b>
&nbsp;
&nbsp;		try {
<b class="fc">&nbsp;			statements = con.getStatements(null, null, null, uc.isIncludeInferred(), (Resource) source);</b>
<b class="pc">&nbsp;			if (maxExecutionTime &gt; 0) {</b>
<b class="nc">&nbsp;				statements = new TimeLimitIteration&lt;Statement, SailException&gt;(statements,</b>
<b class="nc">&nbsp;						1000L * (maxExecutionTime - clearTime)) {</b>
&nbsp;
&nbsp;					@Override
&nbsp;					protected void throwInterruptedException() throws SailException {
<b class="nc">&nbsp;						throw new SailException(&quot;execution took too long&quot;);</b>
&nbsp;					}
&nbsp;				};
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			while (statements.hasNext()) {</b>
<b class="fc">&nbsp;				Statement st = statements.next();</b>
<b class="fc">&nbsp;				con.addStatement(uc, st.getSubject(), st.getPredicate(), st.getObject(), (Resource) destination);</b>
<b class="fc">&nbsp;				con.removeStatement(uc, st.getSubject(), st.getPredicate(), st.getObject(), (Resource) source);</b>
<b class="fc">&nbsp;			}</b>
&nbsp;		} finally {
<b class="pc">&nbsp;			if (statements != null) {</b>
<b class="fc">&nbsp;				statements.close();</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * @param clearExpr
&nbsp;	 * @param uc
&nbsp;	 * @throws SailException
&nbsp;	 */
&nbsp;	protected void executeClear(Clear clearExpr, UpdateContext uc, int maxExecutionTime) throws SailException {
&nbsp;		try {
<b class="fc">&nbsp;			ValueConstant graph = clearExpr.getGraph();</b>
&nbsp;
<b class="fc">&nbsp;			if (graph != null) {</b>
<b class="fc">&nbsp;				Resource context = (Resource) graph.getValue();</b>
<b class="fc">&nbsp;				con.clear(context);</b>
<b class="fc">&nbsp;			} else {</b>
<b class="fc">&nbsp;				Scope scope = clearExpr.getScope();</b>
<b class="fc">&nbsp;				if (Scope.NAMED_CONTEXTS.equals(scope)) {</b>
<b class="fc">&nbsp;					CloseableIteration&lt;? extends Resource, SailException&gt; contextIDs = null;</b>
&nbsp;					try {
<b class="fc">&nbsp;						contextIDs = con.getContextIDs();</b>
<b class="pc">&nbsp;						if (maxExecutionTime &gt; 0) {</b>
<b class="nc">&nbsp;							contextIDs = new TimeLimitIteration&lt;Resource, SailException&gt;(contextIDs,</b>
<b class="nc">&nbsp;									1000L * maxExecutionTime) {</b>
&nbsp;
&nbsp;								@Override
&nbsp;								protected void throwInterruptedException() throws SailException {
<b class="nc">&nbsp;									throw new SailException(&quot;execution took too long&quot;);</b>
&nbsp;								}
&nbsp;							};
&nbsp;						}
<b class="fc">&nbsp;						while (contextIDs.hasNext()) {</b>
<b class="fc">&nbsp;							con.clear(contextIDs.next());</b>
&nbsp;						}
&nbsp;					} finally {
<b class="pc">&nbsp;						if (contextIDs != null) {</b>
<b class="fc">&nbsp;							contextIDs.close();</b>
&nbsp;						}
<b class="nc">&nbsp;					}</b>
<b class="fc">&nbsp;				} else if (Scope.DEFAULT_CONTEXTS.equals(scope)) {</b>
<b class="fc">&nbsp;					con.clear((Resource) null);</b>
&nbsp;				} else {
<b class="fc">&nbsp;					con.clear();</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;		} catch (SailException e) {</b>
<b class="nc">&nbsp;			if (!clearExpr.isSilent()) {</b>
<b class="nc">&nbsp;				throw e;</b>
&nbsp;			}
<b class="fc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * @param insertDataExpr
&nbsp;	 * @param uc
&nbsp;	 * @throws SailException
&nbsp;	 */
&nbsp;	protected void executeInsertData(InsertData insertDataExpr, UpdateContext uc, int maxExecutionTime)
&nbsp;			throws SailException {
&nbsp;
<b class="fc">&nbsp;		SPARQLUpdateDataBlockParser parser = new SPARQLUpdateDataBlockParser(vf);</b>
<b class="fc">&nbsp;		RDFHandler handler = new RDFSailInserter(con, vf, uc);</b>
<b class="pc">&nbsp;		if (maxExecutionTime &gt; 0) {</b>
<b class="nc">&nbsp;			handler = new TimeLimitRDFHandler(handler, 1000L * maxExecutionTime);</b>
&nbsp;		}
<b class="fc">&nbsp;		parser.setRDFHandler(handler);</b>
<b class="fc">&nbsp;		parser.setLineNumberOffset(insertDataExpr.getLineNumberOffset());</b>
<b class="fc">&nbsp;		parser.getParserConfig().addNonFatalError(BasicParserSettings.VERIFY_DATATYPE_VALUES);</b>
<b class="fc">&nbsp;		parser.getParserConfig().addNonFatalError(BasicParserSettings.FAIL_ON_UNKNOWN_DATATYPES);</b>
<b class="fc">&nbsp;		parser.getParserConfig().set(BasicParserSettings.SKOLEMIZE_ORIGIN, null);</b>
&nbsp;		try {
&nbsp;			// TODO process update context somehow? dataset, base URI, etc.
<b class="fc">&nbsp;			parser.parse(new StringReader(insertDataExpr.getDataBlock()), &quot;&quot;);</b>
<b class="nc">&nbsp;		} catch (RDFParseException | RDFHandlerException | IOException e) {</b>
<b class="nc">&nbsp;			throw new SailException(e);</b>
<b class="fc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * @param deleteDataExpr
&nbsp;	 * @param uc
&nbsp;	 * @throws SailException
&nbsp;	 */
&nbsp;	protected void executeDeleteData(DeleteData deleteDataExpr, UpdateContext uc, int maxExecutionTime)
&nbsp;			throws SailException {
&nbsp;
<b class="fc">&nbsp;		SPARQLUpdateDataBlockParser parser = new SPARQLUpdateDataBlockParser(vf);</b>
<b class="fc">&nbsp;		parser.setLineNumberOffset(deleteDataExpr.getLineNumberOffset());</b>
<b class="fc">&nbsp;		parser.setAllowBlankNodes(false); // no blank nodes allowed in DELETE DATA.</b>
<b class="fc">&nbsp;		RDFHandler handler = new RDFSailRemover(con, vf, uc);</b>
<b class="pc">&nbsp;		if (maxExecutionTime &gt; 0) {</b>
<b class="nc">&nbsp;			handler = new TimeLimitRDFHandler(handler, 1000L * maxExecutionTime);</b>
&nbsp;		}
<b class="fc">&nbsp;		parser.setRDFHandler(handler);</b>
&nbsp;
&nbsp;		try {
&nbsp;			// TODO process update context somehow? dataset, base URI, etc.
<b class="fc">&nbsp;			parser.parse(new StringReader(deleteDataExpr.getDataBlock()), &quot;&quot;);</b>
<b class="nc">&nbsp;		} catch (RDFParseException | RDFHandlerException | IOException e) {</b>
<b class="nc">&nbsp;			throw new SailException(e);</b>
<b class="fc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	protected void executeModify(Modify modify, UpdateContext uc, int maxExecutionTime) throws SailException {
&nbsp;		try {
<b class="fc">&nbsp;			TupleExpr whereClause = modify.getWhereExpr();</b>
&nbsp;
<b class="pc">&nbsp;			if (!(whereClause instanceof QueryRoot)) {</b>
<b class="fc">&nbsp;				whereClause = new QueryRoot(whereClause);</b>
&nbsp;			}
&nbsp;
<b class="pc">&nbsp;			try (CloseableIteration&lt;? extends BindingSet, QueryEvaluationException&gt; sourceBindings = evaluateWhereClause(</b>
&nbsp;					whereClause, uc, maxExecutionTime)) {
<b class="fc">&nbsp;				while (sourceBindings.hasNext()) {</b>
<b class="fc">&nbsp;					BindingSet sourceBinding = sourceBindings.next();</b>
<b class="fc">&nbsp;					deleteBoundTriples(sourceBinding, modify.getDeleteExpr(), uc);</b>
&nbsp;
<b class="fc">&nbsp;					insertBoundTriples(sourceBinding, modify.getInsertExpr(), uc);</b>
<b class="fc">&nbsp;				}</b>
<b class="pc">&nbsp;			}</b>
<b class="nc">&nbsp;		} catch (QueryEvaluationException e) {</b>
<b class="nc">&nbsp;			throw new SailException(e);</b>
<b class="fc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private IRI[] getDefaultRemoveGraphs(Dataset dataset) {
<b class="pc">&nbsp;		if (dataset == null) {</b>
<b class="nc">&nbsp;			return new IRI[0];</b>
&nbsp;		}
<b class="fc">&nbsp;		Set&lt;IRI&gt; set = new HashSet&lt;&gt;(dataset.getDefaultRemoveGraphs());</b>
<b class="pc">&nbsp;		if (set.isEmpty()) {</b>
<b class="nc">&nbsp;			return new IRI[0];</b>
&nbsp;		}
&nbsp;
<b class="pc">&nbsp;		if (set.remove(SESAME.NIL) | set.remove(RDF4J.NIL)) {</b>
<b class="nc">&nbsp;			set.add(null);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return set.toArray(new IRI[set.size()]);</b>
&nbsp;	}
&nbsp;
&nbsp;	private CloseableIteration&lt;? extends BindingSet, QueryEvaluationException&gt; evaluateWhereClause(
&nbsp;			final TupleExpr whereClause, final UpdateContext uc, final int maxExecutionTime)
&nbsp;			throws SailException, QueryEvaluationException {
<b class="fc">&nbsp;		CloseableIteration&lt;? extends BindingSet, QueryEvaluationException&gt; sourceBindings1 = null;</b>
<b class="fc">&nbsp;		CloseableIteration&lt;? extends BindingSet, QueryEvaluationException&gt; sourceBindings2 = null;</b>
<b class="fc">&nbsp;		ConvertingIteration&lt;BindingSet, BindingSet, QueryEvaluationException&gt; result = null;</b>
<b class="fc">&nbsp;		boolean allGood = false;</b>
&nbsp;		try {
<b class="fc">&nbsp;			sourceBindings1 = con.evaluate(whereClause, uc.getDataset(), uc.getBindingSet(), uc.isIncludeInferred());</b>
&nbsp;
<b class="pc">&nbsp;			if (maxExecutionTime &gt; 0) {</b>
<b class="nc">&nbsp;				sourceBindings2 = new TimeLimitIteration&lt;BindingSet, QueryEvaluationException&gt;(sourceBindings1,</b>
<b class="nc">&nbsp;						1000L * maxExecutionTime) {</b>
&nbsp;
&nbsp;					@Override
&nbsp;					protected void throwInterruptedException() throws QueryEvaluationException {
<b class="nc">&nbsp;						throw new QueryInterruptedException(&quot;execution took too long&quot;);</b>
&nbsp;					}
&nbsp;				};
&nbsp;			} else {
<b class="fc">&nbsp;				sourceBindings2 = sourceBindings1;</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			result = new ConvertingIteration&lt;BindingSet, BindingSet, QueryEvaluationException&gt;(sourceBindings2) {</b>
&nbsp;
&nbsp;				@Override
&nbsp;				protected BindingSet convert(BindingSet sourceBinding) throws QueryEvaluationException {
<b class="pc">&nbsp;					if (whereClause instanceof SingletonSet &amp;&amp; sourceBinding instanceof EmptyBindingSet</b>
<b class="nc">&nbsp;							&amp;&amp; uc.getBindingSet() != null) {</b>
&nbsp;						// in the case of an empty WHERE clause, we use the supplied bindings to produce triples to
&nbsp;						// DELETE/INSERT
<b class="nc">&nbsp;						return uc.getBindingSet();</b>
&nbsp;					} else {
&nbsp;						// check if any supplied bindings do not occur in the bindingset produced by the WHERE clause.
&nbsp;						// If so, merge.
<b class="fc">&nbsp;						Set&lt;String&gt; uniqueBindings = new HashSet&lt;&gt;(uc.getBindingSet().getBindingNames());</b>
<b class="fc">&nbsp;						uniqueBindings.removeAll(sourceBinding.getBindingNames());</b>
<b class="pc">&nbsp;						if (uniqueBindings.size() &gt; 0) {</b>
<b class="nc">&nbsp;							MapBindingSet mergedSet = new MapBindingSet();</b>
<b class="nc">&nbsp;							for (String bindingName : sourceBinding.getBindingNames()) {</b>
<b class="nc">&nbsp;								final Binding binding = sourceBinding.getBinding(bindingName);</b>
<b class="nc">&nbsp;								if (binding != null) {</b>
<b class="nc">&nbsp;									mergedSet.addBinding(binding);</b>
&nbsp;								}
<b class="nc">&nbsp;							}</b>
<b class="nc">&nbsp;							for (String bindingName : uniqueBindings) {</b>
<b class="nc">&nbsp;								final Binding binding = uc.getBindingSet().getBinding(bindingName);</b>
<b class="nc">&nbsp;								if (binding != null) {</b>
<b class="nc">&nbsp;									mergedSet.addBinding(binding);</b>
&nbsp;								}
<b class="nc">&nbsp;							}</b>
<b class="nc">&nbsp;							return mergedSet;</b>
&nbsp;						}
<b class="fc">&nbsp;						return sourceBinding;</b>
&nbsp;					}
&nbsp;				}
&nbsp;			};
<b class="fc">&nbsp;			allGood = true;</b>
<b class="fc">&nbsp;			return result;</b>
&nbsp;		} finally {
<b class="pc">&nbsp;			if (!allGood) {</b>
&nbsp;				try {
<b class="nc">&nbsp;					if (result != null) {</b>
<b class="nc">&nbsp;						result.close();</b>
&nbsp;					}
&nbsp;				} finally {
<b class="nc">&nbsp;					try {</b>
<b class="nc">&nbsp;						if (sourceBindings2 != null) {</b>
<b class="nc">&nbsp;							sourceBindings2.close();</b>
&nbsp;						}
&nbsp;					} finally {
<b class="nc">&nbsp;						if (sourceBindings1 != null) {</b>
<b class="nc">&nbsp;							sourceBindings1.close();</b>
&nbsp;						}
<b class="nc">&nbsp;					}</b>
<b class="nc">&nbsp;				}</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * @param whereBinding
&nbsp;	 * @param deleteClause
&nbsp;	 * @throws SailException
&nbsp;	 */
&nbsp;	private void deleteBoundTriples(BindingSet whereBinding, TupleExpr deleteClause, UpdateContext uc)
&nbsp;			throws SailException {
<b class="fc">&nbsp;		if (deleteClause != null) {</b>
<b class="fc">&nbsp;			List&lt;StatementPattern&gt; deletePatterns = StatementPatternCollector.process(deleteClause);</b>
&nbsp;
&nbsp;			Value patternValue;
<b class="fc">&nbsp;			for (StatementPattern deletePattern : deletePatterns) {</b>
&nbsp;
<b class="fc">&nbsp;				patternValue = getValueForVar(deletePattern.getSubjectVar(), whereBinding);</b>
<b class="pc">&nbsp;				Resource subject = patternValue instanceof Resource ? (Resource) patternValue : null;</b>
&nbsp;
<b class="fc">&nbsp;				patternValue = getValueForVar(deletePattern.getPredicateVar(), whereBinding);</b>
<b class="fc">&nbsp;				IRI predicate = patternValue instanceof IRI ? (IRI) patternValue : null;</b>
&nbsp;
<b class="fc">&nbsp;				Value object = getValueForVar(deletePattern.getObjectVar(), whereBinding);</b>
&nbsp;
<b class="fc">&nbsp;				Resource context = null;</b>
<b class="fc">&nbsp;				if (deletePattern.getContextVar() != null) {</b>
<b class="fc">&nbsp;					patternValue = getValueForVar(deletePattern.getContextVar(), whereBinding);</b>
<b class="pc">&nbsp;					context = patternValue instanceof Resource ? (Resource) patternValue : null;</b>
&nbsp;				}
&nbsp;
<b class="pc">&nbsp;				if (subject == null || predicate == null || object == null) {</b>
&nbsp;					/*
&nbsp;					 * skip removal of triple if any variable is unbound (may happen with optional patterns or if triple
&nbsp;					 * pattern forms illegal triple). See SES-1047 and #610.
&nbsp;					 */
<b class="nc">&nbsp;					continue;</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				if (context != null) {</b>
<b class="pc">&nbsp;					if (RDF4J.NIL.equals(context) || SESAME.NIL.equals(context)) {</b>
<b class="nc">&nbsp;						con.removeStatement(uc, subject, predicate, object, (Resource) null);</b>
&nbsp;					} else {
<b class="fc">&nbsp;						con.removeStatement(uc, subject, predicate, object, context);</b>
&nbsp;					}
&nbsp;				} else {
<b class="fc">&nbsp;					IRI[] remove = getDefaultRemoveGraphs(uc.getDataset());</b>
<b class="fc">&nbsp;					con.removeStatement(uc, subject, predicate, object, remove);</b>
&nbsp;				}
<b class="fc">&nbsp;			}</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * @param whereBinding
&nbsp;	 * @param insertClause
&nbsp;	 * @throws SailException
&nbsp;	 */
&nbsp;	private void insertBoundTriples(BindingSet whereBinding, TupleExpr insertClause, UpdateContext uc)
&nbsp;			throws SailException {
<b class="fc">&nbsp;		if (insertClause != null) {</b>
<b class="fc">&nbsp;			List&lt;StatementPattern&gt; insertPatterns = StatementPatternCollector.process(insertClause);</b>
&nbsp;
&nbsp;			// bnodes in the insert pattern are locally scoped for each
&nbsp;			// individual source binding.
<b class="fc">&nbsp;			MapBindingSet bnodeMapping = new MapBindingSet();</b>
<b class="fc">&nbsp;			for (StatementPattern insertPattern : insertPatterns) {</b>
<b class="fc">&nbsp;				Statement toBeInserted = createStatementFromPattern(insertPattern, whereBinding, bnodeMapping);</b>
&nbsp;
<b class="pc">&nbsp;				if (toBeInserted != null) {</b>
<b class="fc">&nbsp;					IRI with = uc.getDataset().getDefaultInsertGraph();</b>
<b class="fc">&nbsp;					if (with == null &amp;&amp; toBeInserted.getContext() == null) {</b>
<b class="fc">&nbsp;						con.addStatement(uc, toBeInserted.getSubject(), toBeInserted.getPredicate(),</b>
<b class="fc">&nbsp;								toBeInserted.getObject());</b>
<b class="fc">&nbsp;					} else if (toBeInserted.getContext() == null) {</b>
<b class="fc">&nbsp;						con.addStatement(uc, toBeInserted.getSubject(), toBeInserted.getPredicate(),</b>
<b class="fc">&nbsp;								toBeInserted.getObject(), with);</b>
&nbsp;					} else {
<b class="fc">&nbsp;						con.addStatement(uc, toBeInserted.getSubject(), toBeInserted.getPredicate(),</b>
<b class="fc">&nbsp;								toBeInserted.getObject(), toBeInserted.getContext());</b>
&nbsp;					}
&nbsp;				}
<b class="fc">&nbsp;			}</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private Statement createStatementFromPattern(StatementPattern pattern, BindingSet sourceBinding,
&nbsp;			MapBindingSet bnodeMapping) throws SailException {
&nbsp;
<b class="fc">&nbsp;		Resource subject = null;</b>
<b class="fc">&nbsp;		IRI predicate = null;</b>
&nbsp;		Value object;
<b class="fc">&nbsp;		Resource context = null;</b>
&nbsp;
&nbsp;		Value patternValue;
<b class="fc">&nbsp;		if (pattern.getSubjectVar().hasValue()) {</b>
<b class="fc">&nbsp;			patternValue = pattern.getSubjectVar().getValue();</b>
<b class="pc">&nbsp;			if (patternValue instanceof Resource) {</b>
<b class="fc">&nbsp;				subject = (Resource) patternValue;</b>
&nbsp;			}
&nbsp;		} else {
<b class="fc">&nbsp;			patternValue = sourceBinding.getValue(pattern.getSubjectVar().getName());</b>
<b class="pc">&nbsp;			if (patternValue instanceof Resource) {</b>
<b class="fc">&nbsp;				subject = (Resource) patternValue;</b>
&nbsp;			}
&nbsp;
<b class="pc">&nbsp;			if (subject == null &amp;&amp; pattern.getSubjectVar().isAnonymous()) {</b>
<b class="nc">&nbsp;				Binding mappedSubject = bnodeMapping.getBinding(pattern.getSubjectVar().getName());</b>
&nbsp;
<b class="nc">&nbsp;				if (mappedSubject != null) {</b>
<b class="nc">&nbsp;					patternValue = mappedSubject.getValue();</b>
<b class="nc">&nbsp;					if (patternValue instanceof Resource) {</b>
<b class="nc">&nbsp;						subject = (Resource) patternValue;</b>
&nbsp;					}
&nbsp;				} else {
<b class="nc">&nbsp;					subject = vf.createBNode();</b>
<b class="nc">&nbsp;					bnodeMapping.addBinding(pattern.getSubjectVar().getName(), subject);</b>
&nbsp;				}
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="pc">&nbsp;		if (subject == null) {</b>
<b class="nc">&nbsp;			return null;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (pattern.getPredicateVar().hasValue()) {</b>
<b class="fc">&nbsp;			patternValue = pattern.getPredicateVar().getValue();</b>
<b class="pc">&nbsp;			if (patternValue instanceof IRI) {</b>
<b class="fc">&nbsp;				predicate = (IRI) patternValue;</b>
&nbsp;			}
&nbsp;		} else {
<b class="fc">&nbsp;			patternValue = sourceBinding.getValue(pattern.getPredicateVar().getName());</b>
<b class="pc">&nbsp;			if (patternValue instanceof IRI) {</b>
<b class="fc">&nbsp;				predicate = (IRI) patternValue;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="pc">&nbsp;		if (predicate == null) {</b>
<b class="nc">&nbsp;			return null;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (pattern.getObjectVar().hasValue()) {</b>
<b class="fc">&nbsp;			object = pattern.getObjectVar().getValue();</b>
&nbsp;		} else {
<b class="fc">&nbsp;			object = sourceBinding.getValue(pattern.getObjectVar().getName());</b>
&nbsp;
<b class="pc">&nbsp;			if (object == null &amp;&amp; pattern.getObjectVar().isAnonymous()) {</b>
<b class="nc">&nbsp;				Binding mappedObject = bnodeMapping.getBinding(pattern.getObjectVar().getName());</b>
&nbsp;
<b class="nc">&nbsp;				if (mappedObject != null) {</b>
<b class="nc">&nbsp;					patternValue = mappedObject.getValue();</b>
<b class="nc">&nbsp;					if (patternValue instanceof Resource) {</b>
<b class="nc">&nbsp;						object = (Resource) patternValue;</b>
&nbsp;					}
&nbsp;				} else {
<b class="nc">&nbsp;					object = vf.createBNode();</b>
<b class="nc">&nbsp;					bnodeMapping.addBinding(pattern.getObjectVar().getName(), object);</b>
&nbsp;				}
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="pc">&nbsp;		if (object == null) {</b>
<b class="nc">&nbsp;			return null;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (pattern.getContextVar() != null) {</b>
<b class="pc">&nbsp;			if (pattern.getContextVar().hasValue()) {</b>
<b class="fc">&nbsp;				patternValue = pattern.getContextVar().getValue();</b>
<b class="pc">&nbsp;				if (patternValue instanceof Resource) {</b>
<b class="fc">&nbsp;					context = (Resource) patternValue;</b>
&nbsp;				}
&nbsp;			} else {
<b class="nc">&nbsp;				patternValue = sourceBinding.getValue(pattern.getContextVar().getName());</b>
<b class="nc">&nbsp;				if (patternValue instanceof Resource) {</b>
<b class="nc">&nbsp;					context = (Resource) patternValue;</b>
&nbsp;				}
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		Statement st = null;</b>
<b class="pc">&nbsp;		if (subject != null &amp;&amp; predicate != null &amp;&amp; object != null) {</b>
<b class="fc">&nbsp;			if (context != null) {</b>
<b class="fc">&nbsp;				st = vf.createStatement(subject, predicate, object, context);</b>
&nbsp;			} else {
<b class="fc">&nbsp;				st = vf.createStatement(subject, predicate, object);</b>
&nbsp;			}
&nbsp;		}
<b class="fc">&nbsp;		return st;</b>
&nbsp;	}
&nbsp;
&nbsp;	private Value getValueForVar(Var var, BindingSet bindings) throws SailException {
&nbsp;		Value value;
<b class="fc">&nbsp;		if (var.hasValue()) {</b>
<b class="fc">&nbsp;			value = var.getValue();</b>
&nbsp;		} else {
<b class="fc">&nbsp;			value = bindings.getValue(var.getName());</b>
&nbsp;		}
<b class="fc">&nbsp;		return value;</b>
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:20</div>
</div>
</body>
</html>
