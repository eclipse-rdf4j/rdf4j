


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > Shape</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.sail.shacl.ast</a>
</div>

<h1>Coverage Summary for Class: Shape (org.eclipse.rdf4j.sail.shacl.ast)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Shape</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/80)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/207)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Shape$Factory</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/46)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/80)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/38)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/126)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/287)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2020 Eclipse RDF4J contributors.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;package org.eclipse.rdf4j.sail.shacl.ast;
&nbsp;
&nbsp;import java.io.StringWriter;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Set;
&nbsp;import java.util.stream.Collectors;
&nbsp;import java.util.stream.Stream;
&nbsp;
&nbsp;import org.eclipse.rdf4j.model.IRI;
&nbsp;import org.eclipse.rdf4j.model.Literal;
&nbsp;import org.eclipse.rdf4j.model.Model;
&nbsp;import org.eclipse.rdf4j.model.Resource;
&nbsp;import org.eclipse.rdf4j.model.impl.DynamicModel;
&nbsp;import org.eclipse.rdf4j.model.impl.LinkedHashModelFactory;
&nbsp;import org.eclipse.rdf4j.model.util.ModelBuilder;
&nbsp;import org.eclipse.rdf4j.model.vocabulary.DASH;
&nbsp;import org.eclipse.rdf4j.model.vocabulary.RDF;
&nbsp;import org.eclipse.rdf4j.model.vocabulary.RDFS;
&nbsp;import org.eclipse.rdf4j.model.vocabulary.RSX;
&nbsp;import org.eclipse.rdf4j.model.vocabulary.SHACL;
&nbsp;import org.eclipse.rdf4j.model.vocabulary.XSD;
&nbsp;import org.eclipse.rdf4j.rio.RDFFormat;
&nbsp;import org.eclipse.rdf4j.rio.Rio;
&nbsp;import org.eclipse.rdf4j.rio.WriterConfig;
&nbsp;import org.eclipse.rdf4j.rio.helpers.BasicWriterSettings;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ShaclSail;
&nbsp;import org.eclipse.rdf4j.sail.shacl.SourceConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ValidationSettings;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.AndConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.ClassConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.ClosedConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.ConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.DashHasValueInConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.DatatypeConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.DisjointConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.EqualsConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.HasValueConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.InConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.LanguageInConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.LessThanConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.LessThanOrEqualsConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.MaxCountConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.MaxExclusiveConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.MaxInclusiveConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.MaxLengthConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.MinCountConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.MinExclusiveConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.MinInclusiveConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.MinLengthConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.NodeKindConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.NotConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.OrConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.PatternConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.QualifiedMaxCountConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.QualifiedMinCountConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.UniqueLangConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.XoneConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.planNodes.EmptyNode;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.planNodes.PlanNode;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.targets.DashAllObjects;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.targets.DashAllSubjects;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.targets.RSXTargetShape;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.targets.Target;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.targets.TargetChain;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.targets.TargetClass;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.targets.TargetNode;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.targets.TargetObjectsOf;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.targets.TargetSubjectsOf;
&nbsp;import org.eclipse.rdf4j.sail.shacl.wrapper.data.ConnectionsGroup;
&nbsp;import org.eclipse.rdf4j.sail.shacl.wrapper.data.RdfsSubClassOfReasoner;
&nbsp;import org.eclipse.rdf4j.sail.shacl.wrapper.shape.ShapeSource;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;
<b class="nc">&nbsp;abstract public class Shape implements ConstraintComponent, Identifiable {</b>
&nbsp;
<b class="nc">&nbsp;	private static final Logger logger = LoggerFactory.getLogger(Shape.class);</b>
&nbsp;	protected boolean produceValidationReports;
&nbsp;
&nbsp;	Resource id;
&nbsp;	TargetChain targetChain;
&nbsp;
<b class="nc">&nbsp;	List&lt;Target&gt; target = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;	boolean deactivated;
&nbsp;	List&lt;Literal&gt; message;
<b class="nc">&nbsp;	Severity severity = Severity.Violation;</b>
&nbsp;
<b class="nc">&nbsp;	List&lt;ConstraintComponent&gt; constraintComponents = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;	Resource[] contexts;
&nbsp;
<b class="nc">&nbsp;	public Shape() {</b>
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public Shape(Shape shape) {</b>
<b class="nc">&nbsp;		this.deactivated = shape.deactivated;</b>
<b class="nc">&nbsp;		this.message = shape.message;</b>
<b class="nc">&nbsp;		this.severity = shape.severity;</b>
<b class="nc">&nbsp;		this.id = shape.id;</b>
<b class="nc">&nbsp;		this.targetChain = shape.targetChain;</b>
<b class="nc">&nbsp;		this.contexts = shape.contexts;</b>
<b class="nc">&nbsp;		this.produceValidationReports = shape.produceValidationReports;</b>
&nbsp;	}
&nbsp;
&nbsp;	public void populate(ShaclProperties properties, ShapeSource shapeSource, Cache cache,
&nbsp;			ShaclSail shaclSail) {
<b class="nc">&nbsp;		this.deactivated = properties.isDeactivated();</b>
<b class="nc">&nbsp;		this.message = properties.getMessage();</b>
<b class="nc">&nbsp;		this.id = properties.getId();</b>
<b class="nc">&nbsp;		this.contexts = shapeSource.getActiveContexts();</b>
&nbsp;
<b class="nc">&nbsp;		if (!properties.getTargetClass().isEmpty()) {</b>
<b class="nc">&nbsp;			target.add(new TargetClass(properties.getTargetClass()));</b>
&nbsp;		}
<b class="nc">&nbsp;		if (!properties.getTargetNode().isEmpty()) {</b>
<b class="nc">&nbsp;			target.add(new TargetNode(properties.getTargetNode(), shapeSource.getActiveContexts()));</b>
&nbsp;		}
<b class="nc">&nbsp;		if (!properties.getTargetObjectsOf().isEmpty()) {</b>
<b class="nc">&nbsp;			target.add(new TargetObjectsOf(properties.getTargetObjectsOf()));</b>
&nbsp;		}
<b class="nc">&nbsp;		if (!properties.getTargetSubjectsOf().isEmpty()) {</b>
<b class="nc">&nbsp;			target.add(new TargetSubjectsOf(properties.getTargetSubjectsOf()));</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (shaclSail.isEclipseRdf4jShaclExtensions() &amp;&amp; !properties.getTargetShape().isEmpty()) {</b>
&nbsp;
<b class="nc">&nbsp;			properties.getTargetShape()</b>
<b class="nc">&nbsp;					.stream()</b>
<b class="nc">&nbsp;					.map(targetShape -&gt; new RSXTargetShape(targetShape, shapeSource, shaclSail))</b>
<b class="nc">&nbsp;					.forEach(target::add);</b>
&nbsp;
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (!properties.getTarget().isEmpty()) {</b>
<b class="nc">&nbsp;			properties.getTarget()</b>
<b class="nc">&nbsp;					.forEach(target -&gt; {</b>
&nbsp;//									if (shapeSource.hasStatement(sparqlTarget, RDF.TYPE, SHACL.SPARQL_TARGET, true)) {
&nbsp;//										propertyShapes.add(new SparqlTarget(shapeId, shaclSail, shapeSource,
&nbsp;//												shaclProperties.isDeactivated(), target));
&nbsp;//									}
<b class="nc">&nbsp;						if (shaclSail.isDashDataShapes() &amp;&amp; shapeSource.isType(target,</b>
&nbsp;								DASH.AllObjectsTarget)) {
<b class="nc">&nbsp;							this.target.add(new DashAllObjects(target));</b>
&nbsp;						}
<b class="nc">&nbsp;						if (shaclSail.isDashDataShapes() &amp;&amp; shapeSource.isType(target,</b>
&nbsp;								DASH.AllSubjectsTarget)) {
<b class="nc">&nbsp;							this.target.add(new DashAllSubjects(target));</b>
&nbsp;						}
&nbsp;
&nbsp;					});
&nbsp;
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Resource getId() {
<b class="nc">&nbsp;		return id;</b>
&nbsp;	}
&nbsp;
&nbsp;	public Resource[] getContexts() {
<b class="nc">&nbsp;		return contexts;</b>
&nbsp;	}
&nbsp;
&nbsp;	protected abstract Shape shallowClone();
&nbsp;
&nbsp;	/**
&nbsp;	 * @param model the model to export the shapes into
&nbsp;	 * @return the provided model
&nbsp;	 */
&nbsp;	public Model toModel(Model model) {
<b class="nc">&nbsp;		toModel(null, null, model, new HashSet&lt;&gt;());</b>
<b class="nc">&nbsp;		return model;</b>
&nbsp;	}
&nbsp;
&nbsp;	public void toModel(Resource subject, IRI predicate, Model model, Set&lt;Resource&gt; cycleDetection) {
<b class="nc">&nbsp;		ModelBuilder modelBuilder = new ModelBuilder();</b>
&nbsp;
<b class="nc">&nbsp;		modelBuilder.subject(getId());</b>
&nbsp;
<b class="nc">&nbsp;		if (deactivated) {</b>
<b class="nc">&nbsp;			modelBuilder.add(SHACL.DEACTIVATED, deactivated);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		target.forEach(t -&gt; {</b>
<b class="nc">&nbsp;			t.toModel(getId(), null, model, cycleDetection);</b>
&nbsp;		});
&nbsp;
<b class="nc">&nbsp;		model.addAll(modelBuilder.build());</b>
&nbsp;	}
&nbsp;
&nbsp;	List&lt;ConstraintComponent&gt; getConstraintComponents(ShaclProperties properties, ShapeSource shapeSource,
&nbsp;			Cache cache, ShaclSail shaclSail) {
&nbsp;
<b class="nc">&nbsp;		List&lt;ConstraintComponent&gt; constraintComponent = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;		properties.getProperty()</b>
<b class="nc">&nbsp;				.stream()</b>
<b class="nc">&nbsp;				.map(r -&gt; new ShaclProperties(r, shapeSource))</b>
<b class="nc">&nbsp;				.map(p -&gt; PropertyShape.getInstance(p, shapeSource, cache, shaclSail))</b>
<b class="nc">&nbsp;				.forEach(constraintComponent::add);</b>
&nbsp;
<b class="nc">&nbsp;		properties.getNode()</b>
<b class="nc">&nbsp;				.stream()</b>
<b class="nc">&nbsp;				.map(r -&gt; new ShaclProperties(r, shapeSource))</b>
<b class="nc">&nbsp;				.map(p -&gt; NodeShape.getInstance(p, shapeSource, cache, shaclSail))</b>
<b class="nc">&nbsp;				.forEach(constraintComponent::add);</b>
&nbsp;
<b class="nc">&nbsp;		if (properties.getMinCount() != null) {</b>
<b class="nc">&nbsp;			constraintComponent.add(new MinCountConstraintComponent(properties.getMinCount()));</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (properties.getMaxCount() != null) {</b>
<b class="nc">&nbsp;			constraintComponent.add(new MaxCountConstraintComponent(properties.getMaxCount()));</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (properties.getDatatype() != null) {</b>
<b class="nc">&nbsp;			constraintComponent.add(new DatatypeConstraintComponent(properties.getDatatype()));</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (properties.getMinLength() != null) {</b>
<b class="nc">&nbsp;			constraintComponent.add(new MinLengthConstraintComponent(properties.getMinLength()));</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (properties.getMaxLength() != null) {</b>
<b class="nc">&nbsp;			constraintComponent.add(new MaxLengthConstraintComponent(properties.getMaxLength()));</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (properties.getMinInclusive() != null) {</b>
<b class="nc">&nbsp;			constraintComponent.add(new MinInclusiveConstraintComponent(properties.getMinInclusive()));</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (properties.getMaxInclusive() != null) {</b>
<b class="nc">&nbsp;			constraintComponent.add(new MaxInclusiveConstraintComponent(properties.getMaxInclusive()));</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (properties.getMinExclusive() != null) {</b>
<b class="nc">&nbsp;			constraintComponent.add(new MinExclusiveConstraintComponent(properties.getMinExclusive()));</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (properties.getMaxExclusive() != null) {</b>
<b class="nc">&nbsp;			constraintComponent.add(new MaxExclusiveConstraintComponent(properties.getMaxExclusive()));</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (properties.isUniqueLang()) {</b>
<b class="nc">&nbsp;			constraintComponent.add(new UniqueLangConstraintComponent());</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		properties.getPattern()</b>
<b class="nc">&nbsp;				.stream()</b>
<b class="nc">&nbsp;				.map(pattern -&gt; new PatternConstraintComponent(pattern, properties.getFlags()))</b>
<b class="nc">&nbsp;				.forEach(constraintComponent::add);</b>
&nbsp;
<b class="nc">&nbsp;		if (properties.getLanguageIn() != null) {</b>
<b class="nc">&nbsp;			constraintComponent.add(new LanguageInConstraintComponent(shapeSource, properties.getLanguageIn()));</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (properties.getIn() != null) {</b>
<b class="nc">&nbsp;			constraintComponent.add(new InConstraintComponent(shapeSource, properties.getIn()));</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (properties.getNodeKind() != null) {</b>
<b class="nc">&nbsp;			constraintComponent.add(new NodeKindConstraintComponent(properties.getNodeKind()));</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (properties.isClosed()) {</b>
<b class="nc">&nbsp;			constraintComponent.add(new ClosedConstraintComponent(shapeSource, properties.getProperty(),</b>
<b class="nc">&nbsp;					properties.getIgnoredProperties()));</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		properties.getClazz()</b>
<b class="nc">&nbsp;				.stream()</b>
<b class="nc">&nbsp;				.map(ClassConstraintComponent::new)</b>
<b class="nc">&nbsp;				.forEach(constraintComponent::add);</b>
&nbsp;
<b class="nc">&nbsp;		properties.getHasValue()</b>
<b class="nc">&nbsp;				.stream()</b>
<b class="nc">&nbsp;				.map(HasValueConstraintComponent::new)</b>
<b class="nc">&nbsp;				.forEach(constraintComponent::add);</b>
&nbsp;
<b class="nc">&nbsp;		properties.getEquals()</b>
<b class="nc">&nbsp;				.stream()</b>
<b class="nc">&nbsp;				.map(EqualsConstraintComponent::new)</b>
<b class="nc">&nbsp;				.forEach(constraintComponent::add);</b>
&nbsp;
<b class="nc">&nbsp;		properties.getDisjoint()</b>
<b class="nc">&nbsp;				.stream()</b>
<b class="nc">&nbsp;				.map(DisjointConstraintComponent::new)</b>
<b class="nc">&nbsp;				.forEach(constraintComponent::add);</b>
&nbsp;
<b class="nc">&nbsp;		properties.getLessThan()</b>
<b class="nc">&nbsp;				.stream()</b>
<b class="nc">&nbsp;				.map(LessThanConstraintComponent::new)</b>
<b class="nc">&nbsp;				.forEach(constraintComponent::add);</b>
&nbsp;
<b class="nc">&nbsp;		properties.getLessThanOrEquals()</b>
<b class="nc">&nbsp;				.stream()</b>
<b class="nc">&nbsp;				.map(LessThanOrEqualsConstraintComponent::new)</b>
<b class="nc">&nbsp;				.forEach(constraintComponent::add);</b>
&nbsp;
<b class="nc">&nbsp;		if (properties.getQualifiedValueShape() != null) {</b>
&nbsp;
<b class="nc">&nbsp;			if (properties.getQualifiedMaxCount() != null) {</b>
<b class="nc">&nbsp;				QualifiedMaxCountConstraintComponent qualifiedMaxCountConstraintComponent = new QualifiedMaxCountConstraintComponent(</b>
<b class="nc">&nbsp;						properties.getQualifiedValueShape(), shapeSource, cache, shaclSail,</b>
<b class="nc">&nbsp;						properties.getQualifiedValueShapesDisjoint(), properties.getQualifiedMaxCount());</b>
<b class="nc">&nbsp;				constraintComponent.add(qualifiedMaxCountConstraintComponent);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (properties.getQualifiedMinCount() != null) {</b>
<b class="nc">&nbsp;				QualifiedMinCountConstraintComponent qualifiedMinCountConstraintComponent = new QualifiedMinCountConstraintComponent(</b>
<b class="nc">&nbsp;						properties.getQualifiedValueShape(), shapeSource, cache, shaclSail,</b>
<b class="nc">&nbsp;						properties.getQualifiedValueShapesDisjoint(), properties.getQualifiedMinCount());</b>
<b class="nc">&nbsp;				constraintComponent.add(qualifiedMinCountConstraintComponent);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (shaclSail.isDashDataShapes()) {</b>
<b class="nc">&nbsp;			properties.getHasValueIn()</b>
<b class="nc">&nbsp;					.stream()</b>
<b class="nc">&nbsp;					.map(hasValueIn -&gt; new DashHasValueInConstraintComponent(shapeSource, hasValueIn))</b>
<b class="nc">&nbsp;					.forEach(constraintComponent::add);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		properties.getOr()</b>
<b class="nc">&nbsp;				.stream()</b>
<b class="nc">&nbsp;				.map(or -&gt; new OrConstraintComponent(or, shapeSource, cache, shaclSail))</b>
<b class="nc">&nbsp;				.forEach(constraintComponent::add);</b>
&nbsp;
<b class="nc">&nbsp;		properties.getXone()</b>
<b class="nc">&nbsp;				.stream()</b>
<b class="nc">&nbsp;				.map(xone -&gt; new XoneConstraintComponent(xone, shapeSource, cache, shaclSail))</b>
<b class="nc">&nbsp;				.forEach(constraintComponent::add);</b>
&nbsp;
<b class="nc">&nbsp;		properties.getAnd()</b>
<b class="nc">&nbsp;				.stream()</b>
<b class="nc">&nbsp;				.map(and -&gt; new AndConstraintComponent(and, shapeSource, cache, shaclSail))</b>
<b class="nc">&nbsp;				.forEach(constraintComponent::add);</b>
&nbsp;
<b class="nc">&nbsp;		properties.getNot()</b>
<b class="nc">&nbsp;				.stream()</b>
<b class="nc">&nbsp;				.map(or -&gt; new NotConstraintComponent(or, shapeSource, cache, shaclSail))</b>
<b class="nc">&nbsp;				.forEach(constraintComponent::add);</b>
&nbsp;
<b class="nc">&nbsp;		return constraintComponent;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public TargetChain getTargetChain() {
<b class="nc">&nbsp;		return targetChain;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void setTargetChain(TargetChain targetChain) {
<b class="nc">&nbsp;		this.targetChain = targetChain;</b>
<b class="nc">&nbsp;		constraintComponents.forEach(c -&gt; c.setTargetChain(targetChain));</b>
&nbsp;	}
&nbsp;
&nbsp;	public PlanNode generatePlans(ConnectionsGroup connectionsGroup, ValidationSettings validationSettings) {
<b class="nc">&nbsp;		assert constraintComponents.size() == 1;</b>
&nbsp;
<b class="nc">&nbsp;		StatementMatcher.StableRandomVariableProvider stableRandomVariableProvider = new StatementMatcher.StableRandomVariableProvider();</b>
&nbsp;
<b class="nc">&nbsp;		ValidationApproach validationApproach = ValidationApproach.SPARQL;</b>
<b class="nc">&nbsp;		if (!validationSettings.isValidateEntireBaseSail()) {</b>
<b class="nc">&nbsp;			validationApproach = constraintComponents.stream()</b>
<b class="nc">&nbsp;					.map(constraintComponent -&gt; constraintComponent.getPreferredValidationApproach(connectionsGroup))</b>
<b class="nc">&nbsp;					.reduce(ValidationApproach::reducePreferred)</b>
<b class="nc">&nbsp;					.get();</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (validationApproach == ValidationApproach.SPARQL) {</b>
<b class="nc">&nbsp;			if (connectionsGroup.isSparqlValidation()</b>
<b class="nc">&nbsp;					&amp;&amp; Shape.this.getOptimalBulkValidationApproach() == ValidationApproach.SPARQL) {</b>
<b class="nc">&nbsp;				logger.debug(&quot;Use validation approach {} for shape {}&quot;, validationApproach, this);</b>
<b class="nc">&nbsp;				return Shape.this.generateSparqlValidationQuery(connectionsGroup, validationSettings, false, false,</b>
&nbsp;						Scope.none)
<b class="nc">&nbsp;						.getValidationPlan(connectionsGroup.getBaseConnection(), validationSettings.getDataGraph(),</b>
<b class="nc">&nbsp;								getContexts());</b>
&nbsp;			} else {
<b class="nc">&nbsp;				logger.debug(&quot;Use fall back validation approach for bulk validation instead of SPARQL for shape {}&quot;,</b>
&nbsp;						this);
&nbsp;
<b class="nc">&nbsp;				return Shape.this.generateTransactionalValidationPlan(connectionsGroup, validationSettings,</b>
<b class="nc">&nbsp;						() -&gt; Shape.this.getTargetChain()</b>
<b class="nc">&nbsp;								.getEffectiveTarget(</b>
<b class="nc">&nbsp;										this instanceof NodeShape ? Scope.nodeShape : Scope.propertyShape,</b>
<b class="nc">&nbsp;										connectionsGroup.getRdfsSubClassOfReasoner(), stableRandomVariableProvider)</b>
<b class="nc">&nbsp;								.getAllTargets(connectionsGroup,</b>
<b class="nc">&nbsp;										validationSettings.getDataGraph(),</b>
<b class="nc">&nbsp;										this instanceof NodeShape ? Scope.nodeShape : Scope.propertyShape),</b>
&nbsp;						Scope.none);
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;		} else if (validationApproach == ValidationApproach.Transactional) {</b>
<b class="nc">&nbsp;			logger.debug(&quot;Use validation approach {} for shape {}&quot;, validationApproach, this);</b>
&nbsp;
<b class="nc">&nbsp;			if (this.requiresEvaluation(connectionsGroup, Scope.none, validationSettings.getDataGraph(),</b>
&nbsp;					stableRandomVariableProvider)) {
<b class="nc">&nbsp;				return Shape.this.generateTransactionalValidationPlan(connectionsGroup, validationSettings, null,</b>
&nbsp;						Scope.none);
&nbsp;			} else {
<b class="nc">&nbsp;				return EmptyNode.getInstance();</b>
&nbsp;			}
&nbsp;
&nbsp;		} else {
<b class="nc">&nbsp;			throw new ShaclUnsupportedException(&quot;Unkown validation approach: &quot; + validationApproach);</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public SourceConstraintComponent getConstraintComponent() {
<b class="nc">&nbsp;		throw new ShaclUnsupportedException(this.getClass().getSimpleName());</b>
&nbsp;	}
&nbsp;
&nbsp;	public Severity getSeverity() {
<b class="nc">&nbsp;		return severity;</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean isDeactivated() {
<b class="nc">&nbsp;		return deactivated;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public boolean requiresEvaluation(ConnectionsGroup connectionsGroup, Scope scope, Resource[] dataGraph,
&nbsp;			StatementMatcher.StableRandomVariableProvider stableRandomVariableProvider) {
<b class="nc">&nbsp;		return constraintComponents.stream()</b>
<b class="nc">&nbsp;				.anyMatch(c -&gt; c.requiresEvaluation(connectionsGroup, scope, dataGraph, stableRandomVariableProvider));</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * For rsx:targetShape
&nbsp;	 */
&nbsp;	public SparqlFragment buildSparqlValidNodes_rsx_targetShape(StatementMatcher.Variable subject,
&nbsp;			StatementMatcher.Variable object,
&nbsp;			RdfsSubClassOfReasoner rdfsSubClassOfReasoner, Scope scope,
&nbsp;			StatementMatcher.StableRandomVariableProvider stableRandomVariableProvider) {
<b class="nc">&nbsp;		throw new UnsupportedOperationException(this.getClass().getSimpleName());</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public ValidationApproach getOptimalBulkValidationApproach() {
<b class="nc">&nbsp;		return constraintComponents.stream()</b>
<b class="nc">&nbsp;				.map(ConstraintComponent::getOptimalBulkValidationApproach)</b>
<b class="nc">&nbsp;				.reduce(ValidationApproach::reduceCompatible)</b>
<b class="nc">&nbsp;				.orElse(ValidationApproach.MOST_COMPATIBLE);</b>
&nbsp;
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public static class Factory {</b>
&nbsp;
&nbsp;		public static List&lt;ContextWithShapes&gt; getShapes(ShapeSource shapeSource, ShaclSail shaclSail) {
&nbsp;
<b class="nc">&nbsp;			List&lt;ContextWithShapes&gt; parsed = parse(shapeSource, shaclSail);</b>
&nbsp;
<b class="nc">&nbsp;			return parsed.stream()</b>
<b class="nc">&nbsp;					.map(contextWithShapes -&gt; {</b>
<b class="nc">&nbsp;						List&lt;Shape&gt; split = split(contextWithShapes.getShapes());</b>
<b class="nc">&nbsp;						calculateTargetChain(split);</b>
<b class="nc">&nbsp;						calculateIfProducesValidationResult(split);</b>
<b class="nc">&nbsp;						return new ContextWithShapes(contextWithShapes.getDataGraph(),</b>
<b class="nc">&nbsp;								contextWithShapes.getShapeGraph(), split);</b>
&nbsp;
&nbsp;					})
<b class="nc">&nbsp;					.collect(Collectors.toList());</b>
&nbsp;
&nbsp;		}
&nbsp;
&nbsp;		private static void calculateIfProducesValidationResult(List&lt;Shape&gt; split) {
<b class="nc">&nbsp;			for (Shape shape : split) {</b>
<b class="nc">&nbsp;				assert shape.constraintComponents.size() == 1;</b>
&nbsp;
<b class="nc">&nbsp;				if (shape instanceof PropertyShape || shape.constraintComponents.get(0) instanceof PropertyShape) {</b>
&nbsp;
&nbsp;					PropertyShape propertyShape;
<b class="nc">&nbsp;					if (shape instanceof PropertyShape) {</b>
<b class="nc">&nbsp;						propertyShape = (PropertyShape) shape;</b>
&nbsp;					} else {
<b class="nc">&nbsp;						propertyShape = (PropertyShape) shape.constraintComponents.get(0);</b>
&nbsp;					}
&nbsp;
&nbsp;					// Nested PropertyShape constraints only produce a validation result for the last PropertyShape in
&nbsp;					// the chain of PropertyShapes.
<b class="nc">&nbsp;					while (propertyShape.constraintComponents.get(0) instanceof PropertyShape) {</b>
<b class="nc">&nbsp;						assert propertyShape.constraintComponents.size() == 1;</b>
<b class="nc">&nbsp;						if (propertyShape.constraintComponents.get(0) instanceof PropertyShape) {</b>
<b class="nc">&nbsp;							propertyShape = (PropertyShape) propertyShape.constraintComponents.get(0);</b>
&nbsp;						}
&nbsp;					}
&nbsp;
<b class="nc">&nbsp;					propertyShape.produceValidationReports = true;</b>
&nbsp;
<b class="nc">&nbsp;				} else if (shape instanceof NodeShape) {</b>
<b class="nc">&nbsp;					shape.produceValidationReports = true;</b>
&nbsp;				}
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		private static void calculateTargetChain(List&lt;Shape&gt; parsed) {
<b class="nc">&nbsp;			for (Shape shape : parsed) {</b>
<b class="nc">&nbsp;				assert (shape.target.size() == 1);</b>
&nbsp;
<b class="nc">&nbsp;				shape.setTargetChain(new TargetChain().add(shape.target.get(0)));</b>
&nbsp;
<b class="nc">&nbsp;			}</b>
&nbsp;
&nbsp;		}
&nbsp;
&nbsp;		private static List&lt;Shape&gt; split(List&lt;Shape&gt; collect) {
&nbsp;			// split into shapes by target and constraint component to be able to run them in parallel
<b class="nc">&nbsp;			return collect.stream().flatMap(s -&gt; {</b>
<b class="nc">&nbsp;				List&lt;Shape&gt; temp = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;				s.target.forEach(target -&gt; {</b>
<b class="nc">&nbsp;					s.constraintComponents.forEach(constraintComponent -&gt; {</b>
&nbsp;
<b class="nc">&nbsp;						if (constraintComponent instanceof PropertyShape) {</b>
<b class="nc">&nbsp;							List&lt;PropertyShape&gt; split = splitPropertyShape(((PropertyShape) constraintComponent))</b>
<b class="nc">&nbsp;									.collect(Collectors.toList());</b>
<b class="nc">&nbsp;							for (PropertyShape propertyShape : split) {</b>
<b class="nc">&nbsp;								Shape shape = s.shallowClone();</b>
<b class="nc">&nbsp;								shape.target.add(target);</b>
<b class="nc">&nbsp;								shape.constraintComponents.add(propertyShape);</b>
<b class="nc">&nbsp;								temp.add(shape);</b>
<b class="nc">&nbsp;							}</b>
<b class="nc">&nbsp;						} else {</b>
<b class="nc">&nbsp;							Shape shape = s.shallowClone();</b>
<b class="nc">&nbsp;							shape.target.add(target);</b>
<b class="nc">&nbsp;							shape.constraintComponents.add(constraintComponent);</b>
<b class="nc">&nbsp;							temp.add(shape);</b>
&nbsp;
&nbsp;						}
&nbsp;
&nbsp;					});
&nbsp;				});
<b class="nc">&nbsp;				return temp.stream();</b>
<b class="nc">&nbsp;			}).collect(Collectors.toList());</b>
&nbsp;		}
&nbsp;
&nbsp;		private static Stream&lt;PropertyShape&gt; splitPropertyShape(PropertyShape propertyShape) {
<b class="nc">&nbsp;			return propertyShape.constraintComponents.stream()</b>
<b class="nc">&nbsp;					.flatMap(constraintComponent -&gt; {</b>
<b class="nc">&nbsp;						if (constraintComponent instanceof PropertyShape) {</b>
<b class="nc">&nbsp;							return splitPropertyShape(((PropertyShape) constraintComponent))</b>
<b class="nc">&nbsp;									.map(splitConstraintComponent -&gt; {</b>
<b class="nc">&nbsp;										PropertyShape propertyShapeClone = (PropertyShape) propertyShape.shallowClone();</b>
<b class="nc">&nbsp;										propertyShapeClone.constraintComponents.add(splitConstraintComponent);</b>
<b class="nc">&nbsp;										return propertyShapeClone;</b>
&nbsp;									});
&nbsp;						} else {
<b class="nc">&nbsp;							PropertyShape propertyShapeClone = (PropertyShape) propertyShape.shallowClone();</b>
<b class="nc">&nbsp;							propertyShapeClone.constraintComponents.add(constraintComponent.deepClone());</b>
<b class="nc">&nbsp;							return Stream.of(propertyShapeClone);</b>
&nbsp;						}
&nbsp;					});
&nbsp;		}
&nbsp;
&nbsp;		private static List&lt;ContextWithShapes&gt; parse(ShapeSource shapeSource, ShaclSail shaclSail) {
&nbsp;
<b class="nc">&nbsp;			try (Stream&lt;ShapeSource.ShapesGraph&gt; allShapeContexts = shapeSource.getAllShapeContexts()) {</b>
<b class="nc">&nbsp;				return allShapeContexts</b>
<b class="nc">&nbsp;						.map(shapesGraph -&gt; {</b>
<b class="nc">&nbsp;							Cache cache = new Cache();</b>
<b class="nc">&nbsp;							return getShapesInContext(shapeSource, shaclSail, cache, shapesGraph.getDataGraph(),</b>
<b class="nc">&nbsp;									shapesGraph.getShapesGraph());</b>
&nbsp;						})
<b class="nc">&nbsp;						.collect(Collectors.toList());</b>
&nbsp;
<b class="nc">&nbsp;			}</b>
&nbsp;
&nbsp;		}
&nbsp;
&nbsp;		private static ContextWithShapes getShapesInContext(ShapeSource shapeSource, ShaclSail shaclSail, Cache cache,
&nbsp;				Resource[] dataGraph, Resource[] shapesGraph) {
<b class="nc">&nbsp;			ShapeSource shapeSourceWithContext = shapeSource.withContext(shapesGraph);</b>
&nbsp;
<b class="nc">&nbsp;			try (Stream&lt;Resource&gt; resources = shapeSourceWithContext.getTargetableShape()) {</b>
<b class="nc">&nbsp;				List&lt;Shape&gt; shapes = resources</b>
<b class="nc">&nbsp;						.map(r -&gt; new ShaclProperties(r, shapeSourceWithContext))</b>
<b class="nc">&nbsp;						.map(p -&gt; {</b>
<b class="nc">&nbsp;							if (p.getType() == SHACL.NODE_SHAPE) {</b>
<b class="nc">&nbsp;								return NodeShape.getInstance(p, shapeSourceWithContext, cache, shaclSail);</b>
<b class="nc">&nbsp;							} else if (p.getType() == SHACL.PROPERTY_SHAPE) {</b>
<b class="nc">&nbsp;								return PropertyShape.getInstance(p, shapeSourceWithContext, cache, shaclSail);</b>
&nbsp;							}
<b class="nc">&nbsp;							throw new IllegalStateException(&quot;Unknown shape type for &quot; + p.getId());</b>
&nbsp;						})
<b class="nc">&nbsp;						.collect(Collectors.toList());</b>
&nbsp;
<b class="nc">&nbsp;				return new ContextWithShapes(dataGraph, shapesGraph, shapes);</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public String toString() {
<b class="nc">&nbsp;		Model statements = toModel(new DynamicModel(new LinkedHashModelFactory()));</b>
<b class="nc">&nbsp;		statements.setNamespace(SHACL.NS);</b>
<b class="nc">&nbsp;		statements.setNamespace(XSD.NS);</b>
<b class="nc">&nbsp;		statements.setNamespace(RSX.NS);</b>
<b class="nc">&nbsp;		statements.setNamespace(RDFS.NS);</b>
<b class="nc">&nbsp;		statements.setNamespace(RDF.NS);</b>
<b class="nc">&nbsp;		WriterConfig writerConfig = new WriterConfig();</b>
<b class="nc">&nbsp;		writerConfig.set(BasicWriterSettings.PRETTY_PRINT, true);</b>
<b class="nc">&nbsp;		writerConfig.set(BasicWriterSettings.INLINE_BLANK_NODES, true);</b>
&nbsp;
<b class="nc">&nbsp;		StringWriter stringWriter = new StringWriter();</b>
<b class="nc">&nbsp;		Rio.write(statements, stringWriter, RDFFormat.TURTLE, writerConfig);</b>
&nbsp;
<b class="nc">&nbsp;		return stringWriter.toString()</b>
<b class="nc">&nbsp;				.replaceAll(&quot;(?m)^(@prefix)(.*)(\\.)$&quot;, &quot;&quot;) // remove all lines that are prefix declarations</b>
<b class="nc">&nbsp;				.trim();</b>
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:20</div>
</div>
</body>
</html>
