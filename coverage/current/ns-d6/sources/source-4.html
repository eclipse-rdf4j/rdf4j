


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > IDFile</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.sail.nativerdf.datastore</a>
</div>

<h1>Coverage Summary for Class: IDFile (org.eclipse.rdf4j.sail.nativerdf.datastore)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">IDFile</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/78)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;package org.eclipse.rdf4j.sail.nativerdf.datastore;
&nbsp;
&nbsp;import java.io.Closeable;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.math.RoundingMode;
&nbsp;import java.util.Arrays;
&nbsp;
&nbsp;import org.eclipse.rdf4j.common.io.NioFile;
&nbsp;
&nbsp;import com.google.common.cache.Cache;
&nbsp;import com.google.common.cache.CacheBuilder;
&nbsp;import com.google.common.math.LongMath;
&nbsp;
&nbsp;/**
&nbsp; * Class supplying access to an ID file. An ID file maps IDs (integers &amp;gt;= 1) to file pointers (long integers). There
&nbsp; * is a direct correlation between IDs and the position at which the file pointers are stored; the file pointer for ID X
&nbsp; * is stored at position 8*X.
&nbsp; *
&nbsp; * This class supports parallel reads but not parallel writes.
&nbsp; *
&nbsp; * @author Arjohn Kampman
&nbsp; */
<b class="nc">&nbsp;public class IDFile implements Closeable {</b>
&nbsp;
&nbsp;	/*-----------*
&nbsp;	 * Constants *
&nbsp;	 *-----------*/
&nbsp;
&nbsp;	/**
&nbsp;	 * Magic number &quot;Native ID File&quot; to detect whether the file is actually an ID file. The first three bytes of the
&nbsp;	 * file should be equal to this magic number.
&nbsp;	 */
<b class="nc">&nbsp;	private static final byte[] MAGIC_NUMBER = new byte[] { &#39;n&#39;, &#39;i&#39;, &#39;f&#39; };</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * File format version, stored as the fourth byte in ID files.
&nbsp;	 */
&nbsp;	private static final byte FILE_FORMAT_VERSION = 1;
&nbsp;
&nbsp;	/**
&nbsp;	 * The size of the file header in bytes. The file header contains the following data: magic number (3 bytes) file
&nbsp;	 * format version (1 byte) and 4 dummy bytes to align data at 8-byte offsets.
&nbsp;	 */
&nbsp;	private static final long HEADER_LENGTH = 8;
&nbsp;
&nbsp;	private static final long ITEM_SIZE = 8L;
&nbsp;
&nbsp;	/*-----------*
&nbsp;	 * Variables *
&nbsp;	 *-----------*/
&nbsp;
&nbsp;	private final NioFile nioFile;
&nbsp;
&nbsp;	private final boolean forceSync;
&nbsp;
&nbsp;	// A cache for lines read from the file index. This cache is unlimited size and uses soft values to allow GC of
&nbsp;	// unreferenced lines when under memory pressure.
<b class="nc">&nbsp;	private final Cache&lt;Integer, Long[]&gt; cache = CacheBuilder.newBuilder().softValues().build();</b>
&nbsp;
&nbsp;	// We choose a cacheLineSize of 4KB since this is a typical file system block size.
<b class="nc">&nbsp;	private final int blockSize = 4 * 1024; // 4KB</b>
<b class="nc">&nbsp;	private final int cacheLineSize = (int) (blockSize / ITEM_SIZE);</b>
<b class="nc">&nbsp;	private final int cacheLineShift = LongMath.log2(cacheLineSize, RoundingMode.UNNECESSARY);</b>
&nbsp;
&nbsp;	// keeping a reference of the last created cache line here should stop GC from removing it
&nbsp;	private int gcReducingCacheIndex;
&nbsp;	private Long[] gcReducingCache;
&nbsp;
&nbsp;	// cached file size
&nbsp;	private volatile long nioFileSize;
&nbsp;
&nbsp;	/*--------------*
&nbsp;	 * Constructors *
&nbsp;	 *--------------*/
&nbsp;
&nbsp;	public IDFile(File file) throws IOException {
<b class="nc">&nbsp;		this(file, false);</b>
<b class="nc">&nbsp;		nioFileSize = nioFile.size();</b>
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public IDFile(File file, boolean forceSync) throws IOException {</b>
<b class="nc">&nbsp;		this.nioFile = new NioFile(file);</b>
<b class="nc">&nbsp;		this.forceSync = forceSync;</b>
&nbsp;
&nbsp;		try {
<b class="nc">&nbsp;			if (nioFile.size() == 0L) {</b>
&nbsp;				// Empty file, write header
<b class="nc">&nbsp;				nioFile.writeBytes(MAGIC_NUMBER, 0);</b>
<b class="nc">&nbsp;				nioFile.writeByte(FILE_FORMAT_VERSION, 3);</b>
<b class="nc">&nbsp;				nioFile.writeBytes(new byte[] { 0, 0, 0, 0 }, 4);</b>
&nbsp;
<b class="nc">&nbsp;				sync();</b>
<b class="nc">&nbsp;			} else if (nioFile.size() &lt; HEADER_LENGTH) {</b>
<b class="nc">&nbsp;				throw new IOException(&quot;File too small to be a compatible ID file&quot;);</b>
&nbsp;			} else {
&nbsp;				// Verify file header
<b class="nc">&nbsp;				if (!Arrays.equals(MAGIC_NUMBER, nioFile.readBytes(0, MAGIC_NUMBER.length))) {</b>
<b class="nc">&nbsp;					throw new IOException(&quot;File doesn&#39;t contain compatible ID records&quot;);</b>
&nbsp;				}
&nbsp;
<b class="nc">&nbsp;				byte version = nioFile.readByte(MAGIC_NUMBER.length);</b>
<b class="nc">&nbsp;				if (version &gt; FILE_FORMAT_VERSION) {</b>
<b class="nc">&nbsp;					throw new IOException(&quot;Unable to read ID file; it uses a newer file format&quot;);</b>
<b class="nc">&nbsp;				} else if (version != FILE_FORMAT_VERSION) {</b>
<b class="nc">&nbsp;					throw new IOException(&quot;Unable to read ID file; invalid file format version: &quot; + version);</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;		} catch (IOException e) {</b>
<b class="nc">&nbsp;			this.nioFile.close();</b>
<b class="nc">&nbsp;			throw e;</b>
<b class="nc">&nbsp;		}</b>
&nbsp;
<b class="nc">&nbsp;		nioFileSize = nioFile.size();</b>
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/*---------*
&nbsp;	 * Methods *
&nbsp;	 *---------*/
&nbsp;
&nbsp;	public final File getFile() {
<b class="nc">&nbsp;		return nioFile.getFile();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets the largest ID that is stored in this ID file.
&nbsp;	 *
&nbsp;	 * @return The largest ID, or &lt;var&gt;0&lt;/var&gt; if the file does not contain any data.
&nbsp;	 * @throws IOException If an I/O error occurs.
&nbsp;	 */
&nbsp;	public int getMaxID() throws IOException {
<b class="nc">&nbsp;		return (int) (nioFileSize / ITEM_SIZE) - 1;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Stores the offset of a new data entry, returning the ID under which is stored.
&nbsp;	 */
&nbsp;	public int storeOffset(long offset) throws IOException {
<b class="nc">&nbsp;		long fileSize = nioFileSize;</b>
<b class="nc">&nbsp;		nioFile.writeLong(offset, fileSize);</b>
<b class="nc">&nbsp;		nioFileSize += ITEM_SIZE;</b>
<b class="nc">&nbsp;		return (int) (fileSize / ITEM_SIZE);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets or updates the stored offset for the specified ID.
&nbsp;	 *
&nbsp;	 * @param id     The ID to set the offset for, must be larger than 0.
&nbsp;	 * @param offset The (new) offset for the specified ID.
&nbsp;	 */
&nbsp;	public void setOffset(int id, long offset) throws IOException {
<b class="nc">&nbsp;		assert id &gt; 0 : &quot;id must be larger than 0, is: &quot; + id;</b>
&nbsp;
<b class="nc">&nbsp;		nioFile.writeLong(offset, ITEM_SIZE * id);</b>
&nbsp;
&nbsp;		// We need to update the cache after writing to file (not before) so that if anyone refreshes the cache it will
&nbsp;		// include the write above.
&nbsp;		// The scenario is as follows:
&nbsp;		// 1. there is nothing in the cache, everything is fine
&nbsp;		// 2. the relevant cache line is from before the writeLong operation above, in which case we update it
&nbsp;		// 3. the relevant cache line is from right after the write in which case updating it doesnt matter
&nbsp;
<b class="nc">&nbsp;		int cacheLookupIndex = id &gt;&gt; cacheLineShift;</b>
<b class="nc">&nbsp;		int cacheLineLookupIndex = id % cacheLineSize;</b>
&nbsp;
<b class="nc">&nbsp;		Long[] cacheLine = getCacheLine(cacheLookupIndex);</b>
&nbsp;
<b class="nc">&nbsp;		if (cacheLine != null) {</b>
<b class="nc">&nbsp;			cacheLine[cacheLineLookupIndex] = offset;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets the offset of the data entry with the specified ID.
&nbsp;	 *
&nbsp;	 * @param id The ID to get the offset for, must be larger than 0.
&nbsp;	 * @return The offset for the ID.
&nbsp;	 */
&nbsp;	public long getOffset(int id) throws IOException {
<b class="nc">&nbsp;		assert id &gt; 0 : &quot;id must be larger than 0, is: &quot; + id;</b>
&nbsp;
&nbsp;		// the index used to lookup the cache line
<b class="nc">&nbsp;		int cacheLookupIndex = id &gt;&gt; cacheLineShift;</b>
&nbsp;
&nbsp;		// the index used to lookup the actual value inside the cache line
<b class="nc">&nbsp;		int cacheLineLookupIndex = id % cacheLineSize;</b>
&nbsp;
&nbsp;		// the cache line which is of size cacheLineSize
<b class="nc">&nbsp;		Long[] cacheLine = getCacheLine(cacheLookupIndex);</b>
&nbsp;
<b class="nc">&nbsp;		if (cacheLine != null) {</b>
<b class="nc">&nbsp;			return cacheLine[cacheLineLookupIndex];</b>
&nbsp;		}
&nbsp;
&nbsp;		// We only cache complete lines of size cacheLineSize. This means that the last line in the file will almost
&nbsp;		// never be cached. This simplifies the code since we don&#39;t have to deal with partial lines.
<b class="nc">&nbsp;		if (getMaxID() &gt; cacheLineSize &amp;&amp; id &lt; getMaxID() - cacheLineSize) {</b>
&nbsp;
&nbsp;			// doing one big read is considerably faster than doing a single read per id
<b class="nc">&nbsp;			byte[] bytes = nioFile.readBytes(ITEM_SIZE * (cacheLookupIndex &lt;&lt; cacheLineShift),</b>
&nbsp;					(int) (ITEM_SIZE * cacheLineSize));
&nbsp;
<b class="nc">&nbsp;			cacheLine = convertBytesToLongs(bytes);</b>
&nbsp;
<b class="nc">&nbsp;			synchronized (this) {</b>
&nbsp;				// we try not to overwrite an existing cache line
<b class="nc">&nbsp;				if (cache.getIfPresent(cacheLineLookupIndex) == null) {</b>
<b class="nc">&nbsp;					cache.put(cacheLookupIndex, cacheLine);</b>
&nbsp;				}
<b class="nc">&nbsp;				gcReducingCache = cacheLine;</b>
<b class="nc">&nbsp;				gcReducingCacheIndex = cacheLookupIndex;</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return cacheLine[cacheLineLookupIndex];</b>
&nbsp;
&nbsp;		}
&nbsp;
&nbsp;		// we did not find a cached value and we did not create a new cache line
<b class="nc">&nbsp;		return nioFile.readLong(ITEM_SIZE * id);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Discards all stored data.
&nbsp;	 *
&nbsp;	 * @throws IOException If an I/O error occurred.
&nbsp;	 */
&nbsp;	public void clear() throws IOException {
<b class="nc">&nbsp;		nioFile.truncate(HEADER_LENGTH);</b>
<b class="nc">&nbsp;		nioFileSize = nioFile.size();</b>
<b class="nc">&nbsp;		clearCache();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Syncs any unstored data to the hash file.
&nbsp;	 */
&nbsp;	public void sync() throws IOException {
<b class="nc">&nbsp;		if (forceSync) {</b>
<b class="nc">&nbsp;			nioFile.force(false);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public void sync(boolean force) throws IOException {
<b class="nc">&nbsp;		nioFile.force(false);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Closes the ID file, releasing any file locks that it might have.
&nbsp;	 *
&nbsp;	 * @throws IOException
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public void close() throws IOException {
<b class="nc">&nbsp;		nioFile.close();</b>
&nbsp;	}
&nbsp;
&nbsp;	synchronized private Long[] getCacheLine(int cacheLookupIndex) {
<b class="nc">&nbsp;		if (cacheLookupIndex == gcReducingCacheIndex) {</b>
<b class="nc">&nbsp;			return gcReducingCache;</b>
&nbsp;		} else {
<b class="nc">&nbsp;			return cache.getIfPresent(cacheLookupIndex);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private Long[] convertBytesToLongs(byte[] bytes) {
&nbsp;		Long[] cacheLine;
<b class="nc">&nbsp;		cacheLine = new Long[cacheLineSize];</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; bytes.length; i += ITEM_SIZE) {</b>
<b class="nc">&nbsp;			long l = ((long) (bytes[i + 0] &amp; 0xff) &lt;&lt; 56)</b>
&nbsp;					| ((long) bytes[i + 1] &amp; 0xff) &lt;&lt; 48
&nbsp;					| ((long) bytes[i + 2] &amp; 0xff) &lt;&lt; 40
&nbsp;					| ((long) bytes[i + 3] &amp; 0xff) &lt;&lt; 32
&nbsp;					| ((long) bytes[i + 4] &amp; 0xff) &lt;&lt; 24
&nbsp;					| ((long) bytes[i + 5] &amp; 0xff) &lt;&lt; 16
&nbsp;					| ((long) bytes[i + 6] &amp; 0xff) &lt;&lt; 8
&nbsp;					| ((long) bytes[i + 7] &amp; 0xff);
&nbsp;
<b class="nc">&nbsp;			cacheLine[(int) (i / ITEM_SIZE)] = l;</b>
&nbsp;		}
<b class="nc">&nbsp;		return cacheLine;</b>
&nbsp;	}
&nbsp;
&nbsp;	synchronized public void clearCache() {
<b class="nc">&nbsp;		cache.invalidateAll();</b>
<b class="nc">&nbsp;		gcReducingCacheIndex = -1;</b>
<b class="nc">&nbsp;		gcReducingCache = null;</b>
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:20</div>
</div>
</body>
</html>
