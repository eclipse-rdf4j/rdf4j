


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > SyntaxTreeBuilder</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.query.parser.sparql.ast</a>
</div>

<h1>Coverage Summary for Class: SyntaxTreeBuilder (org.eclipse.rdf4j.query.parser.sparql.ast)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SyntaxTreeBuilder</td>
<td class="coverageStat">
  <span class="percent">
    93.5%
  </span>
  <span class="absValue">
    (290/310)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25.7%
  </span>
  <span class="absValue">
    (1135/4422)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    54.4%
  </span>
  <span class="absValue">
    (2418/4442)
  </span>
</td>
</tr>
  <tr>
    <td class="name">SyntaxTreeBuilder$JJCalls</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SyntaxTreeBuilder$LookaheadSuccess</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    93.6%
  </span>
  <span class="absValue">
    (293/313)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25.7%
  </span>
  <span class="absValue">
    (1135/4422)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    54.5%
  </span>
  <span class="absValue">
    (2421/4445)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2019 Eclipse RDF4J contributors.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;/* SyntaxTreeBuilder.java */
&nbsp;/* Generated By:JJTree&amp;JavaCC: Do not edit this line. SyntaxTreeBuilder.java */
&nbsp;package org.eclipse.rdf4j.query.parser.sparql.ast;
&nbsp;
&nbsp;import org.eclipse.rdf4j.model.IRI;
&nbsp;import org.eclipse.rdf4j.model.vocabulary.RDF;
&nbsp;import org.eclipse.rdf4j.model.vocabulary.XSD;
&nbsp;import org.eclipse.rdf4j.query.algebra.Compare.CompareOp;
&nbsp;import org.eclipse.rdf4j.query.algebra.MathExpr.MathOp;
&nbsp;
&nbsp;public class SyntaxTreeBuilder
&nbsp;		/* @bgen(jjtree) */ implements SyntaxTreeBuilderTreeConstants, SyntaxTreeBuilderConstants {/* @bgen(jjtree) */
<b class="fc">&nbsp;	protected JJTSyntaxTreeBuilderState jjtree = new JJTSyntaxTreeBuilderState();</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Parses the supplied SPARQL query and builds a syntax tree from it.
&nbsp;	 *
&nbsp;	 * @param query A SPARQL query string.
&nbsp;	 * @return The root of the syntax tree.
&nbsp;	 * @throws TokenMgrError  If the query was syntactically incorrect.
&nbsp;	 * @throws ParseException If the query was syntactically incorrect.
&nbsp;	 */
&nbsp;	public static ASTQueryContainer parseQuery(String query)
&nbsp;			throws TokenMgrError, ParseException {
<b class="fc">&nbsp;		SyntaxTreeBuilder stb = new SyntaxTreeBuilder(new UnicodeEscapeStream(query, 1));</b>
&nbsp;
&nbsp;		// Set size of tab to 1 to force tokenmanager to report correct column
&nbsp;		// index for substring splitting of service graph pattern.
&nbsp;
<b class="fc">&nbsp;		ASTQueryContainer container = stb.QueryContainer();</b>
<b class="fc">&nbsp;		container.setSourceString(query);</b>
<b class="fc">&nbsp;		return container;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Parses the supplied SPARQL update sequence and builds a syntax tree from it.
&nbsp;	 *
&nbsp;	 * @param sequence A SPARQL update sequence string.
&nbsp;	 * @return The root of the syntax tree.
&nbsp;	 * @throws TokenMgrError  If the update sequence was syntactically incorrect.
&nbsp;	 * @throws ParseException If the update sequence was syntactically incorrect.
&nbsp;	 */
&nbsp;	public static ASTUpdateSequence parseUpdateSequence(String sequence)
&nbsp;			throws TokenMgrError, ParseException {
<b class="fc">&nbsp;		SyntaxTreeBuilder stb = new SyntaxTreeBuilder(new UnicodeEscapeStream(sequence, 1));</b>
&nbsp;
&nbsp;		// Set size of tab to 1 to force tokenmanager to report correct column
&nbsp;		// index for substring splitting of service graph pattern.
&nbsp;
<b class="fc">&nbsp;		ASTUpdateSequence seq = stb.UpdateSequence();</b>
<b class="fc">&nbsp;		seq.setSourceString(sequence);</b>
<b class="fc">&nbsp;		return seq;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Trims &lt;tt&gt;n&lt;/tt&gt; character from the start and end of the supplied string.
&nbsp;	 */
&nbsp;	private static String _trimString(String s, int n) {
<b class="pc">&nbsp;		if (s.length() &gt;= 2 * n) {</b>
<b class="fc">&nbsp;			s = s.substring(n, s.length() - n);</b>
&nbsp;		}
<b class="fc">&nbsp;		return s;</b>
&nbsp;	}
&nbsp;
&nbsp;	private String readToMatchingBrace() throws ParseException {
<b class="fc">&nbsp;		StringBuilder sb = new StringBuilder();</b>
&nbsp;		Token tok;
<b class="fc">&nbsp;		int nesting = 1;</b>
<b class="fc">&nbsp;		boolean previousTokenDtSep = false;</b>
&nbsp;		while (true) {
<b class="fc">&nbsp;			tok = getToken(1);</b>
<b class="pc">&nbsp;			if (&quot;&quot;.equals(tok.image)) {</b>
<b class="nc">&nbsp;				throw new ParseException(&quot;closing brace missing&quot;);</b>
&nbsp;			}
<b class="pc">&nbsp;			if (!previousTokenDtSep &amp;&amp; !tok.image.equals(&quot;^^&quot;) &amp;&amp; !tok.image.startsWith(&quot;@&quot;)) {</b>
<b class="fc">&nbsp;				sb.append(&quot; &quot;);</b>
&nbsp;			}
<b class="fc">&nbsp;			if (tok.kind == LBRACE) {</b>
<b class="fc">&nbsp;				nesting++;</b>
&nbsp;			}
<b class="fc">&nbsp;			if (tok.kind == RBRACE) {</b>
<b class="fc">&nbsp;				nesting--;</b>
<b class="fc">&nbsp;				if (nesting == 0) {</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;			}
<b class="fc">&nbsp;			sb.append(tok.image);</b>
<b class="fc">&nbsp;			previousTokenDtSep = tok.image.equals(&quot;^^&quot;);</b>
&nbsp;
<b class="fc">&nbsp;			getNextToken();</b>
&nbsp;		}
<b class="fc">&nbsp;		return sb.toString();</b>
&nbsp;	}
&nbsp;
&nbsp;	//
&nbsp;// grammar
&nbsp;//
&nbsp;	final public ASTUpdateSequence UpdateSequence() throws ParseException {/* @bgen(jjtree) UpdateSequence */
<b class="fc">&nbsp;		ASTUpdateSequence jjtn000 = new ASTUpdateSequence(JJTUPDATESEQUENCE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			UpdateContainer();</b>
<b class="fc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == SEMICOLON) {</b>
<b class="fc">&nbsp;				jj_consume_token(SEMICOLON);</b>
<b class="fc">&nbsp;				UpdateSequence();</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[0] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			jj_consume_token(0);</b>
<b class="fc">&nbsp;			jjtree.closeNodeScope(jjtn000, true);</b>
<b class="fc">&nbsp;			jjtc000 = false;</b>
&nbsp;			{
<b class="fc">&nbsp;				return jjtn000;</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public ASTUpdateContainer UpdateContainer() throws ParseException {/* @bgen(jjtree) UpdateContainer */
<b class="fc">&nbsp;		ASTUpdateContainer jjtn000 = new ASTUpdateContainer(JJTUPDATECONTAINER);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			Prolog();</b>
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case LOAD:
&nbsp;			case CLEAR:
&nbsp;			case DROP:
&nbsp;			case ADD:
&nbsp;			case MOVE:
&nbsp;			case COPY:
&nbsp;			case CREATE:
&nbsp;			case INSERT:
&nbsp;			case DELETE:
&nbsp;			case WITH: {
<b class="fc">&nbsp;				Update();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[1] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			jjtree.closeNodeScope(jjtn000, true);</b>
<b class="fc">&nbsp;			jjtc000 = false;</b>
&nbsp;			{
<b class="fc">&nbsp;				return jjtn000;</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public ASTQueryContainer QueryContainer() throws ParseException {/* @bgen(jjtree) QueryContainer */
<b class="fc">&nbsp;		ASTQueryContainer jjtn000 = new ASTQueryContainer(JJTQUERYCONTAINER);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			Prolog();</b>
<b class="fc">&nbsp;			Query();</b>
<b class="fc">&nbsp;			jj_consume_token(0);</b>
<b class="fc">&nbsp;			jjtree.closeNodeScope(jjtn000, true);</b>
<b class="fc">&nbsp;			jjtc000 = false;</b>
&nbsp;			{
<b class="fc">&nbsp;				return jjtn000;</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Prolog() throws ParseException {
&nbsp;		label_1: while (true) {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case BASE:
&nbsp;			case PREFIX: {
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="fc">&nbsp;				jj_la1[2] = jj_gen;</b>
<b class="fc">&nbsp;				break label_1;</b>
&nbsp;			}
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case PREFIX: {
<b class="fc">&nbsp;				PrefixDecl();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case BASE: {
<b class="fc">&nbsp;				BaseDecl();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[3] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void BaseDecl() throws ParseException {/* @bgen(jjtree) BaseDecl */
<b class="fc">&nbsp;		ASTBaseDecl jjtn000 = new ASTBaseDecl(JJTBASEDECL);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		Token t;
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(BASE);</b>
<b class="fc">&nbsp;			t = jj_consume_token(Q_IRI_REF);</b>
<b class="fc">&nbsp;			jjtree.closeNodeScope(jjtn000, true);</b>
<b class="fc">&nbsp;			jjtc000 = false;</b>
<b class="fc">&nbsp;			jjtn000.setIRI(_trimString(t.image, 1));</b>
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void PrefixDecl() throws ParseException {/* @bgen(jjtree) PrefixDecl */
<b class="fc">&nbsp;		ASTPrefixDecl jjtn000 = new ASTPrefixDecl(JJTPREFIXDECL);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		Token prefix;
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(PREFIX);</b>
<b class="fc">&nbsp;			prefix = jj_consume_token(PNAME_NS);</b>
<b class="fc">&nbsp;			IRI();</b>
<b class="fc">&nbsp;			jjtree.closeNodeScope(jjtn000, true);</b>
<b class="fc">&nbsp;			jjtc000 = false;</b>
&nbsp;// Remove trailing colon from prefix
<b class="fc">&nbsp;			String prefixStr = prefix.image;</b>
<b class="fc">&nbsp;			prefixStr = prefixStr.substring(0, prefixStr.length() - 1);</b>
&nbsp;
<b class="fc">&nbsp;			jjtn000.setPrefix(prefixStr);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;				jjtc000 = false;</b>
&nbsp;			} else {
<b class="nc">&nbsp;				jjtree.popNode();</b>
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Query() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case SELECT: {
<b class="fc">&nbsp;			SelectQuery();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case CONSTRUCT: {
<b class="fc">&nbsp;			ConstructQuery();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case DESCRIBE: {
<b class="fc">&nbsp;			DescribeQuery();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case ASK: {
<b class="fc">&nbsp;			AskQuery();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[4] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void SelectQuery() throws ParseException {/* @bgen(jjtree) SelectQuery */
<b class="fc">&nbsp;		ASTSelectQuery jjtn000 = new ASTSelectQuery(JJTSELECTQUERY);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			Select();</b>
&nbsp;			while (true) {
<b class="fc">&nbsp;				if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) != FROM) {</b>
<b class="fc">&nbsp;					jj_la1[5] = jj_gen;</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
<b class="fc">&nbsp;				DatasetClause();</b>
&nbsp;			}
<b class="fc">&nbsp;			WhereClause();</b>
<b class="fc">&nbsp;			SolutionModifier();</b>
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case BINDINGS:
&nbsp;			case VALUES: {
<b class="fc">&nbsp;				BindingsClause();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="fc">&nbsp;				jj_la1[6] = jj_gen;</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void SubSelect() throws ParseException {/* @bgen(jjtree) SelectQuery */
<b class="fc">&nbsp;		ASTSelectQuery jjtn000 = new ASTSelectQuery(JJTSELECTQUERY);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			Select();</b>
<b class="fc">&nbsp;			WhereClause();</b>
<b class="fc">&nbsp;			SolutionModifier();</b>
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case BINDINGS:
&nbsp;			case VALUES: {
<b class="fc">&nbsp;				BindingsClause();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="fc">&nbsp;				jj_la1[7] = jj_gen;</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Select() throws ParseException {/* @bgen(jjtree) Select */
<b class="fc">&nbsp;		ASTSelect jjtn000 = new ASTSelect(JJTSELECT);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(SELECT);</b>
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case DISTINCT:
&nbsp;			case REDUCED: {
<b class="pc">&nbsp;				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;				case DISTINCT: {
<b class="fc">&nbsp;					jj_consume_token(DISTINCT);</b>
<b class="fc">&nbsp;					jjtn000.setDistinct(true);</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;				case REDUCED: {
<b class="nc">&nbsp;					jj_consume_token(REDUCED);</b>
<b class="nc">&nbsp;					jjtn000.setReduced(true);</b>
<b class="nc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;				default:
<b class="nc">&nbsp;					jj_la1[8] = jj_gen;</b>
<b class="nc">&nbsp;					jj_consume_token(-1);</b>
<b class="nc">&nbsp;					throw new ParseException();</b>
&nbsp;				}
&nbsp;				break;
&nbsp;			}
&nbsp;			default:
<b class="fc">&nbsp;				jj_la1[9] = jj_gen;</b>
&nbsp;			}
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case STAR: {
<b class="fc">&nbsp;				jj_consume_token(STAR);</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
<b class="fc">&nbsp;				jjtc000 = false;</b>
<b class="fc">&nbsp;				jjtn000.setWildcard(true);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case LPAREN:
&nbsp;			case VAR1:
&nbsp;			case VAR2: {
&nbsp;				label_3: while (true) {
<b class="fc">&nbsp;					ProjectionElem();</b>
<b class="pc">&nbsp;					switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;					case LPAREN:
&nbsp;					case VAR1:
&nbsp;					case VAR2: {
<b class="fc">&nbsp;						break;</b>
&nbsp;					}
&nbsp;					default:
<b class="fc">&nbsp;						jj_la1[10] = jj_gen;</b>
<b class="fc">&nbsp;						break label_3;</b>
&nbsp;					}
&nbsp;				}
&nbsp;				break;
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[11] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;				jjtc000 = false;</b>
&nbsp;			} else {
<b class="nc">&nbsp;				jjtree.popNode();</b>
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void ProjectionElem() throws ParseException {/* @bgen(jjtree) ProjectionElem */
<b class="fc">&nbsp;		ASTProjectionElem jjtn000 = new ASTProjectionElem(JJTPROJECTIONELEM);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case VAR1:
&nbsp;			case VAR2: {
<b class="fc">&nbsp;				Var();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case LPAREN: {
<b class="fc">&nbsp;				jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;				Expression();</b>
<b class="fc">&nbsp;				jj_consume_token(AS);</b>
<b class="fc">&nbsp;				Var();</b>
<b class="fc">&nbsp;				jj_consume_token(RPAREN);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[12] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void ConstructQuery() throws ParseException {/* @bgen(jjtree) ConstructQuery */
<b class="fc">&nbsp;		ASTConstructQuery jjtn000 = new ASTConstructQuery(JJTCONSTRUCTQUERY);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			Construct();</b>
&nbsp;			while (true) {
<b class="pc">&nbsp;				if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) != FROM) {</b>
<b class="fc">&nbsp;					jj_la1[13] = jj_gen;</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
<b class="fc">&nbsp;				DatasetClause();</b>
&nbsp;			}
<b class="fc">&nbsp;			WhereClause();</b>
<b class="fc">&nbsp;			SolutionModifier();</b>
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case BINDINGS:
&nbsp;			case VALUES: {
<b class="nc">&nbsp;				BindingsClause();</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="fc">&nbsp;				jj_la1[14] = jj_gen;</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Construct() throws ParseException {/* @bgen(jjtree) Construct */
<b class="fc">&nbsp;		ASTConstruct jjtn000 = new ASTConstruct(JJTCONSTRUCT);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(CONSTRUCT);</b>
<b class="fc">&nbsp;			if (jj_2_1()) {</b>
<b class="fc">&nbsp;				ConstructClause();</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void ConstructClause() throws ParseException {
<b class="fc">&nbsp;		jj_consume_token(LBRACE);</b>
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case LPAREN:
&nbsp;		case LBRACK:
&nbsp;		case NIL:
&nbsp;		case ANON:
&nbsp;		case TRUE:
&nbsp;		case FALSE:
&nbsp;		case Q_IRI_REF:
&nbsp;		case PNAME_NS:
&nbsp;		case PNAME_LN:
&nbsp;		case BLANK_NODE_LABEL:
&nbsp;		case VAR1:
&nbsp;		case VAR2:
&nbsp;		case INTEGER:
&nbsp;		case INTEGER_POSITIVE:
&nbsp;		case INTEGER_NEGATIVE:
&nbsp;		case DECIMAL:
&nbsp;		case DECIMAL_POSITIVE:
&nbsp;		case DECIMAL_NEGATIVE:
&nbsp;		case DOUBLE:
&nbsp;		case DOUBLE_POSITIVE:
&nbsp;		case DOUBLE_NEGATIVE:
&nbsp;		case STRING_LITERAL1:
&nbsp;		case STRING_LITERAL2:
&nbsp;		case STRING_LITERAL_LONG1:
&nbsp;		case STRING_LITERAL_LONG2:
&nbsp;		case TRIPLE_OPEN: {
<b class="fc">&nbsp;			TriplesBlock();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[15] = jj_gen;</b>
&nbsp;		}
<b class="fc">&nbsp;		jj_consume_token(RBRACE);</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void DescribeQuery() throws ParseException {/* @bgen(jjtree) DescribeQuery */
<b class="fc">&nbsp;		ASTDescribeQuery jjtn000 = new ASTDescribeQuery(JJTDESCRIBEQUERY);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			Describe();</b>
&nbsp;			while (true) {
<b class="pc">&nbsp;				if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) != FROM) {</b>
<b class="fc">&nbsp;					jj_la1[16] = jj_gen;</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
<b class="nc">&nbsp;				DatasetClause();</b>
&nbsp;			}
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case LBRACE:
&nbsp;			case WHERE: {
<b class="fc">&nbsp;				WhereClause();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="fc">&nbsp;				jj_la1[17] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			SolutionModifier();</b>
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case BINDINGS:
&nbsp;			case VALUES: {
<b class="nc">&nbsp;				BindingsClause();</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="fc">&nbsp;				jj_la1[18] = jj_gen;</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Describe() throws ParseException {/* @bgen(jjtree) Describe */
<b class="fc">&nbsp;		ASTDescribe jjtn000 = new ASTDescribe(JJTDESCRIBE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(DESCRIBE);</b>
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case STAR: {
<b class="nc">&nbsp;				jj_consume_token(STAR);</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
<b class="nc">&nbsp;				jjtc000 = false;</b>
<b class="nc">&nbsp;				jjtn000.setWildcard(true);</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case Q_IRI_REF:
&nbsp;			case PNAME_NS:
&nbsp;			case PNAME_LN:
&nbsp;			case VAR1:
&nbsp;			case VAR2:
&nbsp;			case TRIPLE_OPEN: {
&nbsp;				label_6: while (true) {
<b class="pc">&nbsp;					switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;					case Q_IRI_REF:
&nbsp;					case PNAME_NS:
&nbsp;					case PNAME_LN:
&nbsp;					case VAR1:
&nbsp;					case VAR2: {
<b class="fc">&nbsp;						VarOrIRIref();</b>
<b class="fc">&nbsp;						break;</b>
&nbsp;					}
&nbsp;					case TRIPLE_OPEN: {
<b class="nc">&nbsp;						ConstTripleRef();</b>
<b class="nc">&nbsp;						break;</b>
&nbsp;					}
&nbsp;					default:
<b class="nc">&nbsp;						jj_la1[19] = jj_gen;</b>
<b class="nc">&nbsp;						jj_consume_token(-1);</b>
<b class="nc">&nbsp;						throw new ParseException();</b>
&nbsp;					}
<b class="pc">&nbsp;					switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;					case Q_IRI_REF:
&nbsp;					case PNAME_NS:
&nbsp;					case PNAME_LN:
&nbsp;					case VAR1:
&nbsp;					case VAR2:
&nbsp;					case TRIPLE_OPEN: {
<b class="fc">&nbsp;						break;</b>
&nbsp;					}
&nbsp;					default:
<b class="fc">&nbsp;						jj_la1[20] = jj_gen;</b>
<b class="fc">&nbsp;						break label_6;</b>
&nbsp;					}
&nbsp;				}
&nbsp;				break;
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[21] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;				jjtc000 = false;</b>
&nbsp;			} else {
<b class="nc">&nbsp;				jjtree.popNode();</b>
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void AskQuery() throws ParseException {/* @bgen(jjtree) AskQuery */
<b class="fc">&nbsp;		ASTAskQuery jjtn000 = new ASTAskQuery(JJTASKQUERY);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(ASK);</b>
&nbsp;			while (true) {
<b class="pc">&nbsp;				if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) != FROM) {</b>
<b class="fc">&nbsp;					jj_la1[22] = jj_gen;</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
<b class="nc">&nbsp;				DatasetClause();</b>
&nbsp;			}
<b class="fc">&nbsp;			WhereClause();</b>
<b class="fc">&nbsp;			SolutionModifier();</b>
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case BINDINGS:
&nbsp;			case VALUES: {
<b class="nc">&nbsp;				BindingsClause();</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="fc">&nbsp;				jj_la1[23] = jj_gen;</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void DatasetClause() throws ParseException {/* @bgen(jjtree) DatasetClause */
<b class="fc">&nbsp;		ASTDatasetClause jjtn000 = new ASTDatasetClause(JJTDATASETCLAUSE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(FROM);</b>
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case NAMED:
&nbsp;			case Q_IRI_REF:
&nbsp;			case PNAME_NS:
&nbsp;			case PNAME_LN: {
<b class="pc">&nbsp;				if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == NAMED) {</b>
<b class="nc">&nbsp;					jj_consume_token(NAMED);</b>
<b class="nc">&nbsp;					jjtn000.setNamed(true);</b>
&nbsp;				} else {
<b class="fc">&nbsp;					jj_la1[24] = jj_gen;</b>
&nbsp;				}
<b class="fc">&nbsp;				IRIref();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case DEFAULT_GRAPH: {
<b class="fc">&nbsp;				jj_consume_token(DEFAULT_GRAPH);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[25] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void WhereClause() throws ParseException {/* @bgen(jjtree) WhereClause */
<b class="fc">&nbsp;		ASTWhereClause jjtn000 = new ASTWhereClause(JJTWHERECLAUSE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == WHERE) {</b>
<b class="fc">&nbsp;				jj_consume_token(WHERE);</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[26] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			GroupGraphPattern();</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void BindingsClause() throws ParseException {/* @bgen(jjtree) BindingsClause */
<b class="fc">&nbsp;		ASTBindingsClause jjtn000 = new ASTBindingsClause(JJTBINDINGSCLAUSE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case VALUES: {
<b class="fc">&nbsp;				jj_consume_token(VALUES);</b>
<b class="fc">&nbsp;				DataBlock();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case BINDINGS: {
<b class="nc">&nbsp;				jj_consume_token(BINDINGS);</b>
&nbsp;				label_8: while (true) {
<b class="nc">&nbsp;					switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;					case VAR1:
&nbsp;					case VAR2: {
<b class="nc">&nbsp;						break;</b>
&nbsp;					}
&nbsp;					default:
<b class="nc">&nbsp;						jj_la1[27] = jj_gen;</b>
<b class="nc">&nbsp;						break label_8;</b>
&nbsp;					}
<b class="nc">&nbsp;					Var();</b>
&nbsp;				}
<b class="nc">&nbsp;				jj_consume_token(LBRACE);</b>
&nbsp;				label_9: while (true) {
<b class="nc">&nbsp;					switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;					case LPAREN:
&nbsp;					case NIL: {
<b class="nc">&nbsp;						break;</b>
&nbsp;					}
&nbsp;					default:
<b class="nc">&nbsp;						jj_la1[28] = jj_gen;</b>
<b class="nc">&nbsp;						break label_9;</b>
&nbsp;					}
<b class="nc">&nbsp;					BindingSet();</b>
&nbsp;				}
<b class="nc">&nbsp;				jj_consume_token(RBRACE);</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[29] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void InlineData() throws ParseException {/* @bgen(jjtree) InlineData */
<b class="fc">&nbsp;		ASTInlineData jjtn000 = new ASTInlineData(JJTINLINEDATA);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(VALUES);</b>
<b class="fc">&nbsp;			DataBlock();</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void DataBlock() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case VAR1:
&nbsp;		case VAR2: {
<b class="fc">&nbsp;			InlineDataOneVar();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case LPAREN:
&nbsp;		case NIL: {
<b class="fc">&nbsp;			InlineDataFull();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[30] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void InlineDataOneVar() throws ParseException {
<b class="fc">&nbsp;		Var();</b>
<b class="fc">&nbsp;		jj_consume_token(LBRACE);</b>
&nbsp;		label_10: while (true) {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case TRUE:
&nbsp;			case FALSE:
&nbsp;			case UNDEF:
&nbsp;			case Q_IRI_REF:
&nbsp;			case PNAME_NS:
&nbsp;			case PNAME_LN:
&nbsp;			case INTEGER:
&nbsp;			case INTEGER_POSITIVE:
&nbsp;			case INTEGER_NEGATIVE:
&nbsp;			case DECIMAL:
&nbsp;			case DECIMAL_POSITIVE:
&nbsp;			case DECIMAL_NEGATIVE:
&nbsp;			case DOUBLE:
&nbsp;			case DOUBLE_POSITIVE:
&nbsp;			case DOUBLE_NEGATIVE:
&nbsp;			case STRING_LITERAL1:
&nbsp;			case STRING_LITERAL2:
&nbsp;			case STRING_LITERAL_LONG1:
&nbsp;			case STRING_LITERAL_LONG2:
&nbsp;			case TRIPLE_OPEN: {
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="fc">&nbsp;				jj_la1[31] = jj_gen;</b>
<b class="fc">&nbsp;				break label_10;</b>
&nbsp;			}
<b class="fc">&nbsp;			SimpleBindingSet();</b>
&nbsp;		}
<b class="fc">&nbsp;		jj_consume_token(RBRACE);</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void InlineDataFull() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case NIL: {
<b class="nc">&nbsp;			jj_consume_token(NIL);</b>
<b class="nc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case LPAREN: {
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
&nbsp;			label_11: while (true) {
<b class="pc">&nbsp;				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;				case VAR1:
&nbsp;				case VAR2: {
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;				default:
<b class="fc">&nbsp;					jj_la1[32] = jj_gen;</b>
<b class="fc">&nbsp;					break label_11;</b>
&nbsp;				}
<b class="fc">&nbsp;				Var();</b>
&nbsp;			}
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[33] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
<b class="fc">&nbsp;		jj_consume_token(LBRACE);</b>
&nbsp;		label_12: while (true) {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case LPAREN:
&nbsp;			case NIL: {
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="fc">&nbsp;				jj_la1[34] = jj_gen;</b>
<b class="fc">&nbsp;				break label_12;</b>
&nbsp;			}
<b class="fc">&nbsp;			BindingSet();</b>
&nbsp;		}
<b class="fc">&nbsp;		jj_consume_token(RBRACE);</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void SimpleBindingSet() throws ParseException {/* @bgen(jjtree) BindingSet */
<b class="fc">&nbsp;		ASTBindingSet jjtn000 = new ASTBindingSet(JJTBINDINGSET);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			BindingValue();</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void BindingSet() throws ParseException {/* @bgen(jjtree) BindingSet */
<b class="fc">&nbsp;		ASTBindingSet jjtn000 = new ASTBindingSet(JJTBINDINGSET);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case LPAREN: {
<b class="fc">&nbsp;				jj_consume_token(LPAREN);</b>
&nbsp;				label_13: while (true) {
<b class="pc">&nbsp;					switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;					case TRUE:
&nbsp;					case FALSE:
&nbsp;					case UNDEF:
&nbsp;					case Q_IRI_REF:
&nbsp;					case PNAME_NS:
&nbsp;					case PNAME_LN:
&nbsp;					case INTEGER:
&nbsp;					case INTEGER_POSITIVE:
&nbsp;					case INTEGER_NEGATIVE:
&nbsp;					case DECIMAL:
&nbsp;					case DECIMAL_POSITIVE:
&nbsp;					case DECIMAL_NEGATIVE:
&nbsp;					case DOUBLE:
&nbsp;					case DOUBLE_POSITIVE:
&nbsp;					case DOUBLE_NEGATIVE:
&nbsp;					case STRING_LITERAL1:
&nbsp;					case STRING_LITERAL2:
&nbsp;					case STRING_LITERAL_LONG1:
&nbsp;					case STRING_LITERAL_LONG2:
&nbsp;					case TRIPLE_OPEN: {
<b class="fc">&nbsp;						break;</b>
&nbsp;					}
&nbsp;					default:
<b class="fc">&nbsp;						jj_la1[35] = jj_gen;</b>
<b class="fc">&nbsp;						break label_13;</b>
&nbsp;					}
<b class="fc">&nbsp;					BindingValue();</b>
&nbsp;				}
<b class="fc">&nbsp;				jj_consume_token(RPAREN);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case NIL: {
<b class="nc">&nbsp;				jj_consume_token(NIL);</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[36] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void BindingValue() throws ParseException {/* @bgen(jjtree) BindingValue */
<b class="fc">&nbsp;		ASTBindingValue jjtn000 = new ASTBindingValue(JJTBINDINGVALUE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case Q_IRI_REF:
&nbsp;			case PNAME_NS:
&nbsp;			case PNAME_LN: {
<b class="fc">&nbsp;				IRIref();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case STRING_LITERAL1:
&nbsp;			case STRING_LITERAL2:
&nbsp;			case STRING_LITERAL_LONG1:
&nbsp;			case STRING_LITERAL_LONG2: {
<b class="fc">&nbsp;				RDFLiteral();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case INTEGER:
&nbsp;			case INTEGER_POSITIVE:
&nbsp;			case INTEGER_NEGATIVE:
&nbsp;			case DECIMAL:
&nbsp;			case DECIMAL_POSITIVE:
&nbsp;			case DECIMAL_NEGATIVE:
&nbsp;			case DOUBLE:
&nbsp;			case DOUBLE_POSITIVE:
&nbsp;			case DOUBLE_NEGATIVE: {
<b class="fc">&nbsp;				NumericLiteral();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case TRUE:
&nbsp;			case FALSE: {
<b class="nc">&nbsp;				BooleanLiteral();</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case UNDEF: {
<b class="fc">&nbsp;				jj_consume_token(UNDEF);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case TRIPLE_OPEN: {
<b class="nc">&nbsp;				ConstTripleRef();</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[37] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void SolutionModifier() throws ParseException {
<b class="fc">&nbsp;		if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == GROUP) {</b>
<b class="fc">&nbsp;			GroupClause();</b>
&nbsp;		} else {
<b class="fc">&nbsp;			jj_la1[38] = jj_gen;</b>
&nbsp;		}
<b class="pc">&nbsp;		if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == HAVING) {</b>
<b class="fc">&nbsp;			HavingClause();</b>
&nbsp;		} else {
<b class="fc">&nbsp;			jj_la1[39] = jj_gen;</b>
&nbsp;		}
<b class="fc">&nbsp;		if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == ORDER) {</b>
<b class="fc">&nbsp;			OrderClause();</b>
&nbsp;		} else {
<b class="fc">&nbsp;			jj_la1[40] = jj_gen;</b>
&nbsp;		}
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case LIMIT:
&nbsp;		case OFFSET: {
<b class="fc">&nbsp;			LimitOffsetClauses();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="fc">&nbsp;			jj_la1[41] = jj_gen;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void GroupClause() throws ParseException {/* @bgen(jjtree) GroupClause */
<b class="fc">&nbsp;		ASTGroupClause jjtn000 = new ASTGroupClause(JJTGROUPCLAUSE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(GROUP);</b>
<b class="fc">&nbsp;			jj_consume_token(BY);</b>
&nbsp;			label_14: while (true) {
<b class="fc">&nbsp;				GroupCondition();</b>
<b class="pc">&nbsp;				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;				case LPAREN:
&nbsp;				case NOT_FUNC:
&nbsp;				case EXISTS:
&nbsp;				case STR:
&nbsp;				case LANG:
&nbsp;				case LANGMATCHES:
&nbsp;				case DATATYPE:
&nbsp;				case BOUND:
&nbsp;				case SAMETERM:
&nbsp;				case IS_IRI:
&nbsp;				case IS_BLANK:
&nbsp;				case IS_LITERAL:
&nbsp;				case IS_NUMERIC:
&nbsp;				case COALESCE:
&nbsp;				case BNODE:
&nbsp;				case STRDT:
&nbsp;				case STRLANG:
&nbsp;				case UUID:
&nbsp;				case STRUUID:
&nbsp;				case IRI:
&nbsp;				case IF:
&nbsp;				case REGEX:
&nbsp;				case STRLEN:
&nbsp;				case SUBSTR:
&nbsp;				case STR_STARTS:
&nbsp;				case STR_ENDS:
&nbsp;				case STR_BEFORE:
&nbsp;				case STR_AFTER:
&nbsp;				case REPLACE:
&nbsp;				case UCASE:
&nbsp;				case LCASE:
&nbsp;				case CONCAT:
&nbsp;				case CONTAINS:
&nbsp;				case ENCODE_FOR_URI:
&nbsp;				case RAND:
&nbsp;				case ABS:
&nbsp;				case CEIL:
&nbsp;				case FLOOR:
&nbsp;				case ROUND:
&nbsp;				case NOW:
&nbsp;				case YEAR:
&nbsp;				case MONTH:
&nbsp;				case DAY:
&nbsp;				case HOURS:
&nbsp;				case MINUTES:
&nbsp;				case SECONDS:
&nbsp;				case TIMEZONE:
&nbsp;				case TZ:
&nbsp;				case MD5:
&nbsp;				case SHA1:
&nbsp;				case SHA224:
&nbsp;				case SHA256:
&nbsp;				case SHA384:
&nbsp;				case SHA512:
&nbsp;				case Q_IRI_REF:
&nbsp;				case PNAME_NS:
&nbsp;				case PNAME_LN:
&nbsp;				case VAR1:
&nbsp;				case VAR2: {
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;				default:
<b class="fc">&nbsp;					jj_la1[42] = jj_gen;</b>
<b class="fc">&nbsp;					break label_14;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void OrderClause() throws ParseException {/* @bgen(jjtree) OrderClause */
<b class="fc">&nbsp;		ASTOrderClause jjtn000 = new ASTOrderClause(JJTORDERCLAUSE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(ORDER);</b>
<b class="fc">&nbsp;			jj_consume_token(BY);</b>
&nbsp;			label_15: while (true) {
<b class="fc">&nbsp;				OrderCondition();</b>
<b class="pc">&nbsp;				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;				case LPAREN:
&nbsp;				case ASC:
&nbsp;				case DESC:
&nbsp;				case NOT_FUNC:
&nbsp;				case EXISTS:
&nbsp;				case STR:
&nbsp;				case LANG:
&nbsp;				case LANGMATCHES:
&nbsp;				case DATATYPE:
&nbsp;				case BOUND:
&nbsp;				case SAMETERM:
&nbsp;				case IS_IRI:
&nbsp;				case IS_BLANK:
&nbsp;				case IS_LITERAL:
&nbsp;				case IS_NUMERIC:
&nbsp;				case COALESCE:
&nbsp;				case BNODE:
&nbsp;				case STRDT:
&nbsp;				case STRLANG:
&nbsp;				case UUID:
&nbsp;				case STRUUID:
&nbsp;				case IRI:
&nbsp;				case IF:
&nbsp;				case REGEX:
&nbsp;				case STRLEN:
&nbsp;				case SUBSTR:
&nbsp;				case STR_STARTS:
&nbsp;				case STR_ENDS:
&nbsp;				case STR_BEFORE:
&nbsp;				case STR_AFTER:
&nbsp;				case REPLACE:
&nbsp;				case UCASE:
&nbsp;				case LCASE:
&nbsp;				case CONCAT:
&nbsp;				case CONTAINS:
&nbsp;				case ENCODE_FOR_URI:
&nbsp;				case RAND:
&nbsp;				case ABS:
&nbsp;				case CEIL:
&nbsp;				case FLOOR:
&nbsp;				case ROUND:
&nbsp;				case NOW:
&nbsp;				case YEAR:
&nbsp;				case MONTH:
&nbsp;				case DAY:
&nbsp;				case HOURS:
&nbsp;				case MINUTES:
&nbsp;				case SECONDS:
&nbsp;				case TIMEZONE:
&nbsp;				case TZ:
&nbsp;				case MD5:
&nbsp;				case SHA1:
&nbsp;				case SHA224:
&nbsp;				case SHA256:
&nbsp;				case SHA384:
&nbsp;				case SHA512:
&nbsp;				case Q_IRI_REF:
&nbsp;				case PNAME_NS:
&nbsp;				case PNAME_LN:
&nbsp;				case VAR1:
&nbsp;				case VAR2: {
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;				default:
<b class="fc">&nbsp;					jj_la1[43] = jj_gen;</b>
<b class="fc">&nbsp;					break label_15;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void GroupCondition() throws ParseException {/* @bgen(jjtree) GroupCondition */
<b class="fc">&nbsp;		ASTGroupCondition jjtn000 = new ASTGroupCondition(JJTGROUPCONDITION);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case Q_IRI_REF:
&nbsp;			case PNAME_NS:
&nbsp;			case PNAME_LN: {
<b class="nc">&nbsp;				FunctionCall();</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case NOT_FUNC:
&nbsp;			case EXISTS:
&nbsp;			case STR:
&nbsp;			case LANG:
&nbsp;			case LANGMATCHES:
&nbsp;			case DATATYPE:
&nbsp;			case BOUND:
&nbsp;			case SAMETERM:
&nbsp;			case IS_IRI:
&nbsp;			case IS_BLANK:
&nbsp;			case IS_LITERAL:
&nbsp;			case IS_NUMERIC:
&nbsp;			case COALESCE:
&nbsp;			case BNODE:
&nbsp;			case STRDT:
&nbsp;			case STRLANG:
&nbsp;			case UUID:
&nbsp;			case STRUUID:
&nbsp;			case IRI:
&nbsp;			case IF:
&nbsp;			case REGEX:
&nbsp;			case STRLEN:
&nbsp;			case SUBSTR:
&nbsp;			case STR_STARTS:
&nbsp;			case STR_ENDS:
&nbsp;			case STR_BEFORE:
&nbsp;			case STR_AFTER:
&nbsp;			case REPLACE:
&nbsp;			case UCASE:
&nbsp;			case LCASE:
&nbsp;			case CONCAT:
&nbsp;			case CONTAINS:
&nbsp;			case ENCODE_FOR_URI:
&nbsp;			case RAND:
&nbsp;			case ABS:
&nbsp;			case CEIL:
&nbsp;			case FLOOR:
&nbsp;			case ROUND:
&nbsp;			case NOW:
&nbsp;			case YEAR:
&nbsp;			case MONTH:
&nbsp;			case DAY:
&nbsp;			case HOURS:
&nbsp;			case MINUTES:
&nbsp;			case SECONDS:
&nbsp;			case TIMEZONE:
&nbsp;			case TZ:
&nbsp;			case MD5:
&nbsp;			case SHA1:
&nbsp;			case SHA224:
&nbsp;			case SHA256:
&nbsp;			case SHA384:
&nbsp;			case SHA512: {
<b class="nc">&nbsp;				BuiltInCall();</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case LPAREN: {
<b class="fc">&nbsp;				jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;				Expression();</b>
<b class="pc">&nbsp;				if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == AS) {</b>
<b class="fc">&nbsp;					jj_consume_token(AS);</b>
<b class="fc">&nbsp;					Var();</b>
&nbsp;				} else {
<b class="nc">&nbsp;					jj_la1[44] = jj_gen;</b>
&nbsp;				}
<b class="fc">&nbsp;				jj_consume_token(RPAREN);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case VAR1:
&nbsp;			case VAR2: {
<b class="fc">&nbsp;				Var();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[45] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void HavingClause() throws ParseException {/* @bgen(jjtree) HavingClause */
<b class="fc">&nbsp;		ASTHavingClause jjtn000 = new ASTHavingClause(JJTHAVINGCLAUSE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(HAVING);</b>
<b class="fc">&nbsp;			Constraint();</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void OrderCondition() throws ParseException {/* @bgen(jjtree) OrderCondition */
<b class="fc">&nbsp;		ASTOrderCondition jjtn000 = new ASTOrderCondition(JJTORDERCONDITION);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case LPAREN:
&nbsp;			case ASC:
&nbsp;			case DESC: {
<b class="pc">&nbsp;				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;				case ASC:
&nbsp;				case DESC: {
<b class="pc">&nbsp;					switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;					case ASC: {
<b class="nc">&nbsp;						jj_consume_token(ASC);</b>
<b class="nc">&nbsp;						break;</b>
&nbsp;					}
&nbsp;					case DESC: {
<b class="fc">&nbsp;						jj_consume_token(DESC);</b>
<b class="fc">&nbsp;						jjtn000.setAscending(false);</b>
<b class="fc">&nbsp;						break;</b>
&nbsp;					}
&nbsp;					default:
<b class="nc">&nbsp;						jj_la1[46] = jj_gen;</b>
<b class="nc">&nbsp;						jj_consume_token(-1);</b>
<b class="nc">&nbsp;						throw new ParseException();</b>
&nbsp;					}
&nbsp;					break;
&nbsp;				}
&nbsp;				default:
<b class="fc">&nbsp;					jj_la1[47] = jj_gen;</b>
&nbsp;				}
<b class="fc">&nbsp;				BrackettedExpression();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case Q_IRI_REF:
&nbsp;			case PNAME_NS:
&nbsp;			case PNAME_LN: {
<b class="nc">&nbsp;				FunctionCall();</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case NOT_FUNC:
&nbsp;			case EXISTS:
&nbsp;			case STR:
&nbsp;			case LANG:
&nbsp;			case LANGMATCHES:
&nbsp;			case DATATYPE:
&nbsp;			case BOUND:
&nbsp;			case SAMETERM:
&nbsp;			case IS_IRI:
&nbsp;			case IS_BLANK:
&nbsp;			case IS_LITERAL:
&nbsp;			case IS_NUMERIC:
&nbsp;			case COALESCE:
&nbsp;			case BNODE:
&nbsp;			case STRDT:
&nbsp;			case STRLANG:
&nbsp;			case UUID:
&nbsp;			case STRUUID:
&nbsp;			case IRI:
&nbsp;			case IF:
&nbsp;			case REGEX:
&nbsp;			case STRLEN:
&nbsp;			case SUBSTR:
&nbsp;			case STR_STARTS:
&nbsp;			case STR_ENDS:
&nbsp;			case STR_BEFORE:
&nbsp;			case STR_AFTER:
&nbsp;			case REPLACE:
&nbsp;			case UCASE:
&nbsp;			case LCASE:
&nbsp;			case CONCAT:
&nbsp;			case CONTAINS:
&nbsp;			case ENCODE_FOR_URI:
&nbsp;			case RAND:
&nbsp;			case ABS:
&nbsp;			case CEIL:
&nbsp;			case FLOOR:
&nbsp;			case ROUND:
&nbsp;			case NOW:
&nbsp;			case YEAR:
&nbsp;			case MONTH:
&nbsp;			case DAY:
&nbsp;			case HOURS:
&nbsp;			case MINUTES:
&nbsp;			case SECONDS:
&nbsp;			case TIMEZONE:
&nbsp;			case TZ:
&nbsp;			case MD5:
&nbsp;			case SHA1:
&nbsp;			case SHA224:
&nbsp;			case SHA256:
&nbsp;			case SHA384:
&nbsp;			case SHA512: {
<b class="nc">&nbsp;				BuiltInCall();</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case VAR1:
&nbsp;			case VAR2: {
<b class="fc">&nbsp;				Var();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[48] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void LimitOffsetClauses() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case LIMIT: {
<b class="fc">&nbsp;			Limit();</b>
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == OFFSET) {</b>
<b class="nc">&nbsp;				Offset();</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[49] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case OFFSET: {
<b class="nc">&nbsp;			Offset();</b>
<b class="nc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == LIMIT) {</b>
<b class="nc">&nbsp;				Limit();</b>
&nbsp;			} else {
<b class="nc">&nbsp;				jj_la1[50] = jj_gen;</b>
&nbsp;			}
<b class="nc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[51] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void Limit() throws ParseException {/* @bgen(jjtree) Limit */
<b class="fc">&nbsp;		ASTLimit jjtn000 = new ASTLimit(JJTLIMIT);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		Token t;
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(LIMIT);</b>
<b class="fc">&nbsp;			t = jj_consume_token(INTEGER);</b>
<b class="fc">&nbsp;			jjtree.closeNodeScope(jjtn000, true);</b>
<b class="fc">&nbsp;			jjtc000 = false;</b>
<b class="fc">&nbsp;			jjtn000.setValue(Long.parseLong(t.image));</b>
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Offset() throws ParseException {/* @bgen(jjtree) Offset */
<b class="nc">&nbsp;		ASTOffset jjtn000 = new ASTOffset(JJTOFFSET);</b>
<b class="nc">&nbsp;		boolean jjtc000 = true;</b>
<b class="nc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		Token t;
&nbsp;		try {
<b class="nc">&nbsp;			jj_consume_token(OFFSET);</b>
<b class="nc">&nbsp;			t = jj_consume_token(INTEGER);</b>
<b class="nc">&nbsp;			jjtree.closeNodeScope(jjtn000, true);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			jjtn000.setValue(Long.parseLong(t.image));</b>
&nbsp;		} finally {
<b class="nc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public Token GroupGraphPattern() throws ParseException, Error {/* @bgen(jjtree) GraphPatternGroup */
<b class="fc">&nbsp;		ASTGraphPatternGroup jjtn000 = new ASTGraphPatternGroup(JJTGRAPHPATTERNGROUP);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		Token endOfPatternToken;
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(LBRACE);</b>
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == SELECT) {</b>
<b class="fc">&nbsp;				SubSelect();</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[52] = jj_gen;</b>
<b class="fc">&nbsp;				GraphPattern();</b>
&nbsp;			}
<b class="fc">&nbsp;			endOfPatternToken = jj_consume_token(RBRACE);</b>
<b class="fc">&nbsp;			jjtree.closeNodeScope(jjtn000, true);</b>
<b class="fc">&nbsp;			jjtc000 = false;</b>
&nbsp;			{
<b class="fc">&nbsp;				return endOfPatternToken;</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void GraphPattern() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case LPAREN:
&nbsp;		case LBRACK:
&nbsp;		case NIL:
&nbsp;		case ANON:
&nbsp;		case FILTER:
&nbsp;		case TRUE:
&nbsp;		case FALSE:
&nbsp;		case BIND:
&nbsp;		case Q_IRI_REF:
&nbsp;		case PNAME_NS:
&nbsp;		case PNAME_LN:
&nbsp;		case BLANK_NODE_LABEL:
&nbsp;		case VAR1:
&nbsp;		case VAR2:
&nbsp;		case INTEGER:
&nbsp;		case INTEGER_POSITIVE:
&nbsp;		case INTEGER_NEGATIVE:
&nbsp;		case DECIMAL:
&nbsp;		case DECIMAL_POSITIVE:
&nbsp;		case DECIMAL_NEGATIVE:
&nbsp;		case DOUBLE:
&nbsp;		case DOUBLE_POSITIVE:
&nbsp;		case DOUBLE_NEGATIVE:
&nbsp;		case STRING_LITERAL1:
&nbsp;		case STRING_LITERAL2:
&nbsp;		case STRING_LITERAL_LONG1:
&nbsp;		case STRING_LITERAL_LONG2:
&nbsp;		case TRIPLE_OPEN: {
<b class="fc">&nbsp;			BasicGraphPattern();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="fc">&nbsp;			jj_la1[53] = jj_gen;</b>
&nbsp;		}
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case LBRACE:
&nbsp;		case OPTIONAL:
&nbsp;		case GRAPH:
&nbsp;		case MINUS_SETOPER:
&nbsp;		case SERVICE:
&nbsp;		case VALUES: {
<b class="fc">&nbsp;			GraphPatternNotTriples();</b>
<b class="fc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == DOT) {</b>
<b class="fc">&nbsp;				jj_consume_token(DOT);</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[54] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			GraphPattern();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="fc">&nbsp;			jj_la1[55] = jj_gen;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void BasicGraphPattern() throws ParseException {/* @bgen(jjtree) BasicGraphPattern */
<b class="fc">&nbsp;		ASTBasicGraphPattern jjtn000 = new ASTBasicGraphPattern(JJTBASICGRAPHPATTERN);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case LPAREN:
&nbsp;			case LBRACK:
&nbsp;			case NIL:
&nbsp;			case ANON:
&nbsp;			case TRUE:
&nbsp;			case FALSE:
&nbsp;			case Q_IRI_REF:
&nbsp;			case PNAME_NS:
&nbsp;			case PNAME_LN:
&nbsp;			case BLANK_NODE_LABEL:
&nbsp;			case VAR1:
&nbsp;			case VAR2:
&nbsp;			case INTEGER:
&nbsp;			case INTEGER_POSITIVE:
&nbsp;			case INTEGER_NEGATIVE:
&nbsp;			case DECIMAL:
&nbsp;			case DECIMAL_POSITIVE:
&nbsp;			case DECIMAL_NEGATIVE:
&nbsp;			case DOUBLE:
&nbsp;			case DOUBLE_POSITIVE:
&nbsp;			case DOUBLE_NEGATIVE:
&nbsp;			case STRING_LITERAL1:
&nbsp;			case STRING_LITERAL2:
&nbsp;			case STRING_LITERAL_LONG1:
&nbsp;			case STRING_LITERAL_LONG2:
&nbsp;			case TRIPLE_OPEN: {
<b class="fc">&nbsp;				TriplesBlock();</b>
&nbsp;				label_16: while (true) {
<b class="fc">&nbsp;					switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;					case FILTER:
&nbsp;					case BIND: {
<b class="fc">&nbsp;						break;</b>
&nbsp;					}
&nbsp;					default:
<b class="fc">&nbsp;						jj_la1[56] = jj_gen;</b>
<b class="fc">&nbsp;						break label_16;</b>
&nbsp;					}
<b class="fc">&nbsp;					FilterOrBind();</b>
<b class="pc">&nbsp;					if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == DOT) {</b>
<b class="fc">&nbsp;						jj_consume_token(DOT);</b>
&nbsp;					} else {
<b class="fc">&nbsp;						jj_la1[57] = jj_gen;</b>
&nbsp;					}
<b class="pc">&nbsp;					switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;					case LPAREN:
&nbsp;					case LBRACK:
&nbsp;					case NIL:
&nbsp;					case ANON:
&nbsp;					case TRUE:
&nbsp;					case FALSE:
&nbsp;					case Q_IRI_REF:
&nbsp;					case PNAME_NS:
&nbsp;					case PNAME_LN:
&nbsp;					case BLANK_NODE_LABEL:
&nbsp;					case VAR1:
&nbsp;					case VAR2:
&nbsp;					case INTEGER:
&nbsp;					case INTEGER_POSITIVE:
&nbsp;					case INTEGER_NEGATIVE:
&nbsp;					case DECIMAL:
&nbsp;					case DECIMAL_POSITIVE:
&nbsp;					case DECIMAL_NEGATIVE:
&nbsp;					case DOUBLE:
&nbsp;					case DOUBLE_POSITIVE:
&nbsp;					case DOUBLE_NEGATIVE:
&nbsp;					case STRING_LITERAL1:
&nbsp;					case STRING_LITERAL2:
&nbsp;					case STRING_LITERAL_LONG1:
&nbsp;					case STRING_LITERAL_LONG2:
&nbsp;					case TRIPLE_OPEN: {
<b class="fc">&nbsp;						TriplesBlock();</b>
<b class="fc">&nbsp;						break;</b>
&nbsp;					}
&nbsp;					default:
<b class="fc">&nbsp;						jj_la1[58] = jj_gen;</b>
&nbsp;					}
&nbsp;				}
&nbsp;				break;
&nbsp;			}
&nbsp;			case FILTER:
&nbsp;			case BIND: {
&nbsp;				label_17: while (true) {
<b class="fc">&nbsp;					FilterOrBind();</b>
<b class="pc">&nbsp;					if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == DOT) {</b>
<b class="nc">&nbsp;						jj_consume_token(DOT);</b>
&nbsp;					} else {
<b class="fc">&nbsp;						jj_la1[59] = jj_gen;</b>
&nbsp;					}
<b class="pc">&nbsp;					switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;					case LPAREN:
&nbsp;					case LBRACK:
&nbsp;					case NIL:
&nbsp;					case ANON:
&nbsp;					case TRUE:
&nbsp;					case FALSE:
&nbsp;					case Q_IRI_REF:
&nbsp;					case PNAME_NS:
&nbsp;					case PNAME_LN:
&nbsp;					case BLANK_NODE_LABEL:
&nbsp;					case VAR1:
&nbsp;					case VAR2:
&nbsp;					case INTEGER:
&nbsp;					case INTEGER_POSITIVE:
&nbsp;					case INTEGER_NEGATIVE:
&nbsp;					case DECIMAL:
&nbsp;					case DECIMAL_POSITIVE:
&nbsp;					case DECIMAL_NEGATIVE:
&nbsp;					case DOUBLE:
&nbsp;					case DOUBLE_POSITIVE:
&nbsp;					case DOUBLE_NEGATIVE:
&nbsp;					case STRING_LITERAL1:
&nbsp;					case STRING_LITERAL2:
&nbsp;					case STRING_LITERAL_LONG1:
&nbsp;					case STRING_LITERAL_LONG2:
&nbsp;					case TRIPLE_OPEN: {
<b class="fc">&nbsp;						TriplesBlock();</b>
<b class="fc">&nbsp;						break;</b>
&nbsp;					}
&nbsp;					default:
<b class="fc">&nbsp;						jj_la1[60] = jj_gen;</b>
&nbsp;					}
<b class="fc">&nbsp;					switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;					case FILTER:
&nbsp;					case BIND: {
<b class="fc">&nbsp;						break;</b>
&nbsp;					}
&nbsp;					default:
<b class="fc">&nbsp;						jj_la1[61] = jj_gen;</b>
<b class="fc">&nbsp;						break label_17;</b>
&nbsp;					}
&nbsp;				}
&nbsp;				break;
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[62] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void FilterOrBind() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case FILTER: {
<b class="fc">&nbsp;			Filter();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case BIND: {
<b class="fc">&nbsp;			Bind();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[63] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void TriplesBlock() throws ParseException {
<b class="fc">&nbsp;		TriplesSameSubjectPath();</b>
<b class="fc">&nbsp;		while (jj_2_2()) {</b>
<b class="fc">&nbsp;			jj_consume_token(DOT);</b>
<b class="fc">&nbsp;			TriplesSameSubjectPath();</b>
&nbsp;		}
<b class="pc">&nbsp;		if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == DOT) {</b>
<b class="fc">&nbsp;			jj_consume_token(DOT);</b>
&nbsp;		} else {
<b class="fc">&nbsp;			jj_la1[64] = jj_gen;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void TriplesTemplate() throws ParseException {
<b class="fc">&nbsp;		TriplesSameSubject();</b>
<b class="pc">&nbsp;		while (jj_2_3()) {</b>
<b class="nc">&nbsp;			jj_consume_token(DOT);</b>
<b class="nc">&nbsp;			TriplesSameSubject();</b>
&nbsp;		}
<b class="pc">&nbsp;		if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == DOT) {</b>
<b class="fc">&nbsp;			jj_consume_token(DOT);</b>
&nbsp;		} else {
<b class="fc">&nbsp;			jj_la1[65] = jj_gen;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void GraphPatternNotTriples() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case OPTIONAL: {
<b class="fc">&nbsp;			OptionalGraphPattern();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case LBRACE: {
<b class="fc">&nbsp;			GroupOrUnionGraphPattern();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case GRAPH: {
<b class="fc">&nbsp;			GraphGraphPattern();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case MINUS_SETOPER: {
<b class="fc">&nbsp;			MinusGraphPattern();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case SERVICE: {
<b class="nc">&nbsp;			ServiceGraphPattern();</b>
<b class="nc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case VALUES: {
<b class="fc">&nbsp;			InlineData();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[66] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void OptionalGraphPattern() throws ParseException {/* @bgen(jjtree) OptionalGraphPattern */
<b class="fc">&nbsp;		ASTOptionalGraphPattern jjtn000 = new ASTOptionalGraphPattern(JJTOPTIONALGRAPHPATTERN);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(OPTIONAL);</b>
<b class="fc">&nbsp;			jj_consume_token(LBRACE);</b>
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == SELECT) {</b>
<b class="fc">&nbsp;				SubSelect();</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[67] = jj_gen;</b>
<b class="fc">&nbsp;				GraphPattern();</b>
&nbsp;			}
<b class="fc">&nbsp;			jj_consume_token(RBRACE);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void GraphGraphPattern() throws ParseException {/* @bgen(jjtree) GraphGraphPattern */
<b class="fc">&nbsp;		ASTGraphGraphPattern jjtn000 = new ASTGraphGraphPattern(JJTGRAPHGRAPHPATTERN);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(GRAPH);</b>
<b class="fc">&nbsp;			VarOrIRIref();</b>
<b class="fc">&nbsp;			GroupGraphPattern();</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void GroupOrUnionGraphPattern() throws ParseException {
<b class="fc">&nbsp;		GroupGraphPattern();</b>
<b class="pc">&nbsp;		if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == UNION) {</b>
<b class="fc">&nbsp;			jj_consume_token(UNION);</b>
<b class="fc">&nbsp;			ASTUnionGraphPattern jjtn001 = new ASTUnionGraphPattern(JJTUNIONGRAPHPATTERN);</b>
<b class="fc">&nbsp;			boolean jjtc001 = true;</b>
<b class="fc">&nbsp;			jjtree.openNodeScope(jjtn001);</b>
&nbsp;			try {
<b class="fc">&nbsp;				GroupOrUnionGraphPattern();</b>
<b class="nc">&nbsp;			} catch (Throwable jjte001) {</b>
<b class="nc">&nbsp;				jjtree.clearNodeScope(jjtn001);</b>
<b class="nc">&nbsp;				jjtc001 = false;</b>
<b class="nc">&nbsp;				if (jjte001 instanceof RuntimeException) {</b>
&nbsp;					{
<b class="nc">&nbsp;						throw (RuntimeException) jjte001;</b>
&nbsp;					}
&nbsp;				}
<b class="nc">&nbsp;				if (jjte001 instanceof ParseException) {</b>
&nbsp;					{
<b class="nc">&nbsp;						throw (ParseException) jjte001;</b>
&nbsp;					}
&nbsp;				}
&nbsp;				{
<b class="nc">&nbsp;					throw (Error) jjte001;</b>
&nbsp;				}
&nbsp;			} finally {
<b class="pc">&nbsp;				if (jjtc001) {</b>
<b class="fc">&nbsp;					jjtree.closeNodeScope(jjtn001, 2);</b>
&nbsp;				}
<b class="nc">&nbsp;			}</b>
<b class="fc">&nbsp;		} else {</b>
<b class="fc">&nbsp;			jj_la1[68] = jj_gen;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void MinusGraphPattern() throws ParseException {/* @bgen(jjtree) MinusGraphPattern */
<b class="fc">&nbsp;		ASTMinusGraphPattern jjtn000 = new ASTMinusGraphPattern(JJTMINUSGRAPHPATTERN);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(MINUS_SETOPER);</b>
<b class="fc">&nbsp;			GroupGraphPattern();</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void ServiceGraphPattern() throws ParseException {/* @bgen(jjtree) ServiceGraphPattern */
<b class="nc">&nbsp;		ASTServiceGraphPattern jjtn000 = new ASTServiceGraphPattern(JJTSERVICEGRAPHPATTERN);</b>
<b class="nc">&nbsp;		boolean jjtc000 = true;</b>
<b class="nc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		Token t;
&nbsp;		try {
<b class="nc">&nbsp;			t = jj_consume_token(SERVICE);</b>
<b class="nc">&nbsp;			jjtn000.setBeginTokenLinePos(t.beginLine);</b>
<b class="nc">&nbsp;			jjtn000.setBeginTokenColumnPos(t.beginColumn);</b>
<b class="nc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == SILENT) {</b>
<b class="nc">&nbsp;				jj_consume_token(SILENT);</b>
<b class="nc">&nbsp;				jjtn000.setSilent(true);</b>
&nbsp;			} else {
<b class="nc">&nbsp;				jj_la1[69] = jj_gen;</b>
&nbsp;			}
<b class="nc">&nbsp;			VarOrIRIref();</b>
<b class="nc">&nbsp;			t = GroupGraphPattern();</b>
<b class="nc">&nbsp;			jjtree.closeNodeScope(jjtn000, true);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			jjtn000.setEndTokenLinePos(t.beginLine);</b>
<b class="nc">&nbsp;			jjtn000.setEndTokenColumnPos(t.beginColumn);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;				jjtc000 = false;</b>
&nbsp;			} else {
<b class="nc">&nbsp;				jjtree.popNode();</b>
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="nc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Filter() throws ParseException {
<b class="fc">&nbsp;		jj_consume_token(FILTER);</b>
<b class="fc">&nbsp;		Constraint();</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Constraint() throws ParseException {/* @bgen(jjtree) Constraint */
<b class="fc">&nbsp;		ASTConstraint jjtn000 = new ASTConstraint(JJTCONSTRAINT);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case LPAREN: {
<b class="fc">&nbsp;				BrackettedExpression();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case NOT_FUNC:
&nbsp;			case EXISTS:
&nbsp;			case STR:
&nbsp;			case LANG:
&nbsp;			case LANGMATCHES:
&nbsp;			case DATATYPE:
&nbsp;			case BOUND:
&nbsp;			case SAMETERM:
&nbsp;			case IS_IRI:
&nbsp;			case IS_BLANK:
&nbsp;			case IS_LITERAL:
&nbsp;			case IS_NUMERIC:
&nbsp;			case COALESCE:
&nbsp;			case BNODE:
&nbsp;			case STRDT:
&nbsp;			case STRLANG:
&nbsp;			case UUID:
&nbsp;			case STRUUID:
&nbsp;			case IRI:
&nbsp;			case IF:
&nbsp;			case REGEX:
&nbsp;			case STRLEN:
&nbsp;			case SUBSTR:
&nbsp;			case STR_STARTS:
&nbsp;			case STR_ENDS:
&nbsp;			case STR_BEFORE:
&nbsp;			case STR_AFTER:
&nbsp;			case REPLACE:
&nbsp;			case UCASE:
&nbsp;			case LCASE:
&nbsp;			case CONCAT:
&nbsp;			case CONTAINS:
&nbsp;			case ENCODE_FOR_URI:
&nbsp;			case RAND:
&nbsp;			case ABS:
&nbsp;			case CEIL:
&nbsp;			case FLOOR:
&nbsp;			case ROUND:
&nbsp;			case NOW:
&nbsp;			case YEAR:
&nbsp;			case MONTH:
&nbsp;			case DAY:
&nbsp;			case HOURS:
&nbsp;			case MINUTES:
&nbsp;			case SECONDS:
&nbsp;			case TIMEZONE:
&nbsp;			case TZ:
&nbsp;			case MD5:
&nbsp;			case SHA1:
&nbsp;			case SHA224:
&nbsp;			case SHA256:
&nbsp;			case SHA384:
&nbsp;			case SHA512: {
<b class="fc">&nbsp;				BuiltInCall();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case Q_IRI_REF:
&nbsp;			case PNAME_NS:
&nbsp;			case PNAME_LN: {
<b class="nc">&nbsp;				FunctionCall();</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[70] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void FunctionCall() throws ParseException {/* @bgen(jjtree) FunctionCall */
<b class="fc">&nbsp;		ASTFunctionCall jjtn000 = new ASTFunctionCall(JJTFUNCTIONCALL);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			IRIref();</b>
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case LPAREN:
<b class="fc">&nbsp;				jj_consume_token(LPAREN);</b>
<b class="pc">&nbsp;				if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == DISTINCT) {</b>
<b class="nc">&nbsp;					jj_consume_token(DISTINCT);</b>
<b class="nc">&nbsp;					jjtn000.setDistinct(true);</b>
&nbsp;				} else {
<b class="fc">&nbsp;					jj_la1[71] = jj_gen;</b>
&nbsp;				}
<b class="fc">&nbsp;				Expression();</b>
&nbsp;				while (true) {
<b class="pc">&nbsp;					if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) != COMMA) {</b>
<b class="fc">&nbsp;						jj_la1[72] = jj_gen;</b>
<b class="fc">&nbsp;						break;</b>
&nbsp;					}
<b class="nc">&nbsp;					jj_consume_token(COMMA);</b>
<b class="nc">&nbsp;					Expression();</b>
&nbsp;				}
<b class="fc">&nbsp;				jj_consume_token(RPAREN);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			case NIL:
<b class="nc">&nbsp;				jj_consume_token(NIL);</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[73] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void ArgList() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case NIL:
<b class="fc">&nbsp;			jj_consume_token(NIL);</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		case LPAREN:
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
&nbsp;			while (true) {
<b class="pc">&nbsp;				if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) != COMMA) {</b>
<b class="fc">&nbsp;					jj_la1[74] = jj_gen;</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
<b class="fc">&nbsp;				jj_consume_token(COMMA);</b>
<b class="fc">&nbsp;				Expression();</b>
&nbsp;			}
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[75] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void TriplesSameSubject() throws ParseException {/* @bgen(jjtree) TriplesSameSubject */
<b class="fc">&nbsp;		ASTTriplesSameSubject jjtn000 = new ASTTriplesSameSubject(JJTTRIPLESSAMESUBJECT);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case NIL:
&nbsp;			case ANON:
&nbsp;			case TRUE:
&nbsp;			case FALSE:
&nbsp;			case Q_IRI_REF:
&nbsp;			case PNAME_NS:
&nbsp;			case PNAME_LN:
&nbsp;			case BLANK_NODE_LABEL:
&nbsp;			case VAR1:
&nbsp;			case VAR2:
&nbsp;			case INTEGER:
&nbsp;			case INTEGER_POSITIVE:
&nbsp;			case INTEGER_NEGATIVE:
&nbsp;			case DECIMAL:
&nbsp;			case DECIMAL_POSITIVE:
&nbsp;			case DECIMAL_NEGATIVE:
&nbsp;			case DOUBLE:
&nbsp;			case DOUBLE_POSITIVE:
&nbsp;			case DOUBLE_NEGATIVE:
&nbsp;			case STRING_LITERAL1:
&nbsp;			case STRING_LITERAL2:
&nbsp;			case STRING_LITERAL_LONG1:
&nbsp;			case STRING_LITERAL_LONG2:
&nbsp;			case TRIPLE_OPEN: {
<b class="fc">&nbsp;				VarOrTerm();</b>
<b class="fc">&nbsp;				PropertyList();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case LPAREN:
&nbsp;			case LBRACK: {
<b class="nc">&nbsp;				TriplesNode();</b>
<b class="nc">&nbsp;				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;				case IS_A:
&nbsp;				case Q_IRI_REF:
&nbsp;				case PNAME_NS:
&nbsp;				case PNAME_LN:
&nbsp;				case VAR1:
&nbsp;				case VAR2: {
<b class="nc">&nbsp;					PropertyList();</b>
<b class="nc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;				default:
<b class="nc">&nbsp;					jj_la1[76] = jj_gen;</b>
&nbsp;				}
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[77] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void PropertyList() throws ParseException {/* @bgen(jjtree) PropertyList */
<b class="fc">&nbsp;		ASTPropertyList jjtn000 = new ASTPropertyList(JJTPROPERTYLIST);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			Verb();</b>
<b class="fc">&nbsp;			ObjectList();</b>
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == SEMICOLON) {</b>
<b class="nc">&nbsp;				jj_consume_token(SEMICOLON);</b>
<b class="nc">&nbsp;				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;				case IS_A:
&nbsp;				case Q_IRI_REF:
&nbsp;				case PNAME_NS:
&nbsp;				case PNAME_LN:
&nbsp;				case VAR1:
&nbsp;				case VAR2: {
<b class="nc">&nbsp;					PropertyList();</b>
<b class="nc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;				default:
<b class="nc">&nbsp;					jj_la1[78] = jj_gen;</b>
&nbsp;				}
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[79] = jj_gen;</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void ObjectList() throws ParseException {/* @bgen(jjtree) ObjectList */
<b class="fc">&nbsp;		ASTObjectList jjtn000 = new ASTObjectList(JJTOBJECTLIST);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			Object();</b>
&nbsp;			while (true) {
<b class="pc">&nbsp;				if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) != COMMA) {</b>
<b class="fc">&nbsp;					jj_la1[80] = jj_gen;</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
<b class="nc">&nbsp;				jj_consume_token(COMMA);</b>
<b class="nc">&nbsp;				Object();</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void TriplesSameSubjectPath() throws ParseException {/* @bgen(jjtree) TriplesSameSubjectPath */
<b class="fc">&nbsp;		ASTTriplesSameSubjectPath jjtn000 = new ASTTriplesSameSubjectPath(JJTTRIPLESSAMESUBJECTPATH);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case NIL:
&nbsp;			case ANON:
&nbsp;			case TRUE:
&nbsp;			case FALSE:
&nbsp;			case Q_IRI_REF:
&nbsp;			case PNAME_NS:
&nbsp;			case PNAME_LN:
&nbsp;			case BLANK_NODE_LABEL:
&nbsp;			case VAR1:
&nbsp;			case VAR2:
&nbsp;			case INTEGER:
&nbsp;			case INTEGER_POSITIVE:
&nbsp;			case INTEGER_NEGATIVE:
&nbsp;			case DECIMAL:
&nbsp;			case DECIMAL_POSITIVE:
&nbsp;			case DECIMAL_NEGATIVE:
&nbsp;			case DOUBLE:
&nbsp;			case DOUBLE_POSITIVE:
&nbsp;			case DOUBLE_NEGATIVE:
&nbsp;			case STRING_LITERAL1:
&nbsp;			case STRING_LITERAL2:
&nbsp;			case STRING_LITERAL_LONG1:
&nbsp;			case STRING_LITERAL_LONG2:
&nbsp;			case TRIPLE_OPEN: {
<b class="fc">&nbsp;				VarOrTerm();</b>
<b class="fc">&nbsp;				PropertyListPath();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case LPAREN:
&nbsp;			case LBRACK: {
<b class="nc">&nbsp;				TriplesNodePath();</b>
<b class="nc">&nbsp;				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;				case LPAREN:
&nbsp;				case NOT:
&nbsp;				case INVERSE:
&nbsp;				case IS_A:
&nbsp;				case Q_IRI_REF:
&nbsp;				case PNAME_NS:
&nbsp;				case PNAME_LN:
&nbsp;				case VAR1:
&nbsp;				case VAR2: {
<b class="nc">&nbsp;					PropertyListPath();</b>
<b class="nc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;				default:
<b class="nc">&nbsp;					jj_la1[81] = jj_gen;</b>
&nbsp;				}
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[82] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void PropertyListPath() throws ParseException {/* @bgen(jjtree) PropertyListPath */
<b class="fc">&nbsp;		ASTPropertyListPath jjtn000 = new ASTPropertyListPath(JJTPROPERTYLISTPATH);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case LPAREN:
&nbsp;			case NOT:
&nbsp;			case INVERSE:
&nbsp;			case IS_A:
&nbsp;			case Q_IRI_REF:
&nbsp;			case PNAME_NS:
&nbsp;			case PNAME_LN: {
<b class="fc">&nbsp;				VerbPath();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case VAR1:
&nbsp;			case VAR2: {
<b class="fc">&nbsp;				VerbSimple();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[83] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="fc">&nbsp;			ObjectListPath();</b>
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == SEMICOLON) {</b>
<b class="fc">&nbsp;				jj_consume_token(SEMICOLON);</b>
<b class="pc">&nbsp;				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;				case LPAREN:
&nbsp;				case NOT:
&nbsp;				case INVERSE:
&nbsp;				case IS_A:
&nbsp;				case Q_IRI_REF:
&nbsp;				case PNAME_NS:
&nbsp;				case PNAME_LN:
&nbsp;				case VAR1:
&nbsp;				case VAR2: {
<b class="fc">&nbsp;					PropertyListPath();</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;				default:
<b class="fc">&nbsp;					jj_la1[84] = jj_gen;</b>
&nbsp;				}
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[85] = jj_gen;</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void ObjectListPath() throws ParseException {/* @bgen(jjtree) ObjectList */
<b class="fc">&nbsp;		ASTObjectList jjtn000 = new ASTObjectList(JJTOBJECTLIST);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			ObjectPath();</b>
&nbsp;			while (true) {
<b class="fc">&nbsp;				if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) != COMMA) {</b>
<b class="fc">&nbsp;					jj_la1[86] = jj_gen;</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
<b class="fc">&nbsp;				jj_consume_token(COMMA);</b>
<b class="fc">&nbsp;				ObjectPath();</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void VerbPath() throws ParseException {
<b class="fc">&nbsp;		Path();</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Path() throws ParseException {
<b class="fc">&nbsp;		PathAlternative();</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void PathAlternative() throws ParseException {/* @bgen(jjtree) PathAlternative */
<b class="fc">&nbsp;		ASTPathAlternative jjtn000 = new ASTPathAlternative(JJTPATHALTERNATIVE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			PathSequence();</b>
&nbsp;			while (true) {
<b class="pc">&nbsp;				if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) != PIPE) {</b>
<b class="fc">&nbsp;					jj_la1[87] = jj_gen;</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
<b class="fc">&nbsp;				jj_consume_token(PIPE);</b>
<b class="fc">&nbsp;				PathSequence();</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void PathSequence() throws ParseException {/* @bgen(jjtree) PathSequence */
<b class="fc">&nbsp;		ASTPathSequence jjtn000 = new ASTPathSequence(JJTPATHSEQUENCE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			PathElt();</b>
&nbsp;			while (true) {
<b class="fc">&nbsp;				if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) != SLASH) {</b>
<b class="fc">&nbsp;					jj_la1[88] = jj_gen;</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
<b class="fc">&nbsp;				jj_consume_token(SLASH);</b>
<b class="fc">&nbsp;				PathElt();</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void PathElt() throws ParseException {/* @bgen(jjtree) PathElt */
<b class="fc">&nbsp;		ASTPathElt jjtn000 = new ASTPathElt(JJTPATHELT);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == INVERSE) {</b>
<b class="fc">&nbsp;				jj_consume_token(INVERSE);</b>
<b class="fc">&nbsp;				jjtn000.setInverse(true);</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[89] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			PathPrimary();</b>
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case PLUS:
&nbsp;			case STAR:
&nbsp;			case QUESTION: {
<b class="fc">&nbsp;				PathMod();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="fc">&nbsp;				jj_la1[90] = jj_gen;</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void PathPrimary() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case Q_IRI_REF:
&nbsp;		case PNAME_NS:
&nbsp;		case PNAME_LN: {
<b class="fc">&nbsp;			IRIref();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case IS_A: {
<b class="fc">&nbsp;			jj_consume_token(IS_A);</b>
<b class="fc">&nbsp;			ASTIRI jjtn001 = new ASTIRI(JJTIRI);</b>
<b class="fc">&nbsp;			boolean jjtc001 = true;</b>
<b class="fc">&nbsp;			jjtree.openNodeScope(jjtn001);</b>
&nbsp;			try {
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn001, true);</b>
<b class="fc">&nbsp;				jjtc001 = false;</b>
<b class="fc">&nbsp;				jjtn001.setValue(RDF.TYPE.toString());</b>
&nbsp;			} finally {
<b class="pc">&nbsp;				if (jjtc001) {</b>
<b class="nc">&nbsp;					jjtree.closeNodeScope(jjtn001, true);</b>
&nbsp;				}
<b class="nc">&nbsp;			}</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case NOT: {
<b class="fc">&nbsp;			jj_consume_token(NOT);</b>
<b class="fc">&nbsp;			PathNegatedPropertySet();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case LPAREN: {
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Path();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[91] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void PathNegatedPropertySet() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case INVERSE:
&nbsp;		case IS_A:
&nbsp;		case Q_IRI_REF:
&nbsp;		case PNAME_NS:
&nbsp;		case PNAME_LN: {
<b class="fc">&nbsp;			PathOneInPropertySet();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case LPAREN: {
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case INVERSE:
&nbsp;			case IS_A:
&nbsp;			case Q_IRI_REF:
&nbsp;			case PNAME_NS:
&nbsp;			case PNAME_LN: {
<b class="fc">&nbsp;				PathOneInPropertySet();</b>
&nbsp;				while (true) {
<b class="pc">&nbsp;					if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) != PIPE) {</b>
<b class="fc">&nbsp;						jj_la1[92] = jj_gen;</b>
<b class="fc">&nbsp;						break;</b>
&nbsp;					}
<b class="fc">&nbsp;					jj_consume_token(PIPE);</b>
<b class="fc">&nbsp;					PathOneInPropertySet();</b>
&nbsp;				}
&nbsp;				break;
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[93] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[94] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void PathOneInPropertySet() throws ParseException {/* @bgen(jjtree) PathOneInPropertySet */
<b class="fc">&nbsp;		ASTPathOneInPropertySet jjtn000 = new ASTPathOneInPropertySet(JJTPATHONEINPROPERTYSET);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case Q_IRI_REF:
&nbsp;			case PNAME_NS:
&nbsp;			case PNAME_LN: {
<b class="fc">&nbsp;				IRIref();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case IS_A: {
<b class="nc">&nbsp;				jj_consume_token(IS_A);</b>
<b class="nc">&nbsp;				ASTIRI jjtn001 = new ASTIRI(JJTIRI);</b>
<b class="nc">&nbsp;				boolean jjtc001 = true;</b>
<b class="nc">&nbsp;				jjtree.openNodeScope(jjtn001);</b>
&nbsp;				try {
<b class="nc">&nbsp;					jjtree.closeNodeScope(jjtn001, true);</b>
<b class="nc">&nbsp;					jjtc001 = false;</b>
<b class="nc">&nbsp;					jjtn001.setValue(RDF.TYPE.toString());</b>
&nbsp;				} finally {
<b class="nc">&nbsp;					if (jjtc001) {</b>
<b class="nc">&nbsp;						jjtree.closeNodeScope(jjtn001, true);</b>
&nbsp;					}
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case INVERSE: {
<b class="nc">&nbsp;				jj_consume_token(INVERSE);</b>
<b class="nc">&nbsp;				jjtn000.setInverse(true);</b>
<b class="nc">&nbsp;				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;				case Q_IRI_REF:
&nbsp;				case PNAME_NS:
&nbsp;				case PNAME_LN: {
<b class="nc">&nbsp;					IRIref();</b>
<b class="nc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;				case IS_A: {
<b class="nc">&nbsp;					jj_consume_token(IS_A);</b>
<b class="nc">&nbsp;					ASTIRI jjtn002 = new ASTIRI(JJTIRI);</b>
<b class="nc">&nbsp;					boolean jjtc002 = true;</b>
<b class="nc">&nbsp;					jjtree.openNodeScope(jjtn002);</b>
&nbsp;					try {
<b class="nc">&nbsp;						jjtree.closeNodeScope(jjtn002, true);</b>
<b class="nc">&nbsp;						jjtc002 = false;</b>
<b class="nc">&nbsp;						jjtn002.setValue(RDF.TYPE.toString());</b>
&nbsp;					} finally {
<b class="nc">&nbsp;						if (jjtc002) {</b>
<b class="nc">&nbsp;							jjtree.closeNodeScope(jjtn002, true);</b>
&nbsp;						}
<b class="nc">&nbsp;					}</b>
<b class="nc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;				default:
<b class="nc">&nbsp;					jj_la1[95] = jj_gen;</b>
<b class="nc">&nbsp;					jj_consume_token(-1);</b>
<b class="nc">&nbsp;					throw new ParseException();</b>
&nbsp;				}
&nbsp;				break;
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[96] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void PathMod() throws ParseException {/* @bgen(jjtree) PathMod */
<b class="fc">&nbsp;		ASTPathMod jjtn000 = new ASTPathMod(JJTPATHMOD);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case STAR: {
<b class="fc">&nbsp;				jj_consume_token(STAR);</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
<b class="fc">&nbsp;				jjtc000 = false;</b>
<b class="fc">&nbsp;				jjtn000.setLowerBound(0);</b>
<b class="fc">&nbsp;				jjtn000.setUpperBound(Long.MAX_VALUE);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case QUESTION: {
<b class="fc">&nbsp;				jj_consume_token(QUESTION);</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
<b class="fc">&nbsp;				jjtc000 = false;</b>
<b class="fc">&nbsp;				jjtn000.setLowerBound(0);</b>
<b class="fc">&nbsp;				jjtn000.setUpperBound(1);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case PLUS: {
<b class="fc">&nbsp;				jj_consume_token(PLUS);</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
<b class="fc">&nbsp;				jjtc000 = false;</b>
<b class="fc">&nbsp;				jjtn000.setLowerBound(1);</b>
<b class="fc">&nbsp;				jjtn000.setUpperBound(Long.MAX_VALUE);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[97] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void VerbSimple() throws ParseException {
<b class="fc">&nbsp;		Var();</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Object() throws ParseException {
<b class="fc">&nbsp;		GraphNode();</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void ObjectPath() throws ParseException {
<b class="fc">&nbsp;		GraphNodePath();</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Verb() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case Q_IRI_REF:
&nbsp;		case PNAME_NS:
&nbsp;		case PNAME_LN:
&nbsp;		case VAR1:
&nbsp;		case VAR2: {
<b class="fc">&nbsp;			VarOrIRIref();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case IS_A: {
<b class="nc">&nbsp;			jj_consume_token(IS_A);</b>
<b class="nc">&nbsp;			ASTIRI jjtn001 = new ASTIRI(JJTIRI);</b>
<b class="nc">&nbsp;			boolean jjtc001 = true;</b>
<b class="nc">&nbsp;			jjtree.openNodeScope(jjtn001);</b>
&nbsp;			try {
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn001, true);</b>
<b class="nc">&nbsp;				jjtc001 = false;</b>
<b class="nc">&nbsp;				jjtn001.setValue(RDF.TYPE.toString());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				if (jjtc001) {</b>
<b class="nc">&nbsp;					jjtree.closeNodeScope(jjtn001, true);</b>
&nbsp;				}
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[98] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void TriplesNode() throws ParseException {
<b class="nc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case LPAREN: {
<b class="nc">&nbsp;			Collection();</b>
<b class="nc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case LBRACK: {
<b class="nc">&nbsp;			BlankNodePropertyList();</b>
<b class="nc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[99] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void TriplesNodePath() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case LPAREN: {
<b class="nc">&nbsp;			CollectionPath();</b>
<b class="nc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case LBRACK: {
<b class="fc">&nbsp;			BlankNodePropertyListPath();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[100] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void BlankNodePropertyList() throws ParseException {/* @bgen(jjtree) BlankNodePropertyList */
<b class="nc">&nbsp;		ASTBlankNodePropertyList jjtn000 = new ASTBlankNodePropertyList(JJTBLANKNODEPROPERTYLIST);</b>
<b class="nc">&nbsp;		boolean jjtc000 = true;</b>
<b class="nc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="nc">&nbsp;			jj_consume_token(LBRACK);</b>
<b class="nc">&nbsp;			PropertyList();</b>
<b class="nc">&nbsp;			jj_consume_token(RBRACK);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="nc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void BlankNodePropertyListPath() throws ParseException {/* @bgen(jjtree) BlankNodePropertyList */
<b class="fc">&nbsp;		ASTBlankNodePropertyList jjtn000 = new ASTBlankNodePropertyList(JJTBLANKNODEPROPERTYLIST);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(LBRACK);</b>
<b class="fc">&nbsp;			PropertyListPath();</b>
<b class="fc">&nbsp;			jj_consume_token(RBRACK);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Collection() throws ParseException {/* @bgen(jjtree) Collection */
<b class="nc">&nbsp;		ASTCollection jjtn000 = new ASTCollection(JJTCOLLECTION);</b>
<b class="nc">&nbsp;		boolean jjtc000 = true;</b>
<b class="nc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="nc">&nbsp;			jj_consume_token(LPAREN);</b>
&nbsp;			label_27: while (true) {
<b class="nc">&nbsp;				GraphNode();</b>
<b class="nc">&nbsp;				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;				case LPAREN:
&nbsp;				case LBRACK:
&nbsp;				case NIL:
&nbsp;				case ANON:
&nbsp;				case TRUE:
&nbsp;				case FALSE:
&nbsp;				case Q_IRI_REF:
&nbsp;				case PNAME_NS:
&nbsp;				case PNAME_LN:
&nbsp;				case BLANK_NODE_LABEL:
&nbsp;				case VAR1:
&nbsp;				case VAR2:
&nbsp;				case INTEGER:
&nbsp;				case INTEGER_POSITIVE:
&nbsp;				case INTEGER_NEGATIVE:
&nbsp;				case DECIMAL:
&nbsp;				case DECIMAL_POSITIVE:
&nbsp;				case DECIMAL_NEGATIVE:
&nbsp;				case DOUBLE:
&nbsp;				case DOUBLE_POSITIVE:
&nbsp;				case DOUBLE_NEGATIVE:
&nbsp;				case STRING_LITERAL1:
&nbsp;				case STRING_LITERAL2:
&nbsp;				case STRING_LITERAL_LONG1:
&nbsp;				case STRING_LITERAL_LONG2:
&nbsp;				case TRIPLE_OPEN: {
<b class="nc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;				default:
<b class="nc">&nbsp;					jj_la1[101] = jj_gen;</b>
<b class="nc">&nbsp;					break label_27;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="nc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void CollectionPath() throws ParseException {/* @bgen(jjtree) Collection */
<b class="nc">&nbsp;		ASTCollection jjtn000 = new ASTCollection(JJTCOLLECTION);</b>
<b class="nc">&nbsp;		boolean jjtc000 = true;</b>
<b class="nc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="nc">&nbsp;			jj_consume_token(LPAREN);</b>
&nbsp;			label_28: while (true) {
<b class="nc">&nbsp;				GraphNodePath();</b>
<b class="nc">&nbsp;				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;				case LPAREN:
&nbsp;				case LBRACK:
&nbsp;				case NIL:
&nbsp;				case ANON:
&nbsp;				case TRUE:
&nbsp;				case FALSE:
&nbsp;				case Q_IRI_REF:
&nbsp;				case PNAME_NS:
&nbsp;				case PNAME_LN:
&nbsp;				case BLANK_NODE_LABEL:
&nbsp;				case VAR1:
&nbsp;				case VAR2:
&nbsp;				case INTEGER:
&nbsp;				case INTEGER_POSITIVE:
&nbsp;				case INTEGER_NEGATIVE:
&nbsp;				case DECIMAL:
&nbsp;				case DECIMAL_POSITIVE:
&nbsp;				case DECIMAL_NEGATIVE:
&nbsp;				case DOUBLE:
&nbsp;				case DOUBLE_POSITIVE:
&nbsp;				case DOUBLE_NEGATIVE:
&nbsp;				case STRING_LITERAL1:
&nbsp;				case STRING_LITERAL2:
&nbsp;				case STRING_LITERAL_LONG1:
&nbsp;				case STRING_LITERAL_LONG2:
&nbsp;				case TRIPLE_OPEN: {
<b class="nc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;				default:
<b class="nc">&nbsp;					jj_la1[102] = jj_gen;</b>
<b class="nc">&nbsp;					break label_28;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="nc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void GraphNode() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case NIL:
&nbsp;		case ANON:
&nbsp;		case TRUE:
&nbsp;		case FALSE:
&nbsp;		case Q_IRI_REF:
&nbsp;		case PNAME_NS:
&nbsp;		case PNAME_LN:
&nbsp;		case BLANK_NODE_LABEL:
&nbsp;		case VAR1:
&nbsp;		case VAR2:
&nbsp;		case INTEGER:
&nbsp;		case INTEGER_POSITIVE:
&nbsp;		case INTEGER_NEGATIVE:
&nbsp;		case DECIMAL:
&nbsp;		case DECIMAL_POSITIVE:
&nbsp;		case DECIMAL_NEGATIVE:
&nbsp;		case DOUBLE:
&nbsp;		case DOUBLE_POSITIVE:
&nbsp;		case DOUBLE_NEGATIVE:
&nbsp;		case STRING_LITERAL1:
&nbsp;		case STRING_LITERAL2:
&nbsp;		case STRING_LITERAL_LONG1:
&nbsp;		case STRING_LITERAL_LONG2:
&nbsp;		case TRIPLE_OPEN: {
<b class="fc">&nbsp;			VarOrTerm();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case LPAREN:
&nbsp;		case LBRACK: {
<b class="nc">&nbsp;			TriplesNode();</b>
<b class="nc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[103] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void GraphNodePath() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case NIL:
&nbsp;		case ANON:
&nbsp;		case TRUE:
&nbsp;		case FALSE:
&nbsp;		case Q_IRI_REF:
&nbsp;		case PNAME_NS:
&nbsp;		case PNAME_LN:
&nbsp;		case BLANK_NODE_LABEL:
&nbsp;		case VAR1:
&nbsp;		case VAR2:
&nbsp;		case INTEGER:
&nbsp;		case INTEGER_POSITIVE:
&nbsp;		case INTEGER_NEGATIVE:
&nbsp;		case DECIMAL:
&nbsp;		case DECIMAL_POSITIVE:
&nbsp;		case DECIMAL_NEGATIVE:
&nbsp;		case DOUBLE:
&nbsp;		case DOUBLE_POSITIVE:
&nbsp;		case DOUBLE_NEGATIVE:
&nbsp;		case STRING_LITERAL1:
&nbsp;		case STRING_LITERAL2:
&nbsp;		case STRING_LITERAL_LONG1:
&nbsp;		case STRING_LITERAL_LONG2:
&nbsp;		case TRIPLE_OPEN: {
<b class="fc">&nbsp;			VarOrTerm();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case LPAREN:
&nbsp;		case LBRACK: {
<b class="fc">&nbsp;			TriplesNodePath();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[104] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void VarOrTerm() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case VAR1:
&nbsp;		case VAR2: {
<b class="fc">&nbsp;			Var();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case NIL:
&nbsp;		case ANON:
&nbsp;		case TRUE:
&nbsp;		case FALSE:
&nbsp;		case Q_IRI_REF:
&nbsp;		case PNAME_NS:
&nbsp;		case PNAME_LN:
&nbsp;		case BLANK_NODE_LABEL:
&nbsp;		case INTEGER:
&nbsp;		case INTEGER_POSITIVE:
&nbsp;		case INTEGER_NEGATIVE:
&nbsp;		case DECIMAL:
&nbsp;		case DECIMAL_POSITIVE:
&nbsp;		case DECIMAL_NEGATIVE:
&nbsp;		case DOUBLE:
&nbsp;		case DOUBLE_POSITIVE:
&nbsp;		case DOUBLE_NEGATIVE:
&nbsp;		case STRING_LITERAL1:
&nbsp;		case STRING_LITERAL2:
&nbsp;		case STRING_LITERAL_LONG1:
&nbsp;		case STRING_LITERAL_LONG2:
&nbsp;		case TRIPLE_OPEN: {
<b class="fc">&nbsp;			GraphTerm();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[105] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void VarOrIRIref() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case VAR1:
&nbsp;		case VAR2: {
<b class="fc">&nbsp;			Var();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case Q_IRI_REF:
&nbsp;		case PNAME_NS:
&nbsp;		case PNAME_LN: {
<b class="fc">&nbsp;			IRIref();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[106] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void Var() throws ParseException {/* @bgen(jjtree) Var */
<b class="fc">&nbsp;		ASTVar jjtn000 = new ASTVar(JJTVAR);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		Token t;
&nbsp;		try {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case VAR1: {
<b class="fc">&nbsp;				t = jj_consume_token(VAR1);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case VAR2: {
<b class="fc">&nbsp;				t = jj_consume_token(VAR2);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[107] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="fc">&nbsp;			jjtree.closeNodeScope(jjtn000, true);</b>
<b class="fc">&nbsp;			jjtc000 = false;</b>
<b class="fc">&nbsp;			jjtn000.setName(t.image.substring(1));</b>
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void GraphTerm() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case Q_IRI_REF:
&nbsp;		case PNAME_NS:
&nbsp;		case PNAME_LN: {
<b class="fc">&nbsp;			IRIref();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case STRING_LITERAL1:
&nbsp;		case STRING_LITERAL2:
&nbsp;		case STRING_LITERAL_LONG1:
&nbsp;		case STRING_LITERAL_LONG2: {
<b class="fc">&nbsp;			RDFLiteral();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case INTEGER:
&nbsp;		case INTEGER_POSITIVE:
&nbsp;		case INTEGER_NEGATIVE:
&nbsp;		case DECIMAL:
&nbsp;		case DECIMAL_POSITIVE:
&nbsp;		case DECIMAL_NEGATIVE:
&nbsp;		case DOUBLE:
&nbsp;		case DOUBLE_POSITIVE:
&nbsp;		case DOUBLE_NEGATIVE: {
<b class="fc">&nbsp;			NumericLiteral();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case TRUE:
&nbsp;		case FALSE: {
<b class="nc">&nbsp;			BooleanLiteral();</b>
<b class="nc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case ANON:
&nbsp;		case BLANK_NODE_LABEL: {
<b class="fc">&nbsp;			BlankNode();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case NIL: {
<b class="nc">&nbsp;			jj_consume_token(NIL);</b>
<b class="nc">&nbsp;			ASTIRI jjtn001 = new ASTIRI(JJTIRI);</b>
<b class="nc">&nbsp;			boolean jjtc001 = true;</b>
<b class="nc">&nbsp;			jjtree.openNodeScope(jjtn001);</b>
&nbsp;			try {
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn001, true);</b>
<b class="nc">&nbsp;				jjtc001 = false;</b>
<b class="nc">&nbsp;				jjtn001.setValue(RDF.NIL.toString());</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				if (jjtc001) {</b>
<b class="nc">&nbsp;					jjtree.closeNodeScope(jjtn001, true);</b>
&nbsp;				}
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case TRIPLE_OPEN: {
<b class="nc">&nbsp;			TripleRef();</b>
<b class="nc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[108] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void TripleRef() throws ParseException {/* @bgen(jjtree) TripleRef */
<b class="nc">&nbsp;		ASTTripleRef jjtn000 = new ASTTripleRef(JJTTRIPLEREF);</b>
<b class="nc">&nbsp;		boolean jjtc000 = true;</b>
<b class="nc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="nc">&nbsp;			jj_consume_token(TRIPLE_OPEN);</b>
<b class="nc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case NIL:
&nbsp;			case ANON:
&nbsp;			case TRUE:
&nbsp;			case FALSE:
&nbsp;			case Q_IRI_REF:
&nbsp;			case PNAME_NS:
&nbsp;			case PNAME_LN:
&nbsp;			case BLANK_NODE_LABEL:
&nbsp;			case INTEGER:
&nbsp;			case INTEGER_POSITIVE:
&nbsp;			case INTEGER_NEGATIVE:
&nbsp;			case DECIMAL:
&nbsp;			case DECIMAL_POSITIVE:
&nbsp;			case DECIMAL_NEGATIVE:
&nbsp;			case DOUBLE:
&nbsp;			case DOUBLE_POSITIVE:
&nbsp;			case DOUBLE_NEGATIVE:
&nbsp;			case STRING_LITERAL1:
&nbsp;			case STRING_LITERAL2:
&nbsp;			case STRING_LITERAL_LONG1:
&nbsp;			case STRING_LITERAL_LONG2:
&nbsp;			case TRIPLE_OPEN: {
<b class="nc">&nbsp;				GraphTerm();</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case VAR1:
&nbsp;			case VAR2: {
<b class="nc">&nbsp;				Var();</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[109] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="nc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case Q_IRI_REF:
&nbsp;			case PNAME_NS:
&nbsp;			case PNAME_LN: {
<b class="nc">&nbsp;				IRIref();</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case VAR1:
&nbsp;			case VAR2: {
<b class="nc">&nbsp;				Var();</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[110] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="nc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case NIL:
&nbsp;			case ANON:
&nbsp;			case TRUE:
&nbsp;			case FALSE:
&nbsp;			case Q_IRI_REF:
&nbsp;			case PNAME_NS:
&nbsp;			case PNAME_LN:
&nbsp;			case BLANK_NODE_LABEL:
&nbsp;			case INTEGER:
&nbsp;			case INTEGER_POSITIVE:
&nbsp;			case INTEGER_NEGATIVE:
&nbsp;			case DECIMAL:
&nbsp;			case DECIMAL_POSITIVE:
&nbsp;			case DECIMAL_NEGATIVE:
&nbsp;			case DOUBLE:
&nbsp;			case DOUBLE_POSITIVE:
&nbsp;			case DOUBLE_NEGATIVE:
&nbsp;			case STRING_LITERAL1:
&nbsp;			case STRING_LITERAL2:
&nbsp;			case STRING_LITERAL_LONG1:
&nbsp;			case STRING_LITERAL_LONG2:
&nbsp;			case TRIPLE_OPEN: {
<b class="nc">&nbsp;				GraphTerm();</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case VAR1:
&nbsp;			case VAR2: {
<b class="nc">&nbsp;				Var();</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[111] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="nc">&nbsp;			jj_consume_token(TRIPLE_CLOSE);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="nc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void ConstTripleRef() throws ParseException {/* @bgen(jjtree) ConstTripleRef */
<b class="nc">&nbsp;		ASTConstTripleRef jjtn000 = new ASTConstTripleRef(JJTCONSTTRIPLEREF);</b>
<b class="nc">&nbsp;		boolean jjtc000 = true;</b>
<b class="nc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="nc">&nbsp;			jj_consume_token(TRIPLE_OPEN);</b>
<b class="nc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case TRIPLE_OPEN: {
<b class="nc">&nbsp;				ConstTripleRef();</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case Q_IRI_REF:
&nbsp;			case PNAME_NS:
&nbsp;			case PNAME_LN: {
<b class="nc">&nbsp;				IRIref();</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[112] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="nc">&nbsp;			IRIref();</b>
<b class="nc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case TRIPLE_OPEN: {
<b class="nc">&nbsp;				ConstTripleRef();</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case Q_IRI_REF:
&nbsp;			case PNAME_NS:
&nbsp;			case PNAME_LN: {
<b class="nc">&nbsp;				IRIref();</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case INTEGER:
&nbsp;			case INTEGER_POSITIVE:
&nbsp;			case INTEGER_NEGATIVE:
&nbsp;			case DECIMAL:
&nbsp;			case DECIMAL_POSITIVE:
&nbsp;			case DECIMAL_NEGATIVE:
&nbsp;			case DOUBLE:
&nbsp;			case DOUBLE_POSITIVE:
&nbsp;			case DOUBLE_NEGATIVE: {
<b class="nc">&nbsp;				NumericLiteral();</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case STRING_LITERAL1:
&nbsp;			case STRING_LITERAL2:
&nbsp;			case STRING_LITERAL_LONG1:
&nbsp;			case STRING_LITERAL_LONG2: {
<b class="nc">&nbsp;				RDFLiteral();</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case TRUE:
&nbsp;			case FALSE: {
<b class="nc">&nbsp;				BooleanLiteral();</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[113] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="nc">&nbsp;			jj_consume_token(TRIPLE_CLOSE);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="nc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Expression() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case TRIPLE_OPEN: {
<b class="nc">&nbsp;			TripleRef();</b>
<b class="nc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case LPAREN:
&nbsp;		case NOT:
&nbsp;		case PLUS:
&nbsp;		case MINUS:
&nbsp;		case NOT_FUNC:
&nbsp;		case EXISTS:
&nbsp;		case STR:
&nbsp;		case LANG:
&nbsp;		case LANGMATCHES:
&nbsp;		case DATATYPE:
&nbsp;		case BOUND:
&nbsp;		case SAMETERM:
&nbsp;		case IS_IRI:
&nbsp;		case IS_BLANK:
&nbsp;		case IS_LITERAL:
&nbsp;		case IS_NUMERIC:
&nbsp;		case COALESCE:
&nbsp;		case BNODE:
&nbsp;		case STRDT:
&nbsp;		case STRLANG:
&nbsp;		case UUID:
&nbsp;		case STRUUID:
&nbsp;		case IRI:
&nbsp;		case IF:
&nbsp;		case COUNT:
&nbsp;		case SUM:
&nbsp;		case MIN:
&nbsp;		case MAX:
&nbsp;		case AVG:
&nbsp;		case SAMPLE:
&nbsp;		case GROUP_CONCAT:
&nbsp;		case REGEX:
&nbsp;		case TRUE:
&nbsp;		case FALSE:
&nbsp;		case STRLEN:
&nbsp;		case SUBSTR:
&nbsp;		case STR_STARTS:
&nbsp;		case STR_ENDS:
&nbsp;		case STR_BEFORE:
&nbsp;		case STR_AFTER:
&nbsp;		case REPLACE:
&nbsp;		case UCASE:
&nbsp;		case LCASE:
&nbsp;		case CONCAT:
&nbsp;		case CONTAINS:
&nbsp;		case ENCODE_FOR_URI:
&nbsp;		case RAND:
&nbsp;		case ABS:
&nbsp;		case CEIL:
&nbsp;		case FLOOR:
&nbsp;		case ROUND:
&nbsp;		case NOW:
&nbsp;		case YEAR:
&nbsp;		case MONTH:
&nbsp;		case DAY:
&nbsp;		case HOURS:
&nbsp;		case MINUTES:
&nbsp;		case SECONDS:
&nbsp;		case TIMEZONE:
&nbsp;		case TZ:
&nbsp;		case MD5:
&nbsp;		case SHA1:
&nbsp;		case SHA224:
&nbsp;		case SHA256:
&nbsp;		case SHA384:
&nbsp;		case SHA512:
&nbsp;		case Q_IRI_REF:
&nbsp;		case PNAME_NS:
&nbsp;		case PNAME_LN:
&nbsp;		case VAR1:
&nbsp;		case VAR2:
&nbsp;		case INTEGER:
&nbsp;		case INTEGER_POSITIVE:
&nbsp;		case INTEGER_NEGATIVE:
&nbsp;		case DECIMAL:
&nbsp;		case DECIMAL_POSITIVE:
&nbsp;		case DECIMAL_NEGATIVE:
&nbsp;		case DOUBLE:
&nbsp;		case DOUBLE_POSITIVE:
&nbsp;		case DOUBLE_NEGATIVE:
&nbsp;		case STRING_LITERAL1:
&nbsp;		case STRING_LITERAL2:
&nbsp;		case STRING_LITERAL_LONG1:
&nbsp;		case STRING_LITERAL_LONG2: {
<b class="fc">&nbsp;			ConditionalOrExpression();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[114] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void ConditionalOrExpression() throws ParseException {
<b class="fc">&nbsp;		ConditionalAndExpression();</b>
<b class="pc">&nbsp;		if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == OR) {</b>
<b class="fc">&nbsp;			jj_consume_token(OR);</b>
<b class="fc">&nbsp;			ASTOr jjtn001 = new ASTOr(JJTOR);</b>
<b class="fc">&nbsp;			boolean jjtc001 = true;</b>
<b class="fc">&nbsp;			jjtree.openNodeScope(jjtn001);</b>
&nbsp;			try {
<b class="fc">&nbsp;				ConditionalOrExpression();</b>
<b class="nc">&nbsp;			} catch (Throwable jjte001) {</b>
<b class="nc">&nbsp;				jjtree.clearNodeScope(jjtn001);</b>
<b class="nc">&nbsp;				jjtc001 = false;</b>
<b class="nc">&nbsp;				if (jjte001 instanceof RuntimeException) {</b>
&nbsp;					{
<b class="nc">&nbsp;						throw (RuntimeException) jjte001;</b>
&nbsp;					}
&nbsp;				}
<b class="nc">&nbsp;				if (jjte001 instanceof ParseException) {</b>
&nbsp;					{
<b class="nc">&nbsp;						throw (ParseException) jjte001;</b>
&nbsp;					}
&nbsp;				}
&nbsp;				{
<b class="nc">&nbsp;					throw (Error) jjte001;</b>
&nbsp;				}
&nbsp;			} finally {
<b class="pc">&nbsp;				if (jjtc001) {</b>
<b class="fc">&nbsp;					jjtree.closeNodeScope(jjtn001, 2);</b>
&nbsp;				}
<b class="nc">&nbsp;			}</b>
<b class="fc">&nbsp;		} else {</b>
<b class="fc">&nbsp;			jj_la1[115] = jj_gen;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void ConditionalAndExpression() throws ParseException {
<b class="fc">&nbsp;		ValueLogical();</b>
<b class="fc">&nbsp;		if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == AND) {</b>
<b class="fc">&nbsp;			jj_consume_token(AND);</b>
<b class="fc">&nbsp;			ASTAnd jjtn001 = new ASTAnd(JJTAND);</b>
<b class="fc">&nbsp;			boolean jjtc001 = true;</b>
<b class="fc">&nbsp;			jjtree.openNodeScope(jjtn001);</b>
&nbsp;			try {
<b class="fc">&nbsp;				ConditionalAndExpression();</b>
<b class="nc">&nbsp;			} catch (Throwable jjte001) {</b>
<b class="nc">&nbsp;				jjtree.clearNodeScope(jjtn001);</b>
<b class="nc">&nbsp;				jjtc001 = false;</b>
<b class="nc">&nbsp;				if (jjte001 instanceof RuntimeException) {</b>
&nbsp;					{
<b class="nc">&nbsp;						throw (RuntimeException) jjte001;</b>
&nbsp;					}
&nbsp;				}
<b class="nc">&nbsp;				if (jjte001 instanceof ParseException) {</b>
&nbsp;					{
<b class="nc">&nbsp;						throw (ParseException) jjte001;</b>
&nbsp;					}
&nbsp;				}
&nbsp;				{
<b class="nc">&nbsp;					throw (Error) jjte001;</b>
&nbsp;				}
&nbsp;			} finally {
<b class="pc">&nbsp;				if (jjtc001) {</b>
<b class="fc">&nbsp;					jjtree.closeNodeScope(jjtn001, 2);</b>
&nbsp;				}
<b class="nc">&nbsp;			}</b>
<b class="fc">&nbsp;		} else {</b>
<b class="fc">&nbsp;			jj_la1[116] = jj_gen;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void ValueLogical() throws ParseException {
<b class="fc">&nbsp;		RelationalExpression();</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void RelationalExpression() throws ParseException {
<b class="fc">&nbsp;		NumericExpression();</b>
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case EQ:
&nbsp;		case NE:
&nbsp;		case GT:
&nbsp;		case LT:
&nbsp;		case LE:
&nbsp;		case GE:
&nbsp;		case NOT_FUNC:
&nbsp;		case IN: {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case EQ: {
<b class="fc">&nbsp;				jj_consume_token(EQ);</b>
<b class="fc">&nbsp;				NumericExpression();</b>
<b class="fc">&nbsp;				ASTCompare jjtn001 = new ASTCompare(JJTCOMPARE);</b>
<b class="fc">&nbsp;				boolean jjtc001 = true;</b>
<b class="fc">&nbsp;				jjtree.openNodeScope(jjtn001);</b>
&nbsp;				try {
<b class="fc">&nbsp;					jjtree.closeNodeScope(jjtn001, 2);</b>
<b class="fc">&nbsp;					jjtc001 = false;</b>
<b class="fc">&nbsp;					jjtn001.setOperator(CompareOp.EQ);</b>
&nbsp;				} finally {
<b class="pc">&nbsp;					if (jjtc001) {</b>
<b class="nc">&nbsp;						jjtree.closeNodeScope(jjtn001, 2);</b>
&nbsp;					}
<b class="nc">&nbsp;				}</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case NE: {
<b class="fc">&nbsp;				jj_consume_token(NE);</b>
<b class="fc">&nbsp;				NumericExpression();</b>
<b class="fc">&nbsp;				ASTCompare jjtn002 = new ASTCompare(JJTCOMPARE);</b>
<b class="fc">&nbsp;				boolean jjtc002 = true;</b>
<b class="fc">&nbsp;				jjtree.openNodeScope(jjtn002);</b>
&nbsp;				try {
<b class="fc">&nbsp;					jjtree.closeNodeScope(jjtn002, 2);</b>
<b class="fc">&nbsp;					jjtc002 = false;</b>
<b class="fc">&nbsp;					jjtn002.setOperator(CompareOp.NE);</b>
&nbsp;				} finally {
<b class="pc">&nbsp;					if (jjtc002) {</b>
<b class="nc">&nbsp;						jjtree.closeNodeScope(jjtn002, 2);</b>
&nbsp;					}
<b class="nc">&nbsp;				}</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case LT: {
<b class="fc">&nbsp;				jj_consume_token(LT);</b>
<b class="fc">&nbsp;				NumericExpression();</b>
<b class="fc">&nbsp;				ASTCompare jjtn003 = new ASTCompare(JJTCOMPARE);</b>
<b class="fc">&nbsp;				boolean jjtc003 = true;</b>
<b class="fc">&nbsp;				jjtree.openNodeScope(jjtn003);</b>
&nbsp;				try {
<b class="fc">&nbsp;					jjtree.closeNodeScope(jjtn003, 2);</b>
<b class="fc">&nbsp;					jjtc003 = false;</b>
<b class="fc">&nbsp;					jjtn003.setOperator(CompareOp.LT);</b>
&nbsp;				} finally {
<b class="pc">&nbsp;					if (jjtc003) {</b>
<b class="nc">&nbsp;						jjtree.closeNodeScope(jjtn003, 2);</b>
&nbsp;					}
<b class="nc">&nbsp;				}</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case LE: {
<b class="fc">&nbsp;				jj_consume_token(LE);</b>
<b class="fc">&nbsp;				NumericExpression();</b>
<b class="fc">&nbsp;				ASTCompare jjtn004 = new ASTCompare(JJTCOMPARE);</b>
<b class="fc">&nbsp;				boolean jjtc004 = true;</b>
<b class="fc">&nbsp;				jjtree.openNodeScope(jjtn004);</b>
&nbsp;				try {
<b class="fc">&nbsp;					jjtree.closeNodeScope(jjtn004, 2);</b>
<b class="fc">&nbsp;					jjtc004 = false;</b>
<b class="fc">&nbsp;					jjtn004.setOperator(CompareOp.LE);</b>
&nbsp;				} finally {
<b class="pc">&nbsp;					if (jjtc004) {</b>
<b class="nc">&nbsp;						jjtree.closeNodeScope(jjtn004, 2);</b>
&nbsp;					}
<b class="nc">&nbsp;				}</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case GE: {
<b class="fc">&nbsp;				jj_consume_token(GE);</b>
<b class="fc">&nbsp;				NumericExpression();</b>
<b class="fc">&nbsp;				ASTCompare jjtn005 = new ASTCompare(JJTCOMPARE);</b>
<b class="fc">&nbsp;				boolean jjtc005 = true;</b>
<b class="fc">&nbsp;				jjtree.openNodeScope(jjtn005);</b>
&nbsp;				try {
<b class="fc">&nbsp;					jjtree.closeNodeScope(jjtn005, 2);</b>
<b class="fc">&nbsp;					jjtc005 = false;</b>
<b class="fc">&nbsp;					jjtn005.setOperator(CompareOp.GE);</b>
&nbsp;				} finally {
<b class="pc">&nbsp;					if (jjtc005) {</b>
<b class="nc">&nbsp;						jjtree.closeNodeScope(jjtn005, 2);</b>
&nbsp;					}
<b class="nc">&nbsp;				}</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case GT: {
<b class="fc">&nbsp;				jj_consume_token(GT);</b>
<b class="fc">&nbsp;				NumericExpression();</b>
<b class="fc">&nbsp;				ASTCompare jjtn006 = new ASTCompare(JJTCOMPARE);</b>
<b class="fc">&nbsp;				boolean jjtc006 = true;</b>
<b class="fc">&nbsp;				jjtree.openNodeScope(jjtn006);</b>
&nbsp;				try {
<b class="fc">&nbsp;					jjtree.closeNodeScope(jjtn006, 2);</b>
<b class="fc">&nbsp;					jjtc006 = false;</b>
<b class="fc">&nbsp;					jjtn006.setOperator(CompareOp.GT);</b>
&nbsp;				} finally {
<b class="pc">&nbsp;					if (jjtc006) {</b>
<b class="nc">&nbsp;						jjtree.closeNodeScope(jjtn006, 2);</b>
&nbsp;					}
<b class="nc">&nbsp;				}</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case IN: {
<b class="fc">&nbsp;				ASTInfix jjtn007 = new ASTInfix(JJTINFIX);</b>
<b class="fc">&nbsp;				boolean jjtc007 = true;</b>
<b class="fc">&nbsp;				jjtree.openNodeScope(jjtn007);</b>
&nbsp;				try {
<b class="fc">&nbsp;					In();</b>
<b class="nc">&nbsp;				} catch (Throwable jjte007) {</b>
<b class="nc">&nbsp;					jjtree.clearNodeScope(jjtn007);</b>
<b class="nc">&nbsp;					jjtc007 = false;</b>
<b class="nc">&nbsp;					if (jjte007 instanceof RuntimeException) {</b>
&nbsp;						{
<b class="nc">&nbsp;							throw (RuntimeException) jjte007;</b>
&nbsp;						}
&nbsp;					}
<b class="nc">&nbsp;					if (jjte007 instanceof ParseException) {</b>
&nbsp;						{
<b class="nc">&nbsp;							throw (ParseException) jjte007;</b>
&nbsp;						}
&nbsp;					}
&nbsp;					{
<b class="nc">&nbsp;						throw (Error) jjte007;</b>
&nbsp;					}
&nbsp;				} finally {
<b class="pc">&nbsp;					if (jjtc007) {</b>
<b class="fc">&nbsp;						jjtree.closeNodeScope(jjtn007, 2);</b>
&nbsp;					}
<b class="nc">&nbsp;				}</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case NOT_FUNC: {
<b class="fc">&nbsp;				ASTInfix jjtn008 = new ASTInfix(JJTINFIX);</b>
<b class="fc">&nbsp;				boolean jjtc008 = true;</b>
<b class="fc">&nbsp;				jjtree.openNodeScope(jjtn008);</b>
&nbsp;				try {
<b class="fc">&nbsp;					NotIn();</b>
<b class="nc">&nbsp;				} catch (Throwable jjte008) {</b>
<b class="nc">&nbsp;					jjtree.clearNodeScope(jjtn008);</b>
<b class="nc">&nbsp;					jjtc008 = false;</b>
<b class="nc">&nbsp;					if (jjte008 instanceof RuntimeException) {</b>
&nbsp;						{
<b class="nc">&nbsp;							throw (RuntimeException) jjte008;</b>
&nbsp;						}
&nbsp;					}
<b class="nc">&nbsp;					if (jjte008 instanceof ParseException) {</b>
&nbsp;						{
<b class="nc">&nbsp;							throw (ParseException) jjte008;</b>
&nbsp;						}
&nbsp;					}
&nbsp;					{
<b class="nc">&nbsp;						throw (Error) jjte008;</b>
&nbsp;					}
&nbsp;				} finally {
<b class="pc">&nbsp;					if (jjtc008) {</b>
<b class="fc">&nbsp;						jjtree.closeNodeScope(jjtn008, 2);</b>
&nbsp;					}
<b class="nc">&nbsp;				}</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[117] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
&nbsp;			break;
&nbsp;		}
&nbsp;		default:
<b class="fc">&nbsp;			jj_la1[118] = jj_gen;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void NumericExpression() throws ParseException {
<b class="fc">&nbsp;		AdditiveExpression();</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void AdditiveExpression() throws ParseException {
<b class="fc">&nbsp;		MultiplicativeExpression();</b>
&nbsp;		label_29: while (true) {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case PLUS:
&nbsp;			case MINUS:
&nbsp;			case INTEGER_POSITIVE:
&nbsp;			case INTEGER_NEGATIVE:
&nbsp;			case DECIMAL_POSITIVE:
&nbsp;			case DECIMAL_NEGATIVE:
&nbsp;			case DOUBLE_POSITIVE:
&nbsp;			case DOUBLE_NEGATIVE: {
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="fc">&nbsp;				jj_la1[119] = jj_gen;</b>
<b class="fc">&nbsp;				break label_29;</b>
&nbsp;			}
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case PLUS: {
<b class="fc">&nbsp;				jj_consume_token(PLUS);</b>
<b class="fc">&nbsp;				MultiplicativeExpression();</b>
<b class="fc">&nbsp;				ASTMath jjtn001 = new ASTMath(JJTMATH);</b>
<b class="fc">&nbsp;				boolean jjtc001 = true;</b>
<b class="fc">&nbsp;				jjtree.openNodeScope(jjtn001);</b>
&nbsp;				try {
<b class="fc">&nbsp;					jjtree.closeNodeScope(jjtn001, 2);</b>
<b class="fc">&nbsp;					jjtc001 = false;</b>
<b class="fc">&nbsp;					jjtn001.setOperator(MathOp.PLUS);</b>
&nbsp;				} finally {
<b class="pc">&nbsp;					if (jjtc001) {</b>
<b class="nc">&nbsp;						jjtree.closeNodeScope(jjtn001, 2);</b>
&nbsp;					}
<b class="nc">&nbsp;				}</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case MINUS: {
<b class="nc">&nbsp;				jj_consume_token(MINUS);</b>
<b class="nc">&nbsp;				MultiplicativeExpression();</b>
<b class="nc">&nbsp;				ASTMath jjtn002 = new ASTMath(JJTMATH);</b>
<b class="nc">&nbsp;				boolean jjtc002 = true;</b>
<b class="nc">&nbsp;				jjtree.openNodeScope(jjtn002);</b>
&nbsp;				try {
<b class="nc">&nbsp;					jjtree.closeNodeScope(jjtn002, 2);</b>
<b class="nc">&nbsp;					jjtc002 = false;</b>
<b class="nc">&nbsp;					jjtn002.setOperator(MathOp.MINUS);</b>
&nbsp;				} finally {
<b class="nc">&nbsp;					if (jjtc002) {</b>
<b class="nc">&nbsp;						jjtree.closeNodeScope(jjtn002, 2);</b>
&nbsp;					}
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case INTEGER_POSITIVE:
&nbsp;			case DECIMAL_POSITIVE:
&nbsp;			case DOUBLE_POSITIVE: {
<b class="fc">&nbsp;				NumericLiteralPositive();</b>
<b class="fc">&nbsp;				ASTMath jjtn003 = new ASTMath(JJTMATH);</b>
<b class="fc">&nbsp;				boolean jjtc003 = true;</b>
<b class="fc">&nbsp;				jjtree.openNodeScope(jjtn003);</b>
&nbsp;				try {
<b class="fc">&nbsp;					jjtree.closeNodeScope(jjtn003, 2);</b>
<b class="fc">&nbsp;					jjtc003 = false;</b>
<b class="fc">&nbsp;					jjtn003.setOperator(MathOp.PLUS);</b>
&nbsp;				} finally {
<b class="pc">&nbsp;					if (jjtc003) {</b>
<b class="nc">&nbsp;						jjtree.closeNodeScope(jjtn003, 2);</b>
&nbsp;					}
<b class="nc">&nbsp;				}</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case INTEGER_NEGATIVE:
&nbsp;			case DECIMAL_NEGATIVE:
&nbsp;			case DOUBLE_NEGATIVE: {
<b class="nc">&nbsp;				NumericLiteralNegative();</b>
<b class="nc">&nbsp;				ASTMath jjtn004 = new ASTMath(JJTMATH);</b>
<b class="nc">&nbsp;				boolean jjtc004 = true;</b>
<b class="nc">&nbsp;				jjtree.openNodeScope(jjtn004);</b>
&nbsp;				try {
<b class="nc">&nbsp;					jjtree.closeNodeScope(jjtn004, 2);</b>
<b class="nc">&nbsp;					jjtc004 = false;</b>
<b class="nc">&nbsp;					jjtn004.setOperator(MathOp.PLUS);</b>
&nbsp;				} finally {
<b class="nc">&nbsp;					if (jjtc004) {</b>
<b class="nc">&nbsp;						jjtree.closeNodeScope(jjtn004, 2);</b>
&nbsp;					}
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[120] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void MultiplicativeExpression() throws ParseException {
<b class="fc">&nbsp;		UnaryExpression();</b>
&nbsp;		label_30: while (true) {
<b class="fc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case STAR:
&nbsp;			case SLASH: {
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="fc">&nbsp;				jj_la1[121] = jj_gen;</b>
<b class="fc">&nbsp;				break label_30;</b>
&nbsp;			}
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case STAR: {
<b class="fc">&nbsp;				jj_consume_token(STAR);</b>
<b class="fc">&nbsp;				UnaryExpression();</b>
<b class="fc">&nbsp;				ASTMath jjtn001 = new ASTMath(JJTMATH);</b>
<b class="fc">&nbsp;				boolean jjtc001 = true;</b>
<b class="fc">&nbsp;				jjtree.openNodeScope(jjtn001);</b>
&nbsp;				try {
<b class="fc">&nbsp;					jjtree.closeNodeScope(jjtn001, 2);</b>
<b class="fc">&nbsp;					jjtc001 = false;</b>
<b class="fc">&nbsp;					jjtn001.setOperator(MathOp.MULTIPLY);</b>
&nbsp;				} finally {
<b class="pc">&nbsp;					if (jjtc001) {</b>
<b class="nc">&nbsp;						jjtree.closeNodeScope(jjtn001, 2);</b>
&nbsp;					}
<b class="nc">&nbsp;				}</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case SLASH: {
<b class="fc">&nbsp;				jj_consume_token(SLASH);</b>
<b class="fc">&nbsp;				UnaryExpression();</b>
<b class="fc">&nbsp;				ASTMath jjtn002 = new ASTMath(JJTMATH);</b>
<b class="fc">&nbsp;				boolean jjtc002 = true;</b>
<b class="fc">&nbsp;				jjtree.openNodeScope(jjtn002);</b>
&nbsp;				try {
<b class="fc">&nbsp;					jjtree.closeNodeScope(jjtn002, 2);</b>
<b class="fc">&nbsp;					jjtc002 = false;</b>
<b class="fc">&nbsp;					jjtn002.setOperator(MathOp.DIVIDE);</b>
&nbsp;				} finally {
<b class="pc">&nbsp;					if (jjtc002) {</b>
<b class="nc">&nbsp;						jjtree.closeNodeScope(jjtn002, 2);</b>
&nbsp;					}
<b class="nc">&nbsp;				}</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[122] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void UnaryExpression() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case NOT: {
<b class="fc">&nbsp;			jj_consume_token(NOT);</b>
<b class="fc">&nbsp;			ASTNot jjtn001 = new ASTNot(JJTNOT);</b>
<b class="fc">&nbsp;			boolean jjtc001 = true;</b>
<b class="fc">&nbsp;			jjtree.openNodeScope(jjtn001);</b>
&nbsp;			try {
<b class="fc">&nbsp;				PrimaryExpression();</b>
<b class="nc">&nbsp;			} catch (Throwable jjte001) {</b>
<b class="nc">&nbsp;				jjtree.clearNodeScope(jjtn001);</b>
<b class="nc">&nbsp;				jjtc001 = false;</b>
<b class="nc">&nbsp;				if (jjte001 instanceof RuntimeException) {</b>
&nbsp;					{
<b class="nc">&nbsp;						throw (RuntimeException) jjte001;</b>
&nbsp;					}
&nbsp;				}
<b class="nc">&nbsp;				if (jjte001 instanceof ParseException) {</b>
&nbsp;					{
<b class="nc">&nbsp;						throw (ParseException) jjte001;</b>
&nbsp;					}
&nbsp;				}
&nbsp;				{
<b class="nc">&nbsp;					throw (Error) jjte001;</b>
&nbsp;				}
&nbsp;			} finally {
<b class="pc">&nbsp;				if (jjtc001) {</b>
<b class="fc">&nbsp;					jjtree.closeNodeScope(jjtn001, true);</b>
&nbsp;				}
<b class="nc">&nbsp;			}</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case LPAREN:
&nbsp;		case PLUS:
&nbsp;		case NOT_FUNC:
&nbsp;		case EXISTS:
&nbsp;		case STR:
&nbsp;		case LANG:
&nbsp;		case LANGMATCHES:
&nbsp;		case DATATYPE:
&nbsp;		case BOUND:
&nbsp;		case SAMETERM:
&nbsp;		case IS_IRI:
&nbsp;		case IS_BLANK:
&nbsp;		case IS_LITERAL:
&nbsp;		case IS_NUMERIC:
&nbsp;		case COALESCE:
&nbsp;		case BNODE:
&nbsp;		case STRDT:
&nbsp;		case STRLANG:
&nbsp;		case UUID:
&nbsp;		case STRUUID:
&nbsp;		case IRI:
&nbsp;		case IF:
&nbsp;		case COUNT:
&nbsp;		case SUM:
&nbsp;		case MIN:
&nbsp;		case MAX:
&nbsp;		case AVG:
&nbsp;		case SAMPLE:
&nbsp;		case GROUP_CONCAT:
&nbsp;		case REGEX:
&nbsp;		case TRUE:
&nbsp;		case FALSE:
&nbsp;		case STRLEN:
&nbsp;		case SUBSTR:
&nbsp;		case STR_STARTS:
&nbsp;		case STR_ENDS:
&nbsp;		case STR_BEFORE:
&nbsp;		case STR_AFTER:
&nbsp;		case REPLACE:
&nbsp;		case UCASE:
&nbsp;		case LCASE:
&nbsp;		case CONCAT:
&nbsp;		case CONTAINS:
&nbsp;		case ENCODE_FOR_URI:
&nbsp;		case RAND:
&nbsp;		case ABS:
&nbsp;		case CEIL:
&nbsp;		case FLOOR:
&nbsp;		case ROUND:
&nbsp;		case NOW:
&nbsp;		case YEAR:
&nbsp;		case MONTH:
&nbsp;		case DAY:
&nbsp;		case HOURS:
&nbsp;		case MINUTES:
&nbsp;		case SECONDS:
&nbsp;		case TIMEZONE:
&nbsp;		case TZ:
&nbsp;		case MD5:
&nbsp;		case SHA1:
&nbsp;		case SHA224:
&nbsp;		case SHA256:
&nbsp;		case SHA384:
&nbsp;		case SHA512:
&nbsp;		case Q_IRI_REF:
&nbsp;		case PNAME_NS:
&nbsp;		case PNAME_LN:
&nbsp;		case VAR1:
&nbsp;		case VAR2:
&nbsp;		case INTEGER:
&nbsp;		case INTEGER_POSITIVE:
&nbsp;		case INTEGER_NEGATIVE:
&nbsp;		case DECIMAL:
&nbsp;		case DECIMAL_POSITIVE:
&nbsp;		case DECIMAL_NEGATIVE:
&nbsp;		case DOUBLE:
&nbsp;		case DOUBLE_POSITIVE:
&nbsp;		case DOUBLE_NEGATIVE:
&nbsp;		case STRING_LITERAL1:
&nbsp;		case STRING_LITERAL2:
&nbsp;		case STRING_LITERAL_LONG1:
&nbsp;		case STRING_LITERAL_LONG2: {
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == PLUS) {</b>
<b class="nc">&nbsp;				jj_consume_token(PLUS);</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[123] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			PrimaryExpression();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case MINUS: {
<b class="nc">&nbsp;			UnaryMinus();</b>
<b class="nc">&nbsp;			PrimaryExpression();</b>
<b class="nc">&nbsp;			ASTMath jjtn002 = new ASTMath(JJTMATH);</b>
<b class="nc">&nbsp;			boolean jjtc002 = true;</b>
<b class="nc">&nbsp;			jjtree.openNodeScope(jjtn002);</b>
&nbsp;			try {
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn002, 2);</b>
<b class="nc">&nbsp;				jjtc002 = false;</b>
<b class="nc">&nbsp;				jjtn002.setOperator(MathOp.MULTIPLY);</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				if (jjtc002) {</b>
<b class="nc">&nbsp;					jjtree.closeNodeScope(jjtn002, 2);</b>
&nbsp;				}
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[124] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void UnaryMinus() throws ParseException {/* @bgen(jjtree) NumericLiteral */
<b class="nc">&nbsp;		ASTNumericLiteral jjtn000 = new ASTNumericLiteral(JJTNUMERICLITERAL);</b>
<b class="nc">&nbsp;		boolean jjtc000 = true;</b>
<b class="nc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="nc">&nbsp;			jj_consume_token(MINUS);</b>
<b class="nc">&nbsp;			jjtree.closeNodeScope(jjtn000, true);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			jjtn000.setValue(&quot;-1&quot;);</b>
<b class="nc">&nbsp;			jjtn000.setDatatype(XSD.INTEGER);</b>
&nbsp;		} finally {
<b class="nc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void PrimaryExpression() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case LPAREN: {
<b class="fc">&nbsp;			BrackettedExpression();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case NOT_FUNC:
&nbsp;		case EXISTS:
&nbsp;		case STR:
&nbsp;		case LANG:
&nbsp;		case LANGMATCHES:
&nbsp;		case DATATYPE:
&nbsp;		case BOUND:
&nbsp;		case SAMETERM:
&nbsp;		case IS_IRI:
&nbsp;		case IS_BLANK:
&nbsp;		case IS_LITERAL:
&nbsp;		case IS_NUMERIC:
&nbsp;		case COALESCE:
&nbsp;		case BNODE:
&nbsp;		case STRDT:
&nbsp;		case STRLANG:
&nbsp;		case UUID:
&nbsp;		case STRUUID:
&nbsp;		case IRI:
&nbsp;		case IF:
&nbsp;		case REGEX:
&nbsp;		case STRLEN:
&nbsp;		case SUBSTR:
&nbsp;		case STR_STARTS:
&nbsp;		case STR_ENDS:
&nbsp;		case STR_BEFORE:
&nbsp;		case STR_AFTER:
&nbsp;		case REPLACE:
&nbsp;		case UCASE:
&nbsp;		case LCASE:
&nbsp;		case CONCAT:
&nbsp;		case CONTAINS:
&nbsp;		case ENCODE_FOR_URI:
&nbsp;		case RAND:
&nbsp;		case ABS:
&nbsp;		case CEIL:
&nbsp;		case FLOOR:
&nbsp;		case ROUND:
&nbsp;		case NOW:
&nbsp;		case YEAR:
&nbsp;		case MONTH:
&nbsp;		case DAY:
&nbsp;		case HOURS:
&nbsp;		case MINUTES:
&nbsp;		case SECONDS:
&nbsp;		case TIMEZONE:
&nbsp;		case TZ:
&nbsp;		case MD5:
&nbsp;		case SHA1:
&nbsp;		case SHA224:
&nbsp;		case SHA256:
&nbsp;		case SHA384:
&nbsp;		case SHA512: {
<b class="fc">&nbsp;			BuiltInCall();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="fc">&nbsp;			jj_la1[125] = jj_gen;</b>
<b class="fc">&nbsp;			if (jj_2_4()) {</b>
<b class="fc">&nbsp;				FunctionCall();</b>
&nbsp;			} else {
<b class="pc">&nbsp;				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;				case Q_IRI_REF:
&nbsp;				case PNAME_NS:
&nbsp;				case PNAME_LN: {
<b class="fc">&nbsp;					IRIref();</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;				case STRING_LITERAL1:
&nbsp;				case STRING_LITERAL2:
&nbsp;				case STRING_LITERAL_LONG1:
&nbsp;				case STRING_LITERAL_LONG2: {
<b class="fc">&nbsp;					RDFLiteral();</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;				case INTEGER:
&nbsp;				case INTEGER_POSITIVE:
&nbsp;				case INTEGER_NEGATIVE:
&nbsp;				case DECIMAL:
&nbsp;				case DECIMAL_POSITIVE:
&nbsp;				case DECIMAL_NEGATIVE:
&nbsp;				case DOUBLE:
&nbsp;				case DOUBLE_POSITIVE:
&nbsp;				case DOUBLE_NEGATIVE: {
<b class="fc">&nbsp;					NumericLiteral();</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;				case TRUE:
&nbsp;				case FALSE: {
<b class="fc">&nbsp;					BooleanLiteral();</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;				case VAR1:
&nbsp;				case VAR2: {
<b class="fc">&nbsp;					Var();</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;				case COUNT:
&nbsp;				case SUM:
&nbsp;				case MIN:
&nbsp;				case MAX:
&nbsp;				case AVG:
&nbsp;				case SAMPLE:
&nbsp;				case GROUP_CONCAT: {
<b class="fc">&nbsp;					Aggregate();</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;				default:
<b class="nc">&nbsp;					jj_la1[126] = jj_gen;</b>
<b class="nc">&nbsp;					jj_consume_token(-1);</b>
<b class="nc">&nbsp;					throw new ParseException();</b>
&nbsp;				}
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void Aggregate() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case COUNT: {
<b class="fc">&nbsp;			Count();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case SUM: {
<b class="fc">&nbsp;			Sum();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case MIN: {
<b class="fc">&nbsp;			Min();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case MAX: {
<b class="fc">&nbsp;			Max();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case AVG: {
<b class="fc">&nbsp;			Avg();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case SAMPLE: {
<b class="fc">&nbsp;			Sample();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case GROUP_CONCAT: {
<b class="fc">&nbsp;			GroupConcat();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[127] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void Count() throws ParseException {/* @bgen(jjtree) Count */
<b class="fc">&nbsp;		ASTCount jjtn000 = new ASTCount(JJTCOUNT);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(COUNT);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == DISTINCT) {</b>
<b class="fc">&nbsp;				jj_consume_token(DISTINCT);</b>
<b class="fc">&nbsp;				jjtn000.setDistinct(true);</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[128] = jj_gen;</b>
&nbsp;			}
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case STAR: {
<b class="fc">&nbsp;				jj_consume_token(STAR);</b>
<b class="fc">&nbsp;				jjtn000.setWildcard(true);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case LPAREN:
&nbsp;			case NOT:
&nbsp;			case PLUS:
&nbsp;			case MINUS:
&nbsp;			case NOT_FUNC:
&nbsp;			case EXISTS:
&nbsp;			case STR:
&nbsp;			case LANG:
&nbsp;			case LANGMATCHES:
&nbsp;			case DATATYPE:
&nbsp;			case BOUND:
&nbsp;			case SAMETERM:
&nbsp;			case IS_IRI:
&nbsp;			case IS_BLANK:
&nbsp;			case IS_LITERAL:
&nbsp;			case IS_NUMERIC:
&nbsp;			case COALESCE:
&nbsp;			case BNODE:
&nbsp;			case STRDT:
&nbsp;			case STRLANG:
&nbsp;			case UUID:
&nbsp;			case STRUUID:
&nbsp;			case IRI:
&nbsp;			case IF:
&nbsp;			case COUNT:
&nbsp;			case SUM:
&nbsp;			case MIN:
&nbsp;			case MAX:
&nbsp;			case AVG:
&nbsp;			case SAMPLE:
&nbsp;			case GROUP_CONCAT:
&nbsp;			case REGEX:
&nbsp;			case TRUE:
&nbsp;			case FALSE:
&nbsp;			case STRLEN:
&nbsp;			case SUBSTR:
&nbsp;			case STR_STARTS:
&nbsp;			case STR_ENDS:
&nbsp;			case STR_BEFORE:
&nbsp;			case STR_AFTER:
&nbsp;			case REPLACE:
&nbsp;			case UCASE:
&nbsp;			case LCASE:
&nbsp;			case CONCAT:
&nbsp;			case CONTAINS:
&nbsp;			case ENCODE_FOR_URI:
&nbsp;			case RAND:
&nbsp;			case ABS:
&nbsp;			case CEIL:
&nbsp;			case FLOOR:
&nbsp;			case ROUND:
&nbsp;			case NOW:
&nbsp;			case YEAR:
&nbsp;			case MONTH:
&nbsp;			case DAY:
&nbsp;			case HOURS:
&nbsp;			case MINUTES:
&nbsp;			case SECONDS:
&nbsp;			case TIMEZONE:
&nbsp;			case TZ:
&nbsp;			case MD5:
&nbsp;			case SHA1:
&nbsp;			case SHA224:
&nbsp;			case SHA256:
&nbsp;			case SHA384:
&nbsp;			case SHA512:
&nbsp;			case Q_IRI_REF:
&nbsp;			case PNAME_NS:
&nbsp;			case PNAME_LN:
&nbsp;			case VAR1:
&nbsp;			case VAR2:
&nbsp;			case INTEGER:
&nbsp;			case INTEGER_POSITIVE:
&nbsp;			case INTEGER_NEGATIVE:
&nbsp;			case DECIMAL:
&nbsp;			case DECIMAL_POSITIVE:
&nbsp;			case DECIMAL_NEGATIVE:
&nbsp;			case DOUBLE:
&nbsp;			case DOUBLE_POSITIVE:
&nbsp;			case DOUBLE_NEGATIVE:
&nbsp;			case STRING_LITERAL1:
&nbsp;			case STRING_LITERAL2:
&nbsp;			case STRING_LITERAL_LONG1:
&nbsp;			case STRING_LITERAL_LONG2:
&nbsp;			case TRIPLE_OPEN: {
<b class="fc">&nbsp;				Expression();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[129] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;
<b class="nc">&nbsp;				throw (RuntimeException) jjte000;</b>
&nbsp;
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
<b class="nc">&nbsp;				throw (ParseException) jjte000;</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			throw (Error) jjte000;</b>
&nbsp;
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Sum() throws ParseException {/* @bgen(jjtree) Sum */
<b class="fc">&nbsp;		ASTSum jjtn000 = new ASTSum(JJTSUM);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(SUM);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == DISTINCT) {</b>
<b class="fc">&nbsp;				jj_consume_token(DISTINCT);</b>
<b class="fc">&nbsp;				jjtn000.setDistinct(true);</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[130] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Min() throws ParseException {/* @bgen(jjtree) Min */
<b class="fc">&nbsp;		ASTMin jjtn000 = new ASTMin(JJTMIN);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(MIN);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == DISTINCT) {</b>
<b class="nc">&nbsp;				jj_consume_token(DISTINCT);</b>
<b class="nc">&nbsp;				jjtn000.setDistinct(true);</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[131] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Max() throws ParseException {/* @bgen(jjtree) Max */
<b class="fc">&nbsp;		ASTMax jjtn000 = new ASTMax(JJTMAX);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(MAX);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == DISTINCT) {</b>
<b class="fc">&nbsp;				jj_consume_token(DISTINCT);</b>
<b class="fc">&nbsp;				jjtn000.setDistinct(true);</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[132] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Avg() throws ParseException {/* @bgen(jjtree) Avg */
<b class="fc">&nbsp;		ASTAvg jjtn000 = new ASTAvg(JJTAVG);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(AVG);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == DISTINCT) {</b>
<b class="fc">&nbsp;				jj_consume_token(DISTINCT);</b>
<b class="fc">&nbsp;				jjtn000.setDistinct(true);</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[133] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Sample() throws ParseException {/* @bgen(jjtree) Sample */
<b class="fc">&nbsp;		ASTSample jjtn000 = new ASTSample(JJTSAMPLE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(SAMPLE);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == DISTINCT) {</b>
<b class="nc">&nbsp;				jj_consume_token(DISTINCT);</b>
<b class="nc">&nbsp;				jjtn000.setDistinct(true);</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[134] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void GroupConcat() throws ParseException {/* @bgen(jjtree) GroupConcat */
<b class="fc">&nbsp;		ASTGroupConcat jjtn000 = new ASTGroupConcat(JJTGROUPCONCAT);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(GROUP_CONCAT);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == DISTINCT) {</b>
<b class="fc">&nbsp;				jj_consume_token(DISTINCT);</b>
<b class="fc">&nbsp;				jjtn000.setDistinct(true);</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[135] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			Expression();</b>
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == SEMICOLON) {</b>
<b class="fc">&nbsp;				jj_consume_token(SEMICOLON);</b>
<b class="fc">&nbsp;				jj_consume_token(SEPARATOR);</b>
<b class="fc">&nbsp;				jj_consume_token(EQ);</b>
<b class="fc">&nbsp;				Expression();</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[136] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void BrackettedExpression() throws ParseException {
<b class="fc">&nbsp;		jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;		Expression();</b>
<b class="fc">&nbsp;		jj_consume_token(RPAREN);</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void BuiltInCall() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case BOUND: {
<b class="fc">&nbsp;			Bound();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case SAMETERM: {
<b class="fc">&nbsp;			SameTerm();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case EXISTS: {
<b class="fc">&nbsp;			ExistsFunc();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case NOT_FUNC: {
<b class="fc">&nbsp;			NotExistsFunc();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case COALESCE: {
<b class="fc">&nbsp;			Coalesce();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case IF: {
<b class="fc">&nbsp;			If();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case LANGMATCHES:
&nbsp;		case REGEX:
&nbsp;		case STRLEN:
&nbsp;		case SUBSTR:
&nbsp;		case STR_STARTS:
&nbsp;		case STR_ENDS:
&nbsp;		case STR_BEFORE:
&nbsp;		case STR_AFTER:
&nbsp;		case REPLACE:
&nbsp;		case UCASE:
&nbsp;		case LCASE:
&nbsp;		case CONCAT:
&nbsp;		case CONTAINS:
&nbsp;		case ENCODE_FOR_URI: {
<b class="fc">&nbsp;			StringFunction();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case RAND:
&nbsp;		case ABS:
&nbsp;		case CEIL:
&nbsp;		case FLOOR:
&nbsp;		case ROUND: {
<b class="fc">&nbsp;			NumericFunction();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case STR:
&nbsp;		case LANG:
&nbsp;		case DATATYPE:
&nbsp;		case IS_IRI:
&nbsp;		case IS_BLANK:
&nbsp;		case IS_LITERAL:
&nbsp;		case IS_NUMERIC:
&nbsp;		case BNODE:
&nbsp;		case STRDT:
&nbsp;		case STRLANG:
&nbsp;		case UUID:
&nbsp;		case STRUUID:
&nbsp;		case IRI: {
<b class="fc">&nbsp;			RDFTermFunction();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case NOW:
&nbsp;		case YEAR:
&nbsp;		case MONTH:
&nbsp;		case DAY:
&nbsp;		case HOURS:
&nbsp;		case MINUTES:
&nbsp;		case SECONDS:
&nbsp;		case TIMEZONE:
&nbsp;		case TZ: {
<b class="fc">&nbsp;			DateTimeFunction();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case MD5:
&nbsp;		case SHA1:
&nbsp;		case SHA224:
&nbsp;		case SHA256:
&nbsp;		case SHA384:
&nbsp;		case SHA512: {
<b class="fc">&nbsp;			HashFunction();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[137] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void StringFunction() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case SUBSTR: {
<b class="fc">&nbsp;			Substr();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case STRLEN: {
<b class="fc">&nbsp;			StrLen();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case UCASE: {
<b class="fc">&nbsp;			UpperCase();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case LCASE: {
<b class="fc">&nbsp;			LowerCase();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case STR_STARTS: {
<b class="fc">&nbsp;			StrStarts();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case STR_ENDS: {
<b class="fc">&nbsp;			StrEnds();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case STR_BEFORE: {
<b class="fc">&nbsp;			StrBefore();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case STR_AFTER: {
<b class="fc">&nbsp;			StrAfter();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case REPLACE: {
<b class="fc">&nbsp;			Replace();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case CONCAT: {
<b class="fc">&nbsp;			Concat();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case CONTAINS: {
<b class="fc">&nbsp;			Contains();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case ENCODE_FOR_URI: {
<b class="fc">&nbsp;			EncodeForURI();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case LANGMATCHES: {
<b class="fc">&nbsp;			LangMatches();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case REGEX: {
<b class="fc">&nbsp;			RegexExpression();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[138] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void NumericFunction() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case RAND: {
<b class="fc">&nbsp;			Rand();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case ABS: {
<b class="fc">&nbsp;			Abs();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case CEIL: {
<b class="fc">&nbsp;			Ceil();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case FLOOR: {
<b class="fc">&nbsp;			Floor();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case ROUND: {
<b class="fc">&nbsp;			Round();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[139] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void RDFTermFunction() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case IS_IRI: {
<b class="fc">&nbsp;			IsIRI();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case IS_BLANK: {
<b class="fc">&nbsp;			IsBlank();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case IS_LITERAL: {
<b class="fc">&nbsp;			IsLiteral();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case IS_NUMERIC: {
<b class="fc">&nbsp;			IsNumeric();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case BNODE: {
<b class="fc">&nbsp;			BNodeFunc();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case IRI: {
<b class="fc">&nbsp;			IRIFunc();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case LANG: {
<b class="fc">&nbsp;			Lang();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case DATATYPE: {
<b class="fc">&nbsp;			Datatype();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case STR: {
<b class="fc">&nbsp;			Str();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case STRDT: {
<b class="fc">&nbsp;			StrDt();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case STRLANG: {
<b class="fc">&nbsp;			StrLang();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case UUID: {
<b class="fc">&nbsp;			UUID();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case STRUUID: {
<b class="fc">&nbsp;			STRUUID();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[140] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void DateTimeFunction() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case NOW: {
<b class="fc">&nbsp;			Now();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case YEAR: {
<b class="fc">&nbsp;			Year();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case MONTH: {
<b class="fc">&nbsp;			Month();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case DAY: {
<b class="fc">&nbsp;			Day();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case HOURS: {
<b class="fc">&nbsp;			Hours();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case MINUTES: {
<b class="fc">&nbsp;			Minutes();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case SECONDS: {
<b class="fc">&nbsp;			Seconds();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case TIMEZONE: {
<b class="fc">&nbsp;			Timezone();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case TZ: {
<b class="fc">&nbsp;			Tz();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[141] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void HashFunction() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case MD5: {
<b class="fc">&nbsp;			MD5();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case SHA1: {
<b class="fc">&nbsp;			SHA1();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case SHA224: {
<b class="nc">&nbsp;			SHA224();</b>
<b class="nc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case SHA256: {
<b class="fc">&nbsp;			SHA256();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case SHA384: {
<b class="nc">&nbsp;			SHA384();</b>
<b class="nc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case SHA512: {
<b class="fc">&nbsp;			SHA512();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[142] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void MD5() throws ParseException {/* @bgen(jjtree) MD5 */
<b class="fc">&nbsp;		ASTMD5 jjtn000 = new ASTMD5(JJTMD5);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(MD5);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void SHA1() throws ParseException {/* @bgen(jjtree) SHA1 */
<b class="fc">&nbsp;		ASTSHA1 jjtn000 = new ASTSHA1(JJTSHA1);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(SHA1);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void SHA224() throws ParseException {/* @bgen(jjtree) SHA224 */
<b class="nc">&nbsp;		ASTSHA224 jjtn000 = new ASTSHA224(JJTSHA224);</b>
<b class="nc">&nbsp;		boolean jjtc000 = true;</b>
<b class="nc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="nc">&nbsp;			jj_consume_token(SHA224);</b>
<b class="nc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="nc">&nbsp;			Expression();</b>
<b class="nc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="nc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void SHA256() throws ParseException {/* @bgen(jjtree) SHA256 */
<b class="fc">&nbsp;		ASTSHA256 jjtn000 = new ASTSHA256(JJTSHA256);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(SHA256);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void SHA384() throws ParseException {/* @bgen(jjtree) SHA384 */
<b class="nc">&nbsp;		ASTSHA384 jjtn000 = new ASTSHA384(JJTSHA384);</b>
<b class="nc">&nbsp;		boolean jjtc000 = true;</b>
<b class="nc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="nc">&nbsp;			jj_consume_token(SHA384);</b>
<b class="nc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="nc">&nbsp;			Expression();</b>
<b class="nc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="nc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void SHA512() throws ParseException {/* @bgen(jjtree) SHA512 */
<b class="fc">&nbsp;		ASTSHA512 jjtn000 = new ASTSHA512(JJTSHA512);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(SHA512);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Now() throws ParseException {/* @bgen(jjtree) Now */
<b class="fc">&nbsp;		ASTNow jjtn000 = new ASTNow(JJTNOW);</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(NOW);</b>
<b class="fc">&nbsp;			jj_consume_token(NIL);</b>
&nbsp;		} finally {
<b class="fc">&nbsp;			jjtree.closeNodeScope(jjtn000, true);</b>
<b class="fc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Year() throws ParseException {/* @bgen(jjtree) Year */
<b class="fc">&nbsp;		ASTYear jjtn000 = new ASTYear(JJTYEAR);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(YEAR);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Month() throws ParseException {/* @bgen(jjtree) Month */
<b class="fc">&nbsp;		ASTMonth jjtn000 = new ASTMonth(JJTMONTH);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(MONTH);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Day() throws ParseException {/* @bgen(jjtree) Day */
<b class="fc">&nbsp;		ASTDay jjtn000 = new ASTDay(JJTDAY);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(DAY);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Hours() throws ParseException {/* @bgen(jjtree) Hours */
<b class="fc">&nbsp;		ASTHours jjtn000 = new ASTHours(JJTHOURS);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(HOURS);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Minutes() throws ParseException {/* @bgen(jjtree) Minutes */
<b class="fc">&nbsp;		ASTMinutes jjtn000 = new ASTMinutes(JJTMINUTES);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(MINUTES);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Seconds() throws ParseException {/* @bgen(jjtree) Seconds */
<b class="fc">&nbsp;		ASTSeconds jjtn000 = new ASTSeconds(JJTSECONDS);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(SECONDS);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Timezone() throws ParseException {/* @bgen(jjtree) Timezone */
<b class="fc">&nbsp;		ASTTimezone jjtn000 = new ASTTimezone(JJTTIMEZONE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(TIMEZONE);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Tz() throws ParseException {/* @bgen(jjtree) Tz */
<b class="fc">&nbsp;		ASTTz jjtn000 = new ASTTz(JJTTZ);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(TZ);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Rand() throws ParseException {/* @bgen(jjtree) Rand */
<b class="fc">&nbsp;		ASTRand jjtn000 = new ASTRand(JJTRAND);</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(RAND);</b>
<b class="fc">&nbsp;			jj_consume_token(NIL);</b>
&nbsp;		} finally {
<b class="fc">&nbsp;			jjtree.closeNodeScope(jjtn000, true);</b>
<b class="fc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Abs() throws ParseException {/* @bgen(jjtree) Abs */
<b class="fc">&nbsp;		ASTAbs jjtn000 = new ASTAbs(JJTABS);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(ABS);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Ceil() throws ParseException {/* @bgen(jjtree) Ceil */
<b class="fc">&nbsp;		ASTCeil jjtn000 = new ASTCeil(JJTCEIL);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(CEIL);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Floor() throws ParseException {/* @bgen(jjtree) Floor */
<b class="fc">&nbsp;		ASTFloor jjtn000 = new ASTFloor(JJTFLOOR);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(FLOOR);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Round() throws ParseException {/* @bgen(jjtree) Round */
<b class="fc">&nbsp;		ASTRound jjtn000 = new ASTRound(JJTROUND);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(ROUND);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Substr() throws ParseException {/* @bgen(jjtree) Substr */
<b class="fc">&nbsp;		ASTSubstr jjtn000 = new ASTSubstr(JJTSUBSTR);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(SUBSTR);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(COMMA);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == COMMA) {</b>
<b class="fc">&nbsp;				jj_consume_token(COMMA);</b>
<b class="fc">&nbsp;				Expression();</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[143] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void StrLen() throws ParseException {/* @bgen(jjtree) StrLen */
<b class="fc">&nbsp;		ASTStrLen jjtn000 = new ASTStrLen(JJTSTRLEN);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(STRLEN);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void UpperCase() throws ParseException {/* @bgen(jjtree) UpperCase */
<b class="fc">&nbsp;		ASTUpperCase jjtn000 = new ASTUpperCase(JJTUPPERCASE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(UCASE);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void LowerCase() throws ParseException {/* @bgen(jjtree) LowerCase */
<b class="fc">&nbsp;		ASTLowerCase jjtn000 = new ASTLowerCase(JJTLOWERCASE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(LCASE);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void StrStarts() throws ParseException {/* @bgen(jjtree) StrStarts */
<b class="fc">&nbsp;		ASTStrStarts jjtn000 = new ASTStrStarts(JJTSTRSTARTS);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(STR_STARTS);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(COMMA);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void StrEnds() throws ParseException {/* @bgen(jjtree) StrEnds */
<b class="fc">&nbsp;		ASTStrEnds jjtn000 = new ASTStrEnds(JJTSTRENDS);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(STR_ENDS);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(COMMA);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void StrBefore() throws ParseException {/* @bgen(jjtree) StrBefore */
<b class="fc">&nbsp;		ASTStrBefore jjtn000 = new ASTStrBefore(JJTSTRBEFORE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(STR_BEFORE);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(COMMA);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void StrAfter() throws ParseException {/* @bgen(jjtree) StrAfter */
<b class="fc">&nbsp;		ASTStrAfter jjtn000 = new ASTStrAfter(JJTSTRAFTER);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(STR_AFTER);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(COMMA);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Replace() throws ParseException {/* @bgen(jjtree) Replace */
<b class="fc">&nbsp;		ASTReplace jjtn000 = new ASTReplace(JJTREPLACE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(REPLACE);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(COMMA);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(COMMA);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == COMMA) {</b>
<b class="nc">&nbsp;				jj_consume_token(COMMA);</b>
<b class="nc">&nbsp;				Expression();</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[144] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Concat() throws ParseException {/* @bgen(jjtree) Concat */
<b class="fc">&nbsp;		ASTConcat jjtn000 = new ASTConcat(JJTCONCAT);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(CONCAT);</b>
<b class="fc">&nbsp;			ArgList();</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Contains() throws ParseException {/* @bgen(jjtree) Contains */
<b class="fc">&nbsp;		ASTContains jjtn000 = new ASTContains(JJTCONTAINS);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(CONTAINS);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(COMMA);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void EncodeForURI() throws ParseException {/* @bgen(jjtree) EncodeForURI */
<b class="fc">&nbsp;		ASTEncodeForURI jjtn000 = new ASTEncodeForURI(JJTENCODEFORURI);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(ENCODE_FOR_URI);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void If() throws ParseException {/* @bgen(jjtree) If */
<b class="fc">&nbsp;		ASTIf jjtn000 = new ASTIf(JJTIF);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(IF);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(COMMA);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(COMMA);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void In() throws ParseException {/* @bgen(jjtree) In */
<b class="fc">&nbsp;		ASTIn jjtn000 = new ASTIn(JJTIN);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(IN);</b>
<b class="fc">&nbsp;			ArgList();</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void NotIn() throws ParseException {/* @bgen(jjtree) NotIn */
<b class="fc">&nbsp;		ASTNotIn jjtn000 = new ASTNotIn(JJTNOTIN);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(NOT_FUNC);</b>
<b class="fc">&nbsp;			jj_consume_token(IN);</b>
<b class="fc">&nbsp;			ArgList();</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Coalesce() throws ParseException {/* @bgen(jjtree) Coalesce */
<b class="fc">&nbsp;		ASTCoalesce jjtn000 = new ASTCoalesce(JJTCOALESCE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(COALESCE);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
&nbsp;			while (true) {
<b class="pc">&nbsp;				if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) != COMMA) {</b>
<b class="fc">&nbsp;					jj_la1[145] = jj_gen;</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
<b class="fc">&nbsp;				jj_consume_token(COMMA);</b>
<b class="fc">&nbsp;				Expression();</b>
&nbsp;			}
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Str() throws ParseException {/* @bgen(jjtree) Str */
<b class="fc">&nbsp;		ASTStr jjtn000 = new ASTStr(JJTSTR);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(STR);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Lang() throws ParseException {/* @bgen(jjtree) Lang */
<b class="fc">&nbsp;		ASTLang jjtn000 = new ASTLang(JJTLANG);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(LANG);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void LangMatches() throws ParseException {/* @bgen(jjtree) LangMatches */
<b class="fc">&nbsp;		ASTLangMatches jjtn000 = new ASTLangMatches(JJTLANGMATCHES);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(LANGMATCHES);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(COMMA);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Datatype() throws ParseException {/* @bgen(jjtree) Datatype */
<b class="fc">&nbsp;		ASTDatatype jjtn000 = new ASTDatatype(JJTDATATYPE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(DATATYPE);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Bound() throws ParseException {/* @bgen(jjtree) Bound */
<b class="fc">&nbsp;		ASTBound jjtn000 = new ASTBound(JJTBOUND);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(BOUND);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Var();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void SameTerm() throws ParseException {/* @bgen(jjtree) SameTerm */
<b class="fc">&nbsp;		ASTSameTerm jjtn000 = new ASTSameTerm(JJTSAMETERM);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(SAMETERM);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(COMMA);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void IsIRI() throws ParseException {/* @bgen(jjtree) IsIRI */
<b class="fc">&nbsp;		ASTIsIRI jjtn000 = new ASTIsIRI(JJTISIRI);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(IS_IRI);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void IsBlank() throws ParseException {/* @bgen(jjtree) IsBlank */
<b class="fc">&nbsp;		ASTIsBlank jjtn000 = new ASTIsBlank(JJTISBLANK);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(IS_BLANK);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void IsLiteral() throws ParseException {/* @bgen(jjtree) IsLiteral */
<b class="fc">&nbsp;		ASTIsLiteral jjtn000 = new ASTIsLiteral(JJTISLITERAL);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(IS_LITERAL);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void IsNumeric() throws ParseException {/* @bgen(jjtree) IsNumeric */
<b class="fc">&nbsp;		ASTIsNumeric jjtn000 = new ASTIsNumeric(JJTISNUMERIC);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(IS_NUMERIC);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void BNodeFunc() throws ParseException {/* @bgen(jjtree) BNodeFunc */
<b class="fc">&nbsp;		ASTBNodeFunc jjtn000 = new ASTBNodeFunc(JJTBNODEFUNC);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(BNODE);</b>
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case NIL: {
<b class="fc">&nbsp;				jj_consume_token(NIL);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case LPAREN: {
<b class="fc">&nbsp;				jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;				Expression();</b>
<b class="fc">&nbsp;				jj_consume_token(RPAREN);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[146] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void IRIFunc() throws ParseException {/* @bgen(jjtree) IRIFunc */
<b class="fc">&nbsp;		ASTIRIFunc jjtn000 = new ASTIRIFunc(JJTIRIFUNC);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(IRI);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void StrDt() throws ParseException {/* @bgen(jjtree) StrDt */
<b class="fc">&nbsp;		ASTStrDt jjtn000 = new ASTStrDt(JJTSTRDT);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(STRDT);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(COMMA);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void StrLang() throws ParseException {/* @bgen(jjtree) StrLang */
<b class="fc">&nbsp;		ASTStrLang jjtn000 = new ASTStrLang(JJTSTRLANG);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(STRLANG);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(COMMA);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void UUID() throws ParseException {/* @bgen(jjtree) UUID */
<b class="fc">&nbsp;		ASTUUID jjtn000 = new ASTUUID(JJTUUID);</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(UUID);</b>
<b class="fc">&nbsp;			jj_consume_token(NIL);</b>
&nbsp;		} finally {
<b class="fc">&nbsp;			jjtree.closeNodeScope(jjtn000, true);</b>
<b class="fc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void STRUUID() throws ParseException {/* @bgen(jjtree) STRUUID */
<b class="fc">&nbsp;		ASTSTRUUID jjtn000 = new ASTSTRUUID(JJTSTRUUID);</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(STRUUID);</b>
<b class="fc">&nbsp;			jj_consume_token(NIL);</b>
&nbsp;		} finally {
<b class="fc">&nbsp;			jjtree.closeNodeScope(jjtn000, true);</b>
<b class="fc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Bind() throws ParseException {/* @bgen(jjtree) Bind */
<b class="fc">&nbsp;		ASTBind jjtn000 = new ASTBind(JJTBIND);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(BIND);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(AS);</b>
<b class="fc">&nbsp;			Var();</b>
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void RegexExpression() throws ParseException {/* @bgen(jjtree) RegexExpression */
<b class="fc">&nbsp;		ASTRegexExpression jjtn000 = new ASTRegexExpression(JJTREGEXEXPRESSION);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(REGEX);</b>
<b class="fc">&nbsp;			jj_consume_token(LPAREN);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="fc">&nbsp;			jj_consume_token(COMMA);</b>
<b class="fc">&nbsp;			Expression();</b>
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == COMMA) {</b>
<b class="fc">&nbsp;				jj_consume_token(COMMA);</b>
<b class="fc">&nbsp;				Expression();</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[147] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			jj_consume_token(RPAREN);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void ExistsFunc() throws ParseException {/* @bgen(jjtree) ExistsFunc */
<b class="fc">&nbsp;		ASTExistsFunc jjtn000 = new ASTExistsFunc(JJTEXISTSFUNC);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(EXISTS);</b>
<b class="fc">&nbsp;			GroupGraphPattern();</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void NotExistsFunc() throws ParseException {/* @bgen(jjtree) NotExistsFunc */
<b class="fc">&nbsp;		ASTNotExistsFunc jjtn000 = new ASTNotExistsFunc(JJTNOTEXISTSFUNC);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(NOT_FUNC);</b>
<b class="fc">&nbsp;			jj_consume_token(EXISTS);</b>
<b class="fc">&nbsp;			GroupGraphPattern();</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void RDFLiteral() throws ParseException {/* @bgen(jjtree) RDFLiteral */
<b class="fc">&nbsp;		ASTRDFLiteral jjtn000 = new ASTRDFLiteral(JJTRDFLITERAL);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		Token t;
&nbsp;		try {
<b class="fc">&nbsp;			String();</b>
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case DT_PREFIX:
&nbsp;			case LANGTAG: {
<b class="pc">&nbsp;				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;				case LANGTAG: {
<b class="fc">&nbsp;					t = jj_consume_token(LANGTAG);</b>
<b class="fc">&nbsp;					jjtn000.setLang(t.image.substring(1));</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;				case DT_PREFIX: {
<b class="fc">&nbsp;					jj_consume_token(DT_PREFIX);</b>
<b class="fc">&nbsp;					IRIref();</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;				default:
<b class="nc">&nbsp;					jj_la1[148] = jj_gen;</b>
<b class="nc">&nbsp;					jj_consume_token(-1);</b>
<b class="nc">&nbsp;					throw new ParseException();</b>
&nbsp;				}
&nbsp;				break;
&nbsp;			}
&nbsp;			default:
<b class="fc">&nbsp;				jj_la1[149] = jj_gen;</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void NumericLiteral() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case INTEGER:
&nbsp;		case DECIMAL:
&nbsp;		case DOUBLE: {
<b class="fc">&nbsp;			NumericLiteralUnsigned();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case INTEGER_POSITIVE:
&nbsp;		case DECIMAL_POSITIVE:
&nbsp;		case DOUBLE_POSITIVE: {
<b class="nc">&nbsp;			NumericLiteralPositive();</b>
<b class="nc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case INTEGER_NEGATIVE:
&nbsp;		case DECIMAL_NEGATIVE:
&nbsp;		case DOUBLE_NEGATIVE: {
<b class="fc">&nbsp;			NumericLiteralNegative();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[150] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void NumericLiteralUnsigned() throws ParseException {/* @bgen(jjtree) NumericLiteral */
<b class="fc">&nbsp;		ASTNumericLiteral jjtn000 = new ASTNumericLiteral(JJTNUMERICLITERAL);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		Token t;
&nbsp;		IRI datatype;
&nbsp;		try {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case INTEGER: {
<b class="fc">&nbsp;				t = jj_consume_token(INTEGER);</b>
<b class="fc">&nbsp;				datatype = XSD.INTEGER;</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case DECIMAL: {
<b class="fc">&nbsp;				t = jj_consume_token(DECIMAL);</b>
<b class="fc">&nbsp;				datatype = XSD.DECIMAL;</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case DOUBLE: {
<b class="nc">&nbsp;				t = jj_consume_token(DOUBLE);</b>
<b class="nc">&nbsp;				datatype = XSD.DOUBLE;</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[151] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="fc">&nbsp;			jjtree.closeNodeScope(jjtn000, true);</b>
<b class="fc">&nbsp;			jjtc000 = false;</b>
<b class="fc">&nbsp;			jjtn000.setValue(t.image);</b>
<b class="fc">&nbsp;			jjtn000.setDatatype(datatype);</b>
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void NumericLiteralPositive() throws ParseException {/* @bgen(jjtree) NumericLiteral */
<b class="fc">&nbsp;		ASTNumericLiteral jjtn000 = new ASTNumericLiteral(JJTNUMERICLITERAL);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		Token t;
&nbsp;		IRI datatype;
&nbsp;		try {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case INTEGER_POSITIVE: {
<b class="fc">&nbsp;				t = jj_consume_token(INTEGER_POSITIVE);</b>
<b class="fc">&nbsp;				datatype = XSD.INTEGER;</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case DECIMAL_POSITIVE: {
<b class="nc">&nbsp;				t = jj_consume_token(DECIMAL_POSITIVE);</b>
<b class="nc">&nbsp;				datatype = XSD.DECIMAL;</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case DOUBLE_POSITIVE: {
<b class="nc">&nbsp;				t = jj_consume_token(DOUBLE_POSITIVE);</b>
<b class="nc">&nbsp;				datatype = XSD.DOUBLE;</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[152] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="fc">&nbsp;			jjtree.closeNodeScope(jjtn000, true);</b>
<b class="fc">&nbsp;			jjtc000 = false;</b>
<b class="fc">&nbsp;			jjtn000.setValue(t.image);</b>
<b class="fc">&nbsp;			jjtn000.setDatatype(datatype);</b>
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void NumericLiteralNegative() throws ParseException {/* @bgen(jjtree) NumericLiteral */
<b class="fc">&nbsp;		ASTNumericLiteral jjtn000 = new ASTNumericLiteral(JJTNUMERICLITERAL);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		Token t;
&nbsp;		IRI datatype;
&nbsp;		try {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case INTEGER_NEGATIVE: {
<b class="fc">&nbsp;				t = jj_consume_token(INTEGER_NEGATIVE);</b>
<b class="fc">&nbsp;				datatype = XSD.INTEGER;</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case DECIMAL_NEGATIVE: {
<b class="nc">&nbsp;				t = jj_consume_token(DECIMAL_NEGATIVE);</b>
<b class="nc">&nbsp;				datatype = XSD.DECIMAL;</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case DOUBLE_NEGATIVE: {
<b class="nc">&nbsp;				t = jj_consume_token(DOUBLE_NEGATIVE);</b>
<b class="nc">&nbsp;				datatype = XSD.DOUBLE;</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[153] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="fc">&nbsp;			jjtree.closeNodeScope(jjtn000, true);</b>
<b class="fc">&nbsp;			jjtc000 = false;</b>
<b class="fc">&nbsp;			jjtn000.setValue(t.image);</b>
<b class="fc">&nbsp;			jjtn000.setDatatype(datatype);</b>
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void BooleanLiteral() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case TRUE: {
<b class="fc">&nbsp;			ASTTrue jjtn001 = new ASTTrue(JJTTRUE);</b>
<b class="fc">&nbsp;			jjtree.openNodeScope(jjtn001);</b>
&nbsp;			try {
<b class="fc">&nbsp;				jj_consume_token(TRUE);</b>
&nbsp;			} finally {
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn001, true);</b>
<b class="fc">&nbsp;			}</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case FALSE: {
<b class="fc">&nbsp;			ASTFalse jjtn002 = new ASTFalse(JJTFALSE);</b>
<b class="fc">&nbsp;			jjtree.openNodeScope(jjtn002);</b>
&nbsp;			try {
<b class="fc">&nbsp;				jj_consume_token(FALSE);</b>
&nbsp;			} finally {
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn002, true);</b>
<b class="fc">&nbsp;			}</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[154] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void String() throws ParseException {/* @bgen(jjtree) String */
<b class="fc">&nbsp;		ASTString jjtn000 = new ASTString(JJTSTRING);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		Token t;
&nbsp;		try {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case STRING_LITERAL1:
&nbsp;			case STRING_LITERAL2: {
<b class="pc">&nbsp;				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;				case STRING_LITERAL1: {
<b class="fc">&nbsp;					t = jj_consume_token(STRING_LITERAL1);</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;				case STRING_LITERAL2: {
<b class="fc">&nbsp;					t = jj_consume_token(STRING_LITERAL2);</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;				default:
<b class="nc">&nbsp;					jj_la1[155] = jj_gen;</b>
<b class="nc">&nbsp;					jj_consume_token(-1);</b>
<b class="nc">&nbsp;					throw new ParseException();</b>
&nbsp;				}
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
<b class="fc">&nbsp;				jjtc000 = false;</b>
<b class="fc">&nbsp;				jjtn000.setValue(_trimString(t.image, 1));</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case STRING_LITERAL_LONG1:
&nbsp;			case STRING_LITERAL_LONG2: {
<b class="nc">&nbsp;				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;				case STRING_LITERAL_LONG1: {
<b class="nc">&nbsp;					t = jj_consume_token(STRING_LITERAL_LONG1);</b>
<b class="nc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;				case STRING_LITERAL_LONG2: {
<b class="nc">&nbsp;					t = jj_consume_token(STRING_LITERAL_LONG2);</b>
<b class="nc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;				default:
<b class="nc">&nbsp;					jj_la1[156] = jj_gen;</b>
<b class="nc">&nbsp;					jj_consume_token(-1);</b>
<b class="nc">&nbsp;					throw new ParseException();</b>
&nbsp;				}
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
<b class="nc">&nbsp;				jjtc000 = false;</b>
<b class="nc">&nbsp;				jjtn000.setValue(_trimString(t.image, 3));</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[157] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void IRIref() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case Q_IRI_REF: {
<b class="fc">&nbsp;			IRI();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case PNAME_NS:
&nbsp;		case PNAME_LN: {
<b class="fc">&nbsp;			PrefixedName();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			jj_la1[158] = jj_gen;</b>
<b class="nc">&nbsp;			jj_consume_token(-1);</b>
<b class="nc">&nbsp;			throw new ParseException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void PrefixedName() throws ParseException {/* @bgen(jjtree) QName */
<b class="fc">&nbsp;		ASTQName jjtn000 = new ASTQName(JJTQNAME);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		Token t;
&nbsp;		try {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case PNAME_LN: {
<b class="fc">&nbsp;				t = jj_consume_token(PNAME_LN);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case PNAME_NS: {
<b class="fc">&nbsp;				t = jj_consume_token(PNAME_NS);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[159] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="fc">&nbsp;			jjtree.closeNodeScope(jjtn000, true);</b>
<b class="fc">&nbsp;			jjtc000 = false;</b>
<b class="fc">&nbsp;			jjtn000.setValue(t.image);</b>
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void BlankNode() throws ParseException {/* @bgen(jjtree) BlankNode */
<b class="fc">&nbsp;		ASTBlankNode jjtn000 = new ASTBlankNode(JJTBLANKNODE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		Token t;
&nbsp;		try {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case BLANK_NODE_LABEL: {
<b class="nc">&nbsp;				t = jj_consume_token(BLANK_NODE_LABEL);</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
<b class="nc">&nbsp;				jjtc000 = false;</b>
<b class="nc">&nbsp;				jjtn000.setID(t.image.substring(2));</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case ANON: {
<b class="fc">&nbsp;				jj_consume_token(ANON);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[160] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void IRI() throws ParseException {/* @bgen(jjtree) IRI */
<b class="fc">&nbsp;		ASTIRI jjtn000 = new ASTIRI(JJTIRI);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		Token t;
&nbsp;		try {
<b class="fc">&nbsp;			t = jj_consume_token(Q_IRI_REF);</b>
<b class="fc">&nbsp;			jjtree.closeNodeScope(jjtn000, true);</b>
<b class="fc">&nbsp;			jjtc000 = false;</b>
<b class="fc">&nbsp;			jjtn000.setValue(_trimString(t.image, 1));</b>
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/// SPARQL 1.1 Update productions
&nbsp;	final public void GraphRefAll() throws ParseException {/* @bgen(jjtree) GraphRefAll */
<b class="fc">&nbsp;		ASTGraphRefAll jjtn000 = new ASTGraphRefAll(JJTGRAPHREFALL);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case GRAPH: {
<b class="fc">&nbsp;				GraphRef();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case DEFAULT_GRAPH: {
<b class="fc">&nbsp;				jj_consume_token(DEFAULT_GRAPH);</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
<b class="fc">&nbsp;				jjtc000 = false;</b>
<b class="fc">&nbsp;				jjtn000.setDefault(true);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case NAMED: {
<b class="fc">&nbsp;				jj_consume_token(NAMED);</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
<b class="fc">&nbsp;				jjtc000 = false;</b>
<b class="fc">&nbsp;				jjtn000.setNamed(true);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case ALL: {
<b class="fc">&nbsp;				jj_consume_token(ALL);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[161] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			if (jjtc000) {</b>
<b class="nc">&nbsp;				jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;				jjtc000 = false;</b>
&nbsp;			} else {
<b class="nc">&nbsp;				jjtree.popNode();</b>
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void GraphOrDefault() throws ParseException {/* @bgen(jjtree) GraphOrDefault */
<b class="fc">&nbsp;		ASTGraphOrDefault jjtn000 = new ASTGraphOrDefault(JJTGRAPHORDEFAULT);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case DEFAULT_GRAPH: {
<b class="fc">&nbsp;				jj_consume_token(DEFAULT_GRAPH);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case GRAPH:
&nbsp;			case Q_IRI_REF:
&nbsp;			case PNAME_NS:
&nbsp;			case PNAME_LN: {
<b class="pc">&nbsp;				if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == GRAPH) {</b>
<b class="fc">&nbsp;					jj_consume_token(GRAPH);</b>
&nbsp;				} else {
<b class="fc">&nbsp;					jj_la1[162] = jj_gen;</b>
&nbsp;				}
<b class="fc">&nbsp;				IRIref();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[163] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void GraphRef() throws ParseException {
<b class="fc">&nbsp;		jj_consume_token(GRAPH);</b>
<b class="fc">&nbsp;		IRIref();</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void UnparsedQuadDataBlock() throws ParseException {/* @bgen(jjtree) UnparsedQuadDataBlock */
<b class="fc">&nbsp;		ASTUnparsedQuadDataBlock jjtn000 = new ASTUnparsedQuadDataBlock(JJTUNPARSEDQUADDATABLOCK);</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(LBRACE);</b>
<b class="fc">&nbsp;			jjtn000.setDataBlock(readToMatchingBrace());</b>
<b class="fc">&nbsp;			jj_consume_token(RBRACE);</b>
&nbsp;		} finally {
<b class="fc">&nbsp;			jjtree.closeNodeScope(jjtn000, true);</b>
<b class="fc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void QuadData() throws ParseException {
<b class="fc">&nbsp;		jj_consume_token(LBRACE);</b>
<b class="fc">&nbsp;		Quads();</b>
<b class="fc">&nbsp;		jj_consume_token(RBRACE);</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Quads() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case LPAREN:
&nbsp;		case LBRACK:
&nbsp;		case NIL:
&nbsp;		case ANON:
&nbsp;		case TRUE:
&nbsp;		case FALSE:
&nbsp;		case Q_IRI_REF:
&nbsp;		case PNAME_NS:
&nbsp;		case PNAME_LN:
&nbsp;		case BLANK_NODE_LABEL:
&nbsp;		case VAR1:
&nbsp;		case VAR2:
&nbsp;		case INTEGER:
&nbsp;		case INTEGER_POSITIVE:
&nbsp;		case INTEGER_NEGATIVE:
&nbsp;		case DECIMAL:
&nbsp;		case DECIMAL_POSITIVE:
&nbsp;		case DECIMAL_NEGATIVE:
&nbsp;		case DOUBLE:
&nbsp;		case DOUBLE_POSITIVE:
&nbsp;		case DOUBLE_NEGATIVE:
&nbsp;		case STRING_LITERAL1:
&nbsp;		case STRING_LITERAL2:
&nbsp;		case STRING_LITERAL_LONG1:
&nbsp;		case STRING_LITERAL_LONG2:
&nbsp;		case TRIPLE_OPEN: {
<b class="fc">&nbsp;			TriplesTemplate();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="fc">&nbsp;			jj_la1[164] = jj_gen;</b>
&nbsp;		}
&nbsp;		while (true) {
<b class="fc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) != GRAPH) {</b>
<b class="fc">&nbsp;				jj_la1[165] = jj_gen;</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
<b class="fc">&nbsp;			QuadsNotTriples();</b>
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == DOT) {</b>
<b class="nc">&nbsp;				jj_consume_token(DOT);</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[166] = jj_gen;</b>
&nbsp;			}
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case LPAREN:
&nbsp;			case LBRACK:
&nbsp;			case NIL:
&nbsp;			case ANON:
&nbsp;			case TRUE:
&nbsp;			case FALSE:
&nbsp;			case Q_IRI_REF:
&nbsp;			case PNAME_NS:
&nbsp;			case PNAME_LN:
&nbsp;			case BLANK_NODE_LABEL:
&nbsp;			case VAR1:
&nbsp;			case VAR2:
&nbsp;			case INTEGER:
&nbsp;			case INTEGER_POSITIVE:
&nbsp;			case INTEGER_NEGATIVE:
&nbsp;			case DECIMAL:
&nbsp;			case DECIMAL_POSITIVE:
&nbsp;			case DECIMAL_NEGATIVE:
&nbsp;			case DOUBLE:
&nbsp;			case DOUBLE_POSITIVE:
&nbsp;			case DOUBLE_NEGATIVE:
&nbsp;			case STRING_LITERAL1:
&nbsp;			case STRING_LITERAL2:
&nbsp;			case STRING_LITERAL_LONG1:
&nbsp;			case STRING_LITERAL_LONG2:
&nbsp;			case TRIPLE_OPEN: {
<b class="nc">&nbsp;				TriplesTemplate();</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="fc">&nbsp;				jj_la1[167] = jj_gen;</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void QuadsNotTriples() throws ParseException {/* @bgen(jjtree) QuadsNotTriples */
<b class="fc">&nbsp;		ASTQuadsNotTriples jjtn000 = new ASTQuadsNotTriples(JJTQUADSNOTTRIPLES);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(GRAPH);</b>
<b class="fc">&nbsp;			VarOrIRIref();</b>
<b class="fc">&nbsp;			jj_consume_token(LBRACE);</b>
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case LPAREN:
&nbsp;			case LBRACK:
&nbsp;			case NIL:
&nbsp;			case ANON:
&nbsp;			case TRUE:
&nbsp;			case FALSE:
&nbsp;			case Q_IRI_REF:
&nbsp;			case PNAME_NS:
&nbsp;			case PNAME_LN:
&nbsp;			case BLANK_NODE_LABEL:
&nbsp;			case VAR1:
&nbsp;			case VAR2:
&nbsp;			case INTEGER:
&nbsp;			case INTEGER_POSITIVE:
&nbsp;			case INTEGER_NEGATIVE:
&nbsp;			case DECIMAL:
&nbsp;			case DECIMAL_POSITIVE:
&nbsp;			case DECIMAL_NEGATIVE:
&nbsp;			case DOUBLE:
&nbsp;			case DOUBLE_POSITIVE:
&nbsp;			case DOUBLE_NEGATIVE:
&nbsp;			case STRING_LITERAL1:
&nbsp;			case STRING_LITERAL2:
&nbsp;			case STRING_LITERAL_LONG1:
&nbsp;			case STRING_LITERAL_LONG2:
&nbsp;			case TRIPLE_OPEN: {
<b class="fc">&nbsp;				TriplesTemplate();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[168] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			jj_consume_token(RBRACE);</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Update() throws ParseException {
<b class="pc">&nbsp;		switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;		case LOAD: {
<b class="fc">&nbsp;			Load();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case CLEAR: {
<b class="fc">&nbsp;			Clear();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case DROP: {
<b class="fc">&nbsp;			Drop();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case ADD: {
<b class="fc">&nbsp;			Add();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case MOVE: {
<b class="fc">&nbsp;			Move();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case COPY: {
<b class="fc">&nbsp;			Copy();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		case CREATE: {
<b class="fc">&nbsp;			Create();</b>
<b class="fc">&nbsp;			break;</b>
&nbsp;		}
&nbsp;		default:
<b class="fc">&nbsp;			jj_la1[169] = jj_gen;</b>
<b class="fc">&nbsp;			if (jj_2_5()) {</b>
<b class="fc">&nbsp;				InsertData();</b>
<b class="fc">&nbsp;			} else if (jj_2_6()) {</b>
<b class="fc">&nbsp;				DeleteData();</b>
<b class="fc">&nbsp;			} else if (jj_2_7()) {</b>
<b class="fc">&nbsp;				DeleteWhere();</b>
&nbsp;			} else {
<b class="pc">&nbsp;				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;				case INSERT:
&nbsp;				case DELETE:
&nbsp;				case WITH: {
<b class="fc">&nbsp;					Modify();</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;				default:
<b class="nc">&nbsp;					jj_la1[170] = jj_gen;</b>
<b class="nc">&nbsp;					jj_consume_token(-1);</b>
<b class="nc">&nbsp;					throw new ParseException();</b>
&nbsp;				}
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	final public void Load() throws ParseException {/* @bgen(jjtree) Load */
<b class="fc">&nbsp;		ASTLoad jjtn000 = new ASTLoad(JJTLOAD);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(LOAD);</b>
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == SILENT) {</b>
<b class="fc">&nbsp;				jj_consume_token(SILENT);</b>
<b class="fc">&nbsp;				jjtn000.setSilent(true);</b>
&nbsp;			} else {
<b class="nc">&nbsp;				jj_la1[171] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			IRIref();</b>
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == INTO) {</b>
<b class="fc">&nbsp;				jj_consume_token(INTO);</b>
<b class="fc">&nbsp;				GraphRef();</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[172] = jj_gen;</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Clear() throws ParseException {/* @bgen(jjtree) Clear */
<b class="fc">&nbsp;		ASTClear jjtn000 = new ASTClear(JJTCLEAR);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(CLEAR);</b>
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == SILENT) {</b>
<b class="fc">&nbsp;				jj_consume_token(SILENT);</b>
<b class="fc">&nbsp;				jjtn000.setSilent(true);</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[173] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			GraphRefAll();</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Drop() throws ParseException {/* @bgen(jjtree) Drop */
<b class="fc">&nbsp;		ASTDrop jjtn000 = new ASTDrop(JJTDROP);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(DROP);</b>
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == SILENT) {</b>
<b class="fc">&nbsp;				jj_consume_token(SILENT);</b>
<b class="fc">&nbsp;				jjtn000.setSilent(true);</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[174] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			GraphRefAll();</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Add() throws ParseException {/* @bgen(jjtree) Add */
<b class="fc">&nbsp;		ASTAdd jjtn000 = new ASTAdd(JJTADD);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(ADD);</b>
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == SILENT) {</b>
<b class="fc">&nbsp;				jj_consume_token(SILENT);</b>
<b class="fc">&nbsp;				jjtn000.setSilent(true);</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[175] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			GraphOrDefault();</b>
<b class="fc">&nbsp;			jj_consume_token(TO);</b>
<b class="fc">&nbsp;			GraphOrDefault();</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Move() throws ParseException {/* @bgen(jjtree) Move */
<b class="fc">&nbsp;		ASTMove jjtn000 = new ASTMove(JJTMOVE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(MOVE);</b>
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == SILENT) {</b>
<b class="fc">&nbsp;				jj_consume_token(SILENT);</b>
<b class="fc">&nbsp;				jjtn000.setSilent(true);</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[176] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			GraphOrDefault();</b>
<b class="fc">&nbsp;			jj_consume_token(TO);</b>
<b class="fc">&nbsp;			GraphOrDefault();</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Copy() throws ParseException {/* @bgen(jjtree) Copy */
<b class="fc">&nbsp;		ASTCopy jjtn000 = new ASTCopy(JJTCOPY);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(COPY);</b>
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == SILENT) {</b>
<b class="fc">&nbsp;				jj_consume_token(SILENT);</b>
<b class="fc">&nbsp;				jjtn000.setSilent(true);</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[177] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			GraphOrDefault();</b>
<b class="fc">&nbsp;			jj_consume_token(TO);</b>
<b class="fc">&nbsp;			GraphOrDefault();</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Create() throws ParseException {/* @bgen(jjtree) Create */
<b class="fc">&nbsp;		ASTCreate jjtn000 = new ASTCreate(JJTCREATE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(CREATE);</b>
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == SILENT) {</b>
<b class="fc">&nbsp;				jj_consume_token(SILENT);</b>
<b class="fc">&nbsp;				jjtn000.setSilent(true);</b>
&nbsp;			} else {
<b class="nc">&nbsp;				jj_la1[178] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			GraphRef();</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void InsertData() throws ParseException {/* @bgen(jjtree) InsertData */
<b class="fc">&nbsp;		ASTInsertData jjtn000 = new ASTInsertData(JJTINSERTDATA);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(INSERT);</b>
<b class="fc">&nbsp;			jj_consume_token(DATA);</b>
<b class="fc">&nbsp;			UnparsedQuadDataBlock();</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void DeleteData() throws ParseException {/* @bgen(jjtree) DeleteData */
<b class="fc">&nbsp;		ASTDeleteData jjtn000 = new ASTDeleteData(JJTDELETEDATA);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(DELETE);</b>
<b class="fc">&nbsp;			jj_consume_token(DATA);</b>
<b class="fc">&nbsp;			UnparsedQuadDataBlock();</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void DeleteWhere() throws ParseException {/* @bgen(jjtree) DeleteWhere */
<b class="fc">&nbsp;		ASTDeleteWhere jjtn000 = new ASTDeleteWhere(JJTDELETEWHERE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(DELETE);</b>
<b class="fc">&nbsp;			jj_consume_token(WHERE);</b>
<b class="fc">&nbsp;			QuadData();</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void DeleteClause() throws ParseException {/* @bgen(jjtree) DeleteClause */
<b class="fc">&nbsp;		ASTDeleteClause jjtn000 = new ASTDeleteClause(JJTDELETECLAUSE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(DELETE);</b>
<b class="fc">&nbsp;			QuadData();</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void InsertClause() throws ParseException {/* @bgen(jjtree) InsertClause */
<b class="fc">&nbsp;		ASTInsertClause jjtn000 = new ASTInsertClause(JJTINSERTCLAUSE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(INSERT);</b>
<b class="fc">&nbsp;			QuadData();</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void UsingClause() throws ParseException {/* @bgen(jjtree) DatasetClause */
<b class="fc">&nbsp;		ASTDatasetClause jjtn000 = new ASTDatasetClause(JJTDATASETCLAUSE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(USING);</b>
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == NAMED) {</b>
<b class="nc">&nbsp;				jj_consume_token(NAMED);</b>
<b class="nc">&nbsp;				jjtn000.setNamed(true);</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[179] = jj_gen;</b>
&nbsp;			}
<b class="fc">&nbsp;			IRIref();</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void WithClause() throws ParseException {/* @bgen(jjtree) DatasetClause */
<b class="fc">&nbsp;		ASTDatasetClause jjtn000 = new ASTDatasetClause(JJTDATASETCLAUSE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(WITH);</b>
<b class="fc">&nbsp;			IRIref();</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * WHERE keyword is required in modify operations
&nbsp;	 */
&nbsp;	final public void ModifyWhereClause() throws ParseException {/* @bgen(jjtree) WhereClause */
<b class="fc">&nbsp;		ASTWhereClause jjtn000 = new ASTWhereClause(JJTWHERECLAUSE);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="fc">&nbsp;			jj_consume_token(WHERE);</b>
<b class="fc">&nbsp;			GroupGraphPattern();</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	final public void Modify() throws ParseException {/* @bgen(jjtree) Modify */
<b class="fc">&nbsp;		ASTModify jjtn000 = new ASTModify(JJTMODIFY);</b>
<b class="fc">&nbsp;		boolean jjtc000 = true;</b>
<b class="fc">&nbsp;		jjtree.openNodeScope(jjtn000);</b>
&nbsp;		try {
<b class="pc">&nbsp;			if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == WITH) {</b>
<b class="fc">&nbsp;				WithClause();</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_la1[180] = jj_gen;</b>
&nbsp;			}
<b class="pc">&nbsp;			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {</b>
&nbsp;			case DELETE: {
<b class="fc">&nbsp;				DeleteClause();</b>
<b class="pc">&nbsp;				if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) == INSERT) {</b>
<b class="fc">&nbsp;					InsertClause();</b>
&nbsp;				} else {
<b class="fc">&nbsp;					jj_la1[181] = jj_gen;</b>
&nbsp;				}
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			case INSERT: {
<b class="fc">&nbsp;				InsertClause();</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;			default:
<b class="nc">&nbsp;				jj_la1[182] = jj_gen;</b>
<b class="nc">&nbsp;				jj_consume_token(-1);</b>
<b class="nc">&nbsp;				throw new ParseException();</b>
&nbsp;			}
&nbsp;			while (true) {
<b class="fc">&nbsp;				if (((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) != USING) {</b>
<b class="fc">&nbsp;					jj_la1[183] = jj_gen;</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
<b class="fc">&nbsp;				UsingClause();</b>
&nbsp;			}
<b class="fc">&nbsp;			ModifyWhereClause();</b>
<b class="nc">&nbsp;		} catch (Throwable jjte000) {</b>
<b class="nc">&nbsp;			jjtree.clearNodeScope(jjtn000);</b>
<b class="nc">&nbsp;			jjtc000 = false;</b>
<b class="nc">&nbsp;			if (jjte000 instanceof RuntimeException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (RuntimeException) jjte000;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (jjte000 instanceof ParseException) {</b>
&nbsp;				{
<b class="nc">&nbsp;					throw (ParseException) jjte000;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			{
<b class="nc">&nbsp;				throw (Error) jjte000;</b>
&nbsp;			}
&nbsp;		} finally {
<b class="pc">&nbsp;			if (jjtc000) {</b>
<b class="fc">&nbsp;				jjtree.closeNodeScope(jjtn000, true);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_2_1() {
<b class="fc">&nbsp;		int xla = 2;</b>
<b class="fc">&nbsp;		jj_la = xla;</b>
<b class="fc">&nbsp;		jj_lastpos = jj_scanpos = token;</b>
&nbsp;		try {
<b class="pc">&nbsp;			return !jj_3_1();</b>
<b class="fc">&nbsp;		} catch (LookaheadSuccess ls) {</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;		} finally {
<b class="fc">&nbsp;			jj_save(0, xla);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_2_2() {
<b class="fc">&nbsp;		int xla = 2;</b>
<b class="fc">&nbsp;		jj_la = xla;</b>
<b class="fc">&nbsp;		jj_lastpos = jj_scanpos = token;</b>
&nbsp;		try {
<b class="pc">&nbsp;			return !jj_3_2();</b>
<b class="fc">&nbsp;		} catch (LookaheadSuccess ls) {</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;		} finally {
<b class="fc">&nbsp;			jj_save(1, xla);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_2_3() {
<b class="fc">&nbsp;		int xla = 2;</b>
<b class="fc">&nbsp;		jj_la = xla;</b>
<b class="fc">&nbsp;		jj_lastpos = jj_scanpos = token;</b>
&nbsp;		try {
<b class="pc">&nbsp;			return !jj_3_3();</b>
<b class="nc">&nbsp;		} catch (LookaheadSuccess ls) {</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;		} finally {
<b class="fc">&nbsp;			jj_save(2, xla);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_2_4() {
<b class="fc">&nbsp;		int xla = 2;</b>
<b class="fc">&nbsp;		jj_la = xla;</b>
<b class="fc">&nbsp;		jj_lastpos = jj_scanpos = token;</b>
&nbsp;		try {
<b class="pc">&nbsp;			return !jj_3_4();</b>
<b class="fc">&nbsp;		} catch (LookaheadSuccess ls) {</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;		} finally {
<b class="fc">&nbsp;			jj_save(3, xla);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_2_5() {
<b class="fc">&nbsp;		int xla = 2;</b>
<b class="fc">&nbsp;		jj_la = xla;</b>
<b class="fc">&nbsp;		jj_lastpos = jj_scanpos = token;</b>
&nbsp;		try {
<b class="pc">&nbsp;			return !jj_3_5();</b>
<b class="fc">&nbsp;		} catch (LookaheadSuccess ls) {</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;		} finally {
<b class="fc">&nbsp;			jj_save(4, xla);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_2_6() {
<b class="fc">&nbsp;		int xla = 2;</b>
<b class="fc">&nbsp;		jj_la = xla;</b>
<b class="fc">&nbsp;		jj_lastpos = jj_scanpos = token;</b>
&nbsp;		try {
<b class="pc">&nbsp;			return !jj_3_6();</b>
<b class="fc">&nbsp;		} catch (LookaheadSuccess ls) {</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;		} finally {
<b class="fc">&nbsp;			jj_save(5, xla);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_2_7() {
<b class="fc">&nbsp;		int xla = 2;</b>
<b class="fc">&nbsp;		jj_la = xla;</b>
<b class="fc">&nbsp;		jj_lastpos = jj_scanpos = token;</b>
&nbsp;		try {
<b class="pc">&nbsp;			return !jj_3_7();</b>
<b class="fc">&nbsp;		} catch (LookaheadSuccess ls) {</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;		} finally {
<b class="fc">&nbsp;			jj_save(6, xla);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_85() {
<b class="fc">&nbsp;		return jj_scan_token(FALSE);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_77() {
&nbsp;		Token xsp;
<b class="fc">&nbsp;		xsp = jj_scanpos;</b>
<b class="pc">&nbsp;		if (jj_3R_84()) {</b>
<b class="fc">&nbsp;			jj_scanpos = xsp;</b>
<b class="fc">&nbsp;			return jj_3R_85();</b>
&nbsp;		}
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_84() {
<b class="fc">&nbsp;		return jj_scan_token(TRUE);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_57() {
<b class="fc">&nbsp;		return jj_3R_65();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_100() {
<b class="fc">&nbsp;		return jj_scan_token(DOUBLE_NEGATIVE);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_56() {
<b class="fc">&nbsp;		return jj_3R_64();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_50() {
&nbsp;		Token xsp;
<b class="fc">&nbsp;		xsp = jj_scanpos;</b>
<b class="pc">&nbsp;		if (jj_3R_56()) {</b>
<b class="fc">&nbsp;			jj_scanpos = xsp;</b>
<b class="fc">&nbsp;			return jj_3R_57();</b>
&nbsp;		}
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_99() {
<b class="fc">&nbsp;		return jj_scan_token(DECIMAL_NEGATIVE);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_98() {
<b class="fc">&nbsp;		return jj_scan_token(INTEGER_NEGATIVE);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_59() {
<b class="fc">&nbsp;		return jj_3R_67();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_58() {
<b class="fc">&nbsp;		return jj_3R_66();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_51() {
&nbsp;		Token xsp;
<b class="fc">&nbsp;		xsp = jj_scanpos;</b>
<b class="pc">&nbsp;		if (jj_3R_58()) {</b>
<b class="fc">&nbsp;			jj_scanpos = xsp;</b>
<b class="fc">&nbsp;			return jj_3R_59();</b>
&nbsp;		}
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_91() {
&nbsp;		Token xsp;
<b class="fc">&nbsp;		xsp = jj_scanpos;</b>
<b class="pc">&nbsp;		if (jj_3R_98()) {</b>
<b class="fc">&nbsp;			jj_scanpos = xsp;</b>
<b class="pc">&nbsp;			if (jj_3R_99()) {</b>
<b class="fc">&nbsp;				jj_scanpos = xsp;</b>
<b class="fc">&nbsp;				return jj_3R_100();</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_97() {
<b class="fc">&nbsp;		return jj_scan_token(DOUBLE_POSITIVE);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_96() {
<b class="fc">&nbsp;		return jj_scan_token(DECIMAL_POSITIVE);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_95() {
<b class="fc">&nbsp;		return jj_scan_token(INTEGER_POSITIVE);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_90() {
&nbsp;		Token xsp;
<b class="fc">&nbsp;		xsp = jj_scanpos;</b>
<b class="pc">&nbsp;		if (jj_3R_95()) {</b>
<b class="fc">&nbsp;			jj_scanpos = xsp;</b>
<b class="pc">&nbsp;			if (jj_3R_96()) {</b>
<b class="fc">&nbsp;				jj_scanpos = xsp;</b>
<b class="fc">&nbsp;				return jj_3R_97();</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_40() {
<b class="fc">&nbsp;		if (jj_scan_token(DELETE)) {</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;		}
<b class="fc">&nbsp;		return jj_scan_token(WHERE);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3_3() {
<b class="fc">&nbsp;		if (jj_scan_token(DOT)) {</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;		}
<b class="fc">&nbsp;		return jj_3R_36();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_94() {
<b class="fc">&nbsp;		return jj_scan_token(DOUBLE);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3_2() {
<b class="fc">&nbsp;		if (jj_scan_token(DOT)) {</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;		}
<b class="fc">&nbsp;		return jj_3R_35();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_93() {
<b class="fc">&nbsp;		return jj_scan_token(DECIMAL);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_92() {
<b class="fc">&nbsp;		return jj_scan_token(INTEGER);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_39() {
<b class="fc">&nbsp;		if (jj_scan_token(DELETE)) {</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;		}
<b class="fc">&nbsp;		return jj_scan_token(DATA);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_38() {
<b class="fc">&nbsp;		if (jj_scan_token(INSERT)) {</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;		}
<b class="fc">&nbsp;		return jj_scan_token(DATA);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_83() {
<b class="fc">&nbsp;		return jj_3R_91();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_82() {
<b class="fc">&nbsp;		return jj_3R_90();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_89() {
&nbsp;		Token xsp;
<b class="fc">&nbsp;		xsp = jj_scanpos;</b>
<b class="pc">&nbsp;		if (jj_3R_92()) {</b>
<b class="fc">&nbsp;			jj_scanpos = xsp;</b>
<b class="pc">&nbsp;			if (jj_3R_93()) {</b>
<b class="fc">&nbsp;				jj_scanpos = xsp;</b>
<b class="fc">&nbsp;				return jj_3R_94();</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_81() {
<b class="fc">&nbsp;		return jj_3R_89();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_76() {
&nbsp;		Token xsp;
<b class="fc">&nbsp;		xsp = jj_scanpos;</b>
<b class="pc">&nbsp;		if (jj_3R_81()) {</b>
<b class="fc">&nbsp;			jj_scanpos = xsp;</b>
<b class="pc">&nbsp;			if (jj_3R_82()) {</b>
<b class="fc">&nbsp;				jj_scanpos = xsp;</b>
<b class="fc">&nbsp;				return jj_3R_83();</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_48() {
<b class="fc">&nbsp;		return jj_3R_35();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_75() {
<b class="fc">&nbsp;		return jj_3R_80();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_41() {
<b class="fc">&nbsp;		return jj_3R_48();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3_1() {
<b class="fc">&nbsp;		return jj_3R_34();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3_7() {
<b class="fc">&nbsp;		return jj_3R_40();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_34() {
<b class="fc">&nbsp;		if (jj_scan_token(LBRACE)) {</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;		}
&nbsp;		Token xsp;
<b class="fc">&nbsp;		xsp = jj_scanpos;</b>
<b class="pc">&nbsp;		if (jj_3R_41()) {</b>
<b class="nc">&nbsp;			jj_scanpos = xsp;</b>
&nbsp;		}
<b class="nc">&nbsp;		return jj_scan_token(RBRACE);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3_6() {
<b class="fc">&nbsp;		return jj_3R_39();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3_5() {
<b class="fc">&nbsp;		return jj_3R_38();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_79() {
<b class="fc">&nbsp;		return jj_scan_token(TRIPLE_OPEN);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_74() {
<b class="fc">&nbsp;		return jj_3R_79();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_73() {
<b class="fc">&nbsp;		return jj_scan_token(NIL);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_72() {
<b class="fc">&nbsp;		return jj_3R_78();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_71() {
<b class="fc">&nbsp;		return jj_3R_77();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_70() {
<b class="fc">&nbsp;		return jj_3R_76();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_69() {
<b class="fc">&nbsp;		return jj_3R_75();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_63() {
&nbsp;		Token xsp;
<b class="fc">&nbsp;		xsp = jj_scanpos;</b>
<b class="pc">&nbsp;		if (jj_3R_68()) {</b>
<b class="fc">&nbsp;			jj_scanpos = xsp;</b>
<b class="pc">&nbsp;			if (jj_3R_69()) {</b>
<b class="fc">&nbsp;				jj_scanpos = xsp;</b>
<b class="pc">&nbsp;				if (jj_3R_70()) {</b>
<b class="fc">&nbsp;					jj_scanpos = xsp;</b>
<b class="pc">&nbsp;					if (jj_3R_71()) {</b>
<b class="fc">&nbsp;						jj_scanpos = xsp;</b>
<b class="pc">&nbsp;						if (jj_3R_72()) {</b>
<b class="fc">&nbsp;							jj_scanpos = xsp;</b>
<b class="pc">&nbsp;							if (jj_3R_73()) {</b>
<b class="fc">&nbsp;								jj_scanpos = xsp;</b>
<b class="fc">&nbsp;								return jj_3R_74();</b>
&nbsp;							}
&nbsp;						}
&nbsp;					}
&nbsp;				}
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_68() {
<b class="fc">&nbsp;		return jj_3R_46();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_62() {
&nbsp;		Token xsp;
<b class="fc">&nbsp;		xsp = jj_scanpos;</b>
<b class="pc">&nbsp;		if (jj_scan_token(148)) {</b>
<b class="fc">&nbsp;			jj_scanpos = xsp;</b>
<b class="fc">&nbsp;			return jj_scan_token(149);</b>
&nbsp;		}
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_43() {
<b class="fc">&nbsp;		return jj_3R_50();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_35() {
&nbsp;		Token xsp;
<b class="fc">&nbsp;		xsp = jj_scanpos;</b>
<b class="pc">&nbsp;		if (jj_3R_42()) {</b>
<b class="fc">&nbsp;			jj_scanpos = xsp;</b>
<b class="fc">&nbsp;			return jj_3R_43();</b>
&nbsp;		}
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_42() {
<b class="fc">&nbsp;		return jj_3R_49();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_55() {
<b class="fc">&nbsp;		return jj_3R_63();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_54() {
<b class="fc">&nbsp;		return jj_3R_62();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_49() {
&nbsp;		Token xsp;
<b class="fc">&nbsp;		xsp = jj_scanpos;</b>
<b class="pc">&nbsp;		if (jj_3R_54()) {</b>
<b class="fc">&nbsp;			jj_scanpos = xsp;</b>
<b class="fc">&nbsp;			return jj_3R_55();</b>
&nbsp;		}
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_60() {
<b class="fc">&nbsp;		return jj_scan_token(Q_IRI_REF);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_45() {
<b class="fc">&nbsp;		return jj_3R_51();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_44() {
<b class="fc">&nbsp;		return jj_3R_49();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_36() {
&nbsp;		Token xsp;
<b class="fc">&nbsp;		xsp = jj_scanpos;</b>
<b class="pc">&nbsp;		if (jj_3R_44()) {</b>
<b class="fc">&nbsp;			jj_scanpos = xsp;</b>
<b class="fc">&nbsp;			return jj_3R_45();</b>
&nbsp;		}
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_78() {
&nbsp;		Token xsp;
<b class="fc">&nbsp;		xsp = jj_scanpos;</b>
<b class="pc">&nbsp;		if (jj_3R_86()) {</b>
<b class="fc">&nbsp;			jj_scanpos = xsp;</b>
<b class="fc">&nbsp;			return jj_scan_token(31);</b>
&nbsp;		}
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_86() {
<b class="fc">&nbsp;		return jj_scan_token(BLANK_NODE_LABEL);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_47() {
<b class="fc">&nbsp;		return jj_scan_token(LPAREN);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_61() {
&nbsp;		Token xsp;
<b class="fc">&nbsp;		xsp = jj_scanpos;</b>
<b class="fc">&nbsp;		if (jj_scan_token(146)) {</b>
<b class="fc">&nbsp;			jj_scanpos = xsp;</b>
<b class="fc">&nbsp;			return jj_scan_token(145);</b>
&nbsp;		}
<b class="fc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_64() {
<b class="fc">&nbsp;		return jj_scan_token(LPAREN);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_53() {
<b class="fc">&nbsp;		return jj_3R_61();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_52() {
<b class="fc">&nbsp;		return jj_3R_60();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_46() {
&nbsp;		Token xsp;
<b class="fc">&nbsp;		xsp = jj_scanpos;</b>
<b class="fc">&nbsp;		if (jj_3R_52()) {</b>
<b class="fc">&nbsp;			jj_scanpos = xsp;</b>
<b class="fc">&nbsp;			return jj_3R_53();</b>
&nbsp;		}
<b class="fc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_66() {
<b class="fc">&nbsp;		return jj_scan_token(LPAREN);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_37() {
<b class="fc">&nbsp;		if (jj_3R_46()) {</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;		}
&nbsp;		Token xsp;
<b class="fc">&nbsp;		xsp = jj_scanpos;</b>
<b class="pc">&nbsp;		if (jj_3R_47()) {</b>
<b class="fc">&nbsp;			jj_scanpos = xsp;</b>
<b class="fc">&nbsp;			return jj_scan_token(30);</b>
&nbsp;		}
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_65() {
<b class="fc">&nbsp;		return jj_scan_token(LBRACK);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_88() {
&nbsp;		Token xsp;
<b class="fc">&nbsp;		xsp = jj_scanpos;</b>
<b class="pc">&nbsp;		if (jj_scan_token(166)) {</b>
<b class="fc">&nbsp;			jj_scanpos = xsp;</b>
<b class="fc">&nbsp;			return jj_scan_token(167);</b>
&nbsp;		}
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_80() {
&nbsp;		Token xsp;
<b class="fc">&nbsp;		xsp = jj_scanpos;</b>
<b class="pc">&nbsp;		if (jj_3R_87()) {</b>
<b class="fc">&nbsp;			jj_scanpos = xsp;</b>
<b class="fc">&nbsp;			return jj_3R_88();</b>
&nbsp;		}
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_87() {
&nbsp;		Token xsp;
<b class="fc">&nbsp;		xsp = jj_scanpos;</b>
<b class="pc">&nbsp;		if (jj_scan_token(164)) {</b>
<b class="fc">&nbsp;			jj_scanpos = xsp;</b>
<b class="fc">&nbsp;			return jj_scan_token(165);</b>
&nbsp;		}
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3_4() {
<b class="fc">&nbsp;		return jj_3R_37();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean jj_3R_67() {
<b class="fc">&nbsp;		return jj_scan_token(LBRACK);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Generated Token Manager.
&nbsp;	 */
&nbsp;	public SyntaxTreeBuilderTokenManager token_source;
&nbsp;	/**
&nbsp;	 * Current token.
&nbsp;	 */
&nbsp;	public Token token;
&nbsp;	/**
&nbsp;	 * Next token.
&nbsp;	 */
&nbsp;	public Token jj_nt;
&nbsp;	private int jj_ntk;
&nbsp;	private Token jj_scanpos, jj_lastpos;
&nbsp;	private int jj_la;
&nbsp;	private int jj_gen;
<b class="fc">&nbsp;	final private int[] jj_la1 = new int[184];</b>
&nbsp;	static private int[] jj_la1_0;
&nbsp;	static private int[] jj_la1_1;
&nbsp;	static private int[] jj_la1_2;
&nbsp;	static private int[] jj_la1_3;
&nbsp;	static private int[] jj_la1_4;
&nbsp;	static private int[] jj_la1_5;
&nbsp;
&nbsp;	static {
<b class="fc">&nbsp;		jj_la1_init_0();</b>
<b class="fc">&nbsp;		jj_la1_init_1();</b>
<b class="fc">&nbsp;		jj_la1_init_2();</b>
<b class="fc">&nbsp;		jj_la1_init_3();</b>
<b class="fc">&nbsp;		jj_la1_init_4();</b>
<b class="fc">&nbsp;		jj_la1_init_5();</b>
&nbsp;	}
&nbsp;
&nbsp;	private static void jj_la1_init_0() {
<b class="fc">&nbsp;		jj_la1_0 = new int[] { 0x400, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x1000010, 0x10, 0x0, 0x0,</b>
&nbsp;				0xc0000110, 0x0, 0x40, 0x0, 0x0, 0x0, 0x1000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40000010, 0x0,
&nbsp;				0x40000010, 0x0, 0x0, 0x40000010, 0x40000010, 0x0, 0x40000010, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x10, 0x0,
&nbsp;				0x10, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0xc0000110, 0x1000, 0x40, 0x0, 0x1000, 0xc0000110, 0x1000,
&nbsp;				0xc0000110, 0x0, 0xc0000110, 0x0, 0x1000, 0x1000, 0x40, 0x0, 0x0, 0x0, 0x10, 0x0, 0x800, 0x40000010,
&nbsp;				0x800, 0x40000010, 0x0, 0xc0000110, 0x0, 0x400, 0x800, 0x10080010, 0xc0000110, 0x10080010, 0x10080010,
&nbsp;				0x400, 0x800, 0x8000000, 0x4000000, 0x10000000, 0x3400000, 0x80010, 0x8000000, 0x10000000, 0x10000010,
&nbsp;				0x0, 0x10000000, 0x3400000, 0x0, 0x110, 0x110, 0xc0000110, 0xc0000110, 0xc0000110, 0xc0000110,
&nbsp;				0xc0000000, 0x0, 0x0, 0xc0000000, 0xc0000000, 0x0, 0xc0000000, 0x0, 0x0, 0xc80010, 0x100000, 0x200000,
&nbsp;				0x7e000, 0x7e000, 0xc00000, 0xc00000, 0x5000000, 0x5000000, 0x400000, 0xc80010, 0x10, 0x0, 0x0, 0x0,
&nbsp;				0x1c80010, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x400, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x800, 0x800, 0x800,
&nbsp;				0x40000010, 0x800, 0x20000000, 0x20000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80000000,
&nbsp;				0x0, 0x0, 0x0, 0xc0000110, 0x0, 0x1000, 0xc0000110, 0xc0000110, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
&nbsp;				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, };
&nbsp;	}
&nbsp;
&nbsp;	private static void jj_la1_init_1() {
<b class="fc">&nbsp;		jj_la1_1 = new int[] { 0x0, 0x0, 0x6, 0x6, 0x78, 0x400, 0x0, 0x0, 0x180, 0x180, 0x0, 0x0, 0x0, 0x400, 0x0, 0x0,</b>
&nbsp;				0x400, 0x1000, 0x0, 0x0, 0x0, 0x0, 0x400, 0x0, 0x800, 0x800, 0x1000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
&nbsp;				0x0, 0x0, 0x0, 0x0, 0x4000, 0x2000000, 0x2000, 0xc0000, 0xfc000000, 0xfc030000, 0x200, 0xfc000000,
&nbsp;				0x30000, 0x30000, 0xfc030000, 0x80000, 0x40000, 0xc0000, 0x8, 0x1000000, 0x0, 0xb00000, 0x1000000, 0x0,
&nbsp;				0x0, 0x0, 0x0, 0x1000000, 0x1000000, 0x1000000, 0x0, 0x0, 0xb00000, 0x8, 0x400000, 0x0, 0xfc000000,
&nbsp;				0x80, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
&nbsp;				0x1, 0x0, 0x1, 0x1, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
&nbsp;				0x0, 0x0, 0xfc000000, 0x0, 0x0, 0x4000000, 0x4000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0xfc000000, 0xfc000000,
&nbsp;				0x0, 0x0, 0x80, 0xfc000000, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x0, 0xfc000000, 0x40000000, 0x0,
&nbsp;				0xb0000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
&nbsp;				0x0, 0x0, 0x200800, 0x200000, 0x200000, 0x0, 0x200000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
&nbsp;				0x0, 0x0, 0x0, 0x800, 0x0, 0x0, 0x0, 0x0, };
&nbsp;	}
&nbsp;
&nbsp;	private static void jj_la1_init_2() {
<b class="fc">&nbsp;		jj_la1_2 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x30000000, 0x30000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,</b>
&nbsp;				0x30000000, 0x3000000, 0x0, 0x0, 0x30000000, 0x0, 0x0, 0x0, 0x0, 0x30000000, 0x0, 0x0, 0x0, 0x0, 0x0,
&nbsp;				0x30000000, 0x0, 0x43000000, 0x0, 0x0, 0x0, 0x43000000, 0x0, 0x43000000, 0x0, 0x0, 0x0, 0x0, 0x80803fff,
&nbsp;				0x80803fff, 0x0, 0x80803fff, 0x0, 0x0, 0x80803fff, 0x0, 0x0, 0x0, 0x0, 0x7000000, 0x0, 0x28000000,
&nbsp;				0x4000000, 0x0, 0x3000000, 0x0, 0x3000000, 0x4000000, 0x7000000, 0x4000000, 0x0, 0x0, 0x28000000, 0x0,
&nbsp;				0x0, 0x0, 0x80803fff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3000000, 0x0, 0x0, 0x0, 0x0, 0x3000000, 0x0, 0x0,
&nbsp;				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3000000, 0x3000000,
&nbsp;				0x3000000, 0x3000000, 0x3000000, 0x0, 0x0, 0x3000000, 0x3000000, 0x0, 0x3000000, 0x0, 0x3000000,
&nbsp;				0x83bfbfff, 0x0, 0x0, 0x4000, 0x4000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x83bfbfff, 0x80803fff, 0x33f8000,
&nbsp;				0x3f8000, 0x0, 0x83bfbfff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80803fff, 0x80800000, 0x0, 0x1fbc, 0x0,
&nbsp;				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
&nbsp;				0x0, 0x0, 0x0, 0x3000000, 0x0, 0x0, 0x3000000, 0x3000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
&nbsp;				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, };
&nbsp;	}
&nbsp;
&nbsp;	private static void jj_la1_init_3() {
<b class="fc">&nbsp;		jj_la1_3 = new int[] { 0x0, 0x80000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,</b>
&nbsp;				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
&nbsp;				0x0, 0x0, 0x0, 0x0, 0x0, 0x7fffffff, 0x7fffffff, 0x0, 0x7fffffff, 0x0, 0x0, 0x7fffffff, 0x0, 0x0, 0x0,
&nbsp;				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7fffffff,
&nbsp;				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
&nbsp;				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
&nbsp;				0x0, 0x7fffffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7fffffff, 0x7fffffff, 0x0, 0x0, 0x0,
&nbsp;				0x7fffffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7fffffff, 0x7ff, 0xf800, 0x0, 0x1ff0000, 0x7e000000,
&nbsp;				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
&nbsp;				0x0, 0x0, 0x0, 0x0, 0x0, 0x80000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
&nbsp;				0x0, };
&nbsp;	}
&nbsp;
&nbsp;	private static void jj_la1_init_4() {
<b class="fc">&nbsp;		jj_la1_4 = new int[] { 0x0, 0x37f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x300000, 0x300000, 0x300000, 0x0,</b>
&nbsp;				0x0, 0x3fbf0000, 0x0, 0x0, 0x0, 0x370000, 0x370000, 0x370000, 0x0, 0x0, 0x0, 0x70800, 0x0, 0x300000,
&nbsp;				0x0, 0x0, 0x300000, 0x3f870000, 0x300000, 0x0, 0x0, 0x3f870000, 0x0, 0x3f870000, 0x0, 0x0, 0x0, 0x0,
&nbsp;				0x370000, 0x370000, 0x0, 0x370000, 0x0, 0x0, 0x370000, 0x0, 0x0, 0x0, 0x0, 0x3fbf0000, 0x0, 0x0, 0x0,
&nbsp;				0x0, 0x3fbf0000, 0x0, 0x3fbf0000, 0x0, 0x3fbf0000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x400, 0x70000, 0x0,
&nbsp;				0x0, 0x0, 0x0, 0x0, 0x370000, 0x3fbf0000, 0x370000, 0x0, 0x0, 0x370000, 0x3fbf0000, 0x370000, 0x370000,
&nbsp;				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x70000, 0x0, 0x70000, 0x70000, 0x70000, 0x70000, 0x0, 0x370000, 0x0, 0x0,
&nbsp;				0x3fbf0000, 0x3fbf0000, 0x3fbf0000, 0x3fbf0000, 0x3fbf0000, 0x370000, 0x300000, 0x3f8f0000, 0x3fbf0000,
&nbsp;				0x370000, 0x3fbf0000, 0x70000, 0x3f870000, 0x3fb70000, 0x0, 0x0, 0x0, 0x0, 0x1b000000, 0x1b000000, 0x0,
&nbsp;				0x0, 0x0, 0x3fb70000, 0x0, 0x3fb70000, 0x0, 0x0, 0x3fb70000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
&nbsp;				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x400000, 0x400000, 0x3f800000, 0x24800000, 0x9000000,
&nbsp;				0x12000000, 0x0, 0x0, 0x0, 0x0, 0x70000, 0x60000, 0x80000, 0x1800, 0x0, 0x70800, 0x3fbf0000, 0x0, 0x0,
&nbsp;				0x3fbf0000, 0x3fbf0000, 0x3f, 0x340, 0x400, 0x2000, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x0,
&nbsp;				0x200, 0x40, 0x140, 0x8000, };
&nbsp;	}
&nbsp;
&nbsp;	private static void jj_la1_init_5() {
<b class="fc">&nbsp;		jj_la1_5 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40000fc,</b>
&nbsp;				0x0, 0x0, 0x0, 0x4000000, 0x4000000, 0x4000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40000fc,
&nbsp;				0x0, 0x0, 0x0, 0x40000fc, 0x0, 0x40000fc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
&nbsp;				0x0, 0x0, 0x0, 0x40000fc, 0x0, 0x0, 0x0, 0x0, 0x40000fc, 0x0, 0x40000fc, 0x0, 0x40000fc, 0x0, 0x0, 0x0,
&nbsp;				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40000fc, 0x0, 0x0, 0x0, 0x0, 0x40000fc, 0x0,
&nbsp;				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40000fc,
&nbsp;				0x40000fc, 0x40000fc, 0x40000fc, 0x40000fc, 0x0, 0x0, 0x40000fc, 0x40000fc, 0x0, 0x40000fc, 0x4000000,
&nbsp;				0x40000fc, 0x40000fc, 0x0, 0x0, 0x0, 0x0, 0xc, 0xc, 0x0, 0x0, 0x0, 0xfc, 0x0, 0xfc, 0x0, 0x0, 0x40000fc,
&nbsp;				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc,
&nbsp;				0x0, 0x4, 0x8, 0x0, 0x30, 0xc0, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40000fc, 0x0, 0x0, 0x40000fc,
&nbsp;				0x40000fc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, };
&nbsp;	}
&nbsp;
<b class="fc">&nbsp;	final private JJCalls[] jj_2_rtns = new JJCalls[7];</b>
<b class="fc">&nbsp;	private boolean jj_rescan = false;</b>
<b class="fc">&nbsp;	private int jj_gc = 0;</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Constructor with user supplied CharStream.
&nbsp;	 */
<b class="fc">&nbsp;	public SyntaxTreeBuilder(CharStream stream) {</b>
<b class="fc">&nbsp;		token_source = new SyntaxTreeBuilderTokenManager(stream);</b>
<b class="fc">&nbsp;		token = new Token();</b>
<b class="fc">&nbsp;		jj_ntk = -1;</b>
<b class="fc">&nbsp;		jj_gen = 0;</b>
<b class="fc">&nbsp;		for (int i = 0; i &lt; 184; i++) {</b>
<b class="fc">&nbsp;			jj_la1[i] = -1;</b>
&nbsp;		}
<b class="fc">&nbsp;		for (int i = 0; i &lt; jj_2_rtns.length; i++) {</b>
<b class="fc">&nbsp;			jj_2_rtns[i] = new JJCalls();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Reinitialise.
&nbsp;	 */
&nbsp;	public void ReInit(CharStream stream) {
<b class="nc">&nbsp;		token_source.ReInit(stream);</b>
<b class="nc">&nbsp;		token = new Token();</b>
<b class="nc">&nbsp;		jj_ntk = -1;</b>
<b class="nc">&nbsp;		jjtree.reset();</b>
<b class="nc">&nbsp;		jj_gen = 0;</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; 184; i++) {</b>
<b class="nc">&nbsp;			jj_la1[i] = -1;</b>
&nbsp;		}
<b class="nc">&nbsp;		for (int i = 0; i &lt; jj_2_rtns.length; i++) {</b>
<b class="nc">&nbsp;			jj_2_rtns[i] = new JJCalls();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Constructor with generated Token Manager.
&nbsp;	 */
<b class="nc">&nbsp;	public SyntaxTreeBuilder(SyntaxTreeBuilderTokenManager tm) {</b>
<b class="nc">&nbsp;		token_source = tm;</b>
<b class="nc">&nbsp;		token = new Token();</b>
<b class="nc">&nbsp;		jj_ntk = -1;</b>
<b class="nc">&nbsp;		jj_gen = 0;</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; 184; i++) {</b>
<b class="nc">&nbsp;			jj_la1[i] = -1;</b>
&nbsp;		}
<b class="nc">&nbsp;		for (int i = 0; i &lt; jj_2_rtns.length; i++) {</b>
<b class="nc">&nbsp;			jj_2_rtns[i] = new JJCalls();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Reinitialise.
&nbsp;	 */
&nbsp;	public void ReInit(SyntaxTreeBuilderTokenManager tm) {
<b class="nc">&nbsp;		token_source = tm;</b>
<b class="nc">&nbsp;		token = new Token();</b>
<b class="nc">&nbsp;		jj_ntk = -1;</b>
<b class="nc">&nbsp;		jjtree.reset();</b>
<b class="nc">&nbsp;		jj_gen = 0;</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; 184; i++) {</b>
<b class="nc">&nbsp;			jj_la1[i] = -1;</b>
&nbsp;		}
<b class="nc">&nbsp;		for (int i = 0; i &lt; jj_2_rtns.length; i++) {</b>
<b class="nc">&nbsp;			jj_2_rtns[i] = new JJCalls();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private Token jj_consume_token(int kind) throws ParseException {
&nbsp;		Token oldToken;
<b class="fc">&nbsp;		if ((oldToken = token).next != null) {</b>
<b class="fc">&nbsp;			token = token.next;</b>
&nbsp;		} else {
<b class="fc">&nbsp;			token = token.next = token_source.getNextToken();</b>
&nbsp;		}
<b class="fc">&nbsp;		jj_ntk = -1;</b>
<b class="pc">&nbsp;		if (token.kind == kind) {</b>
<b class="fc">&nbsp;			jj_gen++;</b>
<b class="fc">&nbsp;			if (++jj_gc &gt; 100) {</b>
<b class="fc">&nbsp;				jj_gc = 0;</b>
<b class="fc">&nbsp;				for (int i = 0; i &lt; jj_2_rtns.length; i++) {</b>
<b class="fc">&nbsp;					JJCalls c = jj_2_rtns[i];</b>
<b class="fc">&nbsp;					while (c != null) {</b>
<b class="fc">&nbsp;						if (c.gen &lt; jj_gen) {</b>
<b class="fc">&nbsp;							c.first = null;</b>
&nbsp;						}
<b class="fc">&nbsp;						c = c.next;</b>
&nbsp;					}
&nbsp;				}
&nbsp;			}
<b class="fc">&nbsp;			return token;</b>
&nbsp;		}
<b class="nc">&nbsp;		token = oldToken;</b>
<b class="nc">&nbsp;		jj_kind = kind;</b>
<b class="nc">&nbsp;		throw generateParseException();</b>
&nbsp;	}
&nbsp;
<b class="fc">&nbsp;	static private final class LookaheadSuccess extends java.lang.Error {</b>
&nbsp;		@Override
&nbsp;		public Throwable fillInStackTrace() {
<b class="fc">&nbsp;			return this;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
<b class="fc">&nbsp;	static private final LookaheadSuccess jj_ls = new LookaheadSuccess();</b>
&nbsp;
&nbsp;	private boolean jj_scan_token(int kind) {
<b class="fc">&nbsp;		if (jj_scanpos == jj_lastpos) {</b>
<b class="fc">&nbsp;			jj_la--;</b>
<b class="fc">&nbsp;			if (jj_scanpos.next == null) {</b>
<b class="fc">&nbsp;				jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();</b>
&nbsp;			} else {
<b class="fc">&nbsp;				jj_lastpos = jj_scanpos = jj_scanpos.next;</b>
&nbsp;			}
&nbsp;		} else {
<b class="fc">&nbsp;			jj_scanpos = jj_scanpos.next;</b>
&nbsp;		}
<b class="pc">&nbsp;		if (jj_rescan) {</b>
<b class="nc">&nbsp;			int i = 0;</b>
<b class="nc">&nbsp;			Token tok = token;</b>
<b class="nc">&nbsp;			while (tok != null &amp;&amp; tok != jj_scanpos) {</b>
<b class="nc">&nbsp;				i++;</b>
<b class="nc">&nbsp;				tok = tok.next;</b>
&nbsp;			}
<b class="nc">&nbsp;			if (tok != null) {</b>
<b class="nc">&nbsp;				jj_add_error_token(kind, i);</b>
&nbsp;			}
&nbsp;		}
<b class="fc">&nbsp;		if (jj_scanpos.kind != kind) {</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;		}
<b class="pc">&nbsp;		if (jj_la == 0 &amp;&amp; jj_scanpos == jj_lastpos) {</b>
<b class="fc">&nbsp;			throw jj_ls;</b>
&nbsp;		}
<b class="fc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Get the next Token.
&nbsp;	 */
&nbsp;	final public Token getNextToken() {
<b class="pc">&nbsp;		if (token.next != null) {</b>
<b class="fc">&nbsp;			token = token.next;</b>
&nbsp;		} else {
<b class="nc">&nbsp;			token = token.next = token_source.getNextToken();</b>
&nbsp;		}
<b class="fc">&nbsp;		jj_ntk = -1;</b>
<b class="fc">&nbsp;		jj_gen++;</b>
<b class="fc">&nbsp;		return token;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Get the specific Token.
&nbsp;	 */
&nbsp;	final public Token getToken(int index) {
<b class="fc">&nbsp;		Token t = token;</b>
<b class="fc">&nbsp;		for (int i = 0; i &lt; index; i++) {</b>
<b class="pc">&nbsp;			if (t.next != null) {</b>
<b class="nc">&nbsp;				t = t.next;</b>
&nbsp;			} else {
<b class="fc">&nbsp;				t = t.next = token_source.getNextToken();</b>
&nbsp;			}
&nbsp;		}
<b class="fc">&nbsp;		return t;</b>
&nbsp;	}
&nbsp;
&nbsp;	private int jj_ntk_f() {
<b class="fc">&nbsp;		if ((jj_nt = token.next) == null) {</b>
<b class="fc">&nbsp;			return (jj_ntk = (token.next = token_source.getNextToken()).kind);</b>
&nbsp;		} else {
<b class="fc">&nbsp;			return (jj_ntk = jj_nt.kind);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
<b class="fc">&nbsp;	private final java.util.List&lt;int[]&gt; jj_expentries = new java.util.ArrayList&lt;&gt;();</b>
&nbsp;	private int[] jj_expentry;
<b class="fc">&nbsp;	private int jj_kind = -1;</b>
<b class="fc">&nbsp;	private final int[] jj_lasttokens = new int[100];</b>
&nbsp;	private int jj_endpos;
&nbsp;
&nbsp;	private void jj_add_error_token(int kind, int pos) {
<b class="nc">&nbsp;		if (pos &gt;= 100) {</b>
&nbsp;			return;
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (pos == jj_endpos + 1) {</b>
<b class="nc">&nbsp;			jj_lasttokens[jj_endpos++] = kind;</b>
<b class="nc">&nbsp;		} else if (jj_endpos != 0) {</b>
<b class="nc">&nbsp;			jj_expentry = new int[jj_endpos];</b>
&nbsp;
<b class="nc">&nbsp;			System.arraycopy(jj_lasttokens, 0, jj_expentry, 0, jj_endpos);</b>
<b class="nc">&nbsp;			boolean exists = false;</b>
<b class="nc">&nbsp;			for (int[] jjExpentry : jj_expentries) {</b>
<b class="nc">&nbsp;				exists = true;</b>
<b class="nc">&nbsp;				if (jjExpentry.length == jj_expentry.length) {</b>
<b class="nc">&nbsp;					for (int i = 0; i &lt; jj_expentry.length; i++) {</b>
<b class="nc">&nbsp;						if (jjExpentry[i] != jj_expentry[i]) {</b>
<b class="nc">&nbsp;							exists = false;</b>
<b class="nc">&nbsp;							break;</b>
&nbsp;						}
&nbsp;					}
<b class="nc">&nbsp;					if (exists) {</b>
<b class="nc">&nbsp;						break;</b>
&nbsp;					}
&nbsp;				}
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			if (!exists) {</b>
<b class="nc">&nbsp;				jj_expentries.add(jj_expentry);</b>
&nbsp;			}
<b class="nc">&nbsp;			if (pos != 0) {</b>
<b class="nc">&nbsp;				jj_lasttokens[(jj_endpos = pos) - 1] = kind;</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Generate ParseException.
&nbsp;	 */
&nbsp;	public ParseException generateParseException() {
<b class="nc">&nbsp;		jj_expentries.clear();</b>
<b class="nc">&nbsp;		boolean[] la1tokens = new boolean[188];</b>
<b class="nc">&nbsp;		if (jj_kind &gt;= 0) {</b>
<b class="nc">&nbsp;			la1tokens[jj_kind] = true;</b>
<b class="nc">&nbsp;			jj_kind = -1;</b>
&nbsp;		}
<b class="nc">&nbsp;		for (int i = 0; i &lt; 184; i++) {</b>
<b class="nc">&nbsp;			if (jj_la1[i] == jj_gen) {</b>
<b class="nc">&nbsp;				for (int j = 0; j &lt; 32; j++) {</b>
<b class="nc">&nbsp;					if ((jj_la1_0[i] &amp; (1 &lt;&lt; j)) != 0) {</b>
<b class="nc">&nbsp;						la1tokens[j] = true;</b>
&nbsp;					}
<b class="nc">&nbsp;					if ((jj_la1_1[i] &amp; (1 &lt;&lt; j)) != 0) {</b>
<b class="nc">&nbsp;						la1tokens[32 + j] = true;</b>
&nbsp;					}
<b class="nc">&nbsp;					if ((jj_la1_2[i] &amp; (1 &lt;&lt; j)) != 0) {</b>
<b class="nc">&nbsp;						la1tokens[64 + j] = true;</b>
&nbsp;					}
<b class="nc">&nbsp;					if ((jj_la1_3[i] &amp; (1 &lt;&lt; j)) != 0) {</b>
<b class="nc">&nbsp;						la1tokens[96 + j] = true;</b>
&nbsp;					}
<b class="nc">&nbsp;					if ((jj_la1_4[i] &amp; (1 &lt;&lt; j)) != 0) {</b>
<b class="nc">&nbsp;						la1tokens[128 + j] = true;</b>
&nbsp;					}
<b class="nc">&nbsp;					if ((jj_la1_5[i] &amp; (1 &lt;&lt; j)) != 0) {</b>
<b class="nc">&nbsp;						la1tokens[160 + j] = true;</b>
&nbsp;					}
&nbsp;				}
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		for (int i = 0; i &lt; 188; i++) {</b>
<b class="nc">&nbsp;			if (la1tokens[i]) {</b>
<b class="nc">&nbsp;				jj_expentry = new int[1];</b>
<b class="nc">&nbsp;				jj_expentry[0] = i;</b>
<b class="nc">&nbsp;				jj_expentries.add(jj_expentry);</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		jj_endpos = 0;</b>
<b class="nc">&nbsp;		jj_rescan_token();</b>
<b class="nc">&nbsp;		jj_add_error_token(0, 0);</b>
<b class="nc">&nbsp;		int[][] exptokseq = new int[jj_expentries.size()][];</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; jj_expentries.size(); i++) {</b>
<b class="nc">&nbsp;			exptokseq[i] = jj_expentries.get(i);</b>
&nbsp;		}
<b class="nc">&nbsp;		return new ParseException(token, exptokseq, tokenImage);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean trace_enabled;
&nbsp;
&nbsp;	/**
&nbsp;	 * Trace enabled.
&nbsp;	 */
&nbsp;	final public boolean trace_enabled() {
<b class="nc">&nbsp;		return trace_enabled;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Enable tracing.
&nbsp;	 */
&nbsp;	final public void enable_tracing() {
<b class="nc">&nbsp;	}</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Disable tracing.
&nbsp;	 */
&nbsp;	final public void disable_tracing() {
<b class="nc">&nbsp;	}</b>
&nbsp;
&nbsp;	private void jj_rescan_token() {
<b class="nc">&nbsp;		jj_rescan = true;</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; 7; i++) {</b>
&nbsp;			try {
<b class="nc">&nbsp;				JJCalls p = jj_2_rtns[i];</b>
&nbsp;
&nbsp;				do {
<b class="nc">&nbsp;					if (p.gen &gt; jj_gen) {</b>
<b class="nc">&nbsp;						jj_la = p.arg;</b>
<b class="nc">&nbsp;						jj_lastpos = jj_scanpos = p.first;</b>
<b class="nc">&nbsp;						switch (i) {</b>
&nbsp;						case 0:
<b class="nc">&nbsp;							jj_3_1();</b>
<b class="nc">&nbsp;							break;</b>
&nbsp;						case 1:
<b class="nc">&nbsp;							jj_3_2();</b>
<b class="nc">&nbsp;							break;</b>
&nbsp;						case 2:
<b class="nc">&nbsp;							jj_3_3();</b>
<b class="nc">&nbsp;							break;</b>
&nbsp;						case 3:
<b class="nc">&nbsp;							jj_3_4();</b>
<b class="nc">&nbsp;							break;</b>
&nbsp;						case 4:
<b class="nc">&nbsp;							jj_3_5();</b>
<b class="nc">&nbsp;							break;</b>
&nbsp;						case 5:
<b class="nc">&nbsp;							jj_3_6();</b>
<b class="nc">&nbsp;							break;</b>
&nbsp;						case 6:
<b class="nc">&nbsp;							jj_3_7();</b>
&nbsp;							break;
&nbsp;						}
&nbsp;					}
<b class="nc">&nbsp;					p = p.next;</b>
<b class="nc">&nbsp;				} while (p != null);</b>
&nbsp;
<b class="nc">&nbsp;			} catch (LookaheadSuccess ignored) {</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
<b class="nc">&nbsp;		jj_rescan = false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private void jj_save(int index, int xla) {
<b class="fc">&nbsp;		JJCalls p = jj_2_rtns[index];</b>
<b class="pc">&nbsp;		while (p.gen &gt; jj_gen) {</b>
<b class="nc">&nbsp;			if (p.next == null) {</b>
<b class="nc">&nbsp;				p = p.next = new JJCalls();</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
<b class="nc">&nbsp;			p = p.next;</b>
&nbsp;		}
<b class="fc">&nbsp;		p.gen = jj_gen + xla - jj_la;</b>
<b class="fc">&nbsp;		p.first = token;</b>
<b class="fc">&nbsp;		p.arg = xla;</b>
&nbsp;	}
&nbsp;
<b class="fc">&nbsp;	static final class JJCalls {</b>
&nbsp;		int gen;
&nbsp;		Token first;
&nbsp;		int arg;
&nbsp;		JJCalls next;
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:20</div>
</div>
</body>
</html>
