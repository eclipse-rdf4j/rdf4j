


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > ParsedURI</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.common.net</a>
</div>

<h1>Coverage Summary for Class: ParsedURI (org.eclipse.rdf4j.common.net)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ParsedURI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/27)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/138)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/193)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;
&nbsp;package org.eclipse.rdf4j.common.net;
&nbsp;
&nbsp;import java.util.LinkedList;
&nbsp;import java.util.StringTokenizer;
&nbsp;
&nbsp;/**
&nbsp; * A replacement for Java&#39;s own URI: java.net.URI. Java&#39;s implementation is quite buggy in that it doesn&#39;t resolve
&nbsp; * relative URIs correctly.
&nbsp; * &lt;p&gt;
&nbsp; * Note: this implementation is not guaranteed to handle ipv6 addresses correctly (yet).
&nbsp; *
&nbsp; * @deprecated use {@link ParsedIRI} instead
&nbsp; */
&nbsp;@Deprecated
&nbsp;public class ParsedURI implements java.lang.Cloneable {
&nbsp;
&nbsp;	/*
&nbsp;	 * // Tesing method public static void main(String[] args) throws Exception { URI baseURI = new URI(args[0]);
&nbsp;	 * baseURI.normalize(); URI uri = null; for (int i = 0; i &lt; 100; i++) { uri = baseURI.resolve(args[1]); } try {
&nbsp;	 * Thread.sleep(1000); } catch (Exception e) {} long startTime = System.currentTimeMillis(); for (int i = 0; i &lt;
&nbsp;	 * 100; i++) { uri = baseURI.resolve(args[1]); } long endTime = System.currentTimeMillis();
&nbsp;	 * System.out.println(args[0] + &quot; was parsed as:&quot;); System.out.println(&quot;scheme = &quot; + uri.getScheme());
&nbsp;	 * System.out.println(&quot;schemeSpecificPart = &quot; + uri.getSchemeSpecificPart()); System.out.println(&quot;authority = &quot; +
&nbsp;	 * uri.getAuthority()); System.out.println(&quot;path = &quot; + uri.getPath()); System.out.println(&quot;query = &quot; +
&nbsp;	 * uri.getQuery()); System.out.println(&quot;fragment = &quot; + uri.getFragment()); System.out.println(&quot;full URI = &quot; +
&nbsp;	 * uri.toString()); System.out.println(&quot; parsed 100 times in &quot; + (endTime-startTime) + &quot;ms&quot;); }
&nbsp;	 */
&nbsp;
&nbsp;	/*-----------*
&nbsp;	 * Variables *
&nbsp;	 *-----------*/
&nbsp;
&nbsp;	// For all URIs:
&nbsp;	private String _scheme;
&nbsp;
&nbsp;	private String _schemeSpecificPart;
&nbsp;
&nbsp;	private String _fragment;
&nbsp;
&nbsp;	// For hierarchical URIs:
&nbsp;	private String _authority;
&nbsp;
&nbsp;	private String _path;
&nbsp;
&nbsp;	private String _query;
&nbsp;
&nbsp;	/*--------------*
&nbsp;	 * Constructors *
&nbsp;	 *--------------*/
&nbsp;
<b class="nc">&nbsp;	public ParsedURI(String uriSpec) {</b>
<b class="nc">&nbsp;		_parse(uriSpec);</b>
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public ParsedURI(String scheme, String schemeSpecificPart, String fragment) {</b>
<b class="nc">&nbsp;		_scheme = scheme;</b>
<b class="nc">&nbsp;		_schemeSpecificPart = schemeSpecificPart;</b>
<b class="nc">&nbsp;		_fragment = fragment;</b>
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public ParsedURI(String scheme, String authority, String path, String query, String fragment) {</b>
<b class="nc">&nbsp;		_scheme = scheme;</b>
<b class="nc">&nbsp;		_authority = authority;</b>
<b class="nc">&nbsp;		_path = path;</b>
<b class="nc">&nbsp;		_query = query;</b>
<b class="nc">&nbsp;		_fragment = fragment;</b>
&nbsp;	}
&nbsp;
&nbsp;	/*-----------------------*
&nbsp;	 * Public access methods *
&nbsp;	 *-----------------------*/
&nbsp;
&nbsp;	public boolean isHierarchical() {
<b class="nc">&nbsp;		return _path != null;</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean isOpaque() {
<b class="nc">&nbsp;		return _path == null;</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean isAbsolute() {
<b class="nc">&nbsp;		return _scheme != null;</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean isRelative() {
<b class="nc">&nbsp;		return _scheme == null;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Checks whether this URI is a relative URI that references itself (i.e. it only contains an anchor).
&nbsp;	 */
&nbsp;	public boolean isSelfReference() {
<b class="nc">&nbsp;		return _scheme == null &amp;&amp; _authority == null &amp;&amp; _query == null &amp;&amp; _path.length() == 0;</b>
&nbsp;	}
&nbsp;
&nbsp;	public String getScheme() {
<b class="nc">&nbsp;		return _scheme;</b>
&nbsp;	}
&nbsp;
&nbsp;	public String getSchemeSpecificPart() {
<b class="nc">&nbsp;		return _schemeSpecificPart;</b>
&nbsp;	}
&nbsp;
&nbsp;	public String getAuthority() {
<b class="nc">&nbsp;		return _authority;</b>
&nbsp;	}
&nbsp;
&nbsp;	public String getPath() {
<b class="nc">&nbsp;		return _path;</b>
&nbsp;	}
&nbsp;
&nbsp;	public String getQuery() {
<b class="nc">&nbsp;		return _query;</b>
&nbsp;	}
&nbsp;
&nbsp;	public String getFragment() {
<b class="nc">&nbsp;		return _fragment;</b>
&nbsp;	}
&nbsp;
&nbsp;	/*------------------------------*
&nbsp;	 * Methods for normalizing URIs *
&nbsp;	 *------------------------------*/
&nbsp;
&nbsp;	/**
&nbsp;	 * Normalizes the path of this URI if it has one. Normalizing a path means that any unnecessary &#39;.&#39; and &#39;..&#39;
&nbsp;	 * segments are removed. For example, the URI &lt;var&gt;http://server.com/a/b/../c/./d&lt;/var&gt; would be normalized to
&nbsp;	 * &lt;var&gt;http://server.com/a/c/d&lt;/var&gt;. A URI doens&#39;t have a path if it is opaque.
&nbsp;	 */
&nbsp;	public void normalize() {
<b class="nc">&nbsp;		if (_path == null) {</b>
&nbsp;			return;
&nbsp;		}
&nbsp;
&nbsp;		// Remove any &#39;.&#39; segments:
&nbsp;
<b class="nc">&nbsp;		_path = _path.replace(&quot;/./&quot;, &quot;/&quot;);</b>
&nbsp;
<b class="nc">&nbsp;		if (_path.startsWith(&quot;./&quot;)) {</b>
&nbsp;			// Remove both characters
<b class="nc">&nbsp;			_path = _path.substring(2);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (_path.endsWith(&quot;/.&quot;)) {</b>
&nbsp;			// Remove only the last dot, not the slash!
<b class="nc">&nbsp;			_path = _path.substring(0, _path.length() - 1);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (_path.indexOf(&quot;/../&quot;) == -1 &amp;&amp; !_path.endsWith(&quot;/..&quot;)) {</b>
&nbsp;			// There are no &#39;..&#39; segments that can be removed. We&#39;re done and
&nbsp;			// don&#39;t have to execute the time-consuming code following this
&nbsp;			// if-statement
&nbsp;			return;
&nbsp;		}
&nbsp;
&nbsp;		// Split the path into its segments
&nbsp;
<b class="nc">&nbsp;		LinkedList&lt;String&gt; segments = new LinkedList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;		StringTokenizer st = new StringTokenizer(_path, &quot;/&quot;);</b>
&nbsp;
<b class="nc">&nbsp;		while (st.hasMoreTokens()) {</b>
<b class="nc">&nbsp;			segments.add(st.nextToken());</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		boolean lastSegmentRemoved = false;</b>
&nbsp;
&nbsp;		// Remove all unnecessary &#39;..&#39; segments
&nbsp;
<b class="nc">&nbsp;		int i = 1;</b>
<b class="nc">&nbsp;		while (i &lt; segments.size()) {</b>
<b class="nc">&nbsp;			String segment = segments.get(i);</b>
&nbsp;
<b class="nc">&nbsp;			if (segment.equals(&quot;..&quot;)) {</b>
<b class="nc">&nbsp;				String prevSegment = segments.get(i - 1);</b>
&nbsp;
<b class="nc">&nbsp;				if (prevSegment.equals(&quot;..&quot;)) {</b>
&nbsp;					// two consecutive &#39;..&#39; segments at position i-1 and i,
&nbsp;					// continue at i + 2
<b class="nc">&nbsp;					i += 2;</b>
&nbsp;				} else {
&nbsp;					// Bingo! Remove these two segments...
<b class="nc">&nbsp;					if (i == segments.size() - 1) {</b>
<b class="nc">&nbsp;						lastSegmentRemoved = true;</b>
&nbsp;					}
&nbsp;
<b class="nc">&nbsp;					segments.remove(i);</b>
<b class="nc">&nbsp;					segments.remove(i - 1);</b>
&nbsp;
&nbsp;					// ...and continue at position (i + 1 - 2) == (i - 1)...
&nbsp;
&nbsp;					// ...but only if i &gt; 1, position 0 does not need to be
&nbsp;					// checked.
&nbsp;
<b class="nc">&nbsp;					if (i &gt; 1) {</b>
<b class="nc">&nbsp;						i--;</b>
&nbsp;					}
&nbsp;				}
<b class="nc">&nbsp;			} else {</b>
&nbsp;				// Not a &#39;..&#39; segment, check next
<b class="nc">&nbsp;				i++;</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;
&nbsp;		// Construct the normalized path
&nbsp;
<b class="nc">&nbsp;		StringBuilder newPath = new StringBuilder(_path.length());</b>
&nbsp;
<b class="nc">&nbsp;		if (_path.startsWith(&quot;/&quot;)) {</b>
<b class="nc">&nbsp;			newPath.append(&#39;/&#39;);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		int segmentCount = segments.size();</b>
<b class="nc">&nbsp;		for (i = 0; i &lt; segmentCount - 1; i++) {</b>
<b class="nc">&nbsp;			newPath.append(segments.get(i));</b>
<b class="nc">&nbsp;			newPath.append(&#39;/&#39;);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (segmentCount &gt; 0) {</b>
<b class="nc">&nbsp;			String lastSegment = segments.get(segmentCount - 1);</b>
<b class="nc">&nbsp;			newPath.append(lastSegment);</b>
&nbsp;
<b class="nc">&nbsp;			if (_path.endsWith(&quot;/&quot;) || lastSegmentRemoved) {</b>
<b class="nc">&nbsp;				newPath.append(&#39;/&#39;);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		_path = newPath.toString();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Resolves a relative URI using this URI as the base URI.
&nbsp;	 */
&nbsp;	public ParsedURI resolve(String relURISpec) {
&nbsp;		// This algorithm is based on the algorithm specified in chapter 5 of
&nbsp;		// RFC 2396: URI Generic Syntax. See http://www.ietf.org/rfc/rfc2396.txt
&nbsp;
&nbsp;		// RFC, step 1:
<b class="nc">&nbsp;		ParsedURI relURI = new ParsedURI(relURISpec);</b>
&nbsp;
<b class="nc">&nbsp;		return this.resolve(relURI);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Resolves a relative URI using this URI as the base URI.
&nbsp;	 */
&nbsp;	public ParsedURI resolve(ParsedURI relURI) {
&nbsp;		// This algorithm is based on the algorithm specified in chapter 5 of
&nbsp;		// RFC 2396: URI Generic Syntax. See http://www.ietf.org/rfc/rfc2396.txt
&nbsp;
&nbsp;		// RFC, step 3:
<b class="nc">&nbsp;		if (relURI.isAbsolute()) {</b>
<b class="nc">&nbsp;			return relURI;</b>
&nbsp;		}
&nbsp;
&nbsp;		// relURI._scheme == null
&nbsp;
&nbsp;		// RFC, step 2:
<b class="nc">&nbsp;		if (relURI._authority == null &amp;&amp; relURI._query == null &amp;&amp; relURI._path.length() == 0) {</b>
&nbsp;			// Reference to this URI
<b class="nc">&nbsp;			ParsedURI result = (ParsedURI) this.clone();</b>
&nbsp;
&nbsp;			// Inherit any fragment identifier from relURI
<b class="nc">&nbsp;			result._fragment = relURI._fragment;</b>
&nbsp;
<b class="nc">&nbsp;			return result;</b>
&nbsp;		}
&nbsp;
&nbsp;		// We can start combining the URIs
&nbsp;		String scheme, authority, path, query, fragment;
<b class="nc">&nbsp;		boolean normalizeURI = false;</b>
&nbsp;
<b class="nc">&nbsp;		scheme = this._scheme;</b>
<b class="nc">&nbsp;		query = relURI._query;</b>
<b class="nc">&nbsp;		fragment = relURI._fragment;</b>
&nbsp;
&nbsp;		// RFC, step 4:
<b class="nc">&nbsp;		if (relURI._authority != null) {</b>
<b class="nc">&nbsp;			authority = relURI._authority;</b>
<b class="nc">&nbsp;			path = relURI._path;</b>
&nbsp;		} else {
<b class="nc">&nbsp;			authority = this._authority;</b>
&nbsp;
&nbsp;			// RFC, step 5:
<b class="nc">&nbsp;			if (relURI._path.startsWith(&quot;/&quot;)) {</b>
<b class="nc">&nbsp;				path = relURI._path;</b>
<b class="nc">&nbsp;			} else if (relURI._path.length() == 0) {</b>
<b class="nc">&nbsp;				path = this._path;</b>
&nbsp;			} else {
&nbsp;				// RFC, step 6:
<b class="nc">&nbsp;				path = this._path;</b>
&nbsp;
<b class="nc">&nbsp;				if (path == null) {</b>
<b class="nc">&nbsp;					path = &quot;/&quot;;</b>
&nbsp;				} else {
<b class="nc">&nbsp;					if (!path.endsWith(&quot;/&quot;)) {</b>
&nbsp;						// Remove the last segment of the path. Note: if
&nbsp;						// lastSlashIdx is -1, the path will become empty,
&nbsp;						// which is fixed later.
<b class="nc">&nbsp;						int lastSlashIdx = path.lastIndexOf(&#39;/&#39;);</b>
<b class="nc">&nbsp;						path = path.substring(0, lastSlashIdx + 1);</b>
&nbsp;					}
&nbsp;
<b class="nc">&nbsp;					if (path.length() == 0) {</b>
&nbsp;						// No path means: start at root.
<b class="nc">&nbsp;						path = &quot;/&quot;;</b>
&nbsp;					}
&nbsp;				}
&nbsp;
&nbsp;				// Append the path of the relative URI
<b class="nc">&nbsp;				path += relURI._path;</b>
&nbsp;
&nbsp;				// Path needs to be normalized.
<b class="nc">&nbsp;				normalizeURI = true;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		ParsedURI result = new ParsedURI(scheme, authority, path, query, fragment);</b>
&nbsp;
<b class="nc">&nbsp;		if (normalizeURI) {</b>
<b class="nc">&nbsp;			result.normalize();</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return result;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public String toString() {
<b class="nc">&nbsp;		StringBuilder sb = new StringBuilder(64);</b>
&nbsp;
<b class="nc">&nbsp;		if (_scheme != null) {</b>
<b class="nc">&nbsp;			sb.append(_scheme);</b>
<b class="nc">&nbsp;			if (!isJarScheme(_scheme)) {</b>
<b class="nc">&nbsp;				sb.append(&#39;:&#39;);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (isOpaque()) {</b>
&nbsp;			// Opaque URI
<b class="nc">&nbsp;			if (_schemeSpecificPart != null) {</b>
<b class="nc">&nbsp;				sb.append(_schemeSpecificPart);</b>
&nbsp;			}
&nbsp;		} else {
&nbsp;			// Hierachical URI
<b class="nc">&nbsp;			if (_authority != null) {</b>
<b class="nc">&nbsp;				sb.append(&quot;//&quot;);</b>
<b class="nc">&nbsp;				sb.append(_authority);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			sb.append(_path);</b>
&nbsp;
<b class="nc">&nbsp;			if (_query != null) {</b>
<b class="nc">&nbsp;				sb.append(&#39;?&#39;);</b>
<b class="nc">&nbsp;				sb.append(_query);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (_fragment != null) {</b>
<b class="nc">&nbsp;			sb.append(&#39;#&#39;);</b>
<b class="nc">&nbsp;			sb.append(_fragment);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return sb.toString();</b>
&nbsp;	}
&nbsp;
&nbsp;	// Overrides Object.clone()
&nbsp;	@Override
&nbsp;	public Object clone() {
&nbsp;		try {
<b class="nc">&nbsp;			return super.clone();</b>
<b class="nc">&nbsp;		} catch (CloneNotSupportedException e) {</b>
<b class="nc">&nbsp;			throw new RuntimeException(e);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/*--------------------------*
&nbsp;	 * Methods for parsing URIs *
&nbsp;	 *--------------------------*/
&nbsp;
&nbsp;	private static boolean isJarScheme(String s) {
<b class="nc">&nbsp;		return (s.length() &gt; 4 &amp;&amp; s.substring(0, 4).equalsIgnoreCase(&quot;jar:&quot;));</b>
&nbsp;	}
&nbsp;
&nbsp;	private void _parse(String uri) {
<b class="nc">&nbsp;		if (isJarScheme(uri)) {</b>
&nbsp;			// uriString is e.g.
&nbsp;			// jar:http://www.foo.com/bar/baz.jar!/COM/foo/Quux.class
&nbsp;			// Treat the part up to and including the exclamation mark as the
&nbsp;			// scheme and
&nbsp;			// the rest as the path to enable &#39;correct&#39; resolving of relative URIs
<b class="nc">&nbsp;			int idx = uri.indexOf(&#39;!&#39;);</b>
<b class="nc">&nbsp;			if (idx != -1) {</b>
<b class="nc">&nbsp;				String scheme = uri.substring(0, idx + 1);</b>
<b class="nc">&nbsp;				String path = uri.substring(idx + 1);</b>
&nbsp;
<b class="nc">&nbsp;				_scheme = scheme;</b>
<b class="nc">&nbsp;				_authority = null;</b>
<b class="nc">&nbsp;				_path = path;</b>
<b class="nc">&nbsp;				_query = null;</b>
<b class="nc">&nbsp;				_fragment = null;</b>
&nbsp;
&nbsp;				return;
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (_parseScheme(uri)) {</b>
&nbsp;			// A scheme was found; _scheme and _schemeSpecificPart are now set
<b class="nc">&nbsp;			if (_schemeSpecificPart.startsWith(&quot;/&quot;)) {</b>
&nbsp;				// Hierachical URI
<b class="nc">&nbsp;				String rest = _schemeSpecificPart;</b>
<b class="nc">&nbsp;				rest = _parseAuthority(rest);</b>
<b class="nc">&nbsp;				rest = _parsePath(rest);</b>
<b class="nc">&nbsp;				rest = _parseQuery(rest);</b>
<b class="nc">&nbsp;				_parseFragment(rest);</b>
<b class="nc">&nbsp;			} else {</b>
&nbsp;				// Opaque URI
<b class="nc">&nbsp;				String rest = _schemeSpecificPart;</b>
<b class="nc">&nbsp;				rest = _parseOpaquePart(rest);</b>
<b class="nc">&nbsp;				_parseFragment(rest);</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		} else {
&nbsp;			// No scheme was found
<b class="nc">&nbsp;			String rest = uri;</b>
<b class="nc">&nbsp;			rest = _parseAuthority(rest);</b>
<b class="nc">&nbsp;			rest = _parsePath(rest);</b>
<b class="nc">&nbsp;			rest = _parseQuery(rest);</b>
<b class="nc">&nbsp;			_parseFragment(rest);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private boolean _parseScheme(String uri) {
&nbsp;		// Query cannot contain a &#39;:&#39;, &#39;/&#39;, &#39;?&#39; or &#39;#&#39; character
&nbsp;
&nbsp;		// Try to find the scheme in the URI
<b class="nc">&nbsp;		char c = 0;</b>
<b class="nc">&nbsp;		int i = 0;</b>
&nbsp;
<b class="nc">&nbsp;		for (; i &lt; uri.length(); i++) {</b>
<b class="nc">&nbsp;			c = uri.charAt(i);</b>
<b class="nc">&nbsp;			if (c == &#39;:&#39; || c == &#39;/&#39; || c == &#39;?&#39; || c == &#39;#&#39;) {</b>
&nbsp;				// c is equal to one of the illegal chars
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (c == &#39;:&#39; &amp;&amp; i &gt; 0) {</b>
&nbsp;			// We&#39;ve found a scheme
<b class="nc">&nbsp;			_scheme = uri.substring(0, i);</b>
<b class="nc">&nbsp;			_schemeSpecificPart = uri.substring(i + 1);</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;		}
&nbsp;
&nbsp;		// No scheme found, uri is relative
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private String _parseAuthority(String s) {
&nbsp;		// Query cannot contain a &#39;/&#39;, &#39;?&#39; or &#39;#&#39; character
&nbsp;
<b class="nc">&nbsp;		if (s.startsWith(&quot;//&quot;)) {</b>
&nbsp;			// Authority present, could be empty though.
<b class="nc">&nbsp;			int i = 2;</b>
<b class="nc">&nbsp;			for (; i &lt; s.length(); i++) {</b>
<b class="nc">&nbsp;				char c = s.charAt(i);</b>
<b class="nc">&nbsp;				if (c == &#39;/&#39; || c == &#39;?&#39; || c == &#39;#&#39;) {</b>
&nbsp;					// c is equal to one of the illegal chars
<b class="nc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			_authority = s.substring(2, i);</b>
<b class="nc">&nbsp;			return s.substring(i);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return s;</b>
&nbsp;	}
&nbsp;
&nbsp;	private String _parsePath(String s) {
&nbsp;		// Query cannot contain a &#39;?&#39; or &#39;#&#39; character
&nbsp;
<b class="nc">&nbsp;		int i = 0;</b>
<b class="nc">&nbsp;		for (; i &lt; s.length(); i++) {</b>
<b class="nc">&nbsp;			char c = s.charAt(i);</b>
<b class="nc">&nbsp;			if (c == &#39;?&#39; || c == &#39;#&#39;) {</b>
&nbsp;				// c is equal to one of the illegal chars
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		_path = s.substring(0, i);</b>
&nbsp;
<b class="nc">&nbsp;		return s.substring(i);</b>
&nbsp;	}
&nbsp;
&nbsp;	private String _parseQuery(String s) {
&nbsp;		// Query must start with a &#39;?&#39; and cannot contain a &#39;#&#39; character
&nbsp;
<b class="nc">&nbsp;		if (s.startsWith(&quot;?&quot;)) {</b>
<b class="nc">&nbsp;			int i = 1;</b>
<b class="nc">&nbsp;			for (; i &lt; s.length(); i++) {</b>
<b class="nc">&nbsp;				char c = s.charAt(i);</b>
<b class="nc">&nbsp;				if (c == &#39;#&#39;) {</b>
&nbsp;					// c is equal to one of the illegal chars
<b class="nc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			_query = s.substring(1, i);</b>
<b class="nc">&nbsp;			return s.substring(i);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			return s;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private String _parseOpaquePart(String s) {
&nbsp;		// Opaque part cannot contain a &#39;#&#39; character
&nbsp;
<b class="nc">&nbsp;		int i = 0;</b>
<b class="nc">&nbsp;		for (; i &lt; s.length(); i++) {</b>
<b class="nc">&nbsp;			char c = s.charAt(i);</b>
<b class="nc">&nbsp;			if (c == &#39;#&#39;) {</b>
&nbsp;				// c is equal to one of the illegal chars
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		_schemeSpecificPart = s.substring(0, i);</b>
&nbsp;
<b class="nc">&nbsp;		return s.substring(i);</b>
&nbsp;	}
&nbsp;
&nbsp;	private void _parseFragment(String s) {
&nbsp;		// Fragment must start with a &#39;#&#39;
<b class="nc">&nbsp;		if (s.startsWith(&quot;#&quot;)) {</b>
<b class="nc">&nbsp;			_fragment = s.substring(1);</b>
&nbsp;		}
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:20</div>
</div>
</body>
</html>
