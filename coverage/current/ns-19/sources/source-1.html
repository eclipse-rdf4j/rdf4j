


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > ParsedIRI</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.common.net</a>
</div>

<h1>Coverage Summary for Class: ParsedIRI (org.eclipse.rdf4j.common.net)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ParsedIRI</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    73.1%
  </span>
  <span class="absValue">
    (38/52)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    37.8%
  </span>
  <span class="absValue">
    (180/476)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    53.2%
  </span>
  <span class="absValue">
    (275/517)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2017 Eclipse RDF4J contributors, Aduna, and others.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;
&nbsp;package org.eclipse.rdf4j.common.net;
&nbsp;
&nbsp;import java.io.Serializable;
&nbsp;import java.net.IDN;
&nbsp;import java.net.URISyntaxException;
&nbsp;import java.net.URLDecoder;
&nbsp;import java.net.URLEncoder;
&nbsp;import java.nio.ByteBuffer;
&nbsp;import java.nio.CharBuffer;
&nbsp;import java.nio.charset.CharacterCodingException;
&nbsp;import java.nio.charset.CharsetEncoder;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.text.Normalizer;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Comparator;
&nbsp;import java.util.LinkedList;
&nbsp;import java.util.List;
&nbsp;
&nbsp;/**
&nbsp; * Represents an Internationalized Resource Identifier (IRI) reference.
&nbsp; * &lt;p&gt;
&nbsp; * Aside from some minor deviations noted below, an instance of this class represents a IRI reference as defined by
&nbsp; * &lt;a href=&quot;http://www.ietf.org/rfc/rfc3987.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;3987: Internationalized Resource Identifiers (IRI): IRI
&nbsp; * Syntax&lt;/i&gt;&lt;/a&gt;. This class provides constructors for creating IRI instances from their components or by parsing their
&nbsp; * string forms, methods for accessing the various components of an instance, and methods for normalizing, resolving,
&nbsp; * and relativizing IRI instances. Instances of this class are immutable.
&nbsp; * &lt;p&gt;
&nbsp; * An IRI instance has the following seven components in string form has the syntax &lt;blockquote&gt;
&nbsp; * [&lt;i&gt;scheme&lt;/i&gt;&lt;b&gt;{@code :}&lt;/b&gt;][&lt;b&gt;{@code //}&lt;/b&gt;[&lt;i&gt;user-info&lt;/i&gt;&lt;b&gt;{@code @}&lt;/b&gt;]&lt;i&gt;host&lt;/i&gt;[&lt;b&gt;{@code :}&lt;/b&gt;&lt;i&gt;port&lt;/i&gt;]][&lt;i&gt;path&lt;/i&gt;][&lt;b&gt;{@code ?}&lt;/b&gt;&lt;i&gt;query&lt;/i&gt;][&lt;b&gt;{@code #}&lt;/b&gt;&lt;i&gt;fragment&lt;/i&gt;]
&nbsp; * &lt;/blockquote&gt;
&nbsp; * &lt;p&gt;
&nbsp; * In a given instance any particular component is either &lt;i&gt;undefined&lt;/i&gt; or &lt;i&gt;defined&lt;/i&gt; with a distinct value.
&nbsp; * Undefined string components are represented by {@code null}, while undefined integer components are represented by
&nbsp; * {@code -1}. A string component may be defined to have the empty string as its value; this is not equivalent to that
&nbsp; * component being undefined.
&nbsp; * &lt;p&gt;
&nbsp; * Whether a particular component is or is not defined in an instance depends upon the type of the IRI being
&nbsp; * represented. An absolute IRI has a scheme component. An opaque IRI has a scheme, a scheme-specific part, and possibly
&nbsp; * a fragment, but has no other components. A hierarchical IRI always has a path (though it may be empty) and a
&nbsp; * scheme-specific-part (which at least contains the path), and may have any of the other components.
&nbsp; * &lt;h4&gt;IRIs, URIs, URLs, and URNs&lt;/h4&gt;
&nbsp; * &lt;p&gt;
&nbsp; * IRIs are meant to replace URIs in identifying resources for protocols, formats, and software components that use a
&nbsp; * UCS-based character repertoire.
&nbsp; * &lt;p&gt;
&nbsp; * Internationalized Resource Identifier (IRI) is a complement to the Uniform Resource Identifier (URI). An IRI is a
&nbsp; * sequence of characters from the Universal Character Set (Unicode/ISO 10646). A mapping from IRIs to URIs is defined
&nbsp; * using {@link #toASCIIString()}, which means that IRIs can be used instead of URIs, where appropriate, to identify
&nbsp; * resources. While all URIs are also IRIs, the {@link #normalize()} method can be used to convert a URI back into a
&nbsp; * normalized IRI.
&nbsp; * &lt;p&gt;
&nbsp; * A URI is a uniform resource &lt;i&gt;identifier&lt;/i&gt; while a URL is a uniform resource &lt;i&gt;locator&lt;/i&gt;. Hence every URL is a
&nbsp; * URI, abstractly speaking, but not every URI is a URL. This is because there is another subcategory of URIs, uniform
&nbsp; * resource &lt;i&gt;names&lt;/i&gt; (URNs), which name resources but do not specify how to locate them. The {@code mailto},
&nbsp; * {@code news}, and {@code isbn} URIs shown above are examples of URNs.
&nbsp; * &lt;h4&gt;Deviations&lt;/h4&gt;
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;jar:&lt;/b&gt; This implementation treats the first colon as part of the scheme if the scheme starts with &quot;jar:&quot;. For
&nbsp; * example the IRI &lt;i&gt;jar:http://www.foo.com/bar/jar.jar!/baz/entry.txt&lt;/i&gt; is parsed with the scheme &lt;i&gt;jar:http&lt;/i&gt;
&nbsp; * and the path &lt;i&gt;/bar/jar.jar!/baz/entry.txt&lt;/i&gt;.
&nbsp; *
&nbsp; * @author James Leigh
&nbsp; * @since 2.3
&nbsp; * @see &lt;a href=&quot;http://www.ietf.org/rfc/rfc3987.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;3987: Internationalized Resource Identifiers
&nbsp; *      (IRIs)&lt;/i&gt;&lt;/a&gt;
&nbsp; * @see &lt;a href=&quot;http://www.ietf.org/rfc/rfc3986.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;3986: Uniform Resource Identifiers (URI): Generic
&nbsp; *      Syntax&lt;/i&gt;&lt;/a&gt;
&nbsp; */
<b class="fc">&nbsp;public class ParsedIRI implements Cloneable, Serializable {</b>
&nbsp;
&nbsp;	private static final long serialVersionUID = -5681843777254402303L;
&nbsp;
<b class="fc">&nbsp;	private static final Comparator&lt;int[]&gt; CMP = (int[] o1, int[] o2) -&gt; o1[0] - o2[0];</b>
&nbsp;
&nbsp;	private static final int EOF = 0;
&nbsp;
<b class="fc">&nbsp;	private static final int[][] iprivate = { new int[] { 0xE000, 0xF8FF }, new int[] { 0xF0000, 0xFFFFD },</b>
&nbsp;			new int[] { 0x100000, 0x10FFFD } };
&nbsp;
<b class="fc">&nbsp;	private static final int[][] ucschar = { new int[] { 0x00A0, 0xD7FF }, new int[] { 0xF900, 0xFDCF },</b>
&nbsp;			new int[] { 0xFDF0, 0xFFEF }, new int[] { 0x10000, 0x1FFFD }, new int[] { 0x20000, 0x2FFFD },
&nbsp;			new int[] { 0x30000, 0x3FFFD }, new int[] { 0x40000, 0x4FFFD }, new int[] { 0x50000, 0x5FFFD },
&nbsp;			new int[] { 0x60000, 0x6FFFD }, new int[] { 0x70000, 0x7FFFD }, new int[] { 0x80000, 0x8FFFD },
&nbsp;			new int[] { 0x90000, 0x9FFFD }, new int[] { 0xA0000, 0xAFFFD }, new int[] { 0xB0000, 0xBFFFD },
&nbsp;			new int[] { 0xC0000, 0xCFFFD }, new int[] { 0xD0000, 0xDFFFD }, new int[] { 0xE1000, 0xEFFFD } };
&nbsp;
<b class="fc">&nbsp;	private static final int[][] ALPHA = { new int[] { &#39;A&#39;, &#39;Z&#39; }, new int[] { &#39;a&#39;, &#39;z&#39; } };</b>
&nbsp;
<b class="fc">&nbsp;	private static final int[][] DIGIT = { new int[] { &#39;0&#39;, &#39;9&#39; } };</b>
&nbsp;
<b class="fc">&nbsp;	private static final int[][] sub_delims = union(&#39;!&#39;, &#39;$&#39;, &#39;&amp;&#39;, &#39;\&#39;&#39;, &#39;(&#39;, &#39;)&#39;, &#39;*&#39;, &#39;+&#39;, &#39;,&#39;, &#39;;&#39;, &#39;=&#39;);</b>
&nbsp;
<b class="fc">&nbsp;	private static final int[][] gen_delims = union(&#39;:&#39;, &#39;/&#39;, &#39;?&#39;, &#39;#&#39;, &#39;[&#39;, &#39;]&#39;, &#39;@&#39;);</b>
&nbsp;
<b class="fc">&nbsp;	private static final int[][] reserved = union(gen_delims, sub_delims);</b>
&nbsp;
<b class="fc">&nbsp;	private static final int[][] unreserved_rfc3986 = union(ALPHA, DIGIT, &#39;-&#39;, &#39;.&#39;, &#39;_&#39;, &#39;~&#39;);</b>
&nbsp;
<b class="fc">&nbsp;	private static final int[][] unreserved = union(unreserved_rfc3986, ucschar);</b>
&nbsp;
<b class="fc">&nbsp;	private static final int[][] schar = union(ALPHA, DIGIT, &#39;+&#39;, &#39;-&#39;, &#39;.&#39;);</b>
&nbsp;
<b class="fc">&nbsp;	private static final int[][] uchar = union(unreserved, sub_delims, &#39;:&#39;);</b>
&nbsp;
<b class="fc">&nbsp;	private static final int[][] hchar = union(unreserved, sub_delims);</b>
&nbsp;
<b class="fc">&nbsp;	private static final int[][] pchar = union(unreserved, sub_delims, &#39;:&#39;, &#39;@&#39;);</b>
&nbsp;
<b class="fc">&nbsp;	private static final int[][] qchar = union(pchar, iprivate, &#39;/&#39;, &#39;?&#39;);</b>
&nbsp;
<b class="fc">&nbsp;	private static final int[][] fchar = union(pchar, &#39;/&#39;, &#39;?&#39;);</b>
&nbsp;
<b class="fc">&nbsp;	private static final int[] HEXDIG = flatten(</b>
<b class="fc">&nbsp;			union(DIGIT, new int[][] { new int[] { &#39;A&#39;, &#39;F&#39; }, new int[] { &#39;a&#39;, &#39;f&#39; } }));</b>
&nbsp;
<b class="fc">&nbsp;	private static final int[] ascii = flatten(union(unreserved_rfc3986, reserved, &#39;%&#39;));</b>
&nbsp;
<b class="fc">&nbsp;	private static final int[] common = flatten(</b>
<b class="fc">&nbsp;			union(unreserved_rfc3986, reserved, &#39;%&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&quot;&#39;, &#39; &#39;, &#39;{&#39;, &#39;}&#39;, &#39;|&#39;, &#39;\\&#39;, &#39;^&#39;, &#39;`&#39;));</b>
&nbsp;
<b class="fc">&nbsp;	private static final String[] common_pct = pctEncode(common);</b>
&nbsp;
&nbsp;	private static int[][] union(Object... sets) {
<b class="fc">&nbsp;		List&lt;int[]&gt; list = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;		for (Object set : sets) {</b>
<b class="fc">&nbsp;			if (set instanceof int[][]) {</b>
<b class="fc">&nbsp;				int[][] ar = (int[][]) set;</b>
<b class="fc">&nbsp;				list.addAll(Arrays.asList(ar));</b>
<b class="pc">&nbsp;			} else if (set instanceof Character) {</b>
<b class="fc">&nbsp;				char chr = (Character) set;</b>
<b class="fc">&nbsp;				list.add(new int[] { chr, chr });</b>
<b class="fc">&nbsp;			} else {</b>
<b class="nc">&nbsp;				throw new IllegalStateException();</b>
&nbsp;			}
&nbsp;		}
<b class="fc">&nbsp;		int[][] dest = list.toArray(new int[][] {});</b>
<b class="fc">&nbsp;		Arrays.sort(dest, CMP);</b>
<b class="fc">&nbsp;		return dest;</b>
&nbsp;	}
&nbsp;
&nbsp;	private static int[] flatten(int[]... arrays) {
<b class="fc">&nbsp;		List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;		for (int[] str : arrays) {</b>
<b class="pc">&nbsp;			if (str.length == 1) {</b>
<b class="nc">&nbsp;				list.add(str[0]); // character</b>
<b class="pc">&nbsp;			} else if (str.length == 2) {</b>
<b class="fc">&nbsp;				for (int chr = str[0], end = str[1]; chr &lt;= end; chr++) {</b>
<b class="fc">&nbsp;					list.add(chr); // range</b>
&nbsp;				}
&nbsp;			} else {
<b class="nc">&nbsp;				throw new IllegalStateException();</b>
&nbsp;			}
&nbsp;		}
<b class="fc">&nbsp;		int[] chars = new int[list.size()];</b>
<b class="fc">&nbsp;		for (int i = 0; i &lt; chars.length; i++) {</b>
<b class="fc">&nbsp;			chars[i] = list.get(i);</b>
&nbsp;		}
<b class="fc">&nbsp;		Arrays.sort(chars);</b>
<b class="fc">&nbsp;		return chars;</b>
&nbsp;	}
&nbsp;
&nbsp;	private static String[] pctEncode(int[] unencoded) {
<b class="fc">&nbsp;		CharsetEncoder encoder = StandardCharsets.UTF_8.newEncoder();</b>
<b class="fc">&nbsp;		String[] result = new String[unencoded.length];</b>
<b class="fc">&nbsp;		for (int i = 0; i &lt; unencoded.length; i++) {</b>
<b class="fc">&nbsp;			String ns = new String(Character.toChars(unencoded[i]));</b>
&nbsp;			ByteBuffer bb;
&nbsp;			try {
<b class="fc">&nbsp;				bb = encoder.encode(CharBuffer.wrap(ns));</b>
<b class="nc">&nbsp;			} catch (CharacterCodingException x) {</b>
<b class="nc">&nbsp;				throw new IllegalStateException();</b>
<b class="fc">&nbsp;			}</b>
<b class="fc">&nbsp;			StringBuilder sb = new StringBuilder();</b>
<b class="fc">&nbsp;			while (bb.hasRemaining()) {</b>
<b class="fc">&nbsp;				byte b = (byte) (bb.get() &amp; 0xff);</b>
<b class="fc">&nbsp;				sb.append(&#39;%&#39;);</b>
<b class="fc">&nbsp;				sb.appendCodePoint(HEXDIG[(b &gt;&gt; 4) &amp; 0x0f]);</b>
<b class="fc">&nbsp;				sb.appendCodePoint(HEXDIG[(b) &amp; 0x0f]);</b>
<b class="fc">&nbsp;			}</b>
<b class="fc">&nbsp;			result[i] = sb.toString();</b>
&nbsp;		}
<b class="fc">&nbsp;		return result;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Creates a ParsedIRI by parsing the given string.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * This convenience factory method works as if by invoking the {@link #ParsedIRI(String)} constructor; any
&nbsp;	 * {@link URISyntaxException} thrown by the constructor is caught and the error code point is percent encoded. This
&nbsp;	 * process is repeated until a syntactically valid IRI is formed or a {@link IllegalArgumentException} is thrown.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * This method is provided for use in situations where it is known that the given string is an IRI, even if it is
&nbsp;	 * not completely syntactically valid, for example a IRI constants declared within in a program. The constructors,
&nbsp;	 * which throw {@link URISyntaxException} directly, should be used situations where a IRI is being constructed from
&nbsp;	 * user input or from some other source that may be prone to errors.
&nbsp;	 * &lt;/p&gt;
&nbsp;	 *
&nbsp;	 * @param str The string to be parsed into an IRI
&nbsp;	 * @return The new ParsedIRI
&nbsp;	 * @throws NullPointerException     If {@code str} is {@code null}
&nbsp;	 * @throws IllegalArgumentException If the given string could not be converted into an IRI
&nbsp;	 */
&nbsp;	public static ParsedIRI create(String str) {
&nbsp;		try {
<b class="fc">&nbsp;			return new ParsedIRI(str);</b>
<b class="fc">&nbsp;		} catch (URISyntaxException x) {</b>
<b class="fc">&nbsp;			int problem = x.getIndex();</b>
<b class="fc">&nbsp;			StringBuilder sb = new StringBuilder(str);</b>
&nbsp;			while (true) {
<b class="fc">&nbsp;				int end = sb.offsetByCodePoints(problem, 1);</b>
<b class="fc">&nbsp;				String decoded = sb.substring(problem, end);</b>
<b class="pc">&nbsp;				String encoded = &quot; &quot;.equals(decoded) ? &quot;%20&quot; : URLEncoder.encode(decoded, StandardCharsets.UTF_8);</b>
<b class="fc">&nbsp;				sb.replace(problem, end, encoded);</b>
&nbsp;				try {
<b class="fc">&nbsp;					return new ParsedIRI(sb.toString());</b>
<b class="nc">&nbsp;				} catch (URISyntaxException ex) {</b>
<b class="nc">&nbsp;					if (ex.getIndex() &lt;= problem) {</b>
<b class="nc">&nbsp;						throw new IllegalArgumentException(x.getMessage(), x);</b>
&nbsp;					} else {
<b class="nc">&nbsp;						problem = ex.getIndex();</b>
&nbsp;					}
&nbsp;				}
<b class="nc">&nbsp;			}</b>
&nbsp;
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private final String iri;
&nbsp;
&nbsp;	private int pos;
&nbsp;
&nbsp;	private String scheme;
&nbsp;
&nbsp;	private String userInfo;
&nbsp;
&nbsp;	private String host;
&nbsp;
<b class="fc">&nbsp;	private int port = -1;</b>
&nbsp;
&nbsp;	private String path;
&nbsp;
&nbsp;	private String query;
&nbsp;
&nbsp;	private String fragment;
&nbsp;
&nbsp;	/**
&nbsp;	 * Constructs a ParsedIRI by parsing the given string.
&nbsp;	 *
&nbsp;	 * @param iri The string to be parsed into a IRI
&nbsp;	 * @throws NullPointerException If {@code iri} is {@code null}
&nbsp;	 * @throws URISyntaxException   If the given string violates RFC&amp;nbsp;3987, as augmented by the above deviations
&nbsp;	 */
<b class="fc">&nbsp;	public ParsedIRI(String iri) throws URISyntaxException {</b>
<b class="pc">&nbsp;		assert iri != null;</b>
<b class="fc">&nbsp;		this.iri = iri;</b>
<b class="fc">&nbsp;		parse();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Constructs a hierarchical IRI from the given components.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * This constructor first builds a IRI string from the given components according to the rules specified in
&nbsp;	 * &lt;a href=&quot;http://www.ietf.org/rfc/rfc3987.txt&quot;&gt;RFC&amp;nbsp;3987&lt;/a&gt;
&nbsp;	 * &lt;/p&gt;
&nbsp;	 *
&nbsp;	 * @param scheme   Scheme name
&nbsp;	 * @param userInfo User name and authorization information
&nbsp;	 * @param host     Host name
&nbsp;	 * @param port     Port number
&nbsp;	 * @param path     Path
&nbsp;	 * @param query    Query
&nbsp;	 * @param fragment Fragment
&nbsp;	 */
&nbsp;	public ParsedIRI(String scheme, String userInfo, String host, int port, String path, String query,
<b class="fc">&nbsp;			String fragment) {</b>
<b class="fc">&nbsp;		this.iri = buildIRI(scheme, userInfo, host, port, path, query, fragment);</b>
<b class="fc">&nbsp;		this.scheme = scheme;</b>
<b class="fc">&nbsp;		this.userInfo = userInfo;</b>
<b class="fc">&nbsp;		this.host = host;</b>
<b class="fc">&nbsp;		this.port = port;</b>
<b class="pc">&nbsp;		this.path = path == null ? &quot;&quot; : path;</b>
<b class="fc">&nbsp;		this.query = query;</b>
<b class="fc">&nbsp;		this.fragment = fragment;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public int hashCode() {
<b class="nc">&nbsp;		return iri.hashCode();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Tests this IRI for simple string comparison with another object.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * If two IRI strings are identical, then it is safe to conclude that they are equivalent. However, even if the IRI
&nbsp;	 * strings are not identical the IRIs might still be equivalent. Further comparison can be made using the
&nbsp;	 * {@link #normalize()} forms.
&nbsp;	 *
&nbsp;	 * @param obj The object to which this object is to be compared
&nbsp;	 * @return {@code true} if the given object is a ParsedIRI that represents the same IRI
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public boolean equals(Object obj) {
<b class="nc">&nbsp;		return obj instanceof ParsedIRI &amp;&amp; this.iri.equals(((ParsedIRI) obj).iri);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the content of this IRI as a string.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * If this URI was created by invoking one of the constructors in this class then a string equivalent to the
&nbsp;	 * original input string, or to the string computed from the originally-given components, as appropriate, is
&nbsp;	 * returned. Otherwise this IRI was created by normalization, resolution, or relativization, and so a string is
&nbsp;	 * constructed from this IRI&#39;s components according to the rules specified in
&nbsp;	 * &lt;a href=&quot;http://www.ietf.org/rfc/rfc3987.txt&quot;&gt;RFC&amp;nbsp;3987&lt;/a&gt;
&nbsp;	 * &lt;/p&gt;
&nbsp;	 *
&nbsp;	 * @return The string form of this IRI
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public String toString() {
<b class="fc">&nbsp;		return iri;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the content of this IRI as a US-ASCII string.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * If this IRI only contains 8bit characters then an invocation of this method will return the same value as an
&nbsp;	 * invocation of the {@link #toString() toString} method. Otherwise this method works as if by encoding the host via
&nbsp;	 * &lt;a href=&quot;http://www.ietf.org/rfc/rfc3490.txt&quot;&gt;RFC 3490&lt;/a&gt; and all other components by percent encoding their
&nbsp;	 * UTF-8 values.
&nbsp;	 * &lt;/p&gt;
&nbsp;	 *
&nbsp;	 * @return The string form of this IRI, encoded as needed so that it only contains characters in the US-ASCII
&nbsp;	 *         charset
&nbsp;	 */
&nbsp;	public String toASCIIString() {
<b class="nc">&nbsp;		StringBuilder sb = new StringBuilder(iri.length());</b>
<b class="nc">&nbsp;		if (scheme != null) {</b>
<b class="nc">&nbsp;			sb.append(scheme).append(&#39;:&#39;);</b>
&nbsp;		}
<b class="nc">&nbsp;		if (host != null) {</b>
<b class="nc">&nbsp;			sb.append(&quot;//&quot;);</b>
<b class="nc">&nbsp;			if (userInfo != null) {</b>
<b class="nc">&nbsp;				appendAscii(sb, userInfo);</b>
<b class="nc">&nbsp;				sb.append(&#39;@&#39;);</b>
&nbsp;			}
<b class="nc">&nbsp;			if (host.length() &gt; 0) {</b>
<b class="nc">&nbsp;				sb.append(IDN.toASCII(host, IDN.ALLOW_UNASSIGNED));</b>
&nbsp;			}
<b class="nc">&nbsp;			if (port &gt;= 0) {</b>
<b class="nc">&nbsp;				sb.append(&#39;:&#39;).append(port);</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		if (path != null) {</b>
<b class="nc">&nbsp;			appendAscii(sb, path);</b>
&nbsp;		}
<b class="nc">&nbsp;		if (query != null) {</b>
<b class="nc">&nbsp;			sb.append(&#39;?&#39;);</b>
<b class="nc">&nbsp;			appendAscii(sb, query);</b>
&nbsp;		}
<b class="nc">&nbsp;		if (fragment != null) {</b>
<b class="nc">&nbsp;			sb.append(&#39;#&#39;);</b>
<b class="nc">&nbsp;			appendAscii(sb, fragment);</b>
&nbsp;		}
<b class="nc">&nbsp;		return sb.toString();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Tells whether or not this IRI is absolute.
&nbsp;	 *
&nbsp;	 * @return {@code true} if, and only if, this IRI has a scheme component
&nbsp;	 */
&nbsp;	public boolean isAbsolute() {
<b class="fc">&nbsp;		return scheme != null;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Tells whether or not this IRI is opaque.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * A IRI is opaque if, and only if, it is absolute and its path part does not begin with a slash character (&#39;/&#39;). An
&nbsp;	 * opaque IRI has a scheme, a path, and possibly a query or fragment; all other components (userInfo, host, and
&nbsp;	 * port) are undefined.
&nbsp;	 * &lt;/p&gt;
&nbsp;	 *
&nbsp;	 * @return {@code true} if, and only if, this IRI is absolute and its path does not start with a slash
&nbsp;	 */
&nbsp;	public boolean isOpaque() {
<b class="pc">&nbsp;		return scheme != null &amp;&amp; !path.isEmpty() &amp;&amp; !path.startsWith(&quot;/&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the scheme component of this IRI.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * The scheme component of a IRI, if defined, only contains characters in the &lt;i&gt;alphanum&lt;/i&gt; category and in the
&nbsp;	 * string {@code &quot;-.+&quot;}, unless the scheme starts with {@code &quot;jar:&quot;}, in which case it may also contain one colon.
&nbsp;	 * A scheme always starts with an &lt;i&gt;alpha&lt;/i&gt; character.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * The scheme component of a IRI cannot contain escaped octets.
&nbsp;	 *
&nbsp;	 * @return The scheme component of this IRI, or {@code null} if the scheme is undefined
&nbsp;	 */
&nbsp;	public String getScheme() {
<b class="fc">&nbsp;		return scheme;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the raw user-information component of this IRI.
&nbsp;	 *
&nbsp;	 * @return The raw user-information component of this IRI, or {@code null} if the user information is undefined
&nbsp;	 */
&nbsp;	public String getUserInfo() {
<b class="fc">&nbsp;		return userInfo;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the host component of this IRI.
&nbsp;	 *
&nbsp;	 * @return The host component of this IRI, or {@code null} if the host is undefined
&nbsp;	 */
&nbsp;	public String getHost() {
<b class="fc">&nbsp;		return host;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the port number of this IRI.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * The port component of a IRI, if defined, is a non-negative integer.
&nbsp;	 * &lt;/p&gt;
&nbsp;	 *
&nbsp;	 * @return The port component of this IRI, or {@code -1} if the port is undefined
&nbsp;	 */
&nbsp;	public int getPort() {
<b class="fc">&nbsp;		return port;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the raw path component of this IRI.
&nbsp;	 *
&nbsp;	 * @return The path component of this IRI (never {@code null})
&nbsp;	 */
&nbsp;	public String getPath() {
<b class="fc">&nbsp;		return path;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the raw query component of this IRI after the first question mark.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * The query component of a IRI, if defined, only contains legal IRI characters.
&nbsp;	 * &lt;/p&gt;
&nbsp;	 *
&nbsp;	 * @return The raw query component of this IRI, or {@code null} if the IRI does not contain a question mark
&nbsp;	 */
&nbsp;	public String getQuery() {
<b class="fc">&nbsp;		return query;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the raw fragment component of this IRI after the hash.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * The fragment component of a IRI, if defined, only contains legal IRI characters and does not contain a hash.
&nbsp;	 * &lt;/p&gt;
&nbsp;	 *
&nbsp;	 * @return The raw fragment component of this IRI, or {@code null} if the IRI does not contain a hash
&nbsp;	 */
&nbsp;	public String getFragment() {
<b class="fc">&nbsp;		return fragment;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Normalizes this IRI&#39;s components.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * Because IRIs exist to identify resources, presumably they should be considered equivalent when they identify the
&nbsp;	 * same resource. However, this definition of equivalence is not of much practical use, as there is no way for an
&nbsp;	 * implementation to compare two resources unless it has full knowledge or control of them. Therefore, IRI
&nbsp;	 * normalization is designed to minimize false negatives while strictly avoiding false positives.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * &lt;b&gt;Case Normalization&lt;/b&gt; the hexadecimal digits within a percent-encoding triplet (e.g., &quot;%3a&quot; versus &quot;%3A&quot;) are
&nbsp;	 * case-insensitive and are normalized to use uppercase letters for the digits A - F. The scheme and host are case
&nbsp;	 * insensitive and are normalized to lowercase.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * &lt;b&gt;Character Normalization&lt;/b&gt; The Unicode Standard defines various equivalences between sequences of characters
&nbsp;	 * for various purposes. Unicode Standard Annex defines various Normalization Forms for these equivalences and is
&nbsp;	 * applied to the IRI components.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * &lt;b&gt;Percent-Encoding Normalization&lt;/b&gt; decodes any percent-encoded octet sequence that corresponds to an
&nbsp;	 * unreserved character anywhere in the IRI.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * &lt;b&gt;Path Segment Normalization&lt;/b&gt; is the process of removing unnecessary {@code &quot;.&quot;} and {@code &quot;..&quot;} segments
&nbsp;	 * from the path component of a hierarchical IRI. Each {@code &quot;.&quot;} segment is simply removed. A {@code &quot;..&quot;} segment
&nbsp;	 * is removed only if it is preceded by a non-{@code &quot;..&quot;} segment or the start of the path.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * &lt;b&gt;HTTP(S) Scheme Normalization&lt;/b&gt; if the port uses the default port number or not given it is set to undefined.
&nbsp;	 * An empty path is replaced with &quot;/&quot;.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * &lt;b&gt;File Scheme Normalization&lt;/b&gt; if the host is &quot;localhost&quot; or empty it is set to undefined.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * &lt;b&gt;Internationalized Domain Name Normalization&lt;/b&gt; of the host component to Unicode.
&nbsp;	 *
&nbsp;	 * @return normalized IRI
&nbsp;	 */
&nbsp;	public ParsedIRI normalize() {
<b class="fc">&nbsp;		String _scheme = toLowerCase(scheme);</b>
<b class="pc">&nbsp;		boolean optionalPort = isScheme(&quot;http&quot;) &amp;&amp; 80 == port || isScheme(&quot;https&quot;) &amp;&amp; 443 == port;</b>
<b class="pc">&nbsp;		int _port = optionalPort ? -1 : port;</b>
<b class="pc">&nbsp;		boolean localhost = isScheme(&quot;file&quot;) &amp;&amp; userInfo == null &amp;&amp; -1 == port</b>
<b class="pc">&nbsp;				&amp;&amp; (&quot;&quot;.equals(host) || &quot;localhost&quot;.equals(host));</b>
<b class="pc">&nbsp;		String _host = localhost ? null</b>
<b class="pc">&nbsp;				: host == null || host.length() == 0 ? host</b>
<b class="nc">&nbsp;						: IDN.toUnicode(pctEncodingNormalization(toLowerCase(host)),</b>
&nbsp;								IDN.USE_STD3_ASCII_RULES | IDN.ALLOW_UNASSIGNED);
<b class="pc">&nbsp;		String _path = _scheme != null &amp;&amp; path == null ? &quot;&quot; : normalizePath(path);</b>
<b class="fc">&nbsp;		String _userInfo = pctEncodingNormalization(userInfo);</b>
<b class="fc">&nbsp;		String _query = pctEncodingNormalization(query);</b>
<b class="fc">&nbsp;		String _fragment = pctEncodingNormalization(fragment);</b>
<b class="fc">&nbsp;		ParsedIRI normalized = new ParsedIRI(_scheme, _userInfo, _host, _port, _path, _query, _fragment);</b>
<b class="pc">&nbsp;		if (this.iri.equals(normalized.iri)) {</b>
<b class="fc">&nbsp;			return this;</b>
&nbsp;		} else {
<b class="nc">&nbsp;			return normalized;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Resolves the given IRI against this ParsedIRI.
&nbsp;	 *
&nbsp;	 * @see #resolve(ParsedIRI)
&nbsp;	 * @param iri The IRI to be resolved against this ParsedIRI
&nbsp;	 * @return The resulting IRI
&nbsp;	 * @throws NullPointerException If {@code relative} is {@code null}
&nbsp;	 */
&nbsp;	public String resolve(String iri) {
<b class="fc">&nbsp;		return resolve(ParsedIRI.create(iri)).toString();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Resolves the given IRI against this ParsedIRI.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * &lt;i&gt;Resolution&lt;/i&gt; is the process of resolving one IRI against another, &lt;i&gt;base&lt;/i&gt; IRI. The resulting IRI is
&nbsp;	 * constructed from components of both IRIs in the manner specified by RFC&amp;nbsp;3986, taking components from the
&nbsp;	 * base IRI for those not specified in the original. For hierarchical IRIs, the path of the original is resolved
&nbsp;	 * against the path of the base and then normalized.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * If the given IRI is already absolute, or if this IRI is opaque, then the given IRI is returned.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * &lt;a name=&quot;resolve-frag&quot;&gt;&lt;/a&gt; If the given URI&#39;s fragment component is defined, its path component is empty, and
&nbsp;	 * its scheme, authority, and query components are undefined, then a URI with the given fragment but with all other
&nbsp;	 * components equal to those of this URI is returned. This allows an IRI representing a standalone fragment
&nbsp;	 * reference, such as {@code &quot;#foo&quot;}, to be usefully resolved against a base IRI.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * Otherwise this method constructs a new hierarchical IRI in a manner consistent with
&nbsp;	 * &lt;a href=&quot;http://www.ietf.org/rfc/rfc3987.txt&quot;&gt;RFC&amp;nbsp;3987&lt;/a&gt;
&nbsp;	 * &lt;/p&gt;
&nbsp;	 * &lt;p&gt;
&nbsp;	 * The result of this method is absolute if, and only if, either this IRI is absolute or the given IRI is absolute.
&nbsp;	 * &lt;/p&gt;
&nbsp;	 *
&nbsp;	 * @param relative The IRI to be resolved against this ParsedIRI
&nbsp;	 * @return The resulting IRI
&nbsp;	 * @throws NullPointerException If {@code relative} is {@code null}
&nbsp;	 */
&nbsp;	public ParsedIRI resolve(ParsedIRI relative) {
&nbsp;		// This algorithm is based on the algorithm specified in chapter 5 of
&nbsp;		// RFC 2396: URI Generic Syntax. See http://www.ietf.org/rfc/rfc2396.txt
&nbsp;
&nbsp;		// RFC, step 3:
<b class="fc">&nbsp;		if (relative.isAbsolute()) {</b>
<b class="fc">&nbsp;			return relative;</b>
&nbsp;		}
&nbsp;
&nbsp;		// relURI._scheme == null
&nbsp;
&nbsp;		// RFC, step 2:
<b class="pc">&nbsp;		if (relative.getHost() == null &amp;&amp; relative.getQuery() == null &amp;&amp; relative.getPath().length() == 0) {</b>
&nbsp;
&nbsp;			// Inherit any fragment identifier from relURI
<b class="fc">&nbsp;			String fragment = relative.getFragment();</b>
&nbsp;
<b class="fc">&nbsp;			return new ParsedIRI(this.getScheme(), this.getUserInfo(), this.getHost(), this.getPort(), this.getPath(),</b>
<b class="fc">&nbsp;					this.getQuery(), fragment);</b>
<b class="pc">&nbsp;		} else if (relative.getHost() == null &amp;&amp; relative.getPath().length() == 0) {</b>
&nbsp;
&nbsp;			// Inherit any query or fragment from relURI
<b class="nc">&nbsp;			String query = relative.getQuery();</b>
<b class="nc">&nbsp;			String fragment = relative.getFragment();</b>
&nbsp;
<b class="nc">&nbsp;			return new ParsedIRI(this.getScheme(), this.getUserInfo(), this.getHost(), this.getPort(), this.getPath(),</b>
&nbsp;					query, fragment);
&nbsp;		}
&nbsp;
&nbsp;		// We can start combining the URIs
&nbsp;		String scheme, userInfo, host, path, query, fragment;
&nbsp;		int port;
<b class="fc">&nbsp;		boolean normalize = false;</b>
&nbsp;
<b class="fc">&nbsp;		scheme = this.getScheme();</b>
<b class="fc">&nbsp;		query = relative.getQuery();</b>
<b class="fc">&nbsp;		fragment = relative.getFragment();</b>
&nbsp;
&nbsp;		// RFC, step 4:
<b class="pc">&nbsp;		if (relative.getHost() != null) {</b>
<b class="nc">&nbsp;			userInfo = relative.getUserInfo();</b>
<b class="nc">&nbsp;			host = relative.getHost();</b>
<b class="nc">&nbsp;			port = relative.getPort();</b>
<b class="nc">&nbsp;			path = relative.getPath();</b>
&nbsp;		} else {
<b class="fc">&nbsp;			userInfo = this.getUserInfo();</b>
<b class="fc">&nbsp;			host = this.getHost();</b>
<b class="fc">&nbsp;			port = this.getPort();</b>
&nbsp;
&nbsp;			// RFC, step 5:
<b class="pc">&nbsp;			if (relative.getPath().startsWith(&quot;/&quot;)) {</b>
<b class="nc">&nbsp;				path = relative.getPath();</b>
&nbsp;			} else {
&nbsp;				// RFC, step 6:
<b class="fc">&nbsp;				path = this.getPath();</b>
&nbsp;
<b class="pc">&nbsp;				if (path == null) {</b>
<b class="nc">&nbsp;					path = &quot;/&quot;;</b>
&nbsp;				} else {
<b class="fc">&nbsp;					if (!path.endsWith(&quot;/&quot;)) {</b>
&nbsp;						// Remove the last segment of the path. Note: if
&nbsp;						// lastSlashIdx is -1, the path will become empty,
&nbsp;						// which is fixed later.
<b class="fc">&nbsp;						int lastSlashIdx = path.lastIndexOf(&#39;/&#39;);</b>
<b class="fc">&nbsp;						path = path.substring(0, lastSlashIdx + 1);</b>
&nbsp;					}
&nbsp;
<b class="pc">&nbsp;					if (path.length() == 0) {</b>
&nbsp;						// No path means: start at root.
<b class="nc">&nbsp;						path = &quot;/&quot;;</b>
&nbsp;					}
&nbsp;				}
&nbsp;
&nbsp;				// Append the path of the relative URI
<b class="fc">&nbsp;				path += relative.getPath();</b>
&nbsp;
&nbsp;				// Path needs to be normalized.
<b class="fc">&nbsp;				normalize = true;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="pc">&nbsp;		if (normalize || path.contains(&quot;/./&quot;) || path.contains(&quot;/../&quot;)) {</b>
<b class="fc">&nbsp;			path = pathSegmentNormalization(path);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return new ParsedIRI(scheme, userInfo, host, port, path, query, fragment);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Relativizes the given IRI against this ParsedIRI.
&nbsp;	 *
&nbsp;	 * @see #relativize(ParsedIRI)
&nbsp;	 * @param iri The IRI to be relativized against this ParsedIRI
&nbsp;	 * @return The resulting IRI
&nbsp;	 * @throws NullPointerException If {@code absolute} is {@code null}
&nbsp;	 */
&nbsp;	public String relativize(String iri) {
<b class="nc">&nbsp;		return relativize(ParsedIRI.create(iri)).toString();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Relativizes the given IRI against this ParsedIRI.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * &lt;i&gt;Relativization&lt;/i&gt; is the inverse of resolution. This operation is often useful when constructing a document
&nbsp;	 * containing IRIs that must be made relative to the base IRI of the document wherever possible.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * The relativization of the given URI against this URI is computed as follows:
&nbsp;	 * &lt;/p&gt;
&nbsp;	 * &lt;ol&gt;
&nbsp;	 * &lt;li&gt;
&nbsp;	 * &lt;p&gt;
&nbsp;	 * If either this IRI or the given IRI are opaque, or if the scheme and authority components of the two IRIs are not
&nbsp;	 * identical, or if the path of this IRI is not a prefix of the path of the given URI, then the given IRI is
&nbsp;	 * returned.
&nbsp;	 * &lt;/p&gt;
&nbsp;	 * &lt;/li&gt;
&nbsp;	 * &lt;li&gt;
&nbsp;	 * &lt;p&gt;
&nbsp;	 * Otherwise a new relative hierarchical IRI is constructed with query and fragment components taken from the given
&nbsp;	 * IRI and with a path component computed by removing this IRI&#39;s path from the beginning of the given IRI&#39;s path.
&nbsp;	 * &lt;/p&gt;
&nbsp;	 * &lt;/li&gt;
&nbsp;	 * &lt;/ol&gt;
&nbsp;	 *
&nbsp;	 * @param absolute The IRI to be relativized against this ParsedIRI
&nbsp;	 * @return The resulting IRI
&nbsp;	 * @throws NullPointerException If {@code absolute} is {@code null}
&nbsp;	 */
&nbsp;	public ParsedIRI relativize(ParsedIRI absolute) {
&nbsp;		// identity URI reference
<b class="nc">&nbsp;		String _frag = absolute.getFragment();</b>
<b class="nc">&nbsp;		if (iri.equals(absolute.iri) &amp;&amp; _frag == null) {</b>
<b class="nc">&nbsp;			return new ParsedIRI(null, null, null, -1, &quot;&quot;, null, null);</b>
&nbsp;		}
&nbsp;		// different scheme or authority
<b class="nc">&nbsp;		if (absolute.getScheme() != null &amp;&amp; !absolute.getScheme().equalsIgnoreCase(this.getScheme())) {</b>
<b class="nc">&nbsp;			return absolute;</b>
&nbsp;		}
<b class="nc">&nbsp;		if (absolute.getUserInfo() != null &amp;&amp; !absolute.getUserInfo().equals(this.getUserInfo())) {</b>
<b class="nc">&nbsp;			return absolute;</b>
&nbsp;		}
<b class="nc">&nbsp;		if (absolute.getHost() != null &amp;&amp; !absolute.getHost().equalsIgnoreCase(this.getHost())) {</b>
<b class="nc">&nbsp;			return absolute;</b>
&nbsp;		}
<b class="nc">&nbsp;		if (absolute.getPort() != this.getPort()) {</b>
<b class="nc">&nbsp;			return absolute;</b>
&nbsp;		}
&nbsp;		// fragment URI reference
<b class="nc">&nbsp;		if (_frag != null) {</b>
<b class="nc">&nbsp;			if (this.getFragment() == null) {</b>
<b class="nc">&nbsp;				if (absolute.iri.startsWith(this.iri) &amp;&amp; absolute.iri.charAt(iri.length()) == &#39;#&#39;) {</b>
<b class="nc">&nbsp;					return new ParsedIRI(null, null, null, -1, &quot;&quot;, null, _frag);</b>
&nbsp;				}
&nbsp;			} else {
<b class="nc">&nbsp;				int this_idx = iri.length() - this.getFragment().length();</b>
<b class="nc">&nbsp;				int abs_idx = absolute.iri.length() - _frag.length();</b>
<b class="nc">&nbsp;				if (iri.substring(0, this_idx).equals(absolute.iri.substring(0, abs_idx))) {</b>
<b class="nc">&nbsp;					return new ParsedIRI(null, null, null, -1, &quot;&quot;, null, _frag);</b>
&nbsp;				}
&nbsp;			}
&nbsp;		}
&nbsp;		// opaque IRI
<b class="nc">&nbsp;		if (this.isOpaque() || absolute.isOpaque()) {</b>
<b class="nc">&nbsp;			return absolute;</b>
&nbsp;		}
&nbsp;		// query string URI reference
<b class="nc">&nbsp;		String _query = absolute.getQuery();</b>
<b class="nc">&nbsp;		if (_query != null) {</b>
<b class="nc">&nbsp;			if (this.getQuery() == null &amp;&amp; this.getFragment() == null) {</b>
<b class="nc">&nbsp;				if (absolute.iri.startsWith(this.iri) &amp;&amp; absolute.iri.charAt(iri.length()) == &#39;?&#39;) {</b>
<b class="nc">&nbsp;					return new ParsedIRI(null, null, null, -1, &quot;&quot;, _query, _frag);</b>
&nbsp;				}
&nbsp;			} else {
<b class="nc">&nbsp;				int this_idx = this.getQuery() == null ? iri.indexOf(&#39;#&#39;) : iri.indexOf(&#39;?&#39;);</b>
<b class="nc">&nbsp;				int abs_idx = absolute.iri.indexOf(&#39;?&#39;);</b>
<b class="nc">&nbsp;				if (iri.substring(0, this_idx).equals(absolute.iri.substring(0, abs_idx))) {</b>
<b class="nc">&nbsp;					return new ParsedIRI(null, null, null, -1, &quot;&quot;, _query, _frag);</b>
&nbsp;				}
&nbsp;			}
&nbsp;		}
&nbsp;		// last path segment
<b class="nc">&nbsp;		String _path = absolute.getPath();</b>
<b class="nc">&nbsp;		int this_idx = this.getPath().lastIndexOf(&#39;/&#39;);</b>
<b class="nc">&nbsp;		int abs_idx = _path.lastIndexOf(&#39;/&#39;);</b>
<b class="nc">&nbsp;		if (this_idx &lt; 0 || abs_idx &lt; 0) {</b>
<b class="nc">&nbsp;			return absolute;</b>
&nbsp;		}
<b class="nc">&nbsp;		if (_path.equals(this.getPath().substring(0, this_idx + 1))) {</b>
<b class="nc">&nbsp;			return new ParsedIRI(null, null, null, -1, &quot;.&quot;, _query, _frag);</b>
&nbsp;		}
&nbsp;		// within last path segment
<b class="nc">&nbsp;		if (_path.startsWith(this.getPath().substring(0, this_idx + 1))) {</b>
<b class="nc">&nbsp;			return new ParsedIRI(null, null, null, -1, _path.substring(this_idx + 1), _query, _frag);</b>
&nbsp;		}
<b class="nc">&nbsp;		return new ParsedIRI(null, null, null, -1, relativizePath(_path), _query, _frag);</b>
&nbsp;	}
&nbsp;
&nbsp;	private void parse() throws URISyntaxException {
<b class="fc">&nbsp;		pos = 0;</b>
<b class="fc">&nbsp;		scheme = parseScheme();</b>
<b class="pc">&nbsp;		if (&quot;jar&quot;.equalsIgnoreCase(scheme)) {</b>
<b class="nc">&nbsp;			scheme = scheme + &#39;:&#39; + parseScheme();</b>
&nbsp;		}
<b class="fc">&nbsp;		int peek = peek();</b>
<b class="fc">&nbsp;		if (&#39;/&#39; == peek &amp;&amp; &#39;/&#39; == peek(1)) {</b>
<b class="fc">&nbsp;			advance(2);</b>
<b class="pc">&nbsp;			if (iri.indexOf(&#39;@&#39;) &gt;= 0) {</b>
<b class="nc">&nbsp;				userInfo = parseUserInfo();</b>
&nbsp;			}
<b class="fc">&nbsp;			host = parseHost();</b>
<b class="pc">&nbsp;			if (&#39;:&#39; == peek()) {</b>
<b class="nc">&nbsp;				advance(1);</b>
<b class="nc">&nbsp;				String p = parseMember(DIGIT, &#39;/&#39;);</b>
<b class="nc">&nbsp;				if (p.length() &gt; 0) {</b>
<b class="nc">&nbsp;					port = Integer.parseInt(p);</b>
&nbsp;				} else {
<b class="nc">&nbsp;					port = -1;</b>
&nbsp;				}
&nbsp;			}
<b class="fc">&nbsp;			int next = peek();</b>
<b class="pc">&nbsp;			if (&#39;/&#39; == next || &#39;?&#39; == next || &#39;#&#39; == next || EOF == next) {</b>
<b class="fc">&nbsp;				path = parsePath();</b>
&nbsp;			} else {
<b class="nc">&nbsp;				throw error(&quot;absolute or empty path expected&quot;);</b>
&nbsp;			}
<b class="pc">&nbsp;		} else if (&#39;/&#39; == peek || &#39;?&#39; == peek || &#39;#&#39; == peek || EOF == peek) {</b>
<b class="fc">&nbsp;			path = parsePath();</b>
<b class="pc">&nbsp;		} else if (&#39;%&#39; == peek || &#39;:&#39; != peek &amp;&amp; isMember(pchar, peek)) {</b>
<b class="fc">&nbsp;			path = parsePath();</b>
<b class="nc">&nbsp;		} else if (scheme != null &amp;&amp; &#39;:&#39; == peek) {</b>
<b class="nc">&nbsp;			path = parsePath();</b>
&nbsp;		}
<b class="pc">&nbsp;		if (&#39;?&#39; == peek()) {</b>
<b class="nc">&nbsp;			advance(1);</b>
<b class="nc">&nbsp;			query = parsePctEncoded(qchar, &#39;#&#39;, EOF);</b>
&nbsp;		}
<b class="fc">&nbsp;		if (&#39;#&#39; == peek()) {</b>
<b class="fc">&nbsp;			advance(1);</b>
<b class="fc">&nbsp;			fragment = parsePctEncoded(fchar, &#39;#&#39;, EOF);</b>
&nbsp;		}
<b class="fc">&nbsp;		if (pos != iri.length()) {</b>
<b class="fc">&nbsp;			throw error(&quot;Unexpected character&quot;);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private String buildIRI(String scheme, String userInfo, String host, int port, String path, String query,
&nbsp;			String fragment) {
<b class="fc">&nbsp;		StringBuilder sb = new StringBuilder();</b>
<b class="pc">&nbsp;		if (scheme != null) {</b>
<b class="fc">&nbsp;			sb.append(scheme).append(&#39;:&#39;);</b>
&nbsp;		}
<b class="fc">&nbsp;		if (host != null) {</b>
<b class="fc">&nbsp;			sb.append(&quot;//&quot;);</b>
<b class="pc">&nbsp;			if (userInfo != null) {</b>
<b class="nc">&nbsp;				sb.append(userInfo).append(&#39;@&#39;);</b>
&nbsp;			}
<b class="fc">&nbsp;			sb.append(host);</b>
<b class="pc">&nbsp;			if (port &gt;= 0) {</b>
<b class="nc">&nbsp;				sb.append(&#39;:&#39;).append(port);</b>
&nbsp;			}
&nbsp;		}
<b class="pc">&nbsp;		if (path != null) {</b>
<b class="fc">&nbsp;			sb.append(path);</b>
&nbsp;		}
<b class="pc">&nbsp;		if (query != null) {</b>
<b class="nc">&nbsp;			sb.append(&#39;?&#39;).append(query);</b>
&nbsp;		}
<b class="pc">&nbsp;		if (fragment != null) {</b>
<b class="nc">&nbsp;			sb.append(&#39;#&#39;).append(fragment);</b>
&nbsp;		}
<b class="fc">&nbsp;		return sb.toString();</b>
&nbsp;	}
&nbsp;
&nbsp;	private String parseScheme() {
<b class="fc">&nbsp;		if (isMember(ALPHA, peek())) {</b>
<b class="fc">&nbsp;			int start = pos;</b>
<b class="fc">&nbsp;			String scheme = parseMember(schar, &#39;:&#39;);</b>
<b class="fc">&nbsp;			if (&#39;:&#39; == peek()) {</b>
<b class="fc">&nbsp;				advance(1);</b>
<b class="fc">&nbsp;				return scheme;</b>
&nbsp;			} else {
<b class="fc">&nbsp;				pos = start; // reset</b>
&nbsp;			}
&nbsp;		}
<b class="fc">&nbsp;		return null;</b>
&nbsp;	}
&nbsp;
&nbsp;	private String parseUserInfo() throws URISyntaxException {
<b class="nc">&nbsp;		int start = pos;</b>
<b class="nc">&nbsp;		String userinfo = parsePctEncoded(uchar, &#39;@&#39;, &#39;/&#39;);</b>
<b class="nc">&nbsp;		if (&#39;@&#39; == peek()) {</b>
<b class="nc">&nbsp;			advance(1);</b>
<b class="nc">&nbsp;			return userinfo;</b>
&nbsp;		} else {
<b class="nc">&nbsp;			pos = start; // reset</b>
<b class="nc">&nbsp;			return null;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private String parseHost() throws URISyntaxException {
<b class="fc">&nbsp;		int start = pos;</b>
<b class="pc">&nbsp;		if (&#39;[&#39; == peek()) {</b>
<b class="nc">&nbsp;			advance(1); // IP-Literal</b>
<b class="nc">&nbsp;			parseMember(uchar, &#39;]&#39;);</b>
<b class="nc">&nbsp;			if (&#39;]&#39; == peek()) {</b>
<b class="nc">&nbsp;				advance(1);</b>
<b class="nc">&nbsp;				return iri.substring(start, pos);</b>
&nbsp;			} else {
<b class="nc">&nbsp;				throw error(&quot;Invalid host IP address&quot;);</b>
&nbsp;			}
<b class="pc">&nbsp;		} else if (isMember(DIGIT, peek())) {</b>
<b class="nc">&nbsp;			URISyntaxException parsingException = null;</b>
<b class="nc">&nbsp;			int startPos = pos;</b>
<b class="nc">&nbsp;			for (int i = 0; i &lt; 4; i++) {</b>
&nbsp;				int octet;
&nbsp;				try {
<b class="nc">&nbsp;					octet = Integer.parseInt(parseMember(DIGIT, &#39;.&#39;));</b>
<b class="nc">&nbsp;				} catch (NumberFormatException e) {</b>
<b class="nc">&nbsp;					parsingException = error(&quot;Invalid IPv4 address&quot;);</b>
<b class="nc">&nbsp;					break;</b>
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;				if (octet &lt; 0 || octet &gt; 255) {</b>
<b class="nc">&nbsp;					parsingException = error(&quot;Invalid IPv4 address&quot;);</b>
<b class="nc">&nbsp;					break;</b>
&nbsp;				}
<b class="nc">&nbsp;				if (&#39;.&#39; == peek()) {</b>
<b class="nc">&nbsp;					advance(1);</b>
&nbsp;				} else {
<b class="nc">&nbsp;					if (i == 3 &amp;&amp; (EOF == peek() || &#39;:&#39; == peek() || &#39;/&#39; == peek())) {</b>
&nbsp;						// next is end of IRI, a port, or a path
&nbsp;					} else {
<b class="nc">&nbsp;						parsingException = error(&quot;Invalid IPv4 address&quot;);</b>
<b class="nc">&nbsp;						break;</b>
&nbsp;					}
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (parsingException == null) {</b>
&nbsp;				// IPv4 parsed successfully
<b class="nc">&nbsp;				return iri.substring(start, pos);</b>
&nbsp;			} else {
&nbsp;				// Reset position and parse host
<b class="nc">&nbsp;				pos = startPos;</b>
<b class="nc">&nbsp;				String host = parsePctEncoded(hchar, &#39;:&#39;, &#39;/&#39;);</b>
&nbsp;
&nbsp;				// http(s) scheme requires a valid top-level domain
<b class="nc">&nbsp;				if (isScheme(&quot;http&quot;) || isScheme(&quot;https&quot;)) {</b>
<b class="nc">&nbsp;					if (!isTLDValid(start)) {</b>
<b class="nc">&nbsp;						throw parsingException;</b>
&nbsp;					}
&nbsp;				}
<b class="nc">&nbsp;				return host;</b>
&nbsp;			}
&nbsp;		} else {
<b class="fc">&nbsp;			return parsePctEncoded(hchar, &#39;:&#39;, &#39;/&#39;);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private boolean isTLDValid(int hostStartPos) {
<b class="nc">&nbsp;		int step = 0;</b>
<b class="nc">&nbsp;		boolean illegalCharFound = false;</b>
&nbsp;
<b class="nc">&nbsp;		while (pos + step &gt; hostStartPos) {</b>
<b class="nc">&nbsp;			int currChar = peek(--step);</b>
<b class="nc">&nbsp;			if (&#39;.&#39; == currChar) {</b>
<b class="nc">&nbsp;				return !illegalCharFound;</b>
&nbsp;			}
&nbsp;
&nbsp;			// TLDs should start with a letter
<b class="nc">&nbsp;			if (!isMember(ALPHA, currChar)) {</b>
<b class="nc">&nbsp;				illegalCharFound = true;</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;
<b class="nc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	private String parsePath() throws URISyntaxException {
<b class="fc">&nbsp;		return parsePctEncoded(fchar, &#39;?&#39;, &#39;#&#39;);</b>
&nbsp;	}
&nbsp;
&nbsp;	private String parsePctEncoded(int[][] set, int end1, int end2) throws URISyntaxException {
<b class="fc">&nbsp;		int start = pos;</b>
&nbsp;		while (true) {
<b class="fc">&nbsp;			int chr = peek();</b>
<b class="pc">&nbsp;			if (chr == EOF || chr == end1 || chr == end2) {</b>
<b class="fc">&nbsp;				break; // optimize end character</b>
<b class="pc">&nbsp;			} else if ((&#39;a&#39; &lt;= chr &amp;&amp; chr &lt;= &#39;z&#39;) || (&#39;A&#39; &lt;= chr &amp;&amp; chr &lt;= &#39;Z&#39;) || (&#39;0&#39; &lt;= chr &amp;&amp; chr &lt;= &#39;9&#39;)) {</b>
<b class="fc">&nbsp;				advance(1);</b>
<b class="fc">&nbsp;			} else if (&#39;%&#39; == chr) {</b>
<b class="pc">&nbsp;				if (Arrays.binarySearch(HEXDIG, peek(1)) &gt;= 0 &amp;&amp; Arrays.binarySearch(HEXDIG, peek(2)) &gt;= 0) {</b>
<b class="fc">&nbsp;					advance(3);</b>
&nbsp;				} else {
<b class="nc">&nbsp;					throw error(&quot;Illegal percent encoding&quot;);</b>
&nbsp;				}
<b class="fc">&nbsp;			} else if (isMember(set, chr)) {</b>
<b class="fc">&nbsp;				advance(1);</b>
&nbsp;			} else {
&nbsp;				break;
&nbsp;			}
<b class="fc">&nbsp;		}</b>
<b class="fc">&nbsp;		return iri.substring(start, pos);</b>
&nbsp;	}
&nbsp;
&nbsp;	private String parseMember(int[][] set, int end) {
<b class="fc">&nbsp;		int start = pos;</b>
&nbsp;		while (true) {
<b class="fc">&nbsp;			int chr = peek();</b>
<b class="fc">&nbsp;			if (chr == EOF || chr == end) {</b>
<b class="fc">&nbsp;				break;</b>
<b class="fc">&nbsp;			} else if (isMember(set, chr)) {</b>
<b class="fc">&nbsp;				advance(1);</b>
&nbsp;			} else {
&nbsp;				break;
&nbsp;			}
<b class="fc">&nbsp;		}</b>
<b class="fc">&nbsp;		return iri.substring(start, pos);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean isMember(int[][] set, int chr) {
<b class="fc">&nbsp;		int idx = Arrays.binarySearch(set, new int[] { chr }, CMP);</b>
<b class="fc">&nbsp;		if (idx &gt;= 0) {</b>
<b class="fc">&nbsp;			return true; // lower range matched exactly</b>
<b class="fc">&nbsp;		} else if (idx == -1) {</b>
<b class="fc">&nbsp;			return false; // insertion point is 0, below lowest range</b>
&nbsp;		} else {
<b class="fc">&nbsp;			int i = -idx - 2; // range just before insertion point</b>
<b class="pc">&nbsp;			assert set[i][0] &lt;= chr &amp;&amp; set[i].length == 2;</b>
<b class="fc">&nbsp;			return chr &lt;= set[i][1];</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private int peek() {
<b class="fc">&nbsp;		if (pos &lt; iri.length()) {</b>
<b class="fc">&nbsp;			return iri.codePointAt(pos);</b>
&nbsp;		} else {
<b class="fc">&nbsp;			return EOF;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private int peek(int ahead) {
<b class="pc">&nbsp;		if (pos + ahead &lt; iri.length()) {</b>
<b class="fc">&nbsp;			return iri.codePointAt(iri.offsetByCodePoints(pos, ahead));</b>
&nbsp;		} else {
<b class="nc">&nbsp;			return EOF;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private void advance(int ahead) {
<b class="fc">&nbsp;		if (pos + ahead &lt; iri.length()) {</b>
<b class="fc">&nbsp;			pos = iri.offsetByCodePoints(pos, ahead);</b>
&nbsp;		} else {
<b class="fc">&nbsp;			pos += ahead;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private URISyntaxException error(String reason) {
<b class="pc">&nbsp;		if (pos &gt; -1 &amp;&amp; pos &lt; iri.length()) {</b>
<b class="fc">&nbsp;			int cp = iri.codePointAt(pos);</b>
<b class="fc">&nbsp;			reason = reason + &quot; U+&quot; + Integer.toHexString(cp).toUpperCase();</b>
&nbsp;		}
<b class="fc">&nbsp;		return new URISyntaxException(iri, reason, pos);</b>
&nbsp;	}
&nbsp;
&nbsp;	private void appendAscii(StringBuilder sb, String input) {
<b class="nc">&nbsp;		for (int c = 0, n = input.codePointCount(0, input.length()); c &lt; n; c++) {</b>
<b class="nc">&nbsp;			int chr = input.codePointAt(input.offsetByCodePoints(0, c));</b>
<b class="nc">&nbsp;			if (Arrays.binarySearch(ascii, chr) &gt;= 0) {</b>
<b class="nc">&nbsp;				sb.appendCodePoint(chr);</b>
&nbsp;			} else {
<b class="nc">&nbsp;				sb.append(pctEncode(chr));</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private String toLowerCase(String string) {
<b class="pc">&nbsp;		if (string == null) {</b>
<b class="nc">&nbsp;			return null;</b>
&nbsp;		}
<b class="fc">&nbsp;		boolean changed = false;</b>
<b class="fc">&nbsp;		StringBuilder sb = new StringBuilder(string);</b>
<b class="fc">&nbsp;		for (int i = 0; i &lt; sb.length(); i++) {</b>
<b class="fc">&nbsp;			char c = sb.charAt(i);</b>
<b class="pc">&nbsp;			if ((c &gt;= &#39;A&#39;) &amp;&amp; (c &lt;= &#39;Z&#39;)) {</b>
<b class="nc">&nbsp;				changed = true;</b>
<b class="nc">&nbsp;				sb.setCharAt(i, (char) (c + (&#39;a&#39; - &#39;A&#39;)));</b>
&nbsp;			}
&nbsp;		}
<b class="pc">&nbsp;		return changed ? sb.toString() : string;</b>
&nbsp;	}
&nbsp;
&nbsp;	private String toUpperCase(String string) {
<b class="nc">&nbsp;		if (string == null) {</b>
<b class="nc">&nbsp;			return null;</b>
&nbsp;		}
<b class="nc">&nbsp;		boolean changed = false;</b>
<b class="nc">&nbsp;		StringBuilder sb = new StringBuilder(string);</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; sb.length(); i++) {</b>
<b class="nc">&nbsp;			char c = sb.charAt(i);</b>
<b class="nc">&nbsp;			if ((c &gt;= &#39;a&#39;) &amp;&amp; (c &lt;= &#39;z&#39;)) {</b>
<b class="nc">&nbsp;				changed = true;</b>
<b class="nc">&nbsp;				sb.setCharAt(i, (char) (c - (&#39;a&#39; - &#39;A&#39;)));</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		return changed ? sb.toString() : string;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean isScheme(String scheme) {
<b class="pc">&nbsp;		return scheme.equalsIgnoreCase(this.scheme) || this.scheme != null &amp;&amp; this.scheme.indexOf(&#39;:&#39;) == 3</b>
<b class="nc">&nbsp;				&amp;&amp; this.scheme.equalsIgnoreCase(&quot;jar:&quot; + scheme);</b>
&nbsp;	}
&nbsp;
&nbsp;	private String normalizePath(String path) {
<b class="pc">&nbsp;		if (&quot;&quot;.equals(path)) {</b>
<b class="nc">&nbsp;			return isScheme(&quot;http&quot;) || isScheme(&quot;https&quot;) ? &quot;/&quot; : &quot;&quot;;</b>
<b class="pc">&nbsp;		} else if (isScheme(&quot;file&quot;)) {</b>
<b class="pc">&nbsp;			if (path.contains(&quot;%5C&quot;)) {</b>
&nbsp;				// replace &quot;/c:\path\to\file&quot; with &quot;/c:/path/to/file&quot;
<b class="nc">&nbsp;				return normalizePath(path.replace(&quot;%5C&quot;, &quot;/&quot;));</b>
<b class="pc">&nbsp;			} else if (!path.startsWith(&quot;/&quot;) &amp;&amp; isMember(ALPHA, path.codePointAt(0))</b>
<b class="nc">&nbsp;					&amp;&amp; (&#39;:&#39; == path.charAt(1) || path.length() &gt;= 4 &amp;&amp; &quot;%7C&quot;.equals(path.substring(1, 4)))) {</b>
&nbsp;				// replace &quot;c:/path/to/file&quot; with &quot;/c:/path/to/file&quot;
<b class="nc">&nbsp;				return normalizePath(&quot;/&quot; + path);</b>
<b class="pc">&nbsp;			} else if (path.length() &gt;= 5 &amp;&amp; &quot;%7C&quot;.equals(path.substring(2, 5))</b>
<b class="nc">&nbsp;					&amp;&amp; isMember(ALPHA, path.codePointAt(1))) {</b>
&nbsp;				// replace &quot;/c|/path/to/file&quot; with &quot;/c:/path/to/file&quot;
<b class="nc">&nbsp;				return normalizePath(path.substring(0, 2) + &#39;:&#39; + path.substring(5));</b>
&nbsp;			}
&nbsp;		}
<b class="fc">&nbsp;		return pctEncodingNormalization(pathSegmentNormalization(path));</b>
&nbsp;	}
&nbsp;
&nbsp;	private String pctEncodingNormalization(String path) {
<b class="pc">&nbsp;		if (path == null || path.length() == 0 || path.indexOf(&#39;%&#39;) &lt; 0) {</b>
<b class="fc">&nbsp;			return path; // no pct encodings</b>
&nbsp;		}
<b class="nc">&nbsp;		String[] encodings = listPctEncodings(path);</b>
<b class="nc">&nbsp;		StringBuilder sb = new StringBuilder(path);</b>
<b class="nc">&nbsp;		int pos = 0;</b>
<b class="nc">&nbsp;		for (String encoding : encodings) {</b>
<b class="nc">&nbsp;			int idx = sb.indexOf(encoding, pos);</b>
<b class="nc">&nbsp;			String decoded = normalizePctEncoding(encoding);</b>
<b class="nc">&nbsp;			sb.replace(idx, idx + encoding.length(), decoded);</b>
<b class="nc">&nbsp;			pos += decoded.length();</b>
&nbsp;		}
<b class="nc">&nbsp;		return Normalizer.normalize(sb, Normalizer.Form.NFC);</b>
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	private String[] listPctEncodings(String path) {
<b class="nc">&nbsp;		if (path == null || path.indexOf(&#39;%&#39;) &lt; 0) {</b>
<b class="nc">&nbsp;			return new String[0];</b>
&nbsp;		}
<b class="nc">&nbsp;		List&lt;String&gt; list = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;		int pct = -1;</b>
<b class="nc">&nbsp;		while ((pct = path.indexOf(&#39;%&#39;, pct + 1)) &gt; 0) {</b>
<b class="nc">&nbsp;			int start = pct;</b>
&nbsp;			// optimize common encoded members by grouping separately
<b class="nc">&nbsp;			if (Arrays.binarySearch(common_pct, path.substring(pct, pct + 3)) &lt; 0) {</b>
<b class="nc">&nbsp;				while (pct + 3 &lt; path.length() &amp;&amp; path.charAt(pct + 3) == &#39;%&#39;</b>
<b class="nc">&nbsp;						&amp;&amp; Arrays.binarySearch(common_pct, path.substring(pct + 3, pct + 6)) &lt; 0) {</b>
<b class="nc">&nbsp;					pct += 3;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			list.add(path.substring(start, pct + 3));</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return list.toArray(new String[0]);</b>
&nbsp;	}
&nbsp;
&nbsp;	private String normalizePctEncoding(String encoded) {
<b class="nc">&nbsp;		int cidx = Arrays.binarySearch(common_pct, encoded);</b>
<b class="nc">&nbsp;		if (cidx &gt;= 0 &amp;&amp; isMember(unreserved, common[cidx])) {</b>
<b class="nc">&nbsp;			return new String(Character.toChars(common[cidx])); // quickly decode unreserved encodings</b>
<b class="nc">&nbsp;		} else if (cidx &gt;= 0) {</b>
<b class="nc">&nbsp;			return encoded; // pass through reserved encodings</b>
&nbsp;		}
<b class="nc">&nbsp;		String decoded = pctDecode(encoded);</b>
<b class="nc">&nbsp;		String ns = Normalizer.normalize(decoded, Normalizer.Form.NFC);</b>
<b class="nc">&nbsp;		StringBuilder sb = new StringBuilder(ns.length());</b>
<b class="nc">&nbsp;		for (int c = 0, n = ns.codePointCount(0, ns.length()); c &lt; n; c++) {</b>
<b class="nc">&nbsp;			int chr = ns.codePointAt(ns.offsetByCodePoints(0, c));</b>
<b class="nc">&nbsp;			if (isMember(unreserved, chr)) {</b>
<b class="nc">&nbsp;				sb.appendCodePoint(chr);</b>
<b class="nc">&nbsp;			} else if (n == 1) {</b>
<b class="nc">&nbsp;				return toUpperCase(encoded);</b>
&nbsp;			} else {
<b class="nc">&nbsp;				sb.append(pctEncode(chr));</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		return sb.toString();</b>
&nbsp;	}
&nbsp;
&nbsp;	private String pctDecode(String encoded) {
<b class="nc">&nbsp;		return URLDecoder.decode(encoded, StandardCharsets.UTF_8);</b>
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	private String pctEncode(int chr) {
<b class="nc">&nbsp;		return URLEncoder.encode(new String(Character.toChars(chr)), StandardCharsets.UTF_8);</b>
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Normalizes the path of this URI if it has one. Normalizing a path means that any unnecessary &#39;.&#39; and &#39;..&#39;
&nbsp;	 * segments are removed. For example, the URI &lt;var&gt;http://server.com/a/b/../c/./d&lt;/var&gt; would be normalized to
&nbsp;	 * &lt;var&gt;http://server.com/a/c/d&lt;/var&gt;. A URI doens&#39;t have a path if it is opaque.
&nbsp;	 */
&nbsp;	private String pathSegmentNormalization(String _path) {
<b class="pc">&nbsp;		if (_path == null) {</b>
<b class="nc">&nbsp;			return null;</b>
&nbsp;		}
&nbsp;
&nbsp;		// Remove any &#39;.&#39; segments:
<b class="fc">&nbsp;		_path = _path.replace(&quot;/./&quot;, &quot;/&quot;);</b>
<b class="pc">&nbsp;		if (_path == null) {</b>
<b class="nc">&nbsp;			return null;</b>
&nbsp;		}
<b class="pc">&nbsp;		if (_path.startsWith(&quot;./&quot;)) {</b>
&nbsp;			// Remove both characters
<b class="nc">&nbsp;			_path = _path.substring(2);</b>
&nbsp;		}
&nbsp;
<b class="pc">&nbsp;		if (_path.endsWith(&quot;/.&quot;)) {</b>
&nbsp;			// Remove only the last dot, not the slash!
<b class="nc">&nbsp;			_path = _path.substring(0, _path.length() - 1);</b>
&nbsp;		}
&nbsp;
<b class="pc">&nbsp;		if (!_path.contains(&quot;/../&quot;) &amp;&amp; !_path.endsWith(&quot;/..&quot;)) {</b>
&nbsp;			// There are no &#39;..&#39; segments that can be removed. We&#39;re done and
&nbsp;			// don&#39;t have to execute the time-consuming code following this
&nbsp;			// if-statement
<b class="fc">&nbsp;			return _path;</b>
&nbsp;		}
&nbsp;
&nbsp;		// Split the path into its segments
&nbsp;
<b class="fc">&nbsp;		LinkedList&lt;String&gt; segments = new LinkedList&lt;&gt;(Arrays.asList(_path.split(&quot;/&quot;)));</b>
<b class="pc">&nbsp;		if (_path.startsWith(&quot;/&quot;)) {</b>
<b class="fc">&nbsp;			segments.remove(0);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		boolean lastSegmentRemoved = false;</b>
&nbsp;
&nbsp;		// Remove all unnecessary &#39;..&#39; segments
&nbsp;
<b class="fc">&nbsp;		int i = 1;</b>
<b class="fc">&nbsp;		while (i &lt; segments.size()) {</b>
<b class="fc">&nbsp;			String segment = segments.get(i);</b>
&nbsp;
<b class="pc">&nbsp;			if (segment.equals(&quot;..&quot;)) {</b>
<b class="fc">&nbsp;				String prevSegment = segments.get(i - 1);</b>
&nbsp;
<b class="pc">&nbsp;				if (prevSegment.equals(&quot;..&quot;)) {</b>
&nbsp;					// two consecutive &#39;..&#39; segments at position i-1 and i,
&nbsp;					// continue at i + 2
<b class="nc">&nbsp;					i += 2;</b>
&nbsp;				} else {
&nbsp;					// Bingo! Remove these two segments...
<b class="pc">&nbsp;					if (i == segments.size() - 1) {</b>
<b class="nc">&nbsp;						lastSegmentRemoved = true;</b>
&nbsp;					}
&nbsp;
<b class="fc">&nbsp;					segments.remove(i);</b>
<b class="fc">&nbsp;					segments.remove(i - 1);</b>
&nbsp;
&nbsp;					// ...and continue at position (i + 1 - 2) == (i - 1)...
&nbsp;
&nbsp;					// ...but only if i &gt; 1, position 0 does not need to be
&nbsp;					// checked.
&nbsp;
<b class="pc">&nbsp;					if (i &gt; 1) {</b>
<b class="nc">&nbsp;						i--;</b>
&nbsp;					}
&nbsp;				}
<b class="fc">&nbsp;			} else {</b>
&nbsp;				// Not a &#39;..&#39; segment, check next
<b class="nc">&nbsp;				i++;</b>
&nbsp;			}
<b class="fc">&nbsp;		}</b>
&nbsp;
<b class="pc">&nbsp;		while (!segments.isEmpty() &amp;&amp; (segments.get(0).equals(&quot;..&quot;) || segments.get(0).equals(&quot;.&quot;))) {</b>
<b class="nc">&nbsp;			segments.remove(0);</b>
&nbsp;		}
&nbsp;
&nbsp;		// Construct the normalized path
&nbsp;
<b class="fc">&nbsp;		StringBuilder newPath = new StringBuilder(_path.length());</b>
&nbsp;
<b class="pc">&nbsp;		if (_path.startsWith(&quot;/&quot;)) {</b>
<b class="fc">&nbsp;			newPath.append(&#39;/&#39;);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		int segmentCount = segments.size();</b>
<b class="pc">&nbsp;		for (i = 0; i &lt; segmentCount - 1; i++) {</b>
<b class="nc">&nbsp;			newPath.append(segments.get(i));</b>
<b class="nc">&nbsp;			newPath.append(&#39;/&#39;);</b>
&nbsp;		}
&nbsp;
<b class="pc">&nbsp;		if (segmentCount &gt; 0) {</b>
<b class="fc">&nbsp;			String lastSegment = segments.get(segmentCount - 1);</b>
<b class="fc">&nbsp;			newPath.append(lastSegment);</b>
&nbsp;
<b class="pc">&nbsp;			if (_path.endsWith(&quot;/&quot;) || lastSegmentRemoved) {</b>
<b class="nc">&nbsp;				newPath.append(&#39;/&#39;);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return newPath.toString();</b>
&nbsp;	}
&nbsp;
&nbsp;	private String relativizePath(String absolute) {
<b class="nc">&nbsp;		assert absolute.charAt(0) == &#39;/&#39;;</b>
<b class="nc">&nbsp;		String[] paths = path.split(&quot;/&quot;, Integer.MAX_VALUE);</b>
<b class="nc">&nbsp;		String[] seg = absolute.split(&quot;/&quot;, Integer.MAX_VALUE);</b>
&nbsp;		// first segment is empty string
<b class="nc">&nbsp;		int same = 1;</b>
<b class="nc">&nbsp;		while (same &lt; paths.length &amp;&amp; same &lt; seg.length - 1 &amp;&amp; paths[same].equals(seg[same])) {</b>
<b class="nc">&nbsp;			same++;</b>
&nbsp;		}
<b class="nc">&nbsp;		if (same &lt; 2) {</b>
<b class="nc">&nbsp;			return absolute;</b>
&nbsp;		}
<b class="nc">&nbsp;		StringBuilder sb = new StringBuilder();</b>
&nbsp;		// last segment is empty or file name
<b class="nc">&nbsp;		for (int i = same; i &lt; paths.length - 1; i++) {</b>
<b class="nc">&nbsp;			sb.append(&quot;../&quot;);</b>
&nbsp;		}
<b class="nc">&nbsp;		for (int i = same; i &lt; seg.length - 1; i++) {</b>
<b class="nc">&nbsp;			sb.append(seg[i]).append(&#39;/&#39;);</b>
&nbsp;		}
<b class="nc">&nbsp;		return sb.append(seg[seg.length - 1]).toString();</b>
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:20</div>
</div>
</body>
</html>
