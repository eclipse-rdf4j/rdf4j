


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > EffectiveTarget</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.sail.shacl.ast.targets</a>
</div>

<h1>Coverage Summary for Class: EffectiveTarget (org.eclipse.rdf4j.sail.shacl.ast.targets)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">EffectiveTarget</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/60)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/126)
  </span>
</td>
</tr>
  <tr>
    <td class="name">EffectiveTarget$ActiveTargetTupleMapper</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EffectiveTarget$EffectiveTargetObject</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EffectiveTarget$Extend</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/74)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/153)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2020 Eclipse RDF4J contributors.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;
&nbsp;package org.eclipse.rdf4j.sail.shacl.ast.targets;
&nbsp;
&nbsp;import java.util.ArrayDeque;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.List;
&nbsp;import java.util.Objects;
&nbsp;import java.util.function.Function;
&nbsp;import java.util.stream.Collectors;
&nbsp;import java.util.stream.IntStream;
&nbsp;import java.util.stream.Stream;
&nbsp;
&nbsp;import org.eclipse.rdf4j.model.Resource;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.ShaclUnsupportedException;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.StatementMatcher;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.Targetable;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.constraintcomponents.ConstraintComponent;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.planNodes.AllTargetsPlanNode;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.planNodes.BindSelect;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.planNodes.ExternalFilterByQuery;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.planNodes.PlanNode;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.planNodes.TupleMapper;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.planNodes.UnBufferedPlanNode;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.planNodes.Unique;
&nbsp;import org.eclipse.rdf4j.sail.shacl.ast.planNodes.ValidationTuple;
&nbsp;import org.eclipse.rdf4j.sail.shacl.wrapper.data.ConnectionsGroup;
&nbsp;import org.eclipse.rdf4j.sail.shacl.wrapper.data.RdfsSubClassOfReasoner;
&nbsp;
<b class="nc">&nbsp;public class EffectiveTarget {</b>
&nbsp;
&nbsp;	public static final String TARGET_VAR_PREFIX = &quot;target_&quot;;
<b class="nc">&nbsp;	public static final String[] TARGET_NAMES = IntStream.range(0, 1000)</b>
<b class="nc">&nbsp;			.mapToObj(i -&gt; TARGET_VAR_PREFIX + String.format(&quot;%010d&quot;, i))</b>
<b class="nc">&nbsp;			.toArray(String[]::new);</b>
&nbsp;	private final ArrayDeque&lt;EffectiveTargetObject&gt; chain;
&nbsp;	private final EffectiveTargetObject optional;
&nbsp;
&nbsp;	public EffectiveTarget(ArrayDeque&lt;Targetable&gt; chain, Targetable optional,
&nbsp;			RdfsSubClassOfReasoner rdfsSubClassOfReasoner,
<b class="nc">&nbsp;			StatementMatcher.StableRandomVariableProvider stableRandomVariableProvider) {</b>
<b class="nc">&nbsp;		int index = 0;</b>
&nbsp;
<b class="nc">&nbsp;		this.chain = new ArrayDeque&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;		EffectiveTargetObject previous = null;</b>
&nbsp;
<b class="nc">&nbsp;		for (Targetable targetable : chain) {</b>
<b class="nc">&nbsp;			EffectiveTargetObject effectiveTargetObject = new EffectiveTargetObject(</b>
<b class="nc">&nbsp;					new StatementMatcher.Variable(getTargetVarName(index++)),</b>
&nbsp;					targetable,
&nbsp;					previous,
&nbsp;					rdfsSubClassOfReasoner,
&nbsp;					stableRandomVariableProvider);
<b class="nc">&nbsp;			previous = effectiveTargetObject;</b>
<b class="nc">&nbsp;			this.chain.addLast(effectiveTargetObject);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;
<b class="nc">&nbsp;		if (optional != null) {</b>
<b class="nc">&nbsp;			this.optional = new EffectiveTargetObject(</b>
<b class="nc">&nbsp;					new StatementMatcher.Variable(getTargetVarName(index)),</b>
&nbsp;					optional,
&nbsp;					previous,
&nbsp;					rdfsSubClassOfReasoner,
&nbsp;					stableRandomVariableProvider);
&nbsp;		} else {
<b class="nc">&nbsp;			this.optional = null;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	private String getTargetVarName(int i) {
<b class="nc">&nbsp;		if (i &lt; TARGET_NAMES.length) {</b>
<b class="nc">&nbsp;			return TARGET_NAMES[i];</b>
&nbsp;		} else {
<b class="nc">&nbsp;			return TARGET_VAR_PREFIX + String.format(&quot;%010d&quot;, i);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public StatementMatcher.Variable getTargetVar() {
<b class="nc">&nbsp;		return chain.getLast().var;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Takes a source plan node and for every entry it extends the target chain with all targets that follow.
&nbsp;	// If the target chain is [type foaf:Person / foaf:knows ] and [ex:Peter] is in the source, this will effectively
&nbsp;	// retrieve all &quot;ex:Peter foaf:knows ?extension&quot;
&nbsp;	public PlanNode extend(PlanNode source, ConnectionsGroup connectionsGroup, Resource[] dataGraph,
&nbsp;			ConstraintComponent.Scope scope,
&nbsp;			Extend direction, boolean includePropertyShapeValues, Function&lt;PlanNode, PlanNode&gt; filter) {
&nbsp;
<b class="nc">&nbsp;		if (source instanceof AllTargetsPlanNode &amp;&amp; !includePropertyShapeValues) {</b>
<b class="nc">&nbsp;			PlanNode allTargets = getAllTargets(connectionsGroup, dataGraph, scope);</b>
<b class="nc">&nbsp;			if (filter != null) {</b>
<b class="nc">&nbsp;				allTargets = filter.apply(allTargets);</b>
&nbsp;			}
<b class="nc">&nbsp;			return allTargets;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		List&lt;StatementMatcher.Variable&gt; vars = getVars();</b>
<b class="nc">&nbsp;		if (includePropertyShapeValues) {</b>
<b class="nc">&nbsp;			vars = new ArrayList&lt;&gt;(vars);</b>
<b class="nc">&nbsp;			vars.add(optional.var);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		List&lt;String&gt; varNames = vars.stream().map(StatementMatcher.Variable::getName).collect(Collectors.toList());</b>
&nbsp;
<b class="nc">&nbsp;		if (varNames.size() == 1) {</b>
&nbsp;
<b class="nc">&nbsp;			PlanNode parent = new TupleMapper(source,</b>
&nbsp;					new ActiveTargetTupleMapper(scope, includePropertyShapeValues, dataGraph));
&nbsp;
<b class="nc">&nbsp;			if (filter != null) {</b>
<b class="nc">&nbsp;				parent = filter.apply(parent);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			return connectionsGroup</b>
<b class="nc">&nbsp;					.getCachedNodeFor(getTargetFilter(connectionsGroup, dataGraph, Unique.getInstance(parent, false)));</b>
&nbsp;		} else {
<b class="nc">&nbsp;			String query = getQuery(includePropertyShapeValues);</b>
&nbsp;
<b class="nc">&nbsp;			PlanNode parent = new BindSelect(connectionsGroup.getBaseConnection(), dataGraph, query, vars, source,</b>
&nbsp;					varNames, scope,
&nbsp;					1000, direction, includePropertyShapeValues);
&nbsp;
<b class="nc">&nbsp;			if (filter != null) {</b>
<b class="nc">&nbsp;				parent = connectionsGroup.getCachedNodeFor(parent);</b>
<b class="nc">&nbsp;				parent = filter.apply(parent);</b>
<b class="nc">&nbsp;				parent = Unique.getInstance(parent, true);</b>
<b class="nc">&nbsp;				return parent;</b>
&nbsp;			} else {
<b class="nc">&nbsp;				return connectionsGroup.getCachedNodeFor(</b>
<b class="nc">&nbsp;						Unique.getInstance(parent, true));</b>
&nbsp;			}
&nbsp;
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private List&lt;StatementMatcher.Variable&gt; getVars() {
<b class="nc">&nbsp;		return chain.stream().map(t -&gt; t.var).collect(Collectors.toList());</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * @return false if it is 100% sure that this will not match, else returns true
&nbsp;	 */
&nbsp;	public boolean couldMatch(ConnectionsGroup connectionsGroup, Resource[] dataGraph) {
&nbsp;
<b class="nc">&nbsp;		boolean hasTargetNode = Stream.concat(chain.stream(), getOptionalAsStream())</b>
<b class="nc">&nbsp;				.anyMatch(e -&gt; e.target instanceof TargetNode);</b>
<b class="nc">&nbsp;		if (hasTargetNode) {</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return Stream.concat(chain.stream(), getOptionalAsStream())</b>
<b class="nc">&nbsp;				.flatMap(EffectiveTargetObject::getStatementMatcher)</b>
<b class="nc">&nbsp;				.anyMatch(</b>
<b class="nc">&nbsp;						currentStatementPattern -&gt; connectionsGroup.getAddedStatements()</b>
<b class="nc">&nbsp;								.hasStatement(currentStatementPattern.getSubjectValue(),</b>
<b class="nc">&nbsp;										currentStatementPattern.getPredicateValue(),</b>
<b class="nc">&nbsp;										currentStatementPattern.getObjectValue(), false, dataGraph)</b>
<b class="nc">&nbsp;								|| connectionsGroup.getRemovedStatements()</b>
<b class="nc">&nbsp;										.hasStatement(currentStatementPattern.getSubjectValue(),</b>
<b class="nc">&nbsp;												currentStatementPattern.getPredicateValue(),</b>
<b class="nc">&nbsp;												currentStatementPattern.getObjectValue(), false, dataGraph)</b>
&nbsp;
&nbsp;				);
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	private Stream&lt;EffectiveTargetObject&gt; getOptionalAsStream() {
&nbsp;		Stream&lt;EffectiveTargetObject&gt; optional;
<b class="nc">&nbsp;		if (this.optional != null) {</b>
<b class="nc">&nbsp;			optional = Stream.of(this.optional);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			optional = Stream.empty();</b>
&nbsp;		}
<b class="nc">&nbsp;		return optional;</b>
&nbsp;	}
&nbsp;
&nbsp;	public PlanNode getAllTargets(ConnectionsGroup connectionsGroup, Resource[] dataGraph,
&nbsp;			ConstraintComponent.Scope scope) {
<b class="nc">&nbsp;		return new AllTargetsPlanNode(connectionsGroup, dataGraph, chain, getVars(), scope);</b>
&nbsp;	}
&nbsp;
&nbsp;	public PlanNode getPlanNode(ConnectionsGroup connectionsGroup, Resource[] dataGraph,
&nbsp;			ConstraintComponent.Scope scope,
&nbsp;			boolean includeTargetsAffectedByRemoval, Function&lt;PlanNode, PlanNode&gt; filter) {
<b class="nc">&nbsp;		assert !chain.isEmpty();</b>
&nbsp;
<b class="nc">&nbsp;		includeTargetsAffectedByRemoval = includeTargetsAffectedByRemoval &amp;&amp; connectionsGroup.getStats().hasRemoved();</b>
&nbsp;
<b class="nc">&nbsp;		if (chain.size() == 1 &amp;&amp; !(includeTargetsAffectedByRemoval &amp;&amp; optional != null)) {</b>
&nbsp;			// simple chain
&nbsp;
<b class="nc">&nbsp;			EffectiveTargetObject last = chain.getLast();</b>
<b class="nc">&nbsp;			if (last.target instanceof Target) {</b>
&nbsp;
<b class="nc">&nbsp;				if (filter != null) {</b>
<b class="nc">&nbsp;					return filter.apply(</b>
&nbsp;							connectionsGroup
<b class="nc">&nbsp;									.getCachedNodeFor(((Target) last.target)</b>
<b class="nc">&nbsp;											.getAdded(connectionsGroup, dataGraph, scope)));</b>
&nbsp;				} else {
<b class="nc">&nbsp;					return connectionsGroup</b>
<b class="nc">&nbsp;							.getCachedNodeFor(((Target) last.target)</b>
<b class="nc">&nbsp;									.getAdded(connectionsGroup, dataGraph, scope));</b>
&nbsp;				}
&nbsp;
&nbsp;			} else {
<b class="nc">&nbsp;				throw new ShaclUnsupportedException(</b>
<b class="nc">&nbsp;						&quot;Unknown target in chain is type: &quot; + last.getClass().getSimpleName());</b>
&nbsp;			}
&nbsp;
&nbsp;		} else {
&nbsp;			// complex chain
&nbsp;
<b class="nc">&nbsp;			List&lt;StatementMatcher&gt; statementMatchers = chain.stream()</b>
<b class="nc">&nbsp;					.flatMap(EffectiveTargetObject::getStatementMatcher)</b>
<b class="nc">&nbsp;					.collect(Collectors.toList());</b>
&nbsp;
<b class="nc">&nbsp;			String query = chain.stream()</b>
<b class="nc">&nbsp;					.map(EffectiveTargetObject::getQueryFragment)</b>
<b class="nc">&nbsp;					.reduce((a, b) -&gt; a + &quot;\n&quot; + b)</b>
<b class="nc">&nbsp;					.orElse(&quot;&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			List&lt;StatementMatcher&gt; statementMatchersRemoval = optional != null</b>
<b class="nc">&nbsp;					? optional.getStatementMatcher().collect(Collectors.toCollection(ArrayList::new))</b>
<b class="nc">&nbsp;					: new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;			if (chain.getFirst().target instanceof RSXTargetShape) {</b>
<b class="nc">&nbsp;				statementMatchersRemoval.addAll(chain.getFirst().getStatementMatcher().collect(Collectors.toList()));</b>
<b class="nc">&nbsp;				includeTargetsAffectedByRemoval = true;</b>
&nbsp;			}
&nbsp;
&nbsp;			TargetChainRetriever targetChainRetriever;
<b class="nc">&nbsp;			if (includeTargetsAffectedByRemoval) {</b>
<b class="nc">&nbsp;				targetChainRetriever = new TargetChainRetriever(</b>
&nbsp;						connectionsGroup,
&nbsp;						dataGraph, statementMatchers,
&nbsp;						statementMatchersRemoval,
&nbsp;						query,
<b class="nc">&nbsp;						getVars(),</b>
&nbsp;						scope
&nbsp;				);
&nbsp;			} else {
<b class="nc">&nbsp;				targetChainRetriever = new TargetChainRetriever(</b>
&nbsp;						connectionsGroup,
&nbsp;						dataGraph, statementMatchers,
&nbsp;						null,
&nbsp;						query,
<b class="nc">&nbsp;						getVars(),</b>
&nbsp;						scope
&nbsp;				);
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (filter != null) {</b>
<b class="nc">&nbsp;				return connectionsGroup.getCachedNodeFor(Unique.getInstance(filter.apply(targetChainRetriever), true));</b>
&nbsp;			} else {
<b class="nc">&nbsp;				return connectionsGroup.getCachedNodeFor(Unique.getInstance(targetChainRetriever, true));</b>
&nbsp;			}
&nbsp;
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	public PlanNode getTargetFilter(ConnectionsGroup connectionsGroup, Resource[] dataGraph,
&nbsp;			PlanNode parent) {
&nbsp;
<b class="nc">&nbsp;		EffectiveTargetObject last = chain.getLast();</b>
&nbsp;
<b class="nc">&nbsp;		if (chain.size() == 1) {</b>
&nbsp;			// simple chain
&nbsp;
<b class="nc">&nbsp;			if (last.target instanceof Target) {</b>
<b class="nc">&nbsp;				return ((Target) last.target).getTargetFilter(connectionsGroup, dataGraph, parent);</b>
&nbsp;			} else {
<b class="nc">&nbsp;				throw new ShaclUnsupportedException(</b>
<b class="nc">&nbsp;						&quot;Unknown target in chain is type: &quot; + last.getClass().getSimpleName());</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		String query = chain.stream()</b>
<b class="nc">&nbsp;				.map(EffectiveTargetObject::getQueryFragment)</b>
<b class="nc">&nbsp;				.reduce((a, b) -&gt; a + &quot;\n&quot; + b)</b>
<b class="nc">&nbsp;				.orElse(&quot;&quot;);</b>
&nbsp;
&nbsp;		// TODO: this is a slow way to solve this problem! We should use bulk operations.
<b class="nc">&nbsp;		return new ExternalFilterByQuery(connectionsGroup.getBaseConnection(), dataGraph, parent, query, last.var,</b>
&nbsp;				ValidationTuple::getActiveTarget)
<b class="nc">&nbsp;						.getTrueNode(UnBufferedPlanNode.class);</b>
&nbsp;	}
&nbsp;
&nbsp;	public String getQuery(boolean includeOptional) {
&nbsp;
&nbsp;		ArrayDeque&lt;EffectiveTargetObject&gt; chain;
&nbsp;
<b class="nc">&nbsp;		if (includeOptional) {</b>
<b class="nc">&nbsp;			chain = new ArrayDeque&lt;&gt;(this.chain);</b>
<b class="nc">&nbsp;			chain.addLast(optional);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			chain = this.chain;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return chain.stream()</b>
<b class="nc">&nbsp;				.map(EffectiveTargetObject::getQueryFragment)</b>
<b class="nc">&nbsp;				.reduce((a, b) -&gt; a + &quot;\n&quot; + b)</b>
<b class="nc">&nbsp;				.orElse(&quot;&quot;);</b>
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	public List&lt;StatementMatcher.Variable&gt; getAllTargetVariables() {
<b class="nc">&nbsp;		return chain.stream()</b>
<b class="nc">&nbsp;				.map(c -&gt; c.var)</b>
<b class="nc">&nbsp;				.collect(Collectors.toCollection(ArrayList::new));</b>
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public enum Extend {</b>
<b class="nc">&nbsp;		left,</b>
<b class="nc">&nbsp;		right</b>
&nbsp;	}
&nbsp;
&nbsp;	public static class EffectiveTargetObject {
&nbsp;
&nbsp;		private final StatementMatcher.Variable var;
&nbsp;		private final Targetable target;
&nbsp;		private final EffectiveTargetObject prev;
&nbsp;		private final RdfsSubClassOfReasoner rdfsSubClassOfReasoner;
&nbsp;		private final StatementMatcher.StableRandomVariableProvider stableRandomVariableProvider;
&nbsp;
&nbsp;		public EffectiveTargetObject(StatementMatcher.Variable var, Targetable target, EffectiveTargetObject prev,
&nbsp;				RdfsSubClassOfReasoner rdfsSubClassOfReasoner,
<b class="nc">&nbsp;				StatementMatcher.StableRandomVariableProvider stableRandomVariableProvider) {</b>
<b class="nc">&nbsp;			this.var = var;</b>
<b class="nc">&nbsp;			this.target = target;</b>
<b class="nc">&nbsp;			this.prev = prev;</b>
<b class="nc">&nbsp;			this.rdfsSubClassOfReasoner = rdfsSubClassOfReasoner;</b>
<b class="nc">&nbsp;			this.stableRandomVariableProvider = stableRandomVariableProvider;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Stream&lt;StatementMatcher&gt; getStatementMatcher() {
<b class="nc">&nbsp;			if (prev == null) {</b>
<b class="nc">&nbsp;				return target.getStatementMatcher(null, var, rdfsSubClassOfReasoner);</b>
&nbsp;			} else {
<b class="nc">&nbsp;				return target.getStatementMatcher(prev.var, var, rdfsSubClassOfReasoner);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		public String getQueryFragment() {
<b class="nc">&nbsp;			if (prev == null) {</b>
<b class="nc">&nbsp;				return target.getTargetQueryFragment(null, var, rdfsSubClassOfReasoner, stableRandomVariableProvider);</b>
&nbsp;			} else {
<b class="nc">&nbsp;				return target.getTargetQueryFragment(prev.var, var, rdfsSubClassOfReasoner,</b>
&nbsp;						stableRandomVariableProvider);
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	static class ActiveTargetTupleMapper implements Function&lt;ValidationTuple, ValidationTuple&gt; {
&nbsp;		private final ConstraintComponent.Scope scope;
&nbsp;		private final boolean includePropertyShapeValues;
&nbsp;		private final Resource[] contexts;
&nbsp;
&nbsp;		public ActiveTargetTupleMapper(ConstraintComponent.Scope scope, boolean includePropertyShapeValues,
<b class="nc">&nbsp;				Resource[] contexts) {</b>
<b class="nc">&nbsp;			this.scope = scope;</b>
<b class="nc">&nbsp;			this.includePropertyShapeValues = includePropertyShapeValues;</b>
<b class="nc">&nbsp;			this.contexts = contexts;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public ValidationTuple apply(ValidationTuple validationTuple) {
<b class="nc">&nbsp;			return new ValidationTuple(validationTuple.getActiveTarget(), scope, includePropertyShapeValues, contexts);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public boolean equals(Object o) {
<b class="nc">&nbsp;			if (this == o) {</b>
<b class="nc">&nbsp;				return true;</b>
&nbsp;			}
<b class="nc">&nbsp;			if (o == null || getClass() != o.getClass()) {</b>
<b class="nc">&nbsp;				return false;</b>
&nbsp;			}
<b class="nc">&nbsp;			ActiveTargetTupleMapper that = (ActiveTargetTupleMapper) o;</b>
<b class="nc">&nbsp;			return includePropertyShapeValues == that.includePropertyShapeValues &amp;&amp; scope == that.scope;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public int hashCode() {
<b class="nc">&nbsp;			return Objects.hash(scope, includePropertyShapeValues);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:56</div>
</div>
</body>
</html>
