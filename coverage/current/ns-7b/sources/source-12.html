


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > UpdateExprBuilder</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.query.parser.sparql</a>
</div>

<h1>Coverage Summary for Class: UpdateExprBuilder (org.eclipse.rdf4j.query.parser.sparql)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">UpdateExprBuilder</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.2%
  </span>
  <span class="absValue">
    (15/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    82.3%
  </span>
  <span class="absValue">
    (51/62)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.8%
  </span>
  <span class="absValue">
    (144/164)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;package org.eclipse.rdf4j.query.parser.sparql;
&nbsp;
&nbsp;import java.util.Map;
&nbsp;
&nbsp;import org.eclipse.rdf4j.common.annotation.InternalUseOnly;
&nbsp;import org.eclipse.rdf4j.model.ValueFactory;
&nbsp;import org.eclipse.rdf4j.query.algebra.Add;
&nbsp;import org.eclipse.rdf4j.query.algebra.Clear;
&nbsp;import org.eclipse.rdf4j.query.algebra.Copy;
&nbsp;import org.eclipse.rdf4j.query.algebra.Create;
&nbsp;import org.eclipse.rdf4j.query.algebra.DeleteData;
&nbsp;import org.eclipse.rdf4j.query.algebra.Extension;
&nbsp;import org.eclipse.rdf4j.query.algebra.ExtensionElem;
&nbsp;import org.eclipse.rdf4j.query.algebra.InsertData;
&nbsp;import org.eclipse.rdf4j.query.algebra.Load;
&nbsp;import org.eclipse.rdf4j.query.algebra.Modify;
&nbsp;import org.eclipse.rdf4j.query.algebra.Move;
&nbsp;import org.eclipse.rdf4j.query.algebra.StatementPattern.Scope;
&nbsp;import org.eclipse.rdf4j.query.algebra.TripleRef;
&nbsp;import org.eclipse.rdf4j.query.algebra.TupleExpr;
&nbsp;import org.eclipse.rdf4j.query.algebra.UpdateExpr;
&nbsp;import org.eclipse.rdf4j.query.algebra.ValueConstant;
&nbsp;import org.eclipse.rdf4j.query.algebra.ValueExpr;
&nbsp;import org.eclipse.rdf4j.query.algebra.Var;
&nbsp;import org.eclipse.rdf4j.query.parser.sparql.ast.ASTAdd;
&nbsp;import org.eclipse.rdf4j.query.parser.sparql.ast.ASTClear;
&nbsp;import org.eclipse.rdf4j.query.parser.sparql.ast.ASTCopy;
&nbsp;import org.eclipse.rdf4j.query.parser.sparql.ast.ASTCreate;
&nbsp;import org.eclipse.rdf4j.query.parser.sparql.ast.ASTDeleteClause;
&nbsp;import org.eclipse.rdf4j.query.parser.sparql.ast.ASTDeleteData;
&nbsp;import org.eclipse.rdf4j.query.parser.sparql.ast.ASTDeleteWhere;
&nbsp;import org.eclipse.rdf4j.query.parser.sparql.ast.ASTDrop;
&nbsp;import org.eclipse.rdf4j.query.parser.sparql.ast.ASTGraphOrDefault;
&nbsp;import org.eclipse.rdf4j.query.parser.sparql.ast.ASTGraphRefAll;
&nbsp;import org.eclipse.rdf4j.query.parser.sparql.ast.ASTInsertClause;
&nbsp;import org.eclipse.rdf4j.query.parser.sparql.ast.ASTInsertData;
&nbsp;import org.eclipse.rdf4j.query.parser.sparql.ast.ASTLoad;
&nbsp;import org.eclipse.rdf4j.query.parser.sparql.ast.ASTModify;
&nbsp;import org.eclipse.rdf4j.query.parser.sparql.ast.ASTMove;
&nbsp;import org.eclipse.rdf4j.query.parser.sparql.ast.ASTQuadsNotTriples;
&nbsp;import org.eclipse.rdf4j.query.parser.sparql.ast.ASTTripleRef;
&nbsp;import org.eclipse.rdf4j.query.parser.sparql.ast.ASTUnparsedQuadDataBlock;
&nbsp;import org.eclipse.rdf4j.query.parser.sparql.ast.ASTUpdate;
&nbsp;import org.eclipse.rdf4j.query.parser.sparql.ast.ASTWhereClause;
&nbsp;import org.eclipse.rdf4j.query.parser.sparql.ast.VisitorException;
&nbsp;
&nbsp;/**
&nbsp; * Extension of TupleExprBuilder that builds Update Expressions.
&nbsp; *
&nbsp; * @author Jeen Broekstra
&nbsp; * @apiNote This feature is for internal use only: its existence, signature or behavior may change without warning from
&nbsp; *          one release to the next.
&nbsp; */
&nbsp;@InternalUseOnly
&nbsp;public class UpdateExprBuilder extends TupleExprBuilder {
&nbsp;
&nbsp;	TupleExpr where;
&nbsp;
&nbsp;	/**
&nbsp;	 * @param valueFactory
&nbsp;	 */
&nbsp;	public UpdateExprBuilder(ValueFactory valueFactory) {
<b class="fc">&nbsp;		super(valueFactory);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public UpdateExpr visit(ASTUpdate node, Object data) throws VisitorException {
<b class="nc">&nbsp;		if (node instanceof ASTModify) {</b>
<b class="nc">&nbsp;			return this.visit((ASTModify) node, data);</b>
<b class="nc">&nbsp;		} else if (node instanceof ASTInsertData) {</b>
<b class="nc">&nbsp;			return this.visit((ASTInsertData) node, data);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return null;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public InsertData visit(ASTInsertData node, Object data) throws VisitorException {
<b class="fc">&nbsp;		ASTUnparsedQuadDataBlock dataBlock = node.jjtGetChild(ASTUnparsedQuadDataBlock.class);</b>
<b class="fc">&nbsp;		InsertData insertData = new InsertData(dataBlock.getDataBlock());</b>
&nbsp;
<b class="fc">&nbsp;		insertData.setLineNumberOffset(dataBlock.getAddedDefaultPrefixes());</b>
<b class="fc">&nbsp;		return insertData;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public DeleteData visit(ASTDeleteData node, Object data) throws VisitorException {
&nbsp;
<b class="fc">&nbsp;		ASTUnparsedQuadDataBlock dataBlock = node.jjtGetChild(ASTUnparsedQuadDataBlock.class);</b>
<b class="fc">&nbsp;		DeleteData deleteData = new DeleteData(dataBlock.getDataBlock());</b>
&nbsp;
<b class="fc">&nbsp;		deleteData.setLineNumberOffset(dataBlock.getAddedDefaultPrefixes());</b>
<b class="fc">&nbsp;		return deleteData;</b>
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public TupleExpr visit(ASTQuadsNotTriples node, Object data) throws VisitorException {
<b class="fc">&nbsp;		GraphPattern parentGP = graphPattern;</b>
<b class="fc">&nbsp;		graphPattern = new GraphPattern();</b>
&nbsp;
<b class="fc">&nbsp;		ValueExpr contextNode = (ValueExpr) node.jjtGetChild(0).jjtAccept(this, data);</b>
&nbsp;
<b class="fc">&nbsp;		Var contextVar = mapValueExprToVar(contextNode);</b>
<b class="fc">&nbsp;		graphPattern.setContextVar(contextVar);</b>
<b class="fc">&nbsp;		graphPattern.setStatementPatternScope(Scope.NAMED_CONTEXTS);</b>
&nbsp;
<b class="fc">&nbsp;		for (int i = 1; i &lt; node.jjtGetNumChildren(); i++) {</b>
<b class="fc">&nbsp;			node.jjtGetChild(i).jjtAccept(this, data);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		TupleExpr result = graphPattern.buildTupleExpr();</b>
<b class="fc">&nbsp;		parentGP.addRequiredTE(result);</b>
&nbsp;
<b class="fc">&nbsp;		graphPattern = parentGP;</b>
&nbsp;
<b class="fc">&nbsp;		return result;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Modify visit(ASTDeleteWhere node, Object data) throws VisitorException {
&nbsp;		// Collect delete clause triples
<b class="fc">&nbsp;		GraphPattern parentGP = graphPattern;</b>
<b class="fc">&nbsp;		graphPattern = new GraphPattern();</b>
&nbsp;
&nbsp;		// inherit scope &amp; context
<b class="fc">&nbsp;		graphPattern.setStatementPatternScope(parentGP.getStatementPatternScope());</b>
<b class="fc">&nbsp;		graphPattern.setContextVar(parentGP.getContextVar());</b>
&nbsp;
<b class="fc">&nbsp;		for (int i = 0; i &lt; node.jjtGetNumChildren(); i++) {</b>
<b class="fc">&nbsp;			node.jjtGetChild(i).jjtAccept(this, data);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		where = graphPattern.buildTupleExpr();</b>
<b class="fc">&nbsp;		graphPattern = parentGP;</b>
<b class="fc">&nbsp;		Map&lt;String, Object&gt; tripleVars = TripleRefCollector.process(where);</b>
&nbsp;
<b class="fc">&nbsp;		TupleExpr deleteExpr = where.clone();</b>
&nbsp;
&nbsp;		// FIXME we should adapt the grammar so we can avoid doing this
&nbsp;		// post-processing.
<b class="fc">&nbsp;		VarCollector collector = new VarCollector();</b>
<b class="fc">&nbsp;		deleteExpr.visit(collector);</b>
<b class="fc">&nbsp;		for (Var var : collector.getCollectedVars()) {</b>
&nbsp;			// skip vars that are provided by ValueExprTripleRef - added as Extentsion
<b class="pc">&nbsp;			if (tripleVars.containsKey(var.getName())) {</b>
<b class="nc">&nbsp;				continue;</b>
&nbsp;			}
&nbsp;
<b class="pc">&nbsp;			if (var.isAnonymous() &amp;&amp; !var.hasValue()) {</b>
<b class="nc">&nbsp;				throw new VisitorException(&quot;DELETE WHERE may not contain blank nodes&quot;);</b>
&nbsp;			}
<b class="fc">&nbsp;		}</b>
&nbsp;
<b class="fc">&nbsp;		return new Modify(deleteExpr, null, where);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Load visit(ASTLoad node, Object data) throws VisitorException {
&nbsp;
<b class="fc">&nbsp;		ValueConstant source = (ValueConstant) node.jjtGetChild(0).jjtAccept(this, data);</b>
&nbsp;
<b class="fc">&nbsp;		Load load = new Load(source);</b>
<b class="fc">&nbsp;		load.setSilent(node.isSilent());</b>
<b class="fc">&nbsp;		if (node.jjtGetNumChildren() &gt; 1) {</b>
<b class="fc">&nbsp;			ValueConstant graph = (ValueConstant) node.jjtGetChild(1).jjtAccept(this, data);</b>
<b class="fc">&nbsp;			load.setGraph(graph);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return load;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Clear visit(ASTClear node, Object data) throws VisitorException {
<b class="fc">&nbsp;		Clear clear = new Clear();</b>
<b class="fc">&nbsp;		clear.setSilent(node.isSilent());</b>
&nbsp;
<b class="fc">&nbsp;		ASTGraphRefAll graphRef = node.jjtGetChild(ASTGraphRefAll.class);</b>
&nbsp;
<b class="fc">&nbsp;		if (graphRef.jjtGetNumChildren() &gt; 0) {</b>
<b class="fc">&nbsp;			ValueConstant graph = (ValueConstant) graphRef.jjtGetChild(0).jjtAccept(this, data);</b>
<b class="fc">&nbsp;			clear.setGraph(graph);</b>
<b class="fc">&nbsp;		} else {</b>
<b class="fc">&nbsp;			if (graphRef.isDefault()) {</b>
<b class="fc">&nbsp;				clear.setScope(Scope.DEFAULT_CONTEXTS);</b>
<b class="fc">&nbsp;			} else if (graphRef.isNamed()) {</b>
<b class="fc">&nbsp;				clear.setScope(Scope.NAMED_CONTEXTS);</b>
&nbsp;			}
&nbsp;		}
<b class="fc">&nbsp;		return clear;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Clear visit(ASTDrop node, Object data) throws VisitorException {
&nbsp;		// implementing drop as a synonym of clear, in Sesame this is really the
&nbsp;		// same thing, as empty
&nbsp;		// graphs are not recorded.
&nbsp;
<b class="fc">&nbsp;		Clear clear = new Clear();</b>
<b class="fc">&nbsp;		clear.setSilent(node.isSilent());</b>
&nbsp;
<b class="fc">&nbsp;		ASTGraphRefAll graphRef = node.jjtGetChild(ASTGraphRefAll.class);</b>
&nbsp;
<b class="fc">&nbsp;		if (graphRef.jjtGetNumChildren() &gt; 0) {</b>
<b class="fc">&nbsp;			ValueConstant graph = (ValueConstant) graphRef.jjtGetChild(0).jjtAccept(this, data);</b>
<b class="fc">&nbsp;			clear.setGraph(graph);</b>
<b class="fc">&nbsp;		} else {</b>
<b class="fc">&nbsp;			if (graphRef.isDefault()) {</b>
<b class="fc">&nbsp;				clear.setScope(Scope.DEFAULT_CONTEXTS);</b>
<b class="fc">&nbsp;			} else if (graphRef.isNamed()) {</b>
<b class="fc">&nbsp;				clear.setScope(Scope.NAMED_CONTEXTS);</b>
&nbsp;			}
&nbsp;		}
<b class="fc">&nbsp;		return clear;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Create visit(ASTCreate node, Object data) throws VisitorException {
<b class="fc">&nbsp;		ValueConstant graph = (ValueConstant) node.jjtGetChild(0).jjtAccept(this, data);</b>
&nbsp;
<b class="fc">&nbsp;		Create create = new Create(graph);</b>
<b class="fc">&nbsp;		create.setSilent(node.isSilent());</b>
<b class="fc">&nbsp;		return create;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Copy visit(ASTCopy node, Object data) throws VisitorException {
<b class="fc">&nbsp;		Copy copy = new Copy();</b>
<b class="fc">&nbsp;		copy.setSilent(node.isSilent());</b>
&nbsp;
<b class="fc">&nbsp;		ASTGraphOrDefault sourceNode = (ASTGraphOrDefault) node.jjtGetChild(0);</b>
<b class="fc">&nbsp;		if (sourceNode.jjtGetNumChildren() &gt; 0) {</b>
<b class="fc">&nbsp;			ValueConstant sourceGraph = (ValueConstant) sourceNode.jjtGetChild(0).jjtAccept(this, data);</b>
<b class="fc">&nbsp;			copy.setSourceGraph(sourceGraph);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		ASTGraphOrDefault destinationNode = (ASTGraphOrDefault) node.jjtGetChild(1);</b>
<b class="fc">&nbsp;		if (destinationNode.jjtGetNumChildren() &gt; 0) {</b>
<b class="fc">&nbsp;			ValueConstant destinationGraph = (ValueConstant) destinationNode.jjtGetChild(0).jjtAccept(this, data);</b>
<b class="fc">&nbsp;			copy.setDestinationGraph(destinationGraph);</b>
&nbsp;		}
<b class="fc">&nbsp;		return copy;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Move visit(ASTMove node, Object data) throws VisitorException {
<b class="fc">&nbsp;		Move move = new Move();</b>
<b class="fc">&nbsp;		move.setSilent(node.isSilent());</b>
&nbsp;
<b class="fc">&nbsp;		ASTGraphOrDefault sourceNode = (ASTGraphOrDefault) node.jjtGetChild(0);</b>
<b class="fc">&nbsp;		if (sourceNode.jjtGetNumChildren() &gt; 0) {</b>
<b class="fc">&nbsp;			ValueConstant sourceGraph = (ValueConstant) sourceNode.jjtGetChild(0).jjtAccept(this, data);</b>
<b class="fc">&nbsp;			move.setSourceGraph(sourceGraph);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		ASTGraphOrDefault destinationNode = (ASTGraphOrDefault) node.jjtGetChild(1);</b>
<b class="fc">&nbsp;		if (destinationNode.jjtGetNumChildren() &gt; 0) {</b>
<b class="fc">&nbsp;			ValueConstant destinationGraph = (ValueConstant) destinationNode.jjtGetChild(0).jjtAccept(this, data);</b>
<b class="fc">&nbsp;			move.setDestinationGraph(destinationGraph);</b>
&nbsp;		}
<b class="fc">&nbsp;		return move;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Add visit(ASTAdd node, Object data) throws VisitorException {
<b class="fc">&nbsp;		Add add = new Add();</b>
<b class="fc">&nbsp;		add.setSilent(node.isSilent());</b>
&nbsp;
<b class="fc">&nbsp;		ASTGraphOrDefault sourceNode = (ASTGraphOrDefault) node.jjtGetChild(0);</b>
<b class="fc">&nbsp;		if (sourceNode.jjtGetNumChildren() &gt; 0) {</b>
<b class="fc">&nbsp;			ValueConstant sourceGraph = (ValueConstant) sourceNode.jjtGetChild(0).jjtAccept(this, data);</b>
<b class="fc">&nbsp;			add.setSourceGraph(sourceGraph);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		ASTGraphOrDefault destinationNode = (ASTGraphOrDefault) node.jjtGetChild(1);</b>
<b class="fc">&nbsp;		if (destinationNode.jjtGetNumChildren() &gt; 0) {</b>
<b class="fc">&nbsp;			ValueConstant destinationGraph = (ValueConstant) destinationNode.jjtGetChild(0).jjtAccept(this, data);</b>
<b class="fc">&nbsp;			add.setDestinationGraph(destinationGraph);</b>
&nbsp;		}
<b class="fc">&nbsp;		return add;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Modify visit(ASTModify node, Object data) throws VisitorException {
<b class="fc">&nbsp;		ASTWhereClause whereClause = node.getWhereClause();</b>
&nbsp;
<b class="fc">&nbsp;		where = null;</b>
<b class="pc">&nbsp;		if (whereClause != null) {</b>
<b class="fc">&nbsp;			where = (TupleExpr) whereClause.jjtAccept(this, data);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		TupleExpr delete = null;</b>
<b class="fc">&nbsp;		ASTDeleteClause deleteNode = node.getDeleteClause();</b>
<b class="fc">&nbsp;		if (deleteNode != null) {</b>
<b class="fc">&nbsp;			delete = (TupleExpr) deleteNode.jjtAccept(this, data);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		TupleExpr insert = null;</b>
<b class="fc">&nbsp;		ASTInsertClause insertNode = node.getInsertClause();</b>
<b class="fc">&nbsp;		if (insertNode != null) {</b>
<b class="fc">&nbsp;			insert = (TupleExpr) insertNode.jjtAccept(this, data);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return new Modify(delete, insert, where);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public TupleExpr visit(ASTDeleteClause node, Object data) throws VisitorException {
&nbsp;
&nbsp;		// Collect construct triples
<b class="fc">&nbsp;		GraphPattern parentGP = graphPattern;</b>
&nbsp;
<b class="fc">&nbsp;		graphPattern = new GraphPattern();</b>
&nbsp;
&nbsp;		// inherit scope &amp; context
<b class="fc">&nbsp;		graphPattern.setStatementPatternScope(parentGP.getStatementPatternScope());</b>
<b class="fc">&nbsp;		graphPattern.setContextVar(parentGP.getContextVar());</b>
&nbsp;
<b class="fc">&nbsp;		for (int i = 0; i &lt; node.jjtGetNumChildren(); i++) {</b>
<b class="fc">&nbsp;			node.jjtGetChild(i).jjtAccept(this, data);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		TupleExpr deleteExpr = graphPattern.buildTupleExpr();</b>
<b class="fc">&nbsp;		Map&lt;String, Object&gt; tripleVars = TripleRefCollector.process(where);</b>
&nbsp;
&nbsp;		// FIXME we should adapt the grammar so we can avoid doing this in
&nbsp;		// post-processing.
<b class="fc">&nbsp;		VarCollector collector = new VarCollector();</b>
<b class="fc">&nbsp;		deleteExpr.visit(collector);</b>
<b class="fc">&nbsp;		for (Var var : collector.getCollectedVars()) {</b>
&nbsp;			// skip vars that are provided by ValueExprTripleRef - added as Extentsion
<b class="pc">&nbsp;			if (tripleVars.containsKey(var.getName())) {</b>
<b class="nc">&nbsp;				continue;</b>
&nbsp;			}
<b class="pc">&nbsp;			if (var.isAnonymous() &amp;&amp; !var.hasValue()) {</b>
&nbsp;				// blank node in delete pattern, not allowed by SPARQL spec.
<b class="nc">&nbsp;				throw new VisitorException(&quot;DELETE clause may not contain blank nodes&quot;);</b>
&nbsp;			}
<b class="fc">&nbsp;		}</b>
&nbsp;
<b class="fc">&nbsp;		graphPattern = parentGP;</b>
&nbsp;
<b class="fc">&nbsp;		return deleteExpr;</b>
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public TupleExpr visit(ASTInsertClause node, Object data) throws VisitorException {
&nbsp;
&nbsp;		// Collect insert clause triples
<b class="fc">&nbsp;		GraphPattern parentGP = graphPattern;</b>
<b class="fc">&nbsp;		graphPattern = new GraphPattern();</b>
&nbsp;
&nbsp;		// inherit scope &amp; context
<b class="fc">&nbsp;		graphPattern.setStatementPatternScope(parentGP.getStatementPatternScope());</b>
<b class="fc">&nbsp;		graphPattern.setContextVar(parentGP.getContextVar());</b>
&nbsp;
<b class="fc">&nbsp;		for (int i = 0; i &lt; node.jjtGetNumChildren(); i++) {</b>
<b class="fc">&nbsp;			node.jjtGetChild(i).jjtAccept(this, data);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		TupleExpr insertExpr = graphPattern.buildTupleExpr();</b>
&nbsp;
<b class="fc">&nbsp;		graphPattern = parentGP;</b>
&nbsp;
<b class="fc">&nbsp;		return insertExpr;</b>
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public TupleExpr visit(ASTTripleRef node, Object data) throws VisitorException {
<b class="nc">&nbsp;		if (where == null) {</b>
<b class="nc">&nbsp;			return super.visit(node, data);</b>
&nbsp;		}
<b class="nc">&nbsp;		TripleRef ret = new TripleRef();</b>
<b class="nc">&nbsp;		ret.setSubjectVar(mapValueExprToVar(node.getSubj().jjtAccept(this, ret)));</b>
<b class="nc">&nbsp;		ret.setPredicateVar(mapValueExprToVar(node.getPred().jjtAccept(this, ret)));</b>
<b class="nc">&nbsp;		ret.setObjectVar(mapValueExprToVar(node.getObj().jjtAccept(this, ret)));</b>
<b class="nc">&nbsp;		ret.setExprVar(createAnonVar());</b>
<b class="nc">&nbsp;		Extension ext = new Extension(where);</b>
<b class="nc">&nbsp;		ext.addElement(new ExtensionElem(castToValueExpr(ret), ret.getExprVar().getName()));</b>
<b class="nc">&nbsp;		where = ext;</b>
&nbsp;
<b class="nc">&nbsp;		return ret;</b>
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:20</div>
</div>
</body>
</html>
