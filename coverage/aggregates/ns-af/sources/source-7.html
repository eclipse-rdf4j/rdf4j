


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > SAXFilter</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.rio.rdfxml</a>
</div>

<h1>Coverage Summary for Class: SAXFilter (org.eclipse.rdf4j.rio.rdfxml)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SAXFilter</td>
<td class="coverageStat">
  <span class="percent">
    63%
  </span>
  <span class="absValue">
    (17/27)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    39.1%
  </span>
  <span class="absValue">
    (54/138)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    52.9%
  </span>
  <span class="absValue">
    (119/225)
  </span>
</td>
</tr>
  <tr>
    <td class="name">SAXFilter$ElementInfo</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (4/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    61.9%
  </span>
  <span class="absValue">
    (13/21)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    59.4%
  </span>
  <span class="absValue">
    (19/32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    38.7%
  </span>
  <span class="absValue">
    (58/150)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    53.7%
  </span>
  <span class="absValue">
    (132/246)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;package org.eclipse.rdf4j.rio.rdfxml;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Stack;
&nbsp;
&nbsp;import org.eclipse.rdf4j.common.net.ParsedIRI;
&nbsp;import org.eclipse.rdf4j.common.xml.XMLUtil;
&nbsp;import org.eclipse.rdf4j.model.vocabulary.RDF;
&nbsp;import org.eclipse.rdf4j.rio.ParseLocationListener;
&nbsp;import org.eclipse.rdf4j.rio.RDFHandlerException;
&nbsp;import org.eclipse.rdf4j.rio.RDFParseException;
&nbsp;import org.eclipse.rdf4j.rio.helpers.XMLParserSettings;
&nbsp;import org.xml.sax.Attributes;
&nbsp;import org.xml.sax.ContentHandler;
&nbsp;import org.xml.sax.Locator;
&nbsp;import org.xml.sax.SAXException;
&nbsp;
&nbsp;/**
&nbsp; * A filter on SAX events to make life easier on the RDF parser itself. This filter does things like combining a call to
&nbsp; * startElement() that is directly followed by a call to endElement() to a single call to emptyElement().
&nbsp; */
&nbsp;class SAXFilter implements ContentHandler {
&nbsp;
&nbsp;	/*-----------*
&nbsp;	 * Variables *
&nbsp;	 *-----------*/
&nbsp;
&nbsp;	/**
&nbsp;	 * The RDF parser to supply the filtered SAX events to.
&nbsp;	 */
&nbsp;	private final RDFXMLParser rdfParser;
&nbsp;
&nbsp;	/**
&nbsp;	 * A Locator indicating a position in the text that is currently being parsed by the SAX parser.
&nbsp;	 */
&nbsp;	private Locator locator;
&nbsp;
&nbsp;	/**
&nbsp;	 * Stack of ElementInfo objects.
&nbsp;	 */
<b class="fc">&nbsp;	private final Stack&lt;ElementInfo&gt; elInfoStack = new Stack&lt;&gt;();</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * StringBuilder used to collect text during parsing.
&nbsp;	 */
<b class="fc">&nbsp;	private final StringBuilder charBuf = new StringBuilder(512);</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * The document&#39;s URI.
&nbsp;	 */
&nbsp;	private ParsedIRI documentURI;
&nbsp;
&nbsp;	/**
&nbsp;	 * Flag indicating whether the parser parses stand-alone RDF documents. In stand-alone documents, the rdf:RDF
&nbsp;	 * element is optional if it contains just one element.
&nbsp;	 */
<b class="fc">&nbsp;	private boolean parseStandAloneDocuments = true;</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Variable used to defer reporting of start tags. Reporting start tags is deferred to be able to combine a start
&nbsp;	 * tag and an immediately following end tag to a single call to emptyElement().
&nbsp;	 */
<b class="fc">&nbsp;	private ElementInfo deferredElement = null;</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * New namespace mappings that have been reported for the next start tag by the SAX parser, but that are not yet
&nbsp;	 * assigned to an ElementInfo object.
&nbsp;	 */
<b class="fc">&nbsp;	private final Map&lt;String, String&gt; newNamespaceMappings = new LinkedHashMap&lt;&gt;();</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Flag indicating whether we&#39;re currently parsing RDF elements.
&nbsp;	 */
&nbsp;	private boolean inRDFContext;
&nbsp;
&nbsp;	/**
&nbsp;	 * The number of elements on the stack that are in the RDF context.
&nbsp;	 */
&nbsp;	private int rdfContextStackHeight;
&nbsp;
&nbsp;	/**
&nbsp;	 * Flag indicating whether we&#39;re currently parsing an XML literal.
&nbsp;	 */
<b class="fc">&nbsp;	private boolean parseLiteralMode = false;</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * The number of elements on the stack that are part of an XML literal.
&nbsp;	 */
&nbsp;	private int xmlLiteralStackHeight;
&nbsp;
&nbsp;	/**
&nbsp;	 * The prefixes that are defined in the XML literal itself (this in contrast to the namespaces from the XML
&nbsp;	 * literal&#39;s context).
&nbsp;	 */
<b class="fc">&nbsp;	private final List&lt;String&gt; xmlLiteralPrefixes = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * The prefixes that were used in an XML literal, but that were not defined in it (but rather in the XML literal&#39;s
&nbsp;	 * context).
&nbsp;	 */
<b class="fc">&nbsp;	private final List&lt;String&gt; unknownPrefixesInXMLLiteral = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;	/*--------------*
&nbsp;	 * Constructors *
&nbsp;	 *--------------*/
&nbsp;
<b class="fc">&nbsp;	public SAXFilter(RDFXMLParser rdfParser) {</b>
<b class="fc">&nbsp;		this.rdfParser = rdfParser;</b>
&nbsp;	}
&nbsp;
&nbsp;	/*---------*
&nbsp;	 * Methods *
&nbsp;	 *---------*/
&nbsp;
&nbsp;	public Locator getLocator() {
<b class="fc">&nbsp;		return locator;</b>
&nbsp;	}
&nbsp;
&nbsp;	public void clear() {
<b class="fc">&nbsp;		locator = null;</b>
<b class="fc">&nbsp;		elInfoStack.clear();</b>
<b class="fc">&nbsp;		charBuf.setLength(0);</b>
<b class="fc">&nbsp;		documentURI = null;</b>
<b class="fc">&nbsp;		deferredElement = null;</b>
&nbsp;
<b class="fc">&nbsp;		newNamespaceMappings.clear();</b>
&nbsp;
<b class="fc">&nbsp;		inRDFContext = false;</b>
<b class="fc">&nbsp;		rdfContextStackHeight = 0;</b>
&nbsp;
<b class="fc">&nbsp;		parseLiteralMode = false;</b>
<b class="fc">&nbsp;		xmlLiteralStackHeight = 0;</b>
&nbsp;
<b class="fc">&nbsp;		xmlLiteralPrefixes.clear();</b>
<b class="fc">&nbsp;		unknownPrefixesInXMLLiteral.clear();</b>
&nbsp;	}
&nbsp;
&nbsp;	public void setDocumentURI(String documentURI) {
<b class="pc">&nbsp;		if (documentURI != null) {</b>
<b class="fc">&nbsp;			this.documentURI = createBaseURI(documentURI);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public void setParseStandAloneDocuments(boolean standAloneDocs) {
<b class="fc">&nbsp;		parseStandAloneDocuments = standAloneDocs;</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean getParseStandAloneDocuments() {
<b class="nc">&nbsp;		return parseStandAloneDocuments;</b>
&nbsp;	}
&nbsp;
&nbsp;	/*---------------------------------------*
&nbsp;	 * Methods from interface ContentHandler *
&nbsp;	 *---------------------------------------*/
&nbsp;
&nbsp;	@Override
&nbsp;	public void setDocumentLocator(Locator loc) {
<b class="fc">&nbsp;		locator = loc;</b>
&nbsp;
<b class="fc">&nbsp;		ParseLocationListener pll = rdfParser.getParseLocationListener();</b>
<b class="pc">&nbsp;		if (pll != null &amp;&amp; loc != null) {</b>
<b class="nc">&nbsp;			pll.parseLocationUpdate(loc.getLineNumber(), loc.getColumnNumber());</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void startDocument() throws SAXException {
&nbsp;		try {
<b class="fc">&nbsp;			rdfParser.startDocument();</b>
<b class="nc">&nbsp;		} catch (RDFParseException | RDFHandlerException e) {</b>
<b class="nc">&nbsp;			throw new SAXException(e);</b>
<b class="fc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void endDocument() throws SAXException {
&nbsp;		try {
<b class="fc">&nbsp;			rdfParser.endDocument();</b>
<b class="nc">&nbsp;		} catch (RDFParseException | RDFHandlerException e) {</b>
<b class="nc">&nbsp;			throw new SAXException(e);</b>
<b class="fc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void startPrefixMapping(String prefix, String uri) throws SAXException {
&nbsp;		try {
<b class="pc">&nbsp;			if (deferredElement != null) {</b>
&nbsp;				// This new prefix mapping must come from a new start tag
<b class="nc">&nbsp;				reportDeferredStartElement();</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			newNamespaceMappings.put(prefix, uri);</b>
&nbsp;
<b class="pc">&nbsp;			if (parseLiteralMode) {</b>
&nbsp;				// This namespace is introduced inside an XML literal
<b class="nc">&nbsp;				xmlLiteralPrefixes.add(prefix);</b>
&nbsp;			}
&nbsp;
<b class="pc">&nbsp;			if (rdfParser.getRDFHandler() != null) {</b>
<b class="fc">&nbsp;				rdfParser.getRDFHandler().handleNamespace(prefix, uri);</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (RDFParseException | RDFHandlerException e) {</b>
<b class="nc">&nbsp;			throw new SAXException(e);</b>
<b class="fc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void endPrefixMapping(String prefix) {
<b class="pc">&nbsp;		if (parseLiteralMode) {</b>
<b class="nc">&nbsp;			xmlLiteralPrefixes.remove(prefix);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void startElement(String namespaceURI, String localName, String qName, Attributes attributes)
&nbsp;			throws SAXException {
&nbsp;		try {
<b class="fc">&nbsp;			if (deferredElement != null) {</b>
&nbsp;				// The next call could set parseLiteralMode to true!
<b class="fc">&nbsp;				reportDeferredStartElement();</b>
&nbsp;			}
&nbsp;
<b class="pc">&nbsp;			if (parseLiteralMode) {</b>
<b class="nc">&nbsp;				appendStartTag(qName, attributes);</b>
<b class="nc">&nbsp;				xmlLiteralStackHeight++;</b>
&nbsp;			} else {
<b class="fc">&nbsp;				ElementInfo parent = peekStack();</b>
<b class="fc">&nbsp;				ElementInfo elInfo = new ElementInfo(parent, qName, namespaceURI, localName);</b>
&nbsp;
<b class="fc">&nbsp;				elInfo.setNamespaceMappings(newNamespaceMappings);</b>
<b class="fc">&nbsp;				newNamespaceMappings.clear();</b>
&nbsp;
<b class="pc">&nbsp;				if (!inRDFContext &amp;&amp; parseStandAloneDocuments</b>
<b class="pc">&nbsp;						&amp;&amp; (!localName.equals(&quot;RDF&quot;) || !namespaceURI.equals(RDF.NAMESPACE))) {</b>
&nbsp;					// Stand-alone document that does not start with an rdf:RDF root
&nbsp;					// element. Assume this root element is omitted.
<b class="nc">&nbsp;					inRDFContext = true;</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				if (!inRDFContext) {</b>
&nbsp;					// Check for presence of xml:base and xlm:lang attributes.
<b class="pc">&nbsp;					for (int i = 0; i &lt; attributes.getLength(); i++) {</b>
<b class="nc">&nbsp;						String attQName = attributes.getQName(i);</b>
&nbsp;
<b class="nc">&nbsp;						if (&quot;xml:base&quot;.equals(attQName)) {</b>
<b class="nc">&nbsp;							elInfo.setBaseURI(attributes.getValue(i));</b>
<b class="nc">&nbsp;						} else if (&quot;xml:lang&quot;.equals(attQName)) {</b>
<b class="nc">&nbsp;							elInfo.xmlLang = attributes.getValue(i);</b>
&nbsp;						}
&nbsp;					}
&nbsp;
<b class="fc">&nbsp;					elInfoStack.push(elInfo);</b>
&nbsp;
&nbsp;					// Check if we are entering RDF context now.
<b class="pc">&nbsp;					if (localName.equals(&quot;RDF&quot;) &amp;&amp; namespaceURI.equals(RDF.NAMESPACE)) {</b>
<b class="fc">&nbsp;						inRDFContext = true;</b>
<b class="fc">&nbsp;						rdfContextStackHeight = 0;</b>
&nbsp;					}
&nbsp;				} else {
&nbsp;					// We&#39;re parsing RDF elements.
<b class="fc">&nbsp;					checkAndCopyAttributes(attributes, elInfo);</b>
&nbsp;
&nbsp;					// Don&#39;t report the new element to the RDF parser just yet.
<b class="fc">&nbsp;					deferredElement = elInfo;</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				charBuf.setLength(0);</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (RDFParseException | RDFHandlerException e) {</b>
<b class="nc">&nbsp;			throw new SAXException(e);</b>
<b class="fc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private void reportDeferredStartElement() throws RDFParseException, RDFHandlerException {
&nbsp;
&nbsp;		// Only useful for debugging.
&nbsp;		// if (deferredElement == null) {
&nbsp;		// throw new RuntimeException(&quot;no deferred start element available&quot;);
&nbsp;		// }
&nbsp;
<b class="fc">&nbsp;		elInfoStack.push(deferredElement);</b>
<b class="fc">&nbsp;		rdfContextStackHeight++;</b>
&nbsp;
<b class="pc">&nbsp;		if (deferredElement.baseURI != null) {</b>
<b class="fc">&nbsp;			rdfParser.setBaseURI(deferredElement.baseURI.toString());</b>
&nbsp;		}
<b class="fc">&nbsp;		rdfParser.setXMLLang(deferredElement.xmlLang);</b>
&nbsp;
<b class="fc">&nbsp;		rdfParser.startElement(deferredElement.namespaceURI, deferredElement.localName, deferredElement.qName,</b>
&nbsp;				deferredElement.atts);
&nbsp;
<b class="fc">&nbsp;		deferredElement = null;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void endElement(String namespaceURI, String localName, String qName) throws SAXException {
&nbsp;		try {
&nbsp;			// FIXME: in parseLiteralMode we should also check if start- and
&nbsp;			// end-tags match but these start tags are not tracked yet.
&nbsp;
<b class="pc">&nbsp;			if (rdfParser.getParserConfig().get(XMLParserSettings.FAIL_ON_MISMATCHED_TAGS) &amp;&amp; !parseLiteralMode) {</b>
&nbsp;				// Verify that the end tag matches the start tag.
&nbsp;				ElementInfo elInfo;
&nbsp;
<b class="fc">&nbsp;				if (deferredElement != null) {</b>
<b class="fc">&nbsp;					elInfo = deferredElement;</b>
&nbsp;				} else {
<b class="fc">&nbsp;					elInfo = peekStack();</b>
&nbsp;				}
&nbsp;
<b class="pc">&nbsp;				if (!qName.equals(elInfo.qName)) {</b>
<b class="nc">&nbsp;					rdfParser.reportError(&quot;expected end tag &lt;/&#39;&quot; + elInfo.qName + &quot;&gt;, found &lt;/&quot; + qName + &quot;&gt;&quot;,</b>
&nbsp;							XMLParserSettings.FAIL_ON_MISMATCHED_TAGS);
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="pc">&nbsp;			if (!inRDFContext) {</b>
<b class="nc">&nbsp;				elInfoStack.pop();</b>
<b class="nc">&nbsp;				charBuf.setLength(0);</b>
&nbsp;				return;
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			if (deferredElement == null &amp;&amp; rdfContextStackHeight == 0) {</b>
&nbsp;				// This end tag removes the element that signaled the start
&nbsp;				// of the RDF context (i.e. &lt;rdf:RDF&gt;) from the stack.
<b class="fc">&nbsp;				inRDFContext = false;</b>
&nbsp;
<b class="fc">&nbsp;				elInfoStack.pop();</b>
<b class="fc">&nbsp;				charBuf.setLength(0);</b>
&nbsp;				return;
&nbsp;			}
&nbsp;
&nbsp;			// We&#39;re still in RDF context.
&nbsp;
<b class="pc">&nbsp;			if (parseLiteralMode &amp;&amp; xmlLiteralStackHeight &gt; 0) {</b>
<b class="nc">&nbsp;				appendEndTag(qName);</b>
<b class="nc">&nbsp;				xmlLiteralStackHeight--;</b>
&nbsp;				return;
&nbsp;			}
&nbsp;
&nbsp;			// Check for any deferred start elements
<b class="fc">&nbsp;			if (deferredElement != null) {</b>
&nbsp;				// Start element still deferred, this is an empty element
<b class="pc">&nbsp;				if (deferredElement.baseURI != null) {</b>
<b class="fc">&nbsp;					rdfParser.setBaseURI(deferredElement.baseURI.toString());</b>
&nbsp;				}
<b class="fc">&nbsp;				rdfParser.setXMLLang(deferredElement.xmlLang);</b>
&nbsp;
<b class="fc">&nbsp;				rdfParser.emptyElement(deferredElement.namespaceURI, deferredElement.localName, deferredElement.qName,</b>
&nbsp;						deferredElement.atts);
&nbsp;
<b class="fc">&nbsp;				deferredElement = null;</b>
&nbsp;			} else {
<b class="pc">&nbsp;				if (parseLiteralMode) {</b>
&nbsp;					// Insert any used namespace prefixes from the XML literal&#39;s
&nbsp;					// context that are not defined in the XML literal itself.
<b class="nc">&nbsp;					insertUsedContextPrefixes();</b>
&nbsp;
<b class="nc">&nbsp;					rdfParser.text(charBuf.toString());</b>
&nbsp;
<b class="nc">&nbsp;					parseLiteralMode = false;</b>
&nbsp;				} else {
<b class="fc">&nbsp;					String s = charBuf.toString();</b>
&nbsp;
&nbsp;					// ignore whitespace-only nodes
<b class="fc">&nbsp;					if (s.trim().length() &gt; 0) {</b>
<b class="fc">&nbsp;						rdfParser.text(s);</b>
&nbsp;					}
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				charBuf.setLength(0);</b>
&nbsp;
&nbsp;				// Handle the end tag
<b class="fc">&nbsp;				elInfoStack.pop();</b>
<b class="fc">&nbsp;				rdfContextStackHeight--;</b>
&nbsp;
<b class="fc">&nbsp;				rdfParser.endElement(namespaceURI, localName, qName);</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (RDFParseException | RDFHandlerException e) {</b>
<b class="nc">&nbsp;			throw new SAXException(e);</b>
<b class="fc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void characters(char[] ch, int start, int length) throws SAXException {
&nbsp;		try {
<b class="pc">&nbsp;			if (inRDFContext) {</b>
&nbsp;				// verify if we need to switch to XMLLiteral processing mode immediately.
<b class="pc">&nbsp;				if (deferredElement != null &amp;&amp; !parseLiteralMode) {</b>
<b class="fc">&nbsp;					Att parseType = deferredElement.atts.getAtt(RDF.NAMESPACE, &quot;parseType&quot;);</b>
<b class="pc">&nbsp;					if (parseType != null &amp;&amp; parseType.getValue().equals(&quot;Literal&quot;)) {</b>
<b class="nc">&nbsp;						setParseLiteralMode();</b>
&nbsp;					}
&nbsp;				}
&nbsp;
<b class="pc">&nbsp;				if (parseLiteralMode) {</b>
<b class="nc">&nbsp;					if (deferredElement != null) {</b>
<b class="nc">&nbsp;						reportDeferredStartElement();</b>
&nbsp;					}
&nbsp;
&nbsp;					// Characters like &#39;&lt;&#39;, &#39;&gt;&#39;, and &#39;&amp;&#39; must be escaped to
&nbsp;					// prevent breaking the XML text.
<b class="nc">&nbsp;					String s = new String(ch, start, length);</b>
<b class="nc">&nbsp;					s = XMLUtil.escapeCharacterData(s);</b>
<b class="nc">&nbsp;					charBuf.append(s);</b>
<b class="nc">&nbsp;				} else {</b>
<b class="fc">&nbsp;					charBuf.append(ch, start, length);</b>
&nbsp;
&nbsp;					// if the element is not empty we need to process it as such. Otherwise,
&nbsp;					// we keep the start element deferred for now.
<b class="fc">&nbsp;					if (deferredElement != null &amp;&amp; charBuf.toString().trim().length() &gt; 0) {</b>
<b class="fc">&nbsp;						reportDeferredStartElement();</b>
&nbsp;					}
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;		} catch (RDFParseException | RDFHandlerException e) {</b>
<b class="nc">&nbsp;			throw new SAXException(e);</b>
<b class="fc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void ignorableWhitespace(char[] ch, int start, int length) {
<b class="nc">&nbsp;		if (parseLiteralMode) {</b>
<b class="nc">&nbsp;			charBuf.append(ch, start, length);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void processingInstruction(String target, String data) {
&nbsp;		// ignore
<b class="nc">&nbsp;	}</b>
&nbsp;
&nbsp;	@Override
&nbsp;	public void skippedEntity(String name) {
&nbsp;		// ignore
<b class="nc">&nbsp;	}</b>
&nbsp;
&nbsp;	private void checkAndCopyAttributes(Attributes attributes, ElementInfo elInfo)
&nbsp;			throws SAXException, RDFParseException {
<b class="fc">&nbsp;		Atts atts = new Atts(attributes.getLength());</b>
&nbsp;
<b class="fc">&nbsp;		int attCount = attributes.getLength();</b>
<b class="fc">&nbsp;		for (int i = 0; i &lt; attCount; i++) {</b>
<b class="fc">&nbsp;			String qName = attributes.getQName(i);</b>
<b class="fc">&nbsp;			String value = attributes.getValue(i);</b>
&nbsp;
&nbsp;			// attributes starting with &quot;xml&quot; should be ignored, except for the
&nbsp;			// ones that are handled by this parser (xml:lang and xml:base).
<b class="pc">&nbsp;			if (qName.startsWith(&quot;xml&quot;)) {</b>
<b class="nc">&nbsp;				if (qName.equals(&quot;xml:lang&quot;)) {</b>
<b class="nc">&nbsp;					elInfo.xmlLang = value;</b>
<b class="nc">&nbsp;				} else if (qName.equals(&quot;xml:base&quot;)) {</b>
<b class="nc">&nbsp;					elInfo.setBaseURI(value);</b>
&nbsp;				}
&nbsp;			} else {
<b class="fc">&nbsp;				String namespace = attributes.getURI(i);</b>
<b class="fc">&nbsp;				String localName = attributes.getLocalName(i);</b>
&nbsp;
&nbsp;				// A limited set of unqualified attributes must be supported by
&nbsp;				// parsers, as is specified in section 6.1.4 of the spec
<b class="pc">&nbsp;				if (&quot;&quot;.equals(namespace)) {</b>
<b class="nc">&nbsp;					if (localName.equals(&quot;ID&quot;) || localName.equals(&quot;about&quot;) || localName.equals(&quot;resource&quot;)</b>
<b class="nc">&nbsp;							|| localName.equals(&quot;parseType&quot;) || localName.equals(&quot;type&quot;)) {</b>
<b class="nc">&nbsp;						rdfParser.reportWarning(&quot;use of unqualified attribute &quot; + localName + &quot; has been deprecated&quot;);</b>
<b class="nc">&nbsp;						namespace = RDF.NAMESPACE;</b>
&nbsp;					}
&nbsp;				}
&nbsp;
<b class="pc">&nbsp;				if (&quot;&quot;.equals(namespace)) {</b>
<b class="nc">&nbsp;					rdfParser.reportError(&quot;unqualified attribute &#39;&quot; + qName + &quot;&#39; not allowed&quot;,</b>
&nbsp;							XMLParserSettings.FAIL_ON_INVALID_QNAME);
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				Att att = new Att(namespace, localName, qName, value);</b>
<b class="fc">&nbsp;				atts.addAtt(att);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		elInfo.atts = atts;</b>
&nbsp;	}
&nbsp;
&nbsp;	public void setParseLiteralMode() {
<b class="nc">&nbsp;		parseLiteralMode = true;</b>
<b class="nc">&nbsp;		xmlLiteralStackHeight = 0;</b>
&nbsp;
&nbsp;		// All currently known namespace prefixes are
&nbsp;		// new for this XML literal.
<b class="nc">&nbsp;		xmlLiteralPrefixes.clear();</b>
<b class="nc">&nbsp;		unknownPrefixesInXMLLiteral.clear();</b>
&nbsp;	}
&nbsp;
&nbsp;	private ParsedIRI createBaseURI(String uriString) {
<b class="fc">&nbsp;		return ParsedIRI.create(uriString).normalize();</b>
&nbsp;	}
&nbsp;
&nbsp;	/*---------------------------------*
&nbsp;	 * Methods related to XML literals *
&nbsp;	 *---------------------------------*/
&nbsp;
&nbsp;	/**
&nbsp;	 * Appends a start tag to charBuf. This method is used during the parsing of an XML Literal.
&nbsp;	 */
&nbsp;	private void appendStartTag(String qName, Attributes attributes) {
&nbsp;		// Write start of start tag
<b class="nc">&nbsp;		charBuf.append(&quot;&lt;&quot; + qName);</b>
&nbsp;
&nbsp;		// Write any new namespace prefix definitions
<b class="nc">&nbsp;		for (Map.Entry&lt;String, String&gt; entry : newNamespaceMappings.entrySet()) {</b>
<b class="nc">&nbsp;			String prefix = entry.getKey();</b>
<b class="nc">&nbsp;			String namespace = entry.getValue();</b>
<b class="nc">&nbsp;			appendNamespaceDecl(charBuf, prefix, namespace);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;
&nbsp;		// Write attributes
<b class="nc">&nbsp;		int attCount = attributes.getLength();</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; attCount; i++) {</b>
<b class="nc">&nbsp;			appendAttribute(charBuf, attributes.getQName(i), attributes.getValue(i));</b>
&nbsp;		}
&nbsp;
&nbsp;		// Write end of start tag
<b class="nc">&nbsp;		charBuf.append(&quot;&gt;&quot;);</b>
&nbsp;
&nbsp;		// Check for any used prefixes that are not
&nbsp;		// defined in the XML literal itself
<b class="nc">&nbsp;		int colonIdx = qName.indexOf(&#39;:&#39;);</b>
<b class="nc">&nbsp;		String prefix = (colonIdx &gt; 0) ? qName.substring(0, colonIdx) : &quot;&quot;;</b>
&nbsp;
<b class="nc">&nbsp;		if (!xmlLiteralPrefixes.contains(prefix) &amp;&amp; !unknownPrefixesInXMLLiteral.contains(prefix)) {</b>
<b class="nc">&nbsp;			unknownPrefixesInXMLLiteral.add(prefix);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Appends an end tag to charBuf. This method is used during the parsing of an XML Literal.
&nbsp;	 */
&nbsp;	private void appendEndTag(String qName) {
<b class="nc">&nbsp;		charBuf.append(&quot;&lt;/&quot; + qName + &quot;&gt;&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Inserts prefix mappings from an XML Literal&#39;s context for all prefixes that are used in the XML Literal and that
&nbsp;	 * are not defined in the XML Literal itself.
&nbsp;	 */
&nbsp;	private void insertUsedContextPrefixes() {
<b class="nc">&nbsp;		int unknownPrefixesCount = unknownPrefixesInXMLLiteral.size();</b>
&nbsp;
<b class="nc">&nbsp;		if (unknownPrefixesCount &gt; 0) {</b>
&nbsp;			// Create a String with all needed context prefixes
<b class="nc">&nbsp;			StringBuilder contextPrefixes = new StringBuilder(1024);</b>
<b class="nc">&nbsp;			ElementInfo topElement = peekStack();</b>
&nbsp;
<b class="nc">&nbsp;			for (int i = 0; i &lt; unknownPrefixesCount; i++) {</b>
<b class="nc">&nbsp;				String prefix = unknownPrefixesInXMLLiteral.get(i);</b>
<b class="nc">&nbsp;				String namespace = topElement.getNamespace(prefix);</b>
<b class="nc">&nbsp;				if (namespace != null) {</b>
<b class="nc">&nbsp;					appendNamespaceDecl(contextPrefixes, prefix, namespace);</b>
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			int i = 0;</b>
<b class="nc">&nbsp;			int opentag = 0;</b>
<b class="nc">&nbsp;			while (i &lt; charBuf.length()) {</b>
<b class="nc">&nbsp;				char ch = charBuf.charAt(i);</b>
<b class="nc">&nbsp;				if (ch == &#39;&lt;&#39;) {</b>
<b class="nc">&nbsp;					if ((i + 1) &lt; charBuf.length()) {</b>
<b class="nc">&nbsp;						char nextChar = charBuf.charAt(i + 1);</b>
<b class="nc">&nbsp;						if (nextChar != &#39;/&#39; &amp;&amp; opentag == 0) {</b>
<b class="nc">&nbsp;							opentag++;</b>
<b class="nc">&nbsp;							int endOfFirstStartTag = charBuf.substring(i).indexOf(&quot;&gt;&quot;);</b>
<b class="nc">&nbsp;							charBuf.insert(endOfFirstStartTag + i, contextPrefixes.toString());</b>
<b class="nc">&nbsp;						} else {</b>
<b class="nc">&nbsp;							opentag--;</b>
&nbsp;						}
&nbsp;					}
&nbsp;				}
<b class="nc">&nbsp;				i += 1;</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		unknownPrefixesInXMLLiteral.clear();</b>
&nbsp;	}
&nbsp;
&nbsp;	private void appendNamespaceDecl(StringBuilder sb, String prefix, String namespace) {
<b class="nc">&nbsp;		String attName = &quot;xmlns&quot;;</b>
&nbsp;
<b class="nc">&nbsp;		if (!&quot;&quot;.equals(prefix)) {</b>
<b class="nc">&nbsp;			attName += &quot;:&quot; + prefix;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		appendAttribute(sb, attName, namespace);</b>
&nbsp;	}
&nbsp;
&nbsp;	private void appendAttribute(StringBuilder sb, String name, String value) {
<b class="nc">&nbsp;		sb.append(&quot; &quot;);</b>
<b class="nc">&nbsp;		sb.append(name);</b>
<b class="nc">&nbsp;		sb.append(&quot;=\&quot;&quot;);</b>
<b class="nc">&nbsp;		sb.append(XMLUtil.escapeDoubleQuotedAttValue(value));</b>
<b class="nc">&nbsp;		sb.append(&quot;\&quot;&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	/*------------------------------------------*
&nbsp;	 * Methods related to the ElementInfo stack *
&nbsp;	 *------------------------------------------*/
&nbsp;
&nbsp;	private ElementInfo peekStack() {
<b class="fc">&nbsp;		ElementInfo result = null;</b>
&nbsp;
<b class="fc">&nbsp;		if (!elInfoStack.empty()) {</b>
<b class="fc">&nbsp;			result = elInfoStack.peek();</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return result;</b>
&nbsp;	}
&nbsp;
&nbsp;	/*----------------------------*
&nbsp;	 * Internal class ElementInfo *
&nbsp;	 *----------------------------*/
&nbsp;
&nbsp;	private class ElementInfo {
&nbsp;
&nbsp;		public String qName;
&nbsp;
&nbsp;		public String namespaceURI;
&nbsp;
&nbsp;		public String localName;
&nbsp;
&nbsp;		public Atts atts;
&nbsp;
&nbsp;		public ElementInfo parent;
&nbsp;
&nbsp;		private Map&lt;String, String&gt; namespaceMap;
&nbsp;
&nbsp;		public ParsedIRI baseURI;
&nbsp;
&nbsp;		public String xmlLang;
&nbsp;
&nbsp;		public ElementInfo(String qName, String namespaceURI, String localName) {
<b class="nc">&nbsp;			this(null, qName, namespaceURI, localName);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		public ElementInfo(ElementInfo parent, String qName, String namespaceURI, String localName) {</b>
<b class="fc">&nbsp;			this.parent = parent;</b>
<b class="fc">&nbsp;			this.qName = qName;</b>
<b class="fc">&nbsp;			this.namespaceURI = namespaceURI;</b>
<b class="fc">&nbsp;			this.localName = localName;</b>
&nbsp;
<b class="fc">&nbsp;			if (parent != null) {</b>
&nbsp;				// Inherit baseURI and xmlLang from parent
<b class="fc">&nbsp;				this.baseURI = parent.baseURI;</b>
<b class="fc">&nbsp;				this.xmlLang = parent.xmlLang;</b>
&nbsp;			} else {
<b class="fc">&nbsp;				this.baseURI = documentURI;</b>
<b class="fc">&nbsp;				this.xmlLang = &quot;&quot;;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		public void setBaseURI(String uriString) {
&nbsp;			// Resolve the specified base URI against the inherited base URI (if any)
<b class="nc">&nbsp;			baseURI = baseURI != null ? baseURI.resolve(createBaseURI(uriString)) : createBaseURI(uriString);</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setNamespaceMappings(Map&lt;String, String&gt; namespaceMappings) {
<b class="fc">&nbsp;			if (namespaceMappings.isEmpty()) {</b>
<b class="fc">&nbsp;				namespaceMap = null;</b>
&nbsp;			} else {
<b class="fc">&nbsp;				namespaceMap = new HashMap&lt;&gt;(namespaceMappings);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		public String getNamespace(String prefix) {
<b class="nc">&nbsp;			String result = null;</b>
&nbsp;
<b class="nc">&nbsp;			if (namespaceMap != null) {</b>
<b class="nc">&nbsp;				result = namespaceMap.get(prefix);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (result == null &amp;&amp; parent != null) {</b>
<b class="nc">&nbsp;				result = parent.getNamespace(prefix);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			return result;</b>
&nbsp;		}
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:58</div>
</div>
</body>
</html>
