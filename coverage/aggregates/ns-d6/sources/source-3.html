


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > HashFile</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.sail.nativerdf.datastore</a>
</div>

<h1>Coverage Summary for Class: HashFile (org.eclipse.rdf4j.sail.nativerdf.datastore)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">HashFile</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/66)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/180)
  </span>
</td>
</tr>
  <tr>
    <td class="name">HashFile$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashFile$IDIterator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/29)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/29)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/74)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/212)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;package org.eclipse.rdf4j.sail.nativerdf.datastore;
&nbsp;
&nbsp;import java.io.Closeable;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.io.RandomAccessFile;
&nbsp;import java.nio.ByteBuffer;
&nbsp;import java.nio.channels.FileChannel;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.BitSet;
&nbsp;import java.util.concurrent.locks.ReentrantReadWriteLock;
&nbsp;
&nbsp;import org.eclipse.rdf4j.common.io.NioFile;
&nbsp;
&nbsp;/**
&nbsp; * Class supplying access to a hash file.
&nbsp; *
&nbsp; * @author Arjohn Kampman
&nbsp; */
&nbsp;public class HashFile implements Closeable {
&nbsp;
&nbsp;	/*-----------*
&nbsp;	 * Constants *
&nbsp;	 *-----------*/
&nbsp;
&nbsp;	// The size of an item (32-bit hash + 32-bit ID), in bytes
&nbsp;	private static final int ITEM_SIZE = 8;
&nbsp;
&nbsp;	/**
&nbsp;	 * Magic number &quot;Native Hash File&quot; to detect whether the file is actually a hash file. The first three bytes of the
&nbsp;	 * file should be equal to this magic number.
&nbsp;	 */
<b class="nc">&nbsp;	private static final byte[] MAGIC_NUMBER = new byte[] { &#39;n&#39;, &#39;h&#39;, &#39;f&#39; };</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * File format version, stored as the fourth byte in hash files.
&nbsp;	 */
&nbsp;	private static final byte FILE_FORMAT_VERSION = 1;
&nbsp;
&nbsp;	/**
&nbsp;	 * The size of the file header in bytes. The file header contains the following data: magic number (3 bytes) file
&nbsp;	 * format version (1 byte), number of buckets (4 bytes), bucket size (4 bytes) and number of stored items (4 bytes).
&nbsp;	 */
&nbsp;	private static final long HEADER_LENGTH = 16;
&nbsp;
&nbsp;	private static final int INIT_BUCKET_SIZE = 8;
&nbsp;
&nbsp;	/*-----------*
&nbsp;	 * Variables *
&nbsp;	 *-----------*/
&nbsp;
&nbsp;	private final NioFile nioFile;
&nbsp;
&nbsp;	private final boolean forceSync;
&nbsp;
&nbsp;	// The number of (non-overflow) buckets in the hash file
&nbsp;	private volatile int bucketCount;
&nbsp;
&nbsp;	// The number of items that can be stored in a bucket
&nbsp;	private final int bucketSize;
&nbsp;
&nbsp;	// The number of items in the hash file
&nbsp;	private volatile int itemCount;
&nbsp;
&nbsp;	// Load factor (fixed, for now)
&nbsp;	private final float loadFactor;
&nbsp;
&nbsp;	// recordSize = ITEM_SIZE * bucketSize + 4
&nbsp;	private final int recordSize;
&nbsp;
&nbsp;	// first prime &gt; 5MB
&nbsp;	private final BitSet poorMansBloomFilter;
&nbsp;
<b class="nc">&nbsp;	boolean loadedHashFileFromDisk = false;</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * A read/write lock that is used to prevent structural changes to the hash file while readers are active in order
&nbsp;	 * to prevent concurrency issues.
&nbsp;	 */
<b class="nc">&nbsp;	private final ReentrantReadWriteLock structureLock = new ReentrantReadWriteLock();</b>
&nbsp;
&nbsp;	/*--------------*
&nbsp;	 * Constructors *
&nbsp;	 *--------------*/
&nbsp;
&nbsp;	public HashFile(File file) throws IOException {
<b class="nc">&nbsp;		this(file, false);</b>
&nbsp;	}
&nbsp;
&nbsp;	public HashFile(File file, boolean forceSync) throws IOException {
<b class="nc">&nbsp;		this(file, forceSync, 512); // 512 is default initial size</b>
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public HashFile(File file, boolean forceSync, int initialSize) throws IOException {</b>
<b class="nc">&nbsp;		this.nioFile = new NioFile(file);</b>
<b class="nc">&nbsp;		this.forceSync = forceSync;</b>
<b class="nc">&nbsp;		loadFactor = 0.75f;</b>
&nbsp;
&nbsp;		try {
<b class="nc">&nbsp;			if (nioFile.size() == 0L) {</b>
&nbsp;				// Empty file, insert bucket count, bucket size
&nbsp;				// and item count at the start of the file
&nbsp;
&nbsp;				// the bucket count handles sizes not divisible by INIT_BUCKET_SIZE
<b class="nc">&nbsp;				bucketCount = (int) Math.ceil(initialSize * 1.0 / INIT_BUCKET_SIZE);</b>
<b class="nc">&nbsp;				bucketSize = INIT_BUCKET_SIZE;</b>
<b class="nc">&nbsp;				itemCount = 0;</b>
<b class="nc">&nbsp;				recordSize = ITEM_SIZE * bucketSize + 4;</b>
&nbsp;
&nbsp;				// Initialize the file by writing &lt;_bucketCount&gt; empty buckets
<b class="nc">&nbsp;				writeEmptyBuckets(HEADER_LENGTH, bucketCount);</b>
&nbsp;
<b class="nc">&nbsp;				sync();</b>
&nbsp;			} else {
&nbsp;				// Read bucket count, bucket size and item count from the file
<b class="nc">&nbsp;				ByteBuffer buf = ByteBuffer.allocate((int) HEADER_LENGTH);</b>
<b class="nc">&nbsp;				nioFile.read(buf, 0L);</b>
<b class="nc">&nbsp;				buf.rewind();</b>
&nbsp;
<b class="nc">&nbsp;				if (buf.remaining() &lt; HEADER_LENGTH) {</b>
<b class="nc">&nbsp;					throw new IOException(&quot;File too short to be a compatible hash file&quot;);</b>
&nbsp;				}
&nbsp;
<b class="nc">&nbsp;				byte[] magicNumber = new byte[MAGIC_NUMBER.length];</b>
<b class="nc">&nbsp;				buf.get(magicNumber);</b>
<b class="nc">&nbsp;				byte version = buf.get();</b>
<b class="nc">&nbsp;				bucketCount = buf.getInt();</b>
<b class="nc">&nbsp;				bucketSize = buf.getInt();</b>
<b class="nc">&nbsp;				itemCount = buf.getInt();</b>
&nbsp;
<b class="nc">&nbsp;				if (!Arrays.equals(MAGIC_NUMBER, magicNumber)) {</b>
<b class="nc">&nbsp;					throw new IOException(&quot;File doesn&#39;t contain compatible hash file data&quot;);</b>
&nbsp;				}
&nbsp;
<b class="nc">&nbsp;				if (version &gt; FILE_FORMAT_VERSION) {</b>
<b class="nc">&nbsp;					throw new IOException(&quot;Unable to read hash file; it uses a newer file format&quot;);</b>
<b class="nc">&nbsp;				} else if (version != FILE_FORMAT_VERSION) {</b>
<b class="nc">&nbsp;					throw new IOException(&quot;Unable to read hash file; invalid file format version: &quot; + version);</b>
&nbsp;				}
&nbsp;
<b class="nc">&nbsp;				recordSize = ITEM_SIZE * bucketSize + 4;</b>
<b class="nc">&nbsp;				loadedHashFileFromDisk = itemCount &gt; 0;</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (!loadedHashFileFromDisk) {</b>
&nbsp;				// 41943049 is ~5MB, and a prime
<b class="nc">&nbsp;				if (initialSize &gt; 41943049) {</b>
&nbsp;					// initialSize &lt; Integer.MAX_VALUE and Integer.MAX_VALUE = ~250 MB
<b class="nc">&nbsp;					poorMansBloomFilter = new BitSet(initialSize);</b>
&nbsp;				} else {
<b class="nc">&nbsp;					poorMansBloomFilter = new BitSet(41943049);</b>
&nbsp;				}
&nbsp;			} else {
<b class="nc">&nbsp;				poorMansBloomFilter = null;</b>
&nbsp;			}
<b class="nc">&nbsp;		} catch (IOException e) {</b>
<b class="nc">&nbsp;			this.nioFile.close();</b>
<b class="nc">&nbsp;			throw e;</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/*---------*
&nbsp;	 * Methods *
&nbsp;	 *---------*/
&nbsp;
&nbsp;	public File getFile() {
<b class="nc">&nbsp;		return nioFile.getFile();</b>
&nbsp;	}
&nbsp;
&nbsp;	public int getItemCount() {
<b class="nc">&nbsp;		return itemCount;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets an iterator that iterates over the IDs with hash codes that match the specified hash code.
&nbsp;	 */
&nbsp;	public IDIterator getIDIterator(int hash) throws IOException {
<b class="nc">&nbsp;		if (!loadedHashFileFromDisk &amp;&amp; !poorMansBloomFilter.get(getBloomFilterIndex(hash))) {</b>
<b class="nc">&nbsp;			return emptyIDIterator;</b>
&nbsp;		} else {
<b class="nc">&nbsp;			return new IDIterator(hash);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private int getBloomFilterIndex(int hash) {
<b class="nc">&nbsp;		return Math.abs(hash) % poorMansBloomFilter.size();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Stores ID under the specified hash code in this hash file.
&nbsp;	 */
&nbsp;	public void storeID(int hash, int id) throws IOException {
<b class="nc">&nbsp;		structureLock.readLock().lock();</b>
<b class="nc">&nbsp;		if (!loadedHashFileFromDisk) {</b>
<b class="nc">&nbsp;			poorMansBloomFilter.set(getBloomFilterIndex(hash), true);</b>
&nbsp;		}
&nbsp;		try {
&nbsp;			// Calculate bucket offset for initial bucket
<b class="nc">&nbsp;			long bucketOffset = getBucketOffset(hash);</b>
<b class="nc">&nbsp;			storeID(bucketOffset, hash, id);</b>
&nbsp;		} finally {
<b class="nc">&nbsp;			structureLock.readLock().unlock();</b>
<b class="nc">&nbsp;		}</b>
&nbsp;
<b class="nc">&nbsp;		if (++itemCount &gt;= loadFactor * bucketCount * bucketSize) {</b>
<b class="nc">&nbsp;			structureLock.writeLock().lock();</b>
&nbsp;			try {
<b class="nc">&nbsp;				increaseHashTable();</b>
&nbsp;			} finally {
<b class="nc">&nbsp;				structureLock.writeLock().unlock();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private void storeID(long bucketOffset, int hash, int id) throws IOException {
<b class="nc">&nbsp;		ByteBuffer bucket = ByteBuffer.allocate(recordSize);</b>
&nbsp;
&nbsp;		while (true) {
<b class="nc">&nbsp;			nioFile.read(bucket, bucketOffset);</b>
&nbsp;
&nbsp;			// Find first empty slot in bucket
<b class="nc">&nbsp;			int slotID = findEmptySlotInBucket(bucket);</b>
&nbsp;
<b class="nc">&nbsp;			if (slotID &gt;= 0) {</b>
&nbsp;				// Empty slot found, store dataOffset in it
&nbsp;
<b class="nc">&nbsp;				ByteBuffer diff = ByteBuffer.allocate(8);</b>
<b class="nc">&nbsp;				diff.putInt(hash);</b>
<b class="nc">&nbsp;				diff.putInt(id);</b>
<b class="nc">&nbsp;				diff.rewind();</b>
&nbsp;
<b class="nc">&nbsp;				nioFile.write(diff, bucketOffset + ITEM_SIZE * slotID);</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			} else {
&nbsp;				// No empty slot found, check if bucket has an overflow bucket
<b class="nc">&nbsp;				int overflowID = bucket.getInt(ITEM_SIZE * bucketSize);</b>
&nbsp;
<b class="nc">&nbsp;				if (overflowID == 0) {</b>
&nbsp;					// No overflow bucket yet, create one
<b class="nc">&nbsp;					overflowID = createOverflowBucket();</b>
&nbsp;
&nbsp;					// Link overflow bucket to current bucket
<b class="nc">&nbsp;					bucket.putInt(ITEM_SIZE * bucketSize, overflowID);</b>
<b class="nc">&nbsp;					bucket.rewind();</b>
<b class="nc">&nbsp;					nioFile.write(bucket, bucketOffset);</b>
&nbsp;				}
&nbsp;
&nbsp;				// Continue searching for an empty slot in the overflow bucket
<b class="nc">&nbsp;				bucketOffset = getOverflowBucketOffset(overflowID);</b>
<b class="nc">&nbsp;				bucket.clear();</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	public void clear() throws IOException {
<b class="nc">&nbsp;		structureLock.writeLock().lock();</b>
<b class="nc">&nbsp;		poorMansBloomFilter.clear();</b>
&nbsp;		try {
&nbsp;			// Truncate the file to remove any overflow buffers
<b class="nc">&nbsp;			nioFile.truncate(HEADER_LENGTH + (long) bucketCount * recordSize);</b>
&nbsp;
&nbsp;			// Overwrite normal buckets with empty ones
<b class="nc">&nbsp;			writeEmptyBuckets(HEADER_LENGTH, bucketCount);</b>
&nbsp;
<b class="nc">&nbsp;			itemCount = 0;</b>
&nbsp;		} finally {
<b class="nc">&nbsp;			structureLock.writeLock().unlock();</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Syncs any unstored data to the hash file.
&nbsp;	 */
&nbsp;	public void sync() throws IOException {
<b class="nc">&nbsp;		structureLock.readLock().lock();</b>
&nbsp;		try {
&nbsp;			// Update the file header
<b class="nc">&nbsp;			writeFileHeader();</b>
&nbsp;		} finally {
<b class="nc">&nbsp;			structureLock.readLock().unlock();</b>
<b class="nc">&nbsp;		}</b>
&nbsp;
<b class="nc">&nbsp;		if (forceSync) {</b>
<b class="nc">&nbsp;			nioFile.force(false);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public void sync(boolean force) throws IOException {
<b class="nc">&nbsp;		sync();</b>
<b class="nc">&nbsp;		nioFile.force(force);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void close() throws IOException {
<b class="nc">&nbsp;		nioFile.close();</b>
&nbsp;	}
&nbsp;
&nbsp;	/*-----------------*
&nbsp;	 * Utility methods *
&nbsp;	 *-----------------*/
&nbsp;
&nbsp;	private RandomAccessFile createEmptyFile(File file) throws IOException {
&nbsp;		// Make sure the file exists
<b class="nc">&nbsp;		if (!file.exists()) {</b>
<b class="nc">&nbsp;			boolean created = file.createNewFile();</b>
<b class="nc">&nbsp;			if (!created) {</b>
<b class="nc">&nbsp;				throw new IOException(&quot;Failed to create file &quot; + file);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		// Open the file in read-write mode and make sure the file is empty
<b class="nc">&nbsp;		RandomAccessFile raf = new RandomAccessFile(file, &quot;rw&quot;);</b>
<b class="nc">&nbsp;		raf.setLength(0L);</b>
&nbsp;
<b class="nc">&nbsp;		return raf;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Writes the bucket count, bucket size and item count to the file header.
&nbsp;	 */
&nbsp;	private void writeFileHeader() throws IOException {
<b class="nc">&nbsp;		ByteBuffer buf = ByteBuffer.allocate((int) HEADER_LENGTH);</b>
<b class="nc">&nbsp;		buf.put(MAGIC_NUMBER);</b>
<b class="nc">&nbsp;		buf.put(FILE_FORMAT_VERSION);</b>
<b class="nc">&nbsp;		buf.putInt(bucketCount);</b>
<b class="nc">&nbsp;		buf.putInt(bucketSize);</b>
<b class="nc">&nbsp;		buf.putInt(itemCount);</b>
<b class="nc">&nbsp;		buf.rewind();</b>
&nbsp;
<b class="nc">&nbsp;		nioFile.write(buf, 0L);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the offset of the bucket for the specified hash code.
&nbsp;	 */
&nbsp;	private long getBucketOffset(int hash) {
<b class="nc">&nbsp;		int bucketNo = hash % bucketCount;</b>
<b class="nc">&nbsp;		if (bucketNo &lt; 0) {</b>
<b class="nc">&nbsp;			bucketNo += bucketCount;</b>
&nbsp;		}
<b class="nc">&nbsp;		return HEADER_LENGTH + (long) bucketNo * recordSize;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the offset of the overflow bucket with the specified ID.
&nbsp;	 */
&nbsp;	private long getOverflowBucketOffset(int bucketID) {
<b class="nc">&nbsp;		return HEADER_LENGTH + ((long) bucketCount + (long) bucketID - 1L) * recordSize;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Creates a new overflow bucket and returns its ID.
&nbsp;	 */
&nbsp;	private int createOverflowBucket() throws IOException {
<b class="nc">&nbsp;		long offset = nioFile.size();</b>
<b class="nc">&nbsp;		writeEmptyBuckets(offset, 1);</b>
<b class="nc">&nbsp;		return (int) ((offset - HEADER_LENGTH) / recordSize) - bucketCount + 1;</b>
&nbsp;	}
&nbsp;
&nbsp;	private void writeEmptyBuckets(long fileOffset, int bucketCount) throws IOException {
<b class="nc">&nbsp;		ByteBuffer emptyBucket = ByteBuffer.allocate(recordSize);</b>
&nbsp;
<b class="nc">&nbsp;		for (int i = 0; i &lt; bucketCount; i++) {</b>
<b class="nc">&nbsp;			nioFile.write(emptyBucket, fileOffset + i * (long) recordSize);</b>
<b class="nc">&nbsp;			emptyBucket.rewind();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private int findEmptySlotInBucket(ByteBuffer bucket) {
<b class="nc">&nbsp;		for (int slotNo = 0; slotNo &lt; bucketSize; slotNo++) {</b>
&nbsp;			// Check for offsets that are equal to 0
<b class="nc">&nbsp;			if (bucket.getInt(ITEM_SIZE * slotNo + 4) == 0) {</b>
<b class="nc">&nbsp;				return slotNo;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return -1;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Double the number of buckets in the hash file and rehashes the stored items.
&nbsp;	 */
&nbsp;	private void increaseHashTable() throws IOException {
<b class="nc">&nbsp;		long oldTableSize = HEADER_LENGTH + (long) bucketCount * recordSize;</b>
<b class="nc">&nbsp;		long newTableSize = HEADER_LENGTH + (long) bucketCount * recordSize * 2;</b>
<b class="nc">&nbsp;		long oldFileSize = nioFile.size(); // includes overflow buckets</b>
&nbsp;
&nbsp;		// Move any overflow buckets out of the way to a temporary file
<b class="nc">&nbsp;		File tmpFile = new File(getFile().getParentFile(), &quot;rehash_&quot; + getFile().getName());</b>
<b class="nc">&nbsp;		try (RandomAccessFile tmpRaf = createEmptyFile(tmpFile)) {</b>
<b class="nc">&nbsp;			FileChannel tmpChannel = tmpRaf.getChannel();</b>
&nbsp;			// Transfer the overflow buckets to the temp file
&nbsp;			// FIXME: work around java bug 6431344:
&nbsp;			// &quot;FileChannel.transferTo() doesn&#39;t work if address space runs out&quot;
<b class="nc">&nbsp;			nioFile.transferTo(oldTableSize, oldFileSize - oldTableSize, tmpChannel);</b>
&nbsp;			// Increase hash table by factor 2
<b class="nc">&nbsp;			writeEmptyBuckets(oldTableSize, bucketCount);</b>
<b class="nc">&nbsp;			bucketCount *= 2;</b>
&nbsp;			// Discard any remaining overflow buffers
<b class="nc">&nbsp;			nioFile.truncate(newTableSize);</b>
<b class="nc">&nbsp;			ByteBuffer bucket = ByteBuffer.allocate(recordSize);</b>
<b class="nc">&nbsp;			ByteBuffer newBucket = ByteBuffer.allocate(recordSize);</b>
&nbsp;			// Rehash items in non-overflow buckets, half of these will move to a
&nbsp;			// new location, but none of them will trigger the creation of new overflow
&nbsp;			// buckets. Any (now deprecated) references to overflow buckets are
&nbsp;			// removed too.
&nbsp;
&nbsp;			// All items that are moved to a new location end up in one and the same
&nbsp;			// new and empty bucket. All items are divided between the old and the
&nbsp;			// new bucket and the changes to the buckets are written to disk only once.
<b class="nc">&nbsp;			for (long bucketOffset = HEADER_LENGTH; bucketOffset &lt; oldTableSize; bucketOffset += recordSize) {</b>
<b class="nc">&nbsp;				nioFile.read(bucket, bucketOffset);</b>
&nbsp;
<b class="nc">&nbsp;				boolean bucketChanged = false;</b>
<b class="nc">&nbsp;				long newBucketOffset = 0L;</b>
&nbsp;
<b class="nc">&nbsp;				for (int slotNo = 0; slotNo &lt; bucketSize; slotNo++) {</b>
<b class="nc">&nbsp;					int id = bucket.getInt(ITEM_SIZE * slotNo + 4);</b>
&nbsp;
<b class="nc">&nbsp;					if (id != 0) {</b>
&nbsp;						// Slot is not empty
<b class="nc">&nbsp;						int hash = bucket.getInt(ITEM_SIZE * slotNo);</b>
<b class="nc">&nbsp;						long newOffset = getBucketOffset(hash);</b>
&nbsp;
<b class="nc">&nbsp;						if (newOffset != bucketOffset) {</b>
&nbsp;							// Move this item to new bucket...
<b class="nc">&nbsp;							newBucket.putInt(hash);</b>
<b class="nc">&nbsp;							newBucket.putInt(id);</b>
&nbsp;
&nbsp;							// ...and remove it from the current bucket
<b class="nc">&nbsp;							bucket.putInt(ITEM_SIZE * slotNo, 0);</b>
<b class="nc">&nbsp;							bucket.putInt(ITEM_SIZE * slotNo + 4, 0);</b>
&nbsp;
<b class="nc">&nbsp;							bucketChanged = true;</b>
<b class="nc">&nbsp;							newBucketOffset = newOffset;</b>
&nbsp;						}
&nbsp;					}
&nbsp;				}
&nbsp;
<b class="nc">&nbsp;				if (bucketChanged) {</b>
&nbsp;					// Some of the items were moved to the new bucket, write it to
&nbsp;					// the file
<b class="nc">&nbsp;					newBucket.flip();</b>
<b class="nc">&nbsp;					nioFile.write(newBucket, newBucketOffset);</b>
<b class="nc">&nbsp;					newBucket.clear();</b>
&nbsp;				}
&nbsp;
&nbsp;				// Reset overflow ID in the old bucket to 0 if necessary
<b class="nc">&nbsp;				if (bucket.getInt(ITEM_SIZE * bucketSize) != 0) {</b>
<b class="nc">&nbsp;					bucket.putInt(ITEM_SIZE * bucketSize, 0);</b>
<b class="nc">&nbsp;					bucketChanged = true;</b>
&nbsp;				}
&nbsp;
<b class="nc">&nbsp;				if (bucketChanged) {</b>
&nbsp;					// Some of the items were moved to the new bucket or the
&nbsp;					// overflow ID has been reset; write the bucket back to the file
<b class="nc">&nbsp;					bucket.rewind();</b>
<b class="nc">&nbsp;					nioFile.write(bucket, bucketOffset);</b>
&nbsp;				}
&nbsp;
<b class="nc">&nbsp;				bucket.clear();</b>
&nbsp;			} // Rehash items in overflow buckets. This might trigger the creation of
&nbsp;				// new overflow buckets so we can&#39;t optimize this in the same way as we
&nbsp;				// rehash the normal buckets.
<b class="nc">&nbsp;			long tmpFileSize = tmpChannel.size();</b>
<b class="nc">&nbsp;			for (long bucketOffset = 0L; bucketOffset &lt; tmpFileSize; bucketOffset += recordSize) {</b>
<b class="nc">&nbsp;				tmpChannel.read(bucket, bucketOffset);</b>
&nbsp;
<b class="nc">&nbsp;				for (int slotNo = 0; slotNo &lt; bucketSize; slotNo++) {</b>
<b class="nc">&nbsp;					int id = bucket.getInt(ITEM_SIZE * slotNo + 4);</b>
&nbsp;
<b class="nc">&nbsp;					if (id != 0) {</b>
&nbsp;						// Slot is not empty
<b class="nc">&nbsp;						int hash = bucket.getInt(ITEM_SIZE * slotNo);</b>
<b class="nc">&nbsp;						long newBucketOffset = getBucketOffset(hash);</b>
&nbsp;
&nbsp;						// Copy this item to its new location
<b class="nc">&nbsp;						storeID(newBucketOffset, hash, id);</b>
&nbsp;					}
&nbsp;				}
&nbsp;
<b class="nc">&nbsp;				bucket.clear();</b>
&nbsp;			}
&nbsp;			// Discard the temp file
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		tmpFile.delete();</b>
&nbsp;	}
&nbsp;
&nbsp;	/*------------------------*
&nbsp;	 * Inner class IDIterator *
&nbsp;	 *------------------------*/
&nbsp;
<b class="nc">&nbsp;	private final IDIterator emptyIDIterator = new IDIterator() {</b>
&nbsp;		@Override
&nbsp;		public void close() {
&nbsp;
<b class="nc">&nbsp;		}</b>
&nbsp;
&nbsp;		@Override
&nbsp;		public int next() throws IOException {
<b class="nc">&nbsp;			return -1;</b>
&nbsp;		}
&nbsp;	};
&nbsp;
&nbsp;	public class IDIterator {
&nbsp;
&nbsp;		private final int queryHash;
&nbsp;
&nbsp;		private ByteBuffer bucketBuffer;
&nbsp;
&nbsp;		private int slotNo;
&nbsp;
<b class="nc">&nbsp;		private IDIterator(int hash) throws IOException {</b>
<b class="nc">&nbsp;			queryHash = hash;</b>
<b class="nc">&nbsp;			bucketBuffer = ByteBuffer.allocate(recordSize);</b>
&nbsp;
<b class="nc">&nbsp;			structureLock.readLock().lock();</b>
&nbsp;			try {
&nbsp;				// Read initial bucket
<b class="nc">&nbsp;				long bucketOffset = getBucketOffset(hash);</b>
<b class="nc">&nbsp;				nioFile.read(bucketBuffer, bucketOffset);</b>
&nbsp;
<b class="nc">&nbsp;				slotNo = -1;</b>
<b class="nc">&nbsp;			} catch (IOException | RuntimeException e) {</b>
<b class="nc">&nbsp;				structureLock.readLock().unlock();</b>
<b class="nc">&nbsp;				throw e;</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		IDIterator() {</b>
<b class="nc">&nbsp;			queryHash = 0;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void close() {
<b class="nc">&nbsp;			bucketBuffer = null;</b>
<b class="nc">&nbsp;			structureLock.readLock().unlock();</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Returns the next ID that has been mapped to the specified hash code, or &lt;var&gt;-1&lt;/var&gt; if no more IDs were
&nbsp;		 * found.
&nbsp;		 */
&nbsp;		public int next() throws IOException {
<b class="nc">&nbsp;			while (bucketBuffer != null) {</b>
&nbsp;				// Search in current bucket
<b class="nc">&nbsp;				while (++slotNo &lt; bucketSize) {</b>
<b class="nc">&nbsp;					if (bucketBuffer.getInt(ITEM_SIZE * slotNo) == queryHash) {</b>
<b class="nc">&nbsp;						return bucketBuffer.getInt(ITEM_SIZE * slotNo + 4);</b>
&nbsp;					}
&nbsp;				}
&nbsp;
&nbsp;				// No matching hash code in current bucket, check overflow
&nbsp;				// bucket
<b class="nc">&nbsp;				int overflowID = bucketBuffer.getInt(ITEM_SIZE * bucketSize);</b>
<b class="nc">&nbsp;				if (overflowID == 0) {</b>
&nbsp;					// No overflow bucket, end the search
<b class="nc">&nbsp;					bucketBuffer = null;</b>
<b class="nc">&nbsp;					break;</b>
&nbsp;				} else {
&nbsp;					// Continue with overflow bucket
<b class="nc">&nbsp;					bucketBuffer.clear();</b>
<b class="nc">&nbsp;					long bucketOffset = getOverflowBucketOffset(overflowID);</b>
<b class="nc">&nbsp;					nioFile.read(bucketBuffer, bucketOffset);</b>
<b class="nc">&nbsp;					slotNo = -1;</b>
&nbsp;				}
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return -1;</b>
&nbsp;		}
&nbsp;
&nbsp;	} // End inner class IDIterator
&nbsp;} // End class HashFile
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:58</div>
</div>
</body>
</html>
