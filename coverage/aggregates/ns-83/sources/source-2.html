


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > AbstractSPARQLXMLWriter</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.query.resultio.sparqlxml</a>
</div>

<h1>Coverage Summary for Class: AbstractSPARQLXMLWriter (org.eclipse.rdf4j.query.resultio.sparqlxml)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AbstractSPARQLXMLWriter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/90)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/187)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;package org.eclipse.rdf4j.query.resultio.sparqlxml;
&nbsp;
&nbsp;import static org.eclipse.rdf4j.query.resultio.sparqlxml.SPARQLResultsXMLConstants.BINDING_NAME_ATT;
&nbsp;import static org.eclipse.rdf4j.query.resultio.sparqlxml.SPARQLResultsXMLConstants.BINDING_TAG;
&nbsp;import static org.eclipse.rdf4j.query.resultio.sparqlxml.SPARQLResultsXMLConstants.BNODE_TAG;
&nbsp;import static org.eclipse.rdf4j.query.resultio.sparqlxml.SPARQLResultsXMLConstants.BOOLEAN_FALSE;
&nbsp;import static org.eclipse.rdf4j.query.resultio.sparqlxml.SPARQLResultsXMLConstants.BOOLEAN_TAG;
&nbsp;import static org.eclipse.rdf4j.query.resultio.sparqlxml.SPARQLResultsXMLConstants.BOOLEAN_TRUE;
&nbsp;import static org.eclipse.rdf4j.query.resultio.sparqlxml.SPARQLResultsXMLConstants.HEAD_TAG;
&nbsp;import static org.eclipse.rdf4j.query.resultio.sparqlxml.SPARQLResultsXMLConstants.HREF_ATT;
&nbsp;import static org.eclipse.rdf4j.query.resultio.sparqlxml.SPARQLResultsXMLConstants.LINK_TAG;
&nbsp;import static org.eclipse.rdf4j.query.resultio.sparqlxml.SPARQLResultsXMLConstants.LITERAL_DATATYPE_ATT;
&nbsp;import static org.eclipse.rdf4j.query.resultio.sparqlxml.SPARQLResultsXMLConstants.LITERAL_LANG_ATT;
&nbsp;import static org.eclipse.rdf4j.query.resultio.sparqlxml.SPARQLResultsXMLConstants.LITERAL_TAG;
&nbsp;import static org.eclipse.rdf4j.query.resultio.sparqlxml.SPARQLResultsXMLConstants.NAMESPACE;
&nbsp;import static org.eclipse.rdf4j.query.resultio.sparqlxml.SPARQLResultsXMLConstants.OBJECT_TAG;
&nbsp;import static org.eclipse.rdf4j.query.resultio.sparqlxml.SPARQLResultsXMLConstants.PREDICATE_TAG;
&nbsp;import static org.eclipse.rdf4j.query.resultio.sparqlxml.SPARQLResultsXMLConstants.QNAME;
&nbsp;import static org.eclipse.rdf4j.query.resultio.sparqlxml.SPARQLResultsXMLConstants.RESULT_SET_TAG;
&nbsp;import static org.eclipse.rdf4j.query.resultio.sparqlxml.SPARQLResultsXMLConstants.RESULT_TAG;
&nbsp;import static org.eclipse.rdf4j.query.resultio.sparqlxml.SPARQLResultsXMLConstants.ROOT_TAG;
&nbsp;import static org.eclipse.rdf4j.query.resultio.sparqlxml.SPARQLResultsXMLConstants.SUBJECT_TAG;
&nbsp;import static org.eclipse.rdf4j.query.resultio.sparqlxml.SPARQLResultsXMLConstants.TRIPLE_TAG;
&nbsp;import static org.eclipse.rdf4j.query.resultio.sparqlxml.SPARQLResultsXMLConstants.URI_TAG;
&nbsp;import static org.eclipse.rdf4j.query.resultio.sparqlxml.SPARQLResultsXMLConstants.VAR_NAME_ATT;
&nbsp;import static org.eclipse.rdf4j.query.resultio.sparqlxml.SPARQLResultsXMLConstants.VAR_TAG;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.io.OutputStream;
&nbsp;import java.io.Writer;
&nbsp;import java.util.Collection;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;
&nbsp;import org.eclipse.rdf4j.common.io.CharSink;
&nbsp;import org.eclipse.rdf4j.common.xml.XMLWriter;
&nbsp;import org.eclipse.rdf4j.model.BNode;
&nbsp;import org.eclipse.rdf4j.model.IRI;
&nbsp;import org.eclipse.rdf4j.model.Literal;
&nbsp;import org.eclipse.rdf4j.model.Triple;
&nbsp;import org.eclipse.rdf4j.model.Value;
&nbsp;import org.eclipse.rdf4j.model.util.Literals;
&nbsp;import org.eclipse.rdf4j.model.vocabulary.SESAMEQNAME;
&nbsp;import org.eclipse.rdf4j.model.vocabulary.XSD;
&nbsp;import org.eclipse.rdf4j.query.Binding;
&nbsp;import org.eclipse.rdf4j.query.BindingSet;
&nbsp;import org.eclipse.rdf4j.query.QueryResultHandlerException;
&nbsp;import org.eclipse.rdf4j.query.TupleQueryResultHandlerException;
&nbsp;import org.eclipse.rdf4j.query.resultio.AbstractQueryResultWriter;
&nbsp;import org.eclipse.rdf4j.query.resultio.BasicQueryWriterSettings;
&nbsp;import org.eclipse.rdf4j.query.resultio.QueryResultWriter;
&nbsp;import org.eclipse.rdf4j.rio.RioSetting;
&nbsp;import org.eclipse.rdf4j.rio.helpers.BasicWriterSettings;
&nbsp;import org.eclipse.rdf4j.rio.helpers.XMLWriterSettings;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;
&nbsp;/**
&nbsp; * An abstract class to implement the base functionality for both SPARQLBooleanXMLWriter and SPARQLResultsXMLWriter.
&nbsp; *
&nbsp; * @author Peter Ansell
&nbsp; */
&nbsp;abstract class AbstractSPARQLXMLWriter extends AbstractQueryResultWriter implements CharSink {
&nbsp;
&nbsp;	/*-----------*
&nbsp;	 * Variables *
&nbsp;	 *-----------*/
&nbsp;
&nbsp;	/**
&nbsp;	 * XMLWriter to write XML to.
&nbsp;	 */
&nbsp;	protected XMLWriter xmlWriter;
&nbsp;
<b class="nc">&nbsp;	protected boolean documentOpen = false;</b>
&nbsp;
<b class="nc">&nbsp;	protected boolean headerOpen = false;</b>
&nbsp;
<b class="nc">&nbsp;	protected boolean headerComplete = false;</b>
&nbsp;
<b class="nc">&nbsp;	protected boolean tupleVariablesFound = false;</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Map with keys as namespace URI strings and the values as the shortened prefixes.
&nbsp;	 */
<b class="nc">&nbsp;	private final Map&lt;String, String&gt; namespaceTable = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;	private final Logger log = LoggerFactory.getLogger(this.getClass());</b>
&nbsp;
&nbsp;	/*--------------*
&nbsp;	 * Constructors *
&nbsp;	 *--------------*/
&nbsp;
<b class="nc">&nbsp;	protected AbstractSPARQLXMLWriter(OutputStream out) {</b>
<b class="nc">&nbsp;		this.xmlWriter = new XMLWriter(out);</b>
<b class="nc">&nbsp;		this.xmlWriter.setPrettyPrint(true);</b>
&nbsp;	}
&nbsp;
&nbsp;	protected AbstractSPARQLXMLWriter(Writer writer) {
<b class="nc">&nbsp;		this(new XMLWriter(writer));</b>
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	protected AbstractSPARQLXMLWriter(XMLWriter xmlWriter) {</b>
<b class="nc">&nbsp;		this.xmlWriter = xmlWriter;</b>
<b class="nc">&nbsp;		this.xmlWriter.setPrettyPrint(true);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Writer getWriter() {
<b class="nc">&nbsp;		return xmlWriter.getWriter();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Enables/disables addition of indentation characters and newlines in the XML document. By default, pretty-printing
&nbsp;	 * is set to &lt;var&gt;true&lt;/var&gt;. If set to &lt;var&gt;false&lt;/var&gt;, no indentation and newlines are added to the XML document.
&nbsp;	 * This method has to be used before writing starts (that is, before {@link #startDocument} is called).
&nbsp;	 *
&nbsp;	 * @deprecated Use {@link #getWriterConfig()} .set(BasicWriterSettings.PRETTY_PRINT, prettyPrint) instead.
&nbsp;	 */
&nbsp;	@Deprecated
&nbsp;	public void setPrettyPrint(boolean prettyPrint) {
<b class="nc">&nbsp;		getWriterConfig().set(BasicWriterSettings.PRETTY_PRINT, prettyPrint);</b>
<b class="nc">&nbsp;		xmlWriter.setPrettyPrint(prettyPrint);</b>
&nbsp;	}
&nbsp;
&nbsp;	protected void endDocument() throws IOException {
<b class="nc">&nbsp;		xmlWriter.endTag(ROOT_TAG);</b>
&nbsp;
<b class="nc">&nbsp;		xmlWriter.endDocument();</b>
&nbsp;
<b class="nc">&nbsp;		tupleVariablesFound = false;</b>
<b class="nc">&nbsp;		headerOpen = false;</b>
<b class="nc">&nbsp;		headerComplete = false;</b>
<b class="nc">&nbsp;		documentOpen = false;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void handleBoolean(boolean value) throws QueryResultHandlerException {
<b class="nc">&nbsp;		if (!documentOpen) {</b>
<b class="nc">&nbsp;			startDocument();</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (!headerOpen) {</b>
<b class="nc">&nbsp;			startHeader();</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (!headerComplete) {</b>
<b class="nc">&nbsp;			endHeader();</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (tupleVariablesFound) {</b>
<b class="nc">&nbsp;			throw new QueryResultHandlerException(&quot;Cannot call handleBoolean after startQueryResults&quot;);</b>
&nbsp;		}
&nbsp;
&nbsp;		try {
<b class="nc">&nbsp;			if (value) {</b>
<b class="nc">&nbsp;				xmlWriter.textElement(BOOLEAN_TAG, BOOLEAN_TRUE);</b>
&nbsp;			} else {
<b class="nc">&nbsp;				xmlWriter.textElement(BOOLEAN_TAG, BOOLEAN_FALSE);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			endDocument();</b>
<b class="nc">&nbsp;		} catch (IOException e) {</b>
<b class="nc">&nbsp;			throw new QueryResultHandlerException(e);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void startDocument() throws QueryResultHandlerException {
<b class="nc">&nbsp;		if (!documentOpen) {</b>
<b class="nc">&nbsp;			documentOpen = true;</b>
<b class="nc">&nbsp;			headerOpen = false;</b>
<b class="nc">&nbsp;			headerComplete = false;</b>
<b class="nc">&nbsp;			tupleVariablesFound = false;</b>
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				xmlWriter.setPrettyPrint(getWriterConfig().get(BasicWriterSettings.PRETTY_PRINT));</b>
&nbsp;
<b class="nc">&nbsp;				if (getWriterConfig().get(XMLWriterSettings.INCLUDE_XML_PI)) {</b>
<b class="nc">&nbsp;					xmlWriter.startDocument();</b>
&nbsp;				}
&nbsp;
<b class="nc">&nbsp;				xmlWriter.setAttribute(&quot;xmlns&quot;, NAMESPACE);</b>
&nbsp;
<b class="nc">&nbsp;				if (getWriterConfig().get(BasicQueryWriterSettings.ADD_SESAME_QNAME)) {</b>
<b class="nc">&nbsp;					xmlWriter.setAttribute(&quot;xmlns:q&quot;, SESAMEQNAME.NAMESPACE);</b>
&nbsp;				}
&nbsp;
<b class="nc">&nbsp;				for (String nextPrefix : namespaceTable.keySet()) {</b>
<b class="nc">&nbsp;					this.log.debug(&quot;Adding custom prefix for &lt;{}&gt; to map to &lt;{}&gt;&quot;, nextPrefix,</b>
<b class="nc">&nbsp;							namespaceTable.get(nextPrefix));</b>
<b class="nc">&nbsp;					xmlWriter.setAttribute(&quot;xmlns:&quot; + namespaceTable.get(nextPrefix), nextPrefix);</b>
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;			} catch (IOException e) {</b>
<b class="nc">&nbsp;				throw new QueryResultHandlerException(e);</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void handleStylesheet(String url) throws QueryResultHandlerException {
<b class="nc">&nbsp;		if (!documentOpen) {</b>
<b class="nc">&nbsp;			startDocument();</b>
&nbsp;		}
&nbsp;
&nbsp;		try {
<b class="nc">&nbsp;			xmlWriter.writeStylesheet(url);</b>
<b class="nc">&nbsp;		} catch (IOException e) {</b>
<b class="nc">&nbsp;			throw new QueryResultHandlerException(e);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void startHeader() throws QueryResultHandlerException {
<b class="nc">&nbsp;		if (!documentOpen) {</b>
<b class="nc">&nbsp;			startDocument();</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (!headerOpen) {</b>
&nbsp;			try {
<b class="nc">&nbsp;				xmlWriter.startTag(ROOT_TAG);</b>
&nbsp;
<b class="nc">&nbsp;				xmlWriter.startTag(HEAD_TAG);</b>
&nbsp;
<b class="nc">&nbsp;				headerOpen = true;</b>
<b class="nc">&nbsp;			} catch (IOException e) {</b>
<b class="nc">&nbsp;				throw new QueryResultHandlerException(e);</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void handleLinks(List&lt;String&gt; linkUrls) throws QueryResultHandlerException {
<b class="nc">&nbsp;		if (!documentOpen) {</b>
<b class="nc">&nbsp;			startDocument();</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (!headerOpen) {</b>
<b class="nc">&nbsp;			startHeader();</b>
&nbsp;		}
&nbsp;
&nbsp;		try {
&nbsp;			// Write link URLs
<b class="nc">&nbsp;			for (String name : linkUrls) {</b>
<b class="nc">&nbsp;				xmlWriter.setAttribute(HREF_ATT, name);</b>
<b class="nc">&nbsp;				xmlWriter.emptyElement(LINK_TAG);</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;		} catch (IOException e) {</b>
<b class="nc">&nbsp;			throw new QueryResultHandlerException(e);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void endHeader() throws QueryResultHandlerException {
<b class="nc">&nbsp;		if (!documentOpen) {</b>
<b class="nc">&nbsp;			startDocument();</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (!headerOpen) {</b>
<b class="nc">&nbsp;			startHeader();</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (!headerComplete) {</b>
&nbsp;			try {
<b class="nc">&nbsp;				xmlWriter.endTag(HEAD_TAG);</b>
&nbsp;
<b class="nc">&nbsp;				if (tupleVariablesFound) {</b>
&nbsp;					// Write start of results, which must always exist, even if there
&nbsp;					// are no result bindings
<b class="nc">&nbsp;					xmlWriter.startTag(RESULT_SET_TAG);</b>
&nbsp;				}
&nbsp;
<b class="nc">&nbsp;				headerComplete = true;</b>
<b class="nc">&nbsp;			} catch (IOException e) {</b>
<b class="nc">&nbsp;				throw new QueryResultHandlerException(e);</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void startQueryResult(List&lt;String&gt; bindingNames) throws TupleQueryResultHandlerException {
<b class="nc">&nbsp;		super.startQueryResult(bindingNames);</b>
&nbsp;
&nbsp;		try {
<b class="nc">&nbsp;			if (!documentOpen) {</b>
<b class="nc">&nbsp;				startDocument();</b>
&nbsp;			}
<b class="nc">&nbsp;			if (!headerOpen) {</b>
<b class="nc">&nbsp;				startHeader();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			tupleVariablesFound = true;</b>
&nbsp;			// Write binding names
<b class="nc">&nbsp;			for (String name : bindingNames) {</b>
<b class="nc">&nbsp;				xmlWriter.setAttribute(VAR_NAME_ATT, name);</b>
<b class="nc">&nbsp;				xmlWriter.emptyElement(VAR_TAG);</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;		} catch (IOException | QueryResultHandlerException e) {</b>
<b class="nc">&nbsp;			throw new TupleQueryResultHandlerException(e);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void endQueryResult() throws TupleQueryResultHandlerException {
&nbsp;		try {
<b class="nc">&nbsp;			if (!documentOpen) {</b>
<b class="nc">&nbsp;				startDocument();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (!headerOpen) {</b>
<b class="nc">&nbsp;				startHeader();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (!headerComplete) {</b>
<b class="nc">&nbsp;				endHeader();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (!tupleVariablesFound) {</b>
<b class="nc">&nbsp;				throw new IllegalStateException(&quot;Could not end query result as startQueryResult was not called first.&quot;);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			xmlWriter.endTag(RESULT_SET_TAG);</b>
<b class="nc">&nbsp;			endDocument();</b>
<b class="nc">&nbsp;		} catch (IOException | QueryResultHandlerException e) {</b>
<b class="nc">&nbsp;			throw new TupleQueryResultHandlerException(e);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected void handleSolutionImpl(BindingSet bindingSet) throws TupleQueryResultHandlerException {
&nbsp;		try {
<b class="nc">&nbsp;			if (!documentOpen) {</b>
<b class="nc">&nbsp;				startDocument();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (!headerOpen) {</b>
<b class="nc">&nbsp;				startHeader();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (!headerComplete) {</b>
<b class="nc">&nbsp;				endHeader();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (!tupleVariablesFound) {</b>
<b class="nc">&nbsp;				throw new IllegalStateException(&quot;Must call startQueryResult before handleSolution&quot;);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			xmlWriter.startTag(RESULT_TAG);</b>
&nbsp;
<b class="nc">&nbsp;			for (Binding binding : bindingSet) {</b>
<b class="nc">&nbsp;				xmlWriter.setAttribute(BINDING_NAME_ATT, binding.getName());</b>
<b class="nc">&nbsp;				xmlWriter.startTag(BINDING_TAG);</b>
&nbsp;
<b class="nc">&nbsp;				writeValue(binding.getValue());</b>
&nbsp;
<b class="nc">&nbsp;				xmlWriter.endTag(BINDING_TAG);</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			xmlWriter.endTag(RESULT_TAG);</b>
<b class="nc">&nbsp;		} catch (IOException | QueryResultHandlerException e) {</b>
<b class="nc">&nbsp;			throw new TupleQueryResultHandlerException(e);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public final Collection&lt;RioSetting&lt;?&gt;&gt; getSupportedSettings() {
<b class="nc">&nbsp;		Set&lt;RioSetting&lt;?&gt;&gt; result = new HashSet&lt;&gt;(super.getSupportedSettings());</b>
&nbsp;
<b class="nc">&nbsp;		result.add(BasicWriterSettings.PRETTY_PRINT);</b>
<b class="nc">&nbsp;		result.add(BasicWriterSettings.XSD_STRING_TO_PLAIN_LITERAL);</b>
<b class="nc">&nbsp;		result.add(BasicWriterSettings.ENCODE_RDF_STAR);</b>
<b class="nc">&nbsp;		result.add(BasicQueryWriterSettings.ADD_SESAME_QNAME);</b>
<b class="nc">&nbsp;		result.add(XMLWriterSettings.INCLUDE_XML_PI);</b>
&nbsp;
<b class="nc">&nbsp;		return result;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void handleNamespace(String prefix, String uri) throws QueryResultHandlerException {
&nbsp;		// we only support the addition of prefixes before the document is open
&nbsp;		// fail silently if namespaces are added after this point
<b class="nc">&nbsp;		if (!documentOpen) {</b>
&nbsp;			// SES-1751 : Do not allow overriding of the fixed sparql or
&nbsp;			// sesameqname prefixes
<b class="nc">&nbsp;			if (!prefix.trim().isEmpty() &amp;&amp; !prefix.trim().equals(SESAMEQNAME.PREFIX)) {</b>
<b class="nc">&nbsp;				this.log.debug(&quot;Handle namespace: Will map &lt;{}&gt; to &lt;{}&gt;&quot;, uri, prefix);</b>
&nbsp;				// NOTE: The keys in the namespace table are the URIs and the values
&nbsp;				// are the prefixes
<b class="nc">&nbsp;				this.namespaceTable.put(uri, prefix);</b>
&nbsp;			} else {
<b class="nc">&nbsp;				this.log.debug(</b>
&nbsp;						&quot;handleNamespace was ignored for either the empty prefix or the sesame qname prefix (q). Attempted to map: &lt;{}&gt; to &lt;{}&gt;&quot;,
&nbsp;						uri, prefix);
&nbsp;			}
&nbsp;		} else {
<b class="nc">&nbsp;			this.log.warn(&quot;handleNamespace was ignored after startDocument: &lt;{}&gt; to &lt;{}&gt;&quot;, uri, prefix);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private void writeValue(Value value) throws IOException {
<b class="nc">&nbsp;		if (value instanceof Triple) {</b>
<b class="nc">&nbsp;			writeTriple((Triple) value);</b>
<b class="nc">&nbsp;		} else if (value instanceof IRI) {</b>
<b class="nc">&nbsp;			writeURI((IRI) value);</b>
<b class="nc">&nbsp;		} else if (value instanceof BNode) {</b>
<b class="nc">&nbsp;			writeBNode((BNode) value);</b>
<b class="nc">&nbsp;		} else if (value instanceof Literal) {</b>
<b class="nc">&nbsp;			writeLiteral((Literal) value);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private boolean isQName(IRI nextUri) {
<b class="nc">&nbsp;		return namespaceTable.containsKey(nextUri.getNamespace());</b>
&nbsp;	}
&nbsp;
&nbsp;	private void writeTriple(Triple triple) throws IOException {
<b class="nc">&nbsp;		xmlWriter.startTag(TRIPLE_TAG);</b>
<b class="nc">&nbsp;		xmlWriter.startTag(SUBJECT_TAG);</b>
<b class="nc">&nbsp;		writeValue(triple.getSubject());</b>
<b class="nc">&nbsp;		xmlWriter.endTag(SUBJECT_TAG);</b>
<b class="nc">&nbsp;		xmlWriter.startTag(PREDICATE_TAG);</b>
<b class="nc">&nbsp;		writeValue(triple.getPredicate());</b>
<b class="nc">&nbsp;		xmlWriter.endTag(PREDICATE_TAG);</b>
<b class="nc">&nbsp;		xmlWriter.startTag(OBJECT_TAG);</b>
<b class="nc">&nbsp;		writeValue(triple.getObject());</b>
<b class="nc">&nbsp;		xmlWriter.endTag(OBJECT_TAG);</b>
<b class="nc">&nbsp;		xmlWriter.endTag(TRIPLE_TAG);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Write a QName for the given URI if and only if the {@link BasicQueryWriterSettings#ADD_SESAME_QNAME} setting has
&nbsp;	 * been set to true. By default it is false, to ensure that this implementation stays within the specification by
&nbsp;	 * default.
&nbsp;	 *
&nbsp;	 * @param nextUri The prefixed URI to be written as a sesame qname attribute.
&nbsp;	 */
&nbsp;	private void writeQName(IRI nextUri) {
<b class="nc">&nbsp;		if (getWriterConfig().get(BasicQueryWriterSettings.ADD_SESAME_QNAME)) {</b>
<b class="nc">&nbsp;			xmlWriter.setAttribute(QNAME, namespaceTable.get(nextUri.getNamespace()) + &quot;:&quot; + nextUri.getLocalName());</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private void writeURI(IRI uri) throws IOException {
<b class="nc">&nbsp;		if (isQName(uri)) {</b>
<b class="nc">&nbsp;			writeQName(uri);</b>
&nbsp;		}
<b class="nc">&nbsp;		xmlWriter.textElement(URI_TAG, uri.toString());</b>
&nbsp;	}
&nbsp;
&nbsp;	private void writeBNode(BNode bNode) throws IOException {
<b class="nc">&nbsp;		xmlWriter.textElement(BNODE_TAG, bNode.getID());</b>
&nbsp;	}
&nbsp;
&nbsp;	private void writeLiteral(Literal literal) throws IOException {
<b class="nc">&nbsp;		if (Literals.isLanguageLiteral(literal)) {</b>
<b class="nc">&nbsp;			xmlWriter.setAttribute(LITERAL_LANG_ATT, literal.getLanguage().get());</b>
&nbsp;		}
&nbsp;		// Only enter this section for non-language literals now, as the
&nbsp;		// rdf:langString datatype is handled implicitly above
&nbsp;		else {
<b class="nc">&nbsp;			IRI datatype = literal.getDatatype();</b>
<b class="nc">&nbsp;			boolean ignoreDatatype = datatype.equals(XSD.STRING) &amp;&amp; xsdStringToPlainLiteral();</b>
<b class="nc">&nbsp;			if (!ignoreDatatype) {</b>
<b class="nc">&nbsp;				if (isQName(datatype)) {</b>
<b class="nc">&nbsp;					writeQName(datatype);</b>
&nbsp;				}
<b class="nc">&nbsp;				xmlWriter.setAttribute(LITERAL_DATATYPE_ATT, datatype.stringValue());</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		xmlWriter.textElement(LITERAL_TAG, literal.getLabel());</b>
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:58</div>
</div>
</body>
</html>
