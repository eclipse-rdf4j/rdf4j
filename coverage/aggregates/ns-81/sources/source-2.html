


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > AbstractSPARQLJSONWriter</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.query.resultio.sparqljson</a>
</div>

<h1>Coverage Summary for Class: AbstractSPARQLJSONWriter (org.eclipse.rdf4j.query.resultio.sparqljson)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AbstractSPARQLJSONWriter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/70)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/166)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;package org.eclipse.rdf4j.query.resultio.sparqljson;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.io.OutputStream;
&nbsp;import java.io.OutputStreamWriter;
&nbsp;import java.io.Writer;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.util.Collection;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.Set;
&nbsp;
&nbsp;import org.eclipse.rdf4j.common.io.CharSink;
&nbsp;import org.eclipse.rdf4j.model.BNode;
&nbsp;import org.eclipse.rdf4j.model.IRI;
&nbsp;import org.eclipse.rdf4j.model.Literal;
&nbsp;import org.eclipse.rdf4j.model.Value;
&nbsp;import org.eclipse.rdf4j.model.util.Literals;
&nbsp;import org.eclipse.rdf4j.model.vocabulary.XSD;
&nbsp;import org.eclipse.rdf4j.query.Binding;
&nbsp;import org.eclipse.rdf4j.query.BindingSet;
&nbsp;import org.eclipse.rdf4j.query.QueryResultHandlerException;
&nbsp;import org.eclipse.rdf4j.query.TupleQueryResultHandlerException;
&nbsp;import org.eclipse.rdf4j.query.resultio.AbstractQueryResultWriter;
&nbsp;import org.eclipse.rdf4j.query.resultio.BasicQueryWriterSettings;
&nbsp;import org.eclipse.rdf4j.query.resultio.QueryResultWriter;
&nbsp;import org.eclipse.rdf4j.rio.RioSetting;
&nbsp;import org.eclipse.rdf4j.rio.helpers.BasicWriterSettings;
&nbsp;
&nbsp;import com.fasterxml.jackson.core.JsonFactory;
&nbsp;import com.fasterxml.jackson.core.JsonGenerator;
&nbsp;import com.fasterxml.jackson.core.util.DefaultIndenter;
&nbsp;import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;
&nbsp;import com.fasterxml.jackson.core.util.DefaultPrettyPrinter.Indenter;
&nbsp;
&nbsp;/**
&nbsp; * An abstract class to implement the base functionality for both SPARQLBooleanJSONWriter and SPARQLResultsJSONWriter.
&nbsp; *
&nbsp; * @author Peter Ansell
&nbsp; */
&nbsp;abstract class AbstractSPARQLJSONWriter extends AbstractQueryResultWriter implements CharSink {
&nbsp;
<b class="nc">&nbsp;	private static final JsonFactory JSON_FACTORY = new JsonFactory();</b>
&nbsp;
&nbsp;	static {
&nbsp;		// Disable features that may work for most JSON where the field names are
&nbsp;		// in limited supply,
&nbsp;		// but does not work for RDF/JSON where a wide range of URIs are used for
&nbsp;		// subjects and
&nbsp;		// predicates
<b class="nc">&nbsp;		JSON_FACTORY.disable(JsonFactory.Feature.INTERN_FIELD_NAMES);</b>
<b class="nc">&nbsp;		JSON_FACTORY.disable(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES);</b>
<b class="nc">&nbsp;		JSON_FACTORY.disable(JsonGenerator.Feature.AUTO_CLOSE_TARGET);</b>
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	protected boolean firstTupleWritten = false;</b>
&nbsp;
<b class="nc">&nbsp;	protected boolean documentOpen = false;</b>
&nbsp;
<b class="nc">&nbsp;	protected boolean headerOpen = false;</b>
&nbsp;
<b class="nc">&nbsp;	protected boolean headerComplete = false;</b>
&nbsp;
<b class="nc">&nbsp;	protected boolean tupleVariablesFound = false;</b>
&nbsp;
<b class="nc">&nbsp;	protected boolean linksFound = false;</b>
&nbsp;
&nbsp;	protected final JsonGenerator jg;
&nbsp;
&nbsp;	private final Writer writer;
&nbsp;
&nbsp;	protected AbstractSPARQLJSONWriter(OutputStream out) {
<b class="nc">&nbsp;		this(new OutputStreamWriter(out, StandardCharsets.UTF_8));</b>
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	protected AbstractSPARQLJSONWriter(Writer writer) {</b>
<b class="nc">&nbsp;		this.writer = writer;</b>
&nbsp;		try {
<b class="nc">&nbsp;			jg = JSON_FACTORY.createGenerator(writer);</b>
<b class="nc">&nbsp;		} catch (IOException e) {</b>
<b class="nc">&nbsp;			throw new IllegalArgumentException(e);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public final Writer getWriter() {
<b class="nc">&nbsp;		return writer;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void endHeader() throws QueryResultHandlerException {
<b class="nc">&nbsp;		if (!headerComplete) {</b>
&nbsp;			try {
<b class="nc">&nbsp;				jg.writeEndObject();</b>
&nbsp;
<b class="nc">&nbsp;				if (tupleVariablesFound) {</b>
&nbsp;					// Write results
<b class="nc">&nbsp;					jg.writeObjectFieldStart(&quot;results&quot;);</b>
&nbsp;
<b class="nc">&nbsp;					jg.writeArrayFieldStart(&quot;bindings&quot;);</b>
&nbsp;				}
&nbsp;
<b class="nc">&nbsp;				headerComplete = true;</b>
<b class="nc">&nbsp;			} catch (IOException e) {</b>
<b class="nc">&nbsp;				throw new QueryResultHandlerException(e);</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void startQueryResult(List&lt;String&gt; columnHeaders) throws TupleQueryResultHandlerException {
<b class="nc">&nbsp;		super.startQueryResult(columnHeaders);</b>
&nbsp;
&nbsp;		try {
<b class="nc">&nbsp;			if (!documentOpen) {</b>
<b class="nc">&nbsp;				startDocument();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (!headerOpen) {</b>
<b class="nc">&nbsp;				startHeader();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			tupleVariablesFound = true;</b>
<b class="nc">&nbsp;			jg.writeArrayFieldStart(&quot;vars&quot;);</b>
<b class="nc">&nbsp;			for (String nextColumn : columnHeaders) {</b>
<b class="nc">&nbsp;				jg.writeString(nextColumn);</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			jg.writeEndArray();</b>
<b class="nc">&nbsp;		} catch (IOException | QueryResultHandlerException e) {</b>
<b class="nc">&nbsp;			throw new TupleQueryResultHandlerException(e);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected void handleSolutionImpl(BindingSet bindingSet) throws TupleQueryResultHandlerException {
&nbsp;		try {
<b class="nc">&nbsp;			if (!documentOpen) {</b>
<b class="nc">&nbsp;				startDocument();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (!headerOpen) {</b>
<b class="nc">&nbsp;				startHeader();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (!headerComplete) {</b>
<b class="nc">&nbsp;				endHeader();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (!tupleVariablesFound) {</b>
<b class="nc">&nbsp;				throw new IllegalStateException(&quot;Must call startQueryResult before handleSolution&quot;);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			firstTupleWritten = true;</b>
&nbsp;
<b class="nc">&nbsp;			jg.writeStartObject();</b>
&nbsp;
<b class="nc">&nbsp;			Iterator&lt;Binding&gt; bindingIter = bindingSet.iterator();</b>
<b class="nc">&nbsp;			while (bindingIter.hasNext()) {</b>
<b class="nc">&nbsp;				Binding binding = bindingIter.next();</b>
<b class="nc">&nbsp;				jg.writeFieldName(binding.getName());</b>
<b class="nc">&nbsp;				writeValue(binding.getValue());</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			jg.writeEndObject();</b>
<b class="nc">&nbsp;		} catch (IOException | QueryResultHandlerException e) {</b>
<b class="nc">&nbsp;			throw new TupleQueryResultHandlerException(e);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void endQueryResult() throws TupleQueryResultHandlerException {
&nbsp;		try {
<b class="nc">&nbsp;			if (!documentOpen) {</b>
<b class="nc">&nbsp;				startDocument();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (!headerOpen) {</b>
<b class="nc">&nbsp;				startHeader();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (!headerComplete) {</b>
<b class="nc">&nbsp;				endHeader();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (!tupleVariablesFound) {</b>
<b class="nc">&nbsp;				throw new IllegalStateException(&quot;Could not end query result as startQueryResult was not called first.&quot;);</b>
&nbsp;			}
&nbsp;
&nbsp;			// bindings array
<b class="nc">&nbsp;			jg.writeEndArray();</b>
&nbsp;			// results braces
<b class="nc">&nbsp;			jg.writeEndObject();</b>
<b class="nc">&nbsp;			endDocument();</b>
<b class="nc">&nbsp;		} catch (IOException | QueryResultHandlerException e) {</b>
<b class="nc">&nbsp;			throw new TupleQueryResultHandlerException(e);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void startDocument() throws QueryResultHandlerException {
<b class="nc">&nbsp;		if (!documentOpen) {</b>
<b class="nc">&nbsp;			documentOpen = true;</b>
<b class="nc">&nbsp;			headerOpen = false;</b>
<b class="nc">&nbsp;			headerComplete = false;</b>
<b class="nc">&nbsp;			tupleVariablesFound = false;</b>
<b class="nc">&nbsp;			firstTupleWritten = false;</b>
<b class="nc">&nbsp;			linksFound = false;</b>
&nbsp;
<b class="nc">&nbsp;			if (getWriterConfig().get(BasicWriterSettings.PRETTY_PRINT)) {</b>
&nbsp;				// SES-2011: Always use \n for consistency
<b class="nc">&nbsp;				Indenter indenter = DefaultIndenter.SYSTEM_LINEFEED_INSTANCE;</b>
&nbsp;				// By default Jackson does not pretty print, so enable this unless
&nbsp;				// PRETTY_PRINT setting is disabled
<b class="nc">&nbsp;				DefaultPrettyPrinter pp = new DefaultPrettyPrinter().withArrayIndenter(indenter)</b>
<b class="nc">&nbsp;						.withObjectIndenter(indenter);</b>
<b class="nc">&nbsp;				jg.setPrettyPrinter(pp);</b>
&nbsp;			}
&nbsp;
&nbsp;			try {
<b class="nc">&nbsp;				if (getWriterConfig().isSet(BasicQueryWriterSettings.JSONP_CALLBACK)) {</b>
&nbsp;					// SES-1019 : Write the callbackfunction name as a wrapper for
&nbsp;					// the results here
<b class="nc">&nbsp;					String callbackName = getWriterConfig().get(BasicQueryWriterSettings.JSONP_CALLBACK);</b>
<b class="nc">&nbsp;					jg.writeRaw(callbackName);</b>
<b class="nc">&nbsp;					jg.writeRaw(&quot;(&quot;);</b>
&nbsp;				}
<b class="nc">&nbsp;				jg.writeStartObject();</b>
<b class="nc">&nbsp;			} catch (IOException e) {</b>
<b class="nc">&nbsp;				throw new QueryResultHandlerException(e);</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void handleStylesheet(String stylesheetUrl) throws QueryResultHandlerException {
&nbsp;		// Ignore, as JSON does not support stylesheets
<b class="nc">&nbsp;	}</b>
&nbsp;
&nbsp;	@Override
&nbsp;	public void startHeader() throws QueryResultHandlerException {
<b class="nc">&nbsp;		if (!documentOpen) {</b>
<b class="nc">&nbsp;			startDocument();</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (!headerOpen) {</b>
&nbsp;			try {
&nbsp;				// Write header
<b class="nc">&nbsp;				jg.writeObjectFieldStart(&quot;head&quot;);</b>
&nbsp;
<b class="nc">&nbsp;				headerOpen = true;</b>
<b class="nc">&nbsp;			} catch (IOException e) {</b>
<b class="nc">&nbsp;				throw new QueryResultHandlerException(e);</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void handleLinks(List&lt;String&gt; linkUrls) throws QueryResultHandlerException {
&nbsp;		try {
<b class="nc">&nbsp;			if (!documentOpen) {</b>
<b class="nc">&nbsp;				startDocument();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (!headerOpen) {</b>
<b class="nc">&nbsp;				startHeader();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			jg.writeArrayFieldStart(&quot;link&quot;);</b>
<b class="nc">&nbsp;			for (String nextLink : linkUrls) {</b>
<b class="nc">&nbsp;				jg.writeString(nextLink);</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			jg.writeEndArray();</b>
<b class="nc">&nbsp;		} catch (IOException e) {</b>
<b class="nc">&nbsp;			throw new QueryResultHandlerException(e);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	protected void writeValue(Value value) throws IOException, QueryResultHandlerException {
<b class="nc">&nbsp;		jg.writeStartObject();</b>
&nbsp;
<b class="nc">&nbsp;		if (value instanceof IRI) {</b>
<b class="nc">&nbsp;			jg.writeStringField(&quot;type&quot;, &quot;uri&quot;);</b>
<b class="nc">&nbsp;			jg.writeStringField(&quot;value&quot;, ((IRI) value).toString());</b>
<b class="nc">&nbsp;		} else if (value instanceof BNode) {</b>
<b class="nc">&nbsp;			jg.writeStringField(&quot;type&quot;, &quot;bnode&quot;);</b>
<b class="nc">&nbsp;			jg.writeStringField(&quot;value&quot;, ((BNode) value).getID());</b>
<b class="nc">&nbsp;		} else if (value instanceof Literal) {</b>
<b class="nc">&nbsp;			Literal lit = (Literal) value;</b>
&nbsp;
<b class="nc">&nbsp;			if (Literals.isLanguageLiteral(lit)) {</b>
<b class="nc">&nbsp;				jg.writeObjectField(&quot;xml:lang&quot;, lit.getLanguage().orElse(null));</b>
&nbsp;			} else {
<b class="nc">&nbsp;				IRI datatype = lit.getDatatype();</b>
<b class="nc">&nbsp;				boolean ignoreDatatype = datatype.equals(XSD.STRING) &amp;&amp; xsdStringToPlainLiteral();</b>
<b class="nc">&nbsp;				if (!ignoreDatatype) {</b>
<b class="nc">&nbsp;					jg.writeObjectField(&quot;datatype&quot;, lit.getDatatype().stringValue());</b>
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			jg.writeObjectField(&quot;type&quot;, &quot;literal&quot;);</b>
&nbsp;
<b class="nc">&nbsp;			jg.writeObjectField(&quot;value&quot;, lit.getLabel());</b>
<b class="nc">&nbsp;		} else {</b>
<b class="nc">&nbsp;			throw new TupleQueryResultHandlerException(&quot;Unknown Value object type: &quot; + value.getClass());</b>
&nbsp;		}
<b class="nc">&nbsp;		jg.writeEndObject();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void handleBoolean(boolean value) throws QueryResultHandlerException {
<b class="nc">&nbsp;		if (!documentOpen) {</b>
<b class="nc">&nbsp;			startDocument();</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (!headerOpen) {</b>
<b class="nc">&nbsp;			startHeader();</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (!headerComplete) {</b>
<b class="nc">&nbsp;			endHeader();</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (tupleVariablesFound) {</b>
<b class="nc">&nbsp;			throw new QueryResultHandlerException(&quot;Cannot call handleBoolean after startQueryResults&quot;);</b>
&nbsp;		}
&nbsp;
&nbsp;		try {
<b class="nc">&nbsp;			if (value) {</b>
<b class="nc">&nbsp;				jg.writeBooleanField(&quot;boolean&quot;, Boolean.TRUE);</b>
&nbsp;			} else {
<b class="nc">&nbsp;				jg.writeBooleanField(&quot;boolean&quot;, Boolean.FALSE);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			endDocument();</b>
<b class="nc">&nbsp;		} catch (IOException e) {</b>
<b class="nc">&nbsp;			throw new QueryResultHandlerException(e);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public final Collection&lt;RioSetting&lt;?&gt;&gt; getSupportedSettings() {
<b class="nc">&nbsp;		Set&lt;RioSetting&lt;?&gt;&gt; result = new HashSet&lt;&gt;(super.getSupportedSettings());</b>
<b class="nc">&nbsp;		result.add(BasicQueryWriterSettings.JSONP_CALLBACK);</b>
<b class="nc">&nbsp;		result.add(BasicWriterSettings.PRETTY_PRINT);</b>
&nbsp;
<b class="nc">&nbsp;		return result;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void handleNamespace(String prefix, String uri) throws QueryResultHandlerException {
&nbsp;		// Ignored by SPARQLJSONWriterBase
<b class="nc">&nbsp;	}</b>
&nbsp;
&nbsp;	protected void endDocument() throws IOException {
<b class="nc">&nbsp;		jg.writeEndObject();</b>
<b class="nc">&nbsp;		if (getWriterConfig().isSet(BasicQueryWriterSettings.JSONP_CALLBACK)) {</b>
<b class="nc">&nbsp;			jg.writeRaw(&quot;);&quot;);</b>
&nbsp;		}
<b class="nc">&nbsp;		jg.flush();</b>
<b class="nc">&nbsp;		documentOpen = false;</b>
<b class="nc">&nbsp;		headerOpen = false;</b>
<b class="nc">&nbsp;		headerComplete = false;</b>
<b class="nc">&nbsp;		tupleVariablesFound = false;</b>
<b class="nc">&nbsp;		firstTupleWritten = false;</b>
<b class="nc">&nbsp;		linksFound = false;</b>
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:58</div>
</div>
</body>
</html>
