


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > TreeModel</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.model.impl</a>
</div>

<h1>Coverage Summary for Class: TreeModel (org.eclipse.rdf4j.model.impl)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TreeModel</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/42)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/158)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/203)
  </span>
</td>
</tr>
  <tr>
    <td class="name">TreeModel$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TreeModel$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TreeModel$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TreeModel$GraphComparator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TreeModel$ModelIterator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TreeModel$ObjectComparator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TreeModel$PredicateComparator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TreeModel$StatementComparator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TreeModel$StatementTree</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/47)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TreeModel$SubjectComparator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TreeModel$SubSet</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/58)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TreeModel$TreeStatement</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/103)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/208)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/348)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;package org.eclipse.rdf4j.model.impl;
&nbsp;
&nbsp;import java.io.Serializable;
&nbsp;import java.util.AbstractSet;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Comparator;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.NavigableSet;
&nbsp;import java.util.NoSuchElementException;
&nbsp;import java.util.Optional;
&nbsp;import java.util.Set;
&nbsp;import java.util.SortedSet;
&nbsp;import java.util.TreeSet;
&nbsp;
&nbsp;import org.eclipse.rdf4j.model.IRI;
&nbsp;import org.eclipse.rdf4j.model.Model;
&nbsp;import org.eclipse.rdf4j.model.Namespace;
&nbsp;import org.eclipse.rdf4j.model.Resource;
&nbsp;import org.eclipse.rdf4j.model.Statement;
&nbsp;import org.eclipse.rdf4j.model.Value;
&nbsp;import org.eclipse.rdf4j.model.util.LexicalValueComparator;
&nbsp;import org.eclipse.rdf4j.model.util.PatternIterator;
&nbsp;
&nbsp;/**
&nbsp; * A Red-Black tree based {@link Model} implementation. The model is sorted according to the lexical ordering of terms.
&nbsp; * &lt;p&gt;
&nbsp; * This implementation provides guaranteed log(n) time cost for filtered access by any number of terms. If an index is
&nbsp; * not yet available for a set of positions, it is created at runtime using a {@link TreeSet}.
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;Note that this implementation is not synchronized.&lt;/b&gt; If multiple threads access a model concurrently, even if
&nbsp; * all of them are read operations, it must be synchronized externally. This is typically accomplished by synchronizing
&nbsp; * on some object that naturally encapsulates the model. If no such object exists, the set should be &quot;wrapped&quot; using the
&nbsp; * Models.synchronizedModel method.
&nbsp; * &lt;/p&gt;
&nbsp; *
&nbsp; * @author James Leigh
&nbsp; */
&nbsp;public class TreeModel extends AbstractModel implements SortedSet&lt;Statement&gt; {
&nbsp;
&nbsp;	private static final long serialVersionUID = 7893197431354524479L;
&nbsp;
<b class="nc">&nbsp;	static final IRI BEFORE = new SimpleIRI(&quot;urn:from&quot;);</b>
&nbsp;
<b class="nc">&nbsp;	static final IRI AFTER = new SimpleIRI(&quot;urn:to&quot;);</b>
&nbsp;
<b class="nc">&nbsp;	private final LexicalValueComparator vc = new LexicalValueComparator();</b>
&nbsp;
<b class="nc">&nbsp;	final Set&lt;Namespace&gt; namespaces = new TreeSet&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;	final List&lt;StatementTree&gt; trees = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;	public TreeModel() {</b>
<b class="nc">&nbsp;		trees.add(new StatementTree(&quot;spog&quot;.toCharArray()));</b>
&nbsp;	}
&nbsp;
&nbsp;	public TreeModel(Model model) {
<b class="nc">&nbsp;		this(model.getNamespaces());</b>
<b class="nc">&nbsp;		addAll(model);</b>
&nbsp;	}
&nbsp;
&nbsp;	public TreeModel(Collection&lt;? extends Statement&gt; c) {
<b class="nc">&nbsp;		this();</b>
<b class="nc">&nbsp;		addAll(c);</b>
&nbsp;	}
&nbsp;
&nbsp;	public TreeModel(Set&lt;Namespace&gt; namespaces, Collection&lt;? extends Statement&gt; c) {
<b class="nc">&nbsp;		this(c);</b>
<b class="nc">&nbsp;		this.namespaces.addAll(namespaces);</b>
&nbsp;	}
&nbsp;
&nbsp;	public TreeModel(Set&lt;Namespace&gt; namespaces) {
<b class="nc">&nbsp;		this();</b>
<b class="nc">&nbsp;		this.namespaces.addAll(namespaces);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Optional&lt;Namespace&gt; getNamespace(String prefix) {
<b class="nc">&nbsp;		for (Namespace nextNamespace : namespaces) {</b>
<b class="nc">&nbsp;			if (prefix.equals(nextNamespace.getPrefix())) {</b>
<b class="nc">&nbsp;				return Optional.of(nextNamespace);</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return Optional.empty();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Set&lt;Namespace&gt; getNamespaces() {
<b class="nc">&nbsp;		return namespaces;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Namespace setNamespace(String prefix, String name) {
<b class="nc">&nbsp;		removeNamespace(prefix);</b>
<b class="nc">&nbsp;		Namespace result = new SimpleNamespace(prefix, name);</b>
<b class="nc">&nbsp;		namespaces.add(result);</b>
<b class="nc">&nbsp;		return result;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void setNamespace(Namespace namespace) {
<b class="nc">&nbsp;		removeNamespace(namespace.getPrefix());</b>
<b class="nc">&nbsp;		namespaces.add(namespace);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Optional&lt;Namespace&gt; removeNamespace(String prefix) {
<b class="nc">&nbsp;		Optional&lt;Namespace&gt; result = getNamespace(prefix);</b>
<b class="nc">&nbsp;		result.ifPresent(namespaces::remove);</b>
<b class="nc">&nbsp;		return result;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public int size() {
<b class="nc">&nbsp;		return trees.get(0).size();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void clear() {
<b class="nc">&nbsp;		for (StatementTree tree : trees) {</b>
<b class="nc">&nbsp;			tree.clear();</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Comparator&lt;? super Statement&gt; comparator() {
<b class="nc">&nbsp;		return trees.get(0).tree.comparator();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Statement first() {
<b class="nc">&nbsp;		return trees.get(0).tree.first();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Statement last() {
<b class="nc">&nbsp;		return trees.get(0).tree.last();</b>
&nbsp;	}
&nbsp;
&nbsp;	public Statement lower(Statement e) {
<b class="nc">&nbsp;		return trees.get(0).tree.lower(e);</b>
&nbsp;	}
&nbsp;
&nbsp;	public Statement floor(Statement e) {
<b class="nc">&nbsp;		return trees.get(0).tree.floor(e);</b>
&nbsp;	}
&nbsp;
&nbsp;	public Statement ceiling(Statement e) {
<b class="nc">&nbsp;		return trees.get(0).tree.ceiling(e);</b>
&nbsp;	}
&nbsp;
&nbsp;	public Statement higher(Statement e) {
<b class="nc">&nbsp;		return trees.get(0).tree.higher(e);</b>
&nbsp;	}
&nbsp;
&nbsp;	public Statement pollFirst() {
&nbsp;		try {
<b class="nc">&nbsp;			Statement first = trees.get(0).tree.first();</b>
<b class="nc">&nbsp;			remove(first);</b>
<b class="nc">&nbsp;			return first;</b>
<b class="nc">&nbsp;		} catch (NoSuchElementException e) {</b>
<b class="nc">&nbsp;			return null;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public Statement pollLast() {
&nbsp;		try {
<b class="nc">&nbsp;			Statement last = trees.get(0).tree.last();</b>
<b class="nc">&nbsp;			remove(last);</b>
<b class="nc">&nbsp;			return last;</b>
<b class="nc">&nbsp;		} catch (NoSuchElementException e) {</b>
<b class="nc">&nbsp;			return null;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public SortedSet&lt;Statement&gt; subSet(Statement fromElement, Statement toElement) {
<b class="nc">&nbsp;		return subSet(fromElement, true, toElement, false);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public SortedSet&lt;Statement&gt; headSet(Statement toElement) {
<b class="nc">&nbsp;		return subSet(before(null, null, null, null), true, toElement, false);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public SortedSet&lt;Statement&gt; tailSet(Statement fromElement) {
<b class="nc">&nbsp;		return subSet(fromElement, true, after(null, null, null, null), true);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public boolean add(Resource subj, IRI pred, Value obj, Resource... contexts) {
<b class="nc">&nbsp;		if (subj == null || pred == null || obj == null) {</b>
<b class="nc">&nbsp;			throw new UnsupportedOperationException(&quot;Incomplete statement&quot;);</b>
&nbsp;		}
<b class="nc">&nbsp;		boolean changed = false;</b>
<b class="nc">&nbsp;		for (Value ctx : notEmpty(contexts)) {</b>
<b class="nc">&nbsp;			if (ctx == null || ctx instanceof Resource) {</b>
<b class="nc">&nbsp;				Statement st = new TreeStatement(subj, pred, obj, (Resource) ctx);</b>
<b class="nc">&nbsp;				for (StatementTree tree : trees) {</b>
<b class="nc">&nbsp;					changed |= tree.add(st);</b>
<b class="nc">&nbsp;				}</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		return changed;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public boolean contains(Resource subj, IRI pred, Value obj, Resource... contexts) {
<b class="nc">&nbsp;		if (contexts == null || contexts.length == 1 &amp;&amp; contexts[0] == null) {</b>
<b class="nc">&nbsp;			Iterator&lt;Statement&gt; iter = matchPattern(subj, pred, obj, null);</b>
<b class="nc">&nbsp;			while (iter.hasNext()) {</b>
<b class="nc">&nbsp;				if (iter.next().getContext() == null) {</b>
<b class="nc">&nbsp;					return true;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			return false;</b>
<b class="nc">&nbsp;		} else if (contexts.length == 0) {</b>
<b class="nc">&nbsp;			return matchPattern(subj, pred, obj, null).hasNext();</b>
&nbsp;		} else {
<b class="nc">&nbsp;			for (Resource ctx : contexts) {</b>
<b class="nc">&nbsp;				if (ctx == null) {</b>
<b class="nc">&nbsp;					if (contains(subj, pred, obj, (Resource[]) null)) {</b>
<b class="nc">&nbsp;						return true;</b>
&nbsp;					}
<b class="nc">&nbsp;				} else if (matchPattern(subj, pred, obj, ctx).hasNext()) {</b>
<b class="nc">&nbsp;					return true;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public boolean remove(Resource subj, IRI pred, Value obj, Resource... contexts) {
<b class="nc">&nbsp;		if (isEmpty()) {</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		boolean changed = false;</b>
<b class="nc">&nbsp;		if (contexts == null || contexts.length == 1 &amp;&amp; contexts[0] == null) {</b>
<b class="nc">&nbsp;			Iterator&lt;Statement&gt; iter = matchPattern(subj, pred, obj, null);</b>
<b class="nc">&nbsp;			while (iter.hasNext()) {</b>
<b class="nc">&nbsp;				if (iter.next().getContext() == null) {</b>
<b class="nc">&nbsp;					iter.remove();</b>
<b class="nc">&nbsp;					changed = true;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;		} else if (contexts.length == 0) {</b>
<b class="nc">&nbsp;			Iterator&lt;Statement&gt; iter = matchPattern(subj, pred, obj, null);</b>
<b class="nc">&nbsp;			while (iter.hasNext()) {</b>
<b class="nc">&nbsp;				iter.next();</b>
<b class="nc">&nbsp;				iter.remove();</b>
<b class="nc">&nbsp;				changed = true;</b>
&nbsp;			}
<b class="nc">&nbsp;		} else {</b>
<b class="nc">&nbsp;			for (Resource ctx : contexts) {</b>
<b class="nc">&nbsp;				if (ctx == null) {</b>
<b class="nc">&nbsp;					changed |= remove(subj, pred, obj, (Resource[]) null);</b>
&nbsp;				} else {
<b class="nc">&nbsp;					Iterator&lt;Statement&gt; iter = matchPattern(subj, pred, obj, ctx);</b>
<b class="nc">&nbsp;					while (iter.hasNext()) {</b>
<b class="nc">&nbsp;						iter.next();</b>
<b class="nc">&nbsp;						iter.remove();</b>
<b class="nc">&nbsp;						changed = true;</b>
&nbsp;					}
&nbsp;				}
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		return changed;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Iterator&lt;Statement&gt; iterator() {
<b class="nc">&nbsp;		return matchPattern(null, null, null, null);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Model filter(final Resource subj, final IRI pred, final Value obj, final Resource... contexts) {
<b class="nc">&nbsp;		if (contexts != null &amp;&amp; contexts.length == 0) {</b>
<b class="nc">&nbsp;			return new FilteredModel(this, subj, pred, obj, contexts) {</b>
&nbsp;
&nbsp;				private static final long serialVersionUID = 396293781006255959L;
&nbsp;
&nbsp;				@Override
&nbsp;				public Iterator&lt;Statement&gt; iterator() {
<b class="nc">&nbsp;					return matchPattern(subj, pred, obj, null);</b>
&nbsp;				}
&nbsp;
&nbsp;				@Override
&nbsp;				protected void removeFilteredTermIteration(Iterator&lt;Statement&gt; iter, Resource subj, IRI pred, Value obj,
&nbsp;						Resource... contexts) {
<b class="nc">&nbsp;					TreeModel.this.removeTermIteration(iter, subj, pred, obj, contexts);</b>
&nbsp;				}
&nbsp;			};
<b class="nc">&nbsp;		} else if (contexts != null &amp;&amp; contexts.length == 1 &amp;&amp; contexts[0] != null) {</b>
<b class="nc">&nbsp;			return new FilteredModel(this, subj, pred, obj, contexts) {</b>
&nbsp;
&nbsp;				@Override
&nbsp;				public Iterator&lt;Statement&gt; iterator() {
<b class="nc">&nbsp;					return matchPattern(subj, pred, obj, contexts[0]);</b>
&nbsp;				}
&nbsp;
&nbsp;				@Override
&nbsp;				protected void removeFilteredTermIteration(Iterator&lt;Statement&gt; iter, Resource subj, IRI pred, Value obj,
&nbsp;						Resource... contexts) {
<b class="nc">&nbsp;					TreeModel.this.removeTermIteration(iter, subj, pred, obj, contexts);</b>
&nbsp;				}
&nbsp;			};
&nbsp;		} else {
<b class="nc">&nbsp;			return new FilteredModel(this, subj, pred, obj, contexts) {</b>
&nbsp;
&nbsp;				private static final long serialVersionUID = 396293781006255959L;
&nbsp;
&nbsp;				@Override
&nbsp;				public Iterator&lt;Statement&gt; iterator() {
<b class="nc">&nbsp;					return new PatternIterator&lt;&gt;(matchPattern(subj, pred, obj, null), subj, pred, obj, contexts);</b>
&nbsp;				}
&nbsp;
&nbsp;				@Override
&nbsp;				protected void removeFilteredTermIteration(Iterator&lt;Statement&gt; iter, Resource subj, IRI pred, Value obj,
&nbsp;						Resource... contexts) {
<b class="nc">&nbsp;					TreeModel.this.removeTermIteration(iter, subj, pred, obj, contexts);</b>
&nbsp;				}
&nbsp;			};
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void removeTermIteration(Iterator&lt;Statement&gt; iterator, Resource subj, IRI pred, Value obj,
&nbsp;			Resource... contexts) {
<b class="nc">&nbsp;		TreeSet&lt;Statement&gt; owner = ((ModelIterator) iterator).getOwner();</b>
<b class="nc">&nbsp;		if (contexts == null || contexts.length == 1 &amp;&amp; contexts[0] == null) {</b>
<b class="nc">&nbsp;			StatementTree chosen = choose(subj, pred, obj, null);</b>
<b class="nc">&nbsp;			Iterator&lt;Statement&gt; iter = chosen.subIterator(before(subj, pred, obj, null), true,</b>
<b class="nc">&nbsp;					after(subj, pred, obj, null), true);</b>
<b class="nc">&nbsp;			iter = new PatternIterator&lt;&gt;(iter, subj, pred, obj, contexts);</b>
<b class="nc">&nbsp;			removeAll(owner, chosen, iter);</b>
<b class="nc">&nbsp;		} else if (contexts.length == 0) {</b>
<b class="nc">&nbsp;			StatementTree chosen = choose(subj, pred, obj, null);</b>
<b class="nc">&nbsp;			Iterator&lt;Statement&gt; iter = chosen.subIterator(before(subj, pred, obj, null), true,</b>
<b class="nc">&nbsp;					after(subj, pred, obj, null), true);</b>
<b class="nc">&nbsp;			removeAll(owner, chosen, iter);</b>
<b class="nc">&nbsp;		} else {</b>
<b class="nc">&nbsp;			for (Value ctx : notEmpty(contexts)) {</b>
<b class="nc">&nbsp;				if (ctx == null) {</b>
<b class="nc">&nbsp;					removeTermIteration(iterator, subj, pred, obj, (Resource[]) null);</b>
&nbsp;				} else {
<b class="nc">&nbsp;					StatementTree chosen = choose(subj, pred, obj, ctx);</b>
<b class="nc">&nbsp;					Iterator&lt;Statement&gt; iter = chosen.subIterator(before(subj, pred, obj, ctx), true,</b>
<b class="nc">&nbsp;							after(subj, pred, obj, ctx), true);</b>
<b class="nc">&nbsp;					removeAll(owner, chosen, iter);</b>
&nbsp;				}
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	Iterator&lt;Statement&gt; matchPattern(Resource subj, IRI pred, Value obj, Resource ctx) {
<b class="nc">&nbsp;		if (!isResourceURIResource(subj, pred, ctx)) {</b>
<b class="nc">&nbsp;			Set&lt;Statement&gt; emptySet = Collections.emptySet();</b>
<b class="nc">&nbsp;			return emptySet.iterator();</b>
&nbsp;		}
<b class="nc">&nbsp;		StatementTree tree = choose(subj, pred, obj, ctx);</b>
<b class="nc">&nbsp;		Iterator&lt;Statement&gt; it = tree.subIterator(before(subj, pred, obj, ctx), true, after(subj, pred, obj, ctx),</b>
&nbsp;				true);
<b class="nc">&nbsp;		return new ModelIterator(it, tree);</b>
&nbsp;	}
&nbsp;
&nbsp;	int compareValue(Value o1, Value o2) {
<b class="nc">&nbsp;		if (o1 == o2) {</b>
<b class="nc">&nbsp;			return 0;</b>
&nbsp;		}
<b class="nc">&nbsp;		if (o1 == BEFORE) {</b>
<b class="nc">&nbsp;			return -1;</b>
&nbsp;		}
<b class="nc">&nbsp;		if (o2 == BEFORE) {</b>
<b class="nc">&nbsp;			return 1;</b>
&nbsp;		}
<b class="nc">&nbsp;		if (o1 == AFTER) {</b>
<b class="nc">&nbsp;			return 1;</b>
&nbsp;		}
<b class="nc">&nbsp;		if (o2 == AFTER) {</b>
<b class="nc">&nbsp;			return -1;</b>
&nbsp;		}
<b class="nc">&nbsp;		return vc.compare(o1, o2);</b>
&nbsp;	}
&nbsp;
&nbsp;	SortedSet&lt;Statement&gt; subSet(Statement lo, boolean loInclusive, Statement hi, boolean hiInclusive) {
<b class="nc">&nbsp;		return new SubSet(this, new TreeStatement(lo), loInclusive, new TreeStatement(hi), hiInclusive);</b>
&nbsp;	}
&nbsp;
&nbsp;	private void removeAll(TreeSet&lt;Statement&gt; owner, StatementTree chosen, Iterator&lt;Statement&gt; iter) {
<b class="nc">&nbsp;		while (iter.hasNext()) {</b>
<b class="nc">&nbsp;			Statement last = iter.next();</b>
<b class="nc">&nbsp;			for (StatementTree tree : trees) {</b>
<b class="nc">&nbsp;				if (tree.owns(owner)) {</b>
<b class="nc">&nbsp;					tree.reindex();</b>
<b class="nc">&nbsp;					tree.remove(last);</b>
<b class="nc">&nbsp;				} else if (tree != chosen) {</b>
<b class="nc">&nbsp;					tree.remove(last);</b>
&nbsp;				}
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			iter.remove(); // remove from chosen</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean isResourceURIResource(Value subj, Value pred, Value ctx) {
<b class="nc">&nbsp;		return (subj == null || subj instanceof Resource) &amp;&amp; (pred == null || pred instanceof IRI)</b>
&nbsp;				&amp;&amp; (ctx == null || ctx instanceof Resource);
&nbsp;	}
&nbsp;
&nbsp;	private Value[] notEmpty(Value[] contexts) {
<b class="nc">&nbsp;		if (contexts == null || contexts.length == 0) {</b>
<b class="nc">&nbsp;			return new Resource[] { null };</b>
&nbsp;		}
<b class="nc">&nbsp;		return contexts;</b>
&nbsp;	}
&nbsp;
&nbsp;	private Statement before(Value subj, Value pred, Value obj, Value ctx) {
<b class="nc">&nbsp;		Resource s = subj instanceof Resource ? (Resource) subj : BEFORE;</b>
<b class="nc">&nbsp;		IRI p = pred instanceof IRI ? (IRI) pred : BEFORE;</b>
<b class="nc">&nbsp;		Value o = obj instanceof Value ? obj : BEFORE;</b>
<b class="nc">&nbsp;		Resource c = ctx instanceof Resource ? (Resource) ctx : BEFORE;</b>
<b class="nc">&nbsp;		return new TreeStatement(s, p, o, c);</b>
&nbsp;	}
&nbsp;
&nbsp;	private Statement after(Value subj, Value pred, Value obj, Value ctx) {
<b class="nc">&nbsp;		Resource s = subj instanceof Resource ? (Resource) subj : AFTER;</b>
<b class="nc">&nbsp;		IRI p = pred instanceof IRI ? (IRI) pred : AFTER;</b>
<b class="nc">&nbsp;		Value o = obj instanceof Value ? obj : AFTER;</b>
<b class="nc">&nbsp;		Resource c = ctx instanceof Resource ? (Resource) ctx : AFTER;</b>
<b class="nc">&nbsp;		return new TreeStatement(s, p, o, c);</b>
&nbsp;	}
&nbsp;
&nbsp;	private StatementTree choose(Value subj, Value pred, Value obj, Value ctx) {
<b class="nc">&nbsp;		for (StatementTree tree : trees) {</b>
<b class="nc">&nbsp;			if (tree.isIndexed(subj, pred, obj, ctx)) {</b>
<b class="nc">&nbsp;				return tree;</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return index(subj, pred, obj, ctx);</b>
&nbsp;	}
&nbsp;
&nbsp;	private StatementTree index(Value subj, Value pred, Value obj, Value ctx) {
<b class="nc">&nbsp;		int idx = 0;</b>
<b class="nc">&nbsp;		char[] index = new char[4];</b>
<b class="nc">&nbsp;		if (subj != null) {</b>
<b class="nc">&nbsp;			index[idx++] = &#39;s&#39;;</b>
&nbsp;		}
<b class="nc">&nbsp;		if (pred != null) {</b>
<b class="nc">&nbsp;			index[idx++] = &#39;p&#39;;</b>
&nbsp;		}
<b class="nc">&nbsp;		if (obj != null) {</b>
<b class="nc">&nbsp;			index[idx++] = &#39;o&#39;;</b>
&nbsp;		}
<b class="nc">&nbsp;		if (ctx != null) {</b>
<b class="nc">&nbsp;			index[idx++] = &#39;g&#39;;</b>
&nbsp;		}
<b class="nc">&nbsp;		if (pred == null) {</b>
<b class="nc">&nbsp;			index[idx++] = &#39;p&#39;;</b>
&nbsp;		}
<b class="nc">&nbsp;		if (obj == null) {</b>
<b class="nc">&nbsp;			index[idx++] = &#39;o&#39;;</b>
&nbsp;		}
<b class="nc">&nbsp;		if (ctx == null) {</b>
<b class="nc">&nbsp;			index[idx++] = &#39;g&#39;;</b>
&nbsp;		}
<b class="nc">&nbsp;		if (subj == null) {</b>
<b class="nc">&nbsp;			index[idx++] = &#39;s&#39;;</b>
&nbsp;		}
<b class="nc">&nbsp;		StatementTree tree = new StatementTree(index);</b>
&nbsp;
<b class="nc">&nbsp;		tree.addAll(trees.get(0));</b>
<b class="nc">&nbsp;		trees.add(tree);</b>
<b class="nc">&nbsp;		return tree;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public boolean isEmpty() {
<b class="nc">&nbsp;		if (trees.isEmpty()) {</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;		}
<b class="nc">&nbsp;		return trees.get(0).isEmpty();</b>
&nbsp;	}
&nbsp;
&nbsp;	private class ModelIterator implements Iterator&lt;Statement&gt; {
&nbsp;
&nbsp;		private final Iterator&lt;Statement&gt; iter;
&nbsp;
&nbsp;		private final TreeSet&lt;Statement&gt; owner;
&nbsp;
&nbsp;		private Statement last;
&nbsp;
<b class="nc">&nbsp;		public ModelIterator(Iterator&lt;Statement&gt; iter, StatementTree owner) {</b>
<b class="nc">&nbsp;			this.iter = iter;</b>
<b class="nc">&nbsp;			this.owner = owner.tree;</b>
&nbsp;		}
&nbsp;
&nbsp;		public TreeSet&lt;Statement&gt; getOwner() {
<b class="nc">&nbsp;			return owner;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public boolean hasNext() {
<b class="nc">&nbsp;			return iter.hasNext();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Statement next() {
<b class="nc">&nbsp;			return last = iter.next();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void remove() {
<b class="nc">&nbsp;			if (last == null) {</b>
<b class="nc">&nbsp;				throw new IllegalStateException();</b>
&nbsp;			}
<b class="nc">&nbsp;			for (StatementTree tree : trees) {</b>
<b class="nc">&nbsp;				removeFrom(tree);</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			iter.remove(); // remove from owner</b>
&nbsp;		}
&nbsp;
&nbsp;		private void removeFrom(StatementTree subjects) {
<b class="nc">&nbsp;			if (!subjects.owns(owner)) {</b>
<b class="nc">&nbsp;				subjects.remove(last);</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	static class TreeStatement extends ContextStatement {
&nbsp;
&nbsp;		private static final long serialVersionUID = -7720419322256724495L;
&nbsp;
&nbsp;		public TreeStatement(Statement st) {
<b class="nc">&nbsp;			super(st.getSubject(), st.getPredicate(), st.getObject(), st.getContext());</b>
&nbsp;		}
&nbsp;
&nbsp;		public TreeStatement(Resource subject, IRI predicate, Value object, Resource ctx) {
<b class="nc">&nbsp;			super(subject, predicate, object, ctx);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	class StatementTree implements Serializable {
&nbsp;
&nbsp;		private static final long serialVersionUID = -7580746419791799953L;
&nbsp;
&nbsp;		private final char[] index;
&nbsp;
&nbsp;		TreeSet&lt;Statement&gt; tree;
&nbsp;
<b class="nc">&nbsp;		public StatementTree(char[] index) {</b>
<b class="nc">&nbsp;			this.index = index;</b>
<b class="nc">&nbsp;			Comparator&lt;Statement&gt;[] comparators = new Comparator[index.length];</b>
<b class="nc">&nbsp;			for (int i = 0; i &lt; index.length; i++) {</b>
<b class="nc">&nbsp;				switch (index[i]) {</b>
&nbsp;				case &#39;s&#39;:
<b class="nc">&nbsp;					comparators[i] = new SubjectComparator();</b>
<b class="nc">&nbsp;					break;</b>
&nbsp;				case &#39;p&#39;:
<b class="nc">&nbsp;					comparators[i] = new PredicateComparator();</b>
<b class="nc">&nbsp;					break;</b>
&nbsp;				case &#39;o&#39;:
<b class="nc">&nbsp;					comparators[i] = new ObjectComparator();</b>
<b class="nc">&nbsp;					break;</b>
&nbsp;				case &#39;g&#39;:
<b class="nc">&nbsp;					comparators[i] = new GraphComparator();</b>
<b class="nc">&nbsp;					break;</b>
&nbsp;				default:
<b class="nc">&nbsp;					throw new AssertionError();</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			tree = new TreeSet&lt;&gt;(new StatementComparator(comparators));</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean owns(TreeSet&lt;Statement&gt; set) {
<b class="nc">&nbsp;			return tree == set;</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean isIndexed(Value subj, Value pred, Value obj, Value ctx) {
<b class="nc">&nbsp;			boolean wild = false;</b>
<b class="nc">&nbsp;			for (int i = 0; i &lt; index.length; i++) {</b>
<b class="nc">&nbsp;				switch (index[i]) {</b>
&nbsp;				case &#39;s&#39;:
<b class="nc">&nbsp;					if (subj == null) {</b>
<b class="nc">&nbsp;						wild = true;</b>
<b class="nc">&nbsp;					} else if (wild) {</b>
<b class="nc">&nbsp;						return false;</b>
&nbsp;					}
&nbsp;					break;
&nbsp;				case &#39;p&#39;:
<b class="nc">&nbsp;					if (pred == null) {</b>
<b class="nc">&nbsp;						wild = true;</b>
<b class="nc">&nbsp;					} else if (wild) {</b>
<b class="nc">&nbsp;						return false;</b>
&nbsp;					}
&nbsp;					break;
&nbsp;				case &#39;o&#39;:
<b class="nc">&nbsp;					if (obj == null) {</b>
<b class="nc">&nbsp;						wild = true;</b>
<b class="nc">&nbsp;					} else if (wild) {</b>
<b class="nc">&nbsp;						return false;</b>
&nbsp;					}
&nbsp;					break;
&nbsp;				case &#39;g&#39;:
<b class="nc">&nbsp;					if (ctx == null) {</b>
<b class="nc">&nbsp;						wild = true;</b>
<b class="nc">&nbsp;					} else if (wild) {</b>
<b class="nc">&nbsp;						return false;</b>
&nbsp;					}
&nbsp;					break;
&nbsp;				default:
<b class="nc">&nbsp;					throw new AssertionError();</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			return true;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void reindex() {
<b class="nc">&nbsp;			TreeSet&lt;Statement&gt; treeSet = new TreeSet&lt;&gt;(tree.comparator());</b>
<b class="nc">&nbsp;			treeSet.addAll(tree);</b>
<b class="nc">&nbsp;			tree = treeSet;</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean add(Statement e) {
<b class="nc">&nbsp;			return tree.add(e);</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean addAll(StatementTree c) {
<b class="nc">&nbsp;			return tree.addAll(c.tree);</b>
&nbsp;		}
&nbsp;
&nbsp;		public int size() {
<b class="nc">&nbsp;			return tree.size();</b>
&nbsp;		}
&nbsp;
&nbsp;		public void clear() {
<b class="nc">&nbsp;			tree.clear();</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean remove(Object o) {
<b class="nc">&nbsp;			return tree.remove(o);</b>
&nbsp;		}
&nbsp;
&nbsp;		public Iterator&lt;Statement&gt; subIterator(Statement fromElement, boolean fromInclusive, Statement toElement,
&nbsp;				boolean toInclusive) {
<b class="nc">&nbsp;			return tree.subSet(fromElement, true, toElement, true).iterator();</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean isEmpty() {
<b class="nc">&nbsp;			return tree.isEmpty();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	class SubjectComparator implements Serializable, Comparator&lt;Statement&gt; {</b>
&nbsp;
&nbsp;		private static final long serialVersionUID = 5275239384134217143L;
&nbsp;
&nbsp;		@Override
&nbsp;		public int compare(Statement s1, Statement s2) {
<b class="nc">&nbsp;			return compareValue(s1.getSubject(), s2.getSubject());</b>
&nbsp;		}
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	class PredicateComparator implements Serializable, Comparator&lt;Statement&gt; {</b>
&nbsp;
&nbsp;		private static final long serialVersionUID = -883414941022127103L;
&nbsp;
&nbsp;		@Override
&nbsp;		public int compare(Statement s1, Statement s2) {
<b class="nc">&nbsp;			return compareValue(s1.getPredicate(), s2.getPredicate());</b>
&nbsp;		}
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	class ObjectComparator implements Serializable, Comparator&lt;Statement&gt; {</b>
&nbsp;
&nbsp;		private static final long serialVersionUID = 1768294714884456242L;
&nbsp;
&nbsp;		@Override
&nbsp;		public int compare(Statement s1, Statement s2) {
<b class="nc">&nbsp;			return compareValue(s1.getObject(), s2.getObject());</b>
&nbsp;		}
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	class GraphComparator implements Serializable, Comparator&lt;Statement&gt; {</b>
&nbsp;
&nbsp;		private static final long serialVersionUID = 7027824614533897706L;
&nbsp;
&nbsp;		@Override
&nbsp;		public int compare(Statement s1, Statement s2) {
<b class="nc">&nbsp;			return compareValue(s1.getContext(), s2.getContext());</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	static class StatementComparator implements Serializable, Comparator&lt;Statement&gt; {
&nbsp;
&nbsp;		private static final long serialVersionUID = -5602364720279633641L;
&nbsp;
&nbsp;		private final Comparator&lt;Statement&gt;[] comparators;
&nbsp;
<b class="nc">&nbsp;		public StatementComparator(Comparator&lt;Statement&gt;... comparators) {</b>
<b class="nc">&nbsp;			this.comparators = comparators;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public int compare(Statement s1, Statement s2) {
<b class="nc">&nbsp;			for (Comparator&lt;Statement&gt; c : comparators) {</b>
<b class="nc">&nbsp;				int r1 = c.compare(s1, s2);</b>
<b class="nc">&nbsp;				if (r1 != 0) {</b>
<b class="nc">&nbsp;					return r1;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			return 0;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	static class SubSet extends AbstractSet&lt;Statement&gt; implements Serializable, SortedSet&lt;Statement&gt; {
&nbsp;
&nbsp;		private static final long serialVersionUID = 6362727792092563793L;
&nbsp;
&nbsp;		private final TreeModel model;
&nbsp;
&nbsp;		private final TreeStatement lo, hi;
&nbsp;
&nbsp;		private final boolean loInclusive, hiInclusive;
&nbsp;
<b class="nc">&nbsp;		public SubSet(TreeModel model, TreeStatement lo, boolean loInclusive, TreeStatement hi, boolean hiInclusive) {</b>
<b class="nc">&nbsp;			this.model = model;</b>
<b class="nc">&nbsp;			this.lo = lo;</b>
<b class="nc">&nbsp;			this.loInclusive = loInclusive;</b>
<b class="nc">&nbsp;			this.hi = hi;</b>
<b class="nc">&nbsp;			this.hiInclusive = hiInclusive;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Optional&lt;Namespace&gt; getNamespace(String prefix) {
<b class="nc">&nbsp;			return model.getNamespace(prefix);</b>
&nbsp;		}
&nbsp;
&nbsp;		public Set&lt;Namespace&gt; getNamespaces() {
<b class="nc">&nbsp;			return model.getNamespaces();</b>
&nbsp;		}
&nbsp;
&nbsp;		public Namespace setNamespace(String prefix, String name) {
<b class="nc">&nbsp;			return model.setNamespace(prefix, name);</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setNamespace(Namespace namespace) {
<b class="nc">&nbsp;			model.setNamespace(namespace);</b>
&nbsp;		}
&nbsp;
&nbsp;		public Optional&lt;Namespace&gt; removeNamespace(String prefix) {
<b class="nc">&nbsp;			return model.removeNamespace(prefix);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public int size() {
<b class="nc">&nbsp;			return subSet().size();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void clear() {
<b class="nc">&nbsp;			StatementTree tree = model.trees.get(0);</b>
<b class="nc">&nbsp;			Iterator&lt;Statement&gt; it = tree.subIterator(lo, loInclusive, hi, hiInclusive);</b>
<b class="nc">&nbsp;			it = model.new ModelIterator(it, tree);</b>
<b class="nc">&nbsp;			while (it.hasNext()) {</b>
<b class="nc">&nbsp;				it.remove();</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Comparator&lt;? super Statement&gt; comparator() {
<b class="nc">&nbsp;			return model.comparator();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Statement first() {
<b class="nc">&nbsp;			return subSet().first();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Statement last() {
<b class="nc">&nbsp;			return subSet().last();</b>
&nbsp;		}
&nbsp;
&nbsp;		public Statement lower(Statement e) {
<b class="nc">&nbsp;			return subSet().lower(e);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public boolean isEmpty() {
<b class="nc">&nbsp;			return subSet().isEmpty();</b>
&nbsp;		}
&nbsp;
&nbsp;		public Statement floor(Statement e) {
<b class="nc">&nbsp;			return subSet().floor(e);</b>
&nbsp;		}
&nbsp;
&nbsp;		public Statement ceiling(Statement e) {
<b class="nc">&nbsp;			return subSet().ceiling(e);</b>
&nbsp;		}
&nbsp;
&nbsp;		public Statement higher(Statement e) {
<b class="nc">&nbsp;			return subSet().higher(e);</b>
&nbsp;		}
&nbsp;
&nbsp;		public Statement pollFirst() {
&nbsp;			try {
<b class="nc">&nbsp;				Statement first = subSet().first();</b>
<b class="nc">&nbsp;				model.remove(first);</b>
<b class="nc">&nbsp;				return first;</b>
<b class="nc">&nbsp;			} catch (NoSuchElementException e) {</b>
<b class="nc">&nbsp;				return null;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		public Statement pollLast() {
&nbsp;			try {
<b class="nc">&nbsp;				Statement last = subSet().last();</b>
<b class="nc">&nbsp;				model.remove(last);</b>
<b class="nc">&nbsp;				return last;</b>
<b class="nc">&nbsp;			} catch (NoSuchElementException e) {</b>
<b class="nc">&nbsp;				return null;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public SortedSet&lt;Statement&gt; subSet(Statement fromElement, Statement toElement) {
<b class="nc">&nbsp;			boolean fromInclusive = true;</b>
<b class="nc">&nbsp;			boolean toInclusive = false;</b>
<b class="nc">&nbsp;			if (comparator().compare(fromElement, lo) &lt; 0) {</b>
<b class="nc">&nbsp;				fromElement = lo;</b>
<b class="nc">&nbsp;				fromInclusive = loInclusive;</b>
&nbsp;			}
<b class="nc">&nbsp;			if (comparator().compare(hi, toElement) &lt; 0) {</b>
<b class="nc">&nbsp;				toElement = hi;</b>
<b class="nc">&nbsp;				toInclusive = hiInclusive;</b>
&nbsp;			}
<b class="nc">&nbsp;			return model.subSet(fromElement, fromInclusive, toElement, toInclusive);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public SortedSet&lt;Statement&gt; headSet(Statement toElement) {
<b class="nc">&nbsp;			boolean toInclusive = false;</b>
<b class="nc">&nbsp;			if (comparator().compare(hi, toElement) &lt; 0) {</b>
<b class="nc">&nbsp;				toElement = hi;</b>
<b class="nc">&nbsp;				toInclusive = hiInclusive;</b>
&nbsp;			}
<b class="nc">&nbsp;			return model.subSet(lo, loInclusive, toElement, toInclusive);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public SortedSet&lt;Statement&gt; tailSet(Statement fromElement) {
<b class="nc">&nbsp;			boolean fromInclusive = true;</b>
<b class="nc">&nbsp;			if (comparator().compare(fromElement, lo) &lt; 0) {</b>
<b class="nc">&nbsp;				fromElement = lo;</b>
<b class="nc">&nbsp;				fromInclusive = loInclusive;</b>
&nbsp;			}
<b class="nc">&nbsp;			return model.subSet(fromElement, fromInclusive, hi, hiInclusive);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Iterator&lt;Statement&gt; iterator() {
<b class="nc">&nbsp;			StatementTree tree = model.trees.get(0);</b>
<b class="nc">&nbsp;			Iterator&lt;Statement&gt; it = tree.subIterator(lo, loInclusive, hi, hiInclusive);</b>
<b class="nc">&nbsp;			return model.new ModelIterator(it, tree);</b>
&nbsp;		}
&nbsp;
&nbsp;		private NavigableSet&lt;Statement&gt; subSet() {
<b class="nc">&nbsp;			return model.trees.get(0).tree.subSet(lo, loInclusive, hi, hiInclusive);</b>
&nbsp;		}
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:58</div>
</div>
</body>
</html>
