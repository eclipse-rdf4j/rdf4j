


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > AbstractSail</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.eclipse.rdf4j.sail.helpers</a>
</div>

<h1>Coverage Summary for Class: AbstractSail (org.eclipse.rdf4j.sail.helpers)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AbstractSail</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (16/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (15/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    65.6%
  </span>
  <span class="absValue">
    (59/90)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
&nbsp; *
&nbsp; * All rights reserved. This program and the accompanying materials
&nbsp; * are made available under the terms of the Eclipse Distribution License v1.0
&nbsp; * which accompanies this distribution, and is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; *******************************************************************************/
&nbsp;package org.eclipse.rdf4j.sail.helpers;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.IdentityHashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.concurrent.locks.ReentrantReadWriteLock;
&nbsp;
&nbsp;import org.eclipse.rdf4j.common.transaction.IsolationLevel;
&nbsp;import org.eclipse.rdf4j.common.transaction.IsolationLevels;
&nbsp;import org.eclipse.rdf4j.sail.Sail;
&nbsp;import org.eclipse.rdf4j.sail.SailConnection;
&nbsp;import org.eclipse.rdf4j.sail.SailException;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;
&nbsp;/**
&nbsp; * An abstract Sail implementation that takes care of common sail tasks, including proper closing of active connections
&nbsp; * and a grace period for active connections during shutdown of the store.
&nbsp; *
&nbsp; * @author Herko ter Horst
&nbsp; * @author jeen
&nbsp; * @author Arjohn Kampman
&nbsp; */
&nbsp;public abstract class AbstractSail implements Sail {
&nbsp;
&nbsp;	/*-----------*
&nbsp;	 * Constants *
&nbsp;	 *-----------*/
&nbsp;
&nbsp;	/**
&nbsp;	 * Default connection timeout on shutdown: 20,000 milliseconds.
&nbsp;	 */
&nbsp;	protected final static long DEFAULT_CONNECTION_TIMEOUT = 20000L;
&nbsp;
&nbsp;	/**
&nbsp;	 * default transaction isolation level, set to {@link IsolationLevels#READ_COMMITTED }.
&nbsp;	 */
<b class="fc">&nbsp;	private IsolationLevel defaultIsolationLevel = IsolationLevels.READ_COMMITTED;</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * list of supported isolation levels. By default set to include {@link IsolationLevels#READ_UNCOMMITTED} and
&nbsp;	 * {@link IsolationLevels#SERIALIZABLE}. Specific store implementations are expected to alter this list according to
&nbsp;	 * their specific capabilities.
&nbsp;	 */
<b class="fc">&nbsp;	private List&lt;IsolationLevel&gt; supportedIsolationLevels = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * default value for the Iteration item sync threshold
&nbsp;	 */
&nbsp;	protected static final long DEFAULT_ITERATION_SYNC_THRESHOLD = 0L;
&nbsp;
&nbsp;	// Note: the following variable and method are package protected so that they
&nbsp;	// can be removed when open connections no longer block other connections and
&nbsp;	// they can be closed silently (just like in JDBC).
&nbsp;	static final String DEBUG_PROP = &quot;org.eclipse.rdf4j.repository.debug&quot;;
&nbsp;
&nbsp;	protected static boolean debugEnabled() {
&nbsp;		try {
<b class="fc">&nbsp;			String value = System.getProperty(DEBUG_PROP);</b>
<b class="pc">&nbsp;			return value != null &amp;&amp; !value.equals(&quot;false&quot;);</b>
<b class="nc">&nbsp;		} catch (SecurityException e) {</b>
&nbsp;			// Thrown when not allowed to read system properties, for example when
&nbsp;			// running in applets
<b class="nc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/*-----------*
&nbsp;	 * Variables *
&nbsp;	 *-----------*/
&nbsp;
<b class="fc">&nbsp;	private static final Logger logger = LoggerFactory.getLogger(AbstractSail.class);</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Directory to store information related to this sail in (if any).
&nbsp;	 */
&nbsp;	private volatile File dataDir;
&nbsp;
&nbsp;	/**
&nbsp;	 * Flag indicating whether the Sail has been initialized. Sails are initialized from {@link #init() initialization}
&nbsp;	 * until {@link #shutDown() shutdown}.
&nbsp;	 */
<b class="fc">&nbsp;	private volatile boolean initialized = false;</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Lock used to synchronize the initialization state of a sail.
&nbsp;	 * &lt;ul&gt;
&nbsp;	 * &lt;li&gt;write lock: initialize(), shutDown()
&nbsp;	 * &lt;li&gt;read lock: getConnection()
&nbsp;	 * &lt;/ul&gt;
&nbsp;	 */
<b class="fc">&nbsp;	protected final ReentrantReadWriteLock initializationLock = new ReentrantReadWriteLock();</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Connection timeout on shutdown (in ms). Defaults to {@link #DEFAULT_CONNECTION_TIMEOUT}.
&nbsp;	 */
<b class="fc">&nbsp;	protected volatile long connectionTimeOut = DEFAULT_CONNECTION_TIMEOUT;</b>
&nbsp;
<b class="fc">&nbsp;	private long iterationCacheSyncThreshold = DEFAULT_ITERATION_SYNC_THRESHOLD;</b>
&nbsp;
&nbsp;	// track the results size that each node in the query plan produces during execution
&nbsp;	private boolean trackResultSize;
&nbsp;
&nbsp;	/**
&nbsp;	 * Map used to track active connections and where these were acquired. The Throwable value may be null in case
&nbsp;	 * debugging was disable at the time the connection was acquired.
&nbsp;	 */
<b class="fc">&nbsp;	private final Map&lt;SailConnection, Throwable&gt; activeConnections = new IdentityHashMap&lt;&gt;();</b>
&nbsp;
&nbsp;	/*
&nbsp;	 * constructors
&nbsp;	 */
&nbsp;
&nbsp;	public AbstractSail() {
<b class="fc">&nbsp;		super();</b>
<b class="fc">&nbsp;		this.addSupportedIsolationLevel(IsolationLevels.READ_UNCOMMITTED);</b>
<b class="fc">&nbsp;		this.addSupportedIsolationLevel(IsolationLevels.SERIALIZABLE);</b>
&nbsp;	}
&nbsp;
&nbsp;	/*---------*
&nbsp;	 * Methods *
&nbsp;	 *---------*/
&nbsp;
&nbsp;	/**
&nbsp;	 * Set connection timeout on shutdown (in ms).
&nbsp;	 *
&nbsp;	 * @param connectionTimeOut timeout (in ms)
&nbsp;	 */
&nbsp;	public void setConnectionTimeOut(long connectionTimeOut) {
<b class="nc">&nbsp;		this.connectionTimeOut = connectionTimeOut;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void setDataDir(File dataDir) {
<b class="pc">&nbsp;		if (isInitialized()) {</b>
<b class="nc">&nbsp;			throw new IllegalStateException(&quot;sail has already been initialized&quot;);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		this.dataDir = dataDir;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public File getDataDir() {
<b class="nc">&nbsp;		return dataDir;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public String toString() {
<b class="nc">&nbsp;		if (dataDir == null) {</b>
<b class="nc">&nbsp;			return super.toString();</b>
&nbsp;		} else {
<b class="nc">&nbsp;			return dataDir.toString();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Checks whether the Sail has been initialized. Sails are initialized from {@link #init() initialization} until
&nbsp;	 * {@link #shutDown() shutdown}.
&nbsp;	 *
&nbsp;	 * @return &lt;var&gt;true&lt;/var&gt; if the Sail has been initialized, &lt;var&gt;false&lt;/var&gt; otherwise.
&nbsp;	 */
&nbsp;	protected boolean isInitialized() {
<b class="fc">&nbsp;		return initialized;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void init() throws SailException {
<b class="fc">&nbsp;		initializationLock.writeLock().lock();</b>
&nbsp;		try {
<b class="pc">&nbsp;			if (isInitialized()) {</b>
&nbsp;				return; // skip silently
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			initializeInternal();</b>
&nbsp;
<b class="fc">&nbsp;			initialized = true;</b>
&nbsp;		} finally {
<b class="fc">&nbsp;			initializationLock.writeLock().unlock();</b>
<b class="fc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Do store-specific operations to initialize the store. The default implementation of this method does nothing.
&nbsp;	 */
&nbsp;	protected void initializeInternal() throws SailException {
<b class="nc">&nbsp;	}</b>
&nbsp;
&nbsp;	@Override
&nbsp;	public void shutDown() throws SailException {
<b class="fc">&nbsp;		initializationLock.writeLock().lock();</b>
&nbsp;		try {
<b class="pc">&nbsp;			if (!isInitialized()) {</b>
&nbsp;				return;
&nbsp;			}
&nbsp;
&nbsp;			Map&lt;SailConnection, Throwable&gt; activeConnectionsCopy;
&nbsp;
<b class="fc">&nbsp;			synchronized (activeConnections) {</b>
&nbsp;				// Check if any active connections exist. If so, wait for a grace
&nbsp;				// period for them to finish.
<b class="pc">&nbsp;				if (!activeConnections.isEmpty()) {</b>
<b class="nc">&nbsp;					logger.debug(&quot;Waiting for active connections to close before shutting down...&quot;);</b>
&nbsp;					try {
<b class="nc">&nbsp;						activeConnections.wait(connectionTimeOut);</b>
<b class="nc">&nbsp;					} catch (InterruptedException e) {</b>
&nbsp;						// ignore and continue
<b class="nc">&nbsp;					}</b>
&nbsp;				}
&nbsp;
&nbsp;				// Copy the current contents of the map so that we don&#39;t have to
&nbsp;				// synchronize on activeConnections. This prevents a potential
&nbsp;				// deadlock with concurrent calls to connectionClosed()
<b class="fc">&nbsp;				activeConnectionsCopy = new IdentityHashMap&lt;&gt;(activeConnections);</b>
<b class="fc">&nbsp;			}</b>
&nbsp;
&nbsp;			// Forcefully close any connections that are still open
<b class="pc">&nbsp;			for (Map.Entry&lt;SailConnection, Throwable&gt; entry : activeConnectionsCopy.entrySet()) {</b>
<b class="nc">&nbsp;				SailConnection con = entry.getKey();</b>
<b class="nc">&nbsp;				Throwable stackTrace = entry.getValue();</b>
&nbsp;
<b class="nc">&nbsp;				if (stackTrace == null) {</b>
<b class="nc">&nbsp;					logger.warn(&quot;Closing active connection due to shut down; consider setting the {} system property&quot;,</b>
&nbsp;							DEBUG_PROP);
&nbsp;				} else {
<b class="nc">&nbsp;					logger.warn(&quot;Closing active connection due to shut down, connection was acquired in&quot;, stackTrace);</b>
&nbsp;				}
&nbsp;
&nbsp;				try {
<b class="nc">&nbsp;					con.close();</b>
<b class="nc">&nbsp;				} catch (SailException e) {</b>
<b class="nc">&nbsp;					logger.error(&quot;Failed to close connection&quot;, e);</b>
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
&nbsp;			// All connections should be closed now
<b class="fc">&nbsp;			synchronized (activeConnections) {</b>
<b class="fc">&nbsp;				activeConnections.clear();</b>
<b class="fc">&nbsp;			}</b>
&nbsp;
<b class="fc">&nbsp;			shutDownInternal();</b>
&nbsp;		} finally {
<b class="fc">&nbsp;			initialized = false;</b>
<b class="fc">&nbsp;			initializationLock.writeLock().unlock();</b>
<b class="fc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Do store-specific operations to ensure proper shutdown of the store.
&nbsp;	 */
&nbsp;	protected abstract void shutDownInternal() throws SailException;
&nbsp;
&nbsp;	@Override
&nbsp;	public SailConnection getConnection() throws SailException {
<b class="pc">&nbsp;		if (!isInitialized()) {</b>
<b class="nc">&nbsp;			init();</b>
&nbsp;		}
<b class="fc">&nbsp;		initializationLock.readLock().lock();</b>
&nbsp;		try {
<b class="fc">&nbsp;			SailConnection connection = getConnectionInternal();</b>
&nbsp;
<b class="fc">&nbsp;			Throwable stackTrace = debugEnabled() ? new Throwable() : null;</b>
<b class="fc">&nbsp;			synchronized (activeConnections) {</b>
<b class="fc">&nbsp;				activeConnections.put(connection, stackTrace);</b>
<b class="fc">&nbsp;			}</b>
&nbsp;
<b class="fc">&nbsp;			return connection;</b>
&nbsp;		} finally {
<b class="fc">&nbsp;			initializationLock.readLock().unlock();</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns a store-specific SailConnection object.
&nbsp;	 *
&nbsp;	 * @return A connection to the store.
&nbsp;	 */
&nbsp;	protected abstract SailConnection getConnectionInternal() throws SailException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Signals to the store that the supplied connection has been closed; called by
&nbsp;	 * {@link AbstractSailConnection#close()}.
&nbsp;	 *
&nbsp;	 * @param connection The connection that has been closed.
&nbsp;	 */
&nbsp;	protected void connectionClosed(SailConnection connection) {
<b class="fc">&nbsp;		synchronized (activeConnections) {</b>
<b class="pc">&nbsp;			if (activeConnections.containsKey(connection)) {</b>
<b class="fc">&nbsp;				activeConnections.remove(connection);</b>
&nbsp;
<b class="fc">&nbsp;				if (activeConnections.isEmpty()) {</b>
&nbsp;					// only notify waiting threads if all active connections have
&nbsp;					// been closed.
<b class="fc">&nbsp;					activeConnections.notifyAll();</b>
&nbsp;				}
&nbsp;			} else {
<b class="nc">&nbsp;				logger.warn(&quot;tried to remove unknown connection object from store.&quot;);</b>
&nbsp;			}
<b class="fc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Appends the provided {@link IsolationLevels} to the SAIL&#39;s list of supported isolation levels.
&nbsp;	 *
&nbsp;	 * @param level a supported IsolationLevel.
&nbsp;	 */
&nbsp;	protected void addSupportedIsolationLevel(IsolationLevels level) {
<b class="fc">&nbsp;		this.supportedIsolationLevels.add(level);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Removes all occurrences of the provided {@link IsolationLevels} in the list of supported Isolation levels.
&nbsp;	 *
&nbsp;	 * @param level the isolation level to remove.
&nbsp;	 */
&nbsp;	protected void removeSupportedIsolationLevel(IsolationLevel level) {
<b class="nc">&nbsp;		while (this.supportedIsolationLevels.remove(level)) {</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets the list of supported {@link IsolationLevels}s for this SAIL. The list is expected to be ordered in
&nbsp;	 * increasing complexity.
&nbsp;	 *
&nbsp;	 * @param supportedIsolationLevels a list of supported isolation levels.
&nbsp;	 */
&nbsp;	protected void setSupportedIsolationLevels(List&lt;IsolationLevel&gt; supportedIsolationLevels) {
<b class="nc">&nbsp;		this.supportedIsolationLevels = supportedIsolationLevels;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets the list of supported {@link IsolationLevels}s for this SAIL. The list is expected to be ordered in
&nbsp;	 * increasing complexity.
&nbsp;	 *
&nbsp;	 * @param supportedIsolationLevels a list of supported isolation levels.
&nbsp;	 */
&nbsp;	protected void setSupportedIsolationLevels(IsolationLevel... supportedIsolationLevels) {
<b class="fc">&nbsp;		this.supportedIsolationLevels = Arrays.asList(supportedIsolationLevels);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public List&lt;IsolationLevel&gt; getSupportedIsolationLevels() {
<b class="fc">&nbsp;		return Collections.unmodifiableList(supportedIsolationLevels);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public IsolationLevel getDefaultIsolationLevel() {
<b class="fc">&nbsp;		return defaultIsolationLevel;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets the default {@link IsolationLevel} on which transactions in this Sail operate.
&nbsp;	 *
&nbsp;	 * @param defaultIsolationLevel The defaultIsolationLevel to set.
&nbsp;	 */
&nbsp;	public void setDefaultIsolationLevel(IsolationLevel defaultIsolationLevel) {
<b class="pc">&nbsp;		if (defaultIsolationLevel == null) {</b>
<b class="nc">&nbsp;			throw new IllegalArgumentException(&quot;default isolation level may not be null&quot;);</b>
&nbsp;		}
<b class="fc">&nbsp;		this.defaultIsolationLevel = defaultIsolationLevel;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Retrieves the currently configured threshold for syncing query evaluation iteration caches to disk.
&nbsp;	 *
&nbsp;	 * @return Returns the iterationCacheSyncThreshold.
&nbsp;	 */
&nbsp;	public long getIterationCacheSyncThreshold() {
<b class="fc">&nbsp;		return iterationCacheSyncThreshold;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Set the threshold for syncing query evaluation iteration caches to disk.
&nbsp;	 *
&nbsp;	 * @param iterationCacheSyncThreshold The iterationCacheSyncThreshold to set.
&nbsp;	 */
&nbsp;	public void setIterationCacheSyncThreshold(long iterationCacheSyncThreshold) {
<b class="nc">&nbsp;		this.iterationCacheSyncThreshold = iterationCacheSyncThreshold;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the status of the result size tracking for the query plan. Useful to determine which parts of a query
&nbsp;	 * plan generated the most data.
&nbsp;	 *
&nbsp;	 * @return true if result size tracking is enabled.
&nbsp;	 */
&nbsp;	public boolean isTrackResultSize() {
<b class="fc">&nbsp;		return trackResultSize;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Enable or disable results size tracking for the query plan. Useful to determine which parts of a query plan
&nbsp;	 * generated the most data.
&nbsp;	 *
&nbsp;	 * @param trackResultSize true to enable tracking.
&nbsp;	 */
&nbsp;	public void setTrackResultSize(boolean trackResultSize) {
<b class="nc">&nbsp;		this.trackResultSize = trackResultSize;</b>
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-18 08:58</div>
</div>
</body>
</html>
