/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.benchmark.rio.util;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Random;
import java.util.function.Consumer;

import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Literal;
import org.eclipse.rdf4j.model.Model;
import org.eclipse.rdf4j.model.Resource;
import org.eclipse.rdf4j.model.Value;
import org.eclipse.rdf4j.model.ValueFactory;
import org.eclipse.rdf4j.model.impl.LinkedHashModel;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.model.vocabulary.RDF;
import org.eclipse.rdf4j.rio.RDFHandler;
import org.eclipse.rdf4j.rio.helpers.StatementCollector;

public final class ThemeDataSetGenerator {

	public enum Theme {
		MEDICAL_RECORDS,
		SOCIAL_MEDIA,
		LIBRARY,
		ENGINEERING,
		HIGHLY_CONNECTED,
		TRAIN,
		ELECTRICAL_GRID
	}

	private static final String BASE = "http://example.com/theme/";
	private static final String MEDICAL_NS = BASE + "medical/";
	private static final String SOCIAL_NS = BASE + "social/";
	private static final String LIBRARY_NS = BASE + "library/";
	private static final String ENGINEERING_NS = BASE + "engineering/";
	private static final String CONNECTED_NS = BASE + "connected/";
	private static final String TRAIN_NS = BASE + "train/";
	private static final String GRID_NS = BASE + "grid/";

	private static final ValueFactory VF = SimpleValueFactory.getInstance();

	private static final String[] WORDS = new String[] {
			"alpha", "beta", "gamma", "delta", "epsilon", "omega", "vector", "node", "graph", "system",
			"signal", "sensor", "dataset", "record", "event", "network", "route", "station", "engine",
			"grid", "current", "voltage", "load", "train", "cable", "user", "profile", "post", "comment"
	};

	private ThemeDataSetGenerator() {
	}

	public static MedicalConfig medicalConfig() {
		return new MedicalConfig();
	}

	public static SocialMediaConfig socialMediaConfig() {
		return new SocialMediaConfig();
	}

	public static LibraryConfig libraryConfig() {
		return new LibraryConfig();
	}

	public static EngineeringConfig engineeringConfig() {
		return new EngineeringConfig();
	}

	public static HighlyConnectedConfig highlyConnectedConfig() {
		return new HighlyConnectedConfig();
	}

	public static TrainConfig trainConfig() {
		return new TrainConfig();
	}

	public static ElectricalGridConfig electricalGridConfig() {
		return new ElectricalGridConfig();
	}

	public static Model generateMedicalRecords(MedicalConfig config) {
		return generateModel(handler -> generateMedicalRecords(config, handler));
	}

	public static void generateMedicalRecords(MedicalConfig config, RDFHandler handler) {
		Objects.requireNonNull(config, "config");
		Objects.requireNonNull(handler, "handler");
		config.validate();

		Random random = new Random(config.seed);

		IRI patientType = iri(MEDICAL_NS, "Patient");
		IRI encounterType = iri(MEDICAL_NS, "Encounter");
		IRI conditionType = iri(MEDICAL_NS, "Condition");
		IRI medicationType = iri(MEDICAL_NS, "Medication");
		IRI practitionerType = iri(MEDICAL_NS, "Practitioner");
		IRI observationType = iri(MEDICAL_NS, "Observation");

		IRI hasEncounter = iri(MEDICAL_NS, "hasEncounter");
		IRI hasCondition = iri(MEDICAL_NS, "hasCondition");
		IRI hasMedication = iri(MEDICAL_NS, "hasMedication");
		IRI hasObservation = iri(MEDICAL_NS, "hasObservation");
		IRI handledBy = iri(MEDICAL_NS, "handledBy");
		IRI recordedOn = iri(MEDICAL_NS, "recordedOn");
		IRI hasName = iri(MEDICAL_NS, "name");
		IRI hasCode = iri(MEDICAL_NS, "code");
		IRI dosage = iri(MEDICAL_NS, "dosage");
		IRI observationValue = iri(MEDICAL_NS, "value");

		handler.startRDF();
		handler.handleNamespace("med", MEDICAL_NS);

		List<IRI> practitioners = new ArrayList<>(config.practitionerCount);
		for (int i = 0; i < config.practitionerCount; i++) {
			IRI practitioner = entity(MEDICAL_NS, "practitioner", i);
			practitioners.add(practitioner);
			add(handler, practitioner, RDF.TYPE, practitionerType);
			add(handler, practitioner, hasName, literal("Dr " + randomWord(random) + " " + i));
		}

		for (int p = 0; p < config.patientCount; p++) {
			IRI patient = entity(MEDICAL_NS, "patient", p);
			add(handler, patient, RDF.TYPE, patientType);
			add(handler, patient, hasName, literal("Patient " + p));

			for (int m = 0; m < config.medicationsPerPatient; m++) {
				IRI medication = entity(MEDICAL_NS, "medication", p * 100 + m);
				add(handler, medication, RDF.TYPE, medicationType);
				add(handler, medication, hasCode, literal("MED-" + (1000 + m)));
				add(handler, medication, dosage, literal((1 + random.nextInt(3)) + "x daily"));
				add(handler, patient, hasMedication, medication);
			}

			for (int e = 0; e < config.encountersPerPatient; e++) {
				int encounterIndex = p * config.encountersPerPatient + e;
				IRI encounter = entity(MEDICAL_NS, "encounter", encounterIndex);
				add(handler, encounter, RDF.TYPE, encounterType);
				add(handler, patient, hasEncounter, encounter);
				add(handler, encounter, recordedOn,
						VF.createLiteral(LocalDate.of(2024, 1, 1).plusDays(random.nextInt(365))));
				IRI practitioner = practitioners.get(random.nextInt(practitioners.size()));
				add(handler, encounter, handledBy, practitioner);

				for (int c = 0; c < config.conditionsPerEncounter; c++) {
					IRI condition = entity(MEDICAL_NS, "condition", encounterIndex * 10 + c);
					add(handler, condition, RDF.TYPE, conditionType);
					add(handler, condition, hasCode, literal("DX-" + (200 + c)));
					add(handler, encounter, hasCondition, condition);
				}

				for (int o = 0; o < config.observationsPerEncounter; o++) {
					IRI observation = entity(MEDICAL_NS, "observation", encounterIndex * 10 + o);
					add(handler, observation, RDF.TYPE, observationType);
					add(handler, observation, observationValue,
							VF.createLiteral(50 + random.nextInt(50)));
					add(handler, encounter, hasObservation, observation);
				}
			}
		}

		handler.endRDF();
	}

	public static Model generateSocialMedia(SocialMediaConfig config) {
		return generateModel(handler -> generateSocialMedia(config, handler));
	}

	public static void generateSocialMedia(SocialMediaConfig config, RDFHandler handler) {
		Objects.requireNonNull(config, "config");
		Objects.requireNonNull(handler, "handler");
		config.validate();

		Random random = new Random(config.seed);

		IRI userType = iri(SOCIAL_NS, "User");
		IRI postType = iri(SOCIAL_NS, "Post");
		IRI commentType = iri(SOCIAL_NS, "Comment");
		IRI tagType = iri(SOCIAL_NS, "Tag");

		IRI follows = iri(SOCIAL_NS, "follows");
		IRI authored = iri(SOCIAL_NS, "authored");
		IRI likedBy = iri(SOCIAL_NS, "likedBy");
		IRI hasComment = iri(SOCIAL_NS, "hasComment");
		IRI hasTag = iri(SOCIAL_NS, "hasTag");
		IRI createdAt = iri(SOCIAL_NS, "createdAt");
		IRI hasName = iri(SOCIAL_NS, "name");
		IRI content = iri(SOCIAL_NS, "content");

		handler.startRDF();
		handler.handleNamespace("social", SOCIAL_NS);

		List<IRI> users = new ArrayList<>(config.userCount);
		for (int u = 0; u < config.userCount; u++) {
			IRI user = entity(SOCIAL_NS, "user", u);
			users.add(user);
			add(handler, user, RDF.TYPE, userType);
			add(handler, user, hasName, literal("user" + u));
		}

		List<IRI> tags = new ArrayList<>(config.tagCount);
		for (int t = 0; t < config.tagCount; t++) {
			IRI tag = entity(SOCIAL_NS, "tag", t);
			tags.add(tag);
			add(handler, tag, RDF.TYPE, tagType);
			add(handler, tag, hasName, literal("tag" + t));
		}

		int postIndex = 0;
		int commentIndex = 0;
		for (IRI user : users) {
			for (int f = 0; f < config.followsPerUser; f++) {
				IRI target = users.get(random.nextInt(users.size()));
				if (!user.equals(target)) {
					add(handler, user, follows, target);
				}
			}

			for (int p = 0; p < config.postsPerUser; p++) {
				IRI post = entity(SOCIAL_NS, "post", postIndex++);
				add(handler, post, RDF.TYPE, postType);
				add(handler, post, authored, user);
				add(handler, post, content, literal(randomSentence(random, 5, 12)));
				add(handler, post, createdAt,
						VF.createLiteral(LocalDateTime.of(2024, 1, 1, 8, 0).plusHours(random.nextInt(500))));

				for (int t = 0; t < config.tagsPerPost; t++) {
					IRI tag = tags.get(random.nextInt(tags.size()));
					add(handler, post, hasTag, tag);
				}

				for (int l = 0; l < config.likesPerPost; l++) {
					IRI liker = users.get(random.nextInt(users.size()));
					add(handler, post, likedBy, liker);
				}

				for (int c = 0; c < config.commentsPerPost; c++) {
					IRI comment = entity(SOCIAL_NS, "comment", commentIndex++);
					IRI commenter = users.get(random.nextInt(users.size()));
					add(handler, comment, RDF.TYPE, commentType);
					add(handler, comment, authored, commenter);
					add(handler, comment, content, literal(randomSentence(random, 3, 8)));
					add(handler, post, hasComment, comment);
				}
			}
		}

		handler.endRDF();
	}

	public static Model generateLibrary(LibraryConfig config) {
		return generateModel(handler -> generateLibrary(config, handler));
	}

	public static void generateLibrary(LibraryConfig config, RDFHandler handler) {
		Objects.requireNonNull(config, "config");
		Objects.requireNonNull(handler, "handler");
		config.validate();

		Random random = new Random(config.seed);

		IRI bookType = iri(LIBRARY_NS, "Book");
		IRI authorType = iri(LIBRARY_NS, "Author");
		IRI copyType = iri(LIBRARY_NS, "Copy");
		IRI memberType = iri(LIBRARY_NS, "Member");
		IRI loanType = iri(LIBRARY_NS, "Loan");
		IRI branchType = iri(LIBRARY_NS, "Branch");

		IRI writtenBy = iri(LIBRARY_NS, "writtenBy");
		IRI hasCopy = iri(LIBRARY_NS, "hasCopy");
		IRI locatedAt = iri(LIBRARY_NS, "locatedAt");
		IRI borrowedBy = iri(LIBRARY_NS, "borrowedBy");
		IRI loanedCopy = iri(LIBRARY_NS, "loanedCopy");
		IRI loanDate = iri(LIBRARY_NS, "loanDate");
		IRI dueDate = iri(LIBRARY_NS, "dueDate");
		IRI hasName = iri(LIBRARY_NS, "name");
		IRI title = iri(LIBRARY_NS, "title");

		handler.startRDF();
		handler.handleNamespace("lib", LIBRARY_NS);

		List<IRI> authors = new ArrayList<>(config.authorCount);
		for (int a = 0; a < config.authorCount; a++) {
			IRI author = entity(LIBRARY_NS, "author", a);
			authors.add(author);
			add(handler, author, RDF.TYPE, authorType);
			add(handler, author, hasName, literal("Author " + a));
		}

		List<IRI> branches = new ArrayList<>(config.branchCount);
		for (int b = 0; b < config.branchCount; b++) {
			IRI branch = entity(LIBRARY_NS, "branch", b);
			branches.add(branch);
			add(handler, branch, RDF.TYPE, branchType);
			add(handler, branch, hasName, literal("Branch " + b));
		}

		List<IRI> copies = new ArrayList<>(config.bookCount * config.copiesPerBook);
		int copyIndex = 0;
		for (int b = 0; b < config.bookCount; b++) {
			IRI book = entity(LIBRARY_NS, "book", b);
			add(handler, book, RDF.TYPE, bookType);
			add(handler, book, title, literal("Book " + b + " " + randomWord(random)));

			for (int a = 0; a < config.authorsPerBook; a++) {
				IRI author = authors.get(random.nextInt(authors.size()));
				add(handler, book, writtenBy, author);
			}

			for (int c = 0; c < config.copiesPerBook; c++) {
				IRI copy = entity(LIBRARY_NS, "copy", copyIndex++);
				copies.add(copy);
				add(handler, copy, RDF.TYPE, copyType);
				add(handler, copy, locatedAt, branches.get(random.nextInt(branches.size())));
				add(handler, book, hasCopy, copy);
			}
		}

		List<IRI> members = new ArrayList<>(config.memberCount);
		for (int m = 0; m < config.memberCount; m++) {
			IRI member = entity(LIBRARY_NS, "member", m);
			members.add(member);
			add(handler, member, RDF.TYPE, memberType);
			add(handler, member, hasName, literal("Member " + m));
		}

		int loanIndex = 0;
		for (IRI member : members) {
			for (int l = 0; l < config.loansPerMember; l++) {
				IRI loan = entity(LIBRARY_NS, "loan", loanIndex++);
				IRI copy = copies.get(random.nextInt(copies.size()));
				add(handler, loan, RDF.TYPE, loanType);
				add(handler, loan, borrowedBy, member);
				add(handler, loan, loanedCopy, copy);
				LocalDate date = LocalDate.of(2024, 1, 1).plusDays(random.nextInt(90));
				add(handler, loan, loanDate, VF.createLiteral(date));
				add(handler, loan, dueDate, VF.createLiteral(date.plusDays(14)));
			}
		}

		handler.endRDF();
	}

	public static Model generateEngineering(EngineeringConfig config) {
		return generateModel(handler -> generateEngineering(config, handler));
	}

	public static void generateEngineering(EngineeringConfig config, RDFHandler handler) {
		Objects.requireNonNull(config, "config");
		Objects.requireNonNull(handler, "handler");
		config.validate();

		Random random = new Random(config.seed);

		IRI componentType = iri(ENGINEERING_NS, "Component");
		IRI assemblyType = iri(ENGINEERING_NS, "Assembly");
		IRI requirementType = iri(ENGINEERING_NS, "Requirement");
		IRI testType = iri(ENGINEERING_NS, "TestCase");
		IRI measurementType = iri(ENGINEERING_NS, "Measurement");

		IRI partOf = iri(ENGINEERING_NS, "partOf");
		IRI dependsOn = iri(ENGINEERING_NS, "dependsOn");
		IRI satisfies = iri(ENGINEERING_NS, "satisfies");
		IRI verifiedBy = iri(ENGINEERING_NS, "verifiedBy");
		IRI measuredValue = iri(ENGINEERING_NS, "measuredValue");
		IRI hasName = iri(ENGINEERING_NS, "name");

		handler.startRDF();
		handler.handleNamespace("eng", ENGINEERING_NS);

		List<IRI> assemblies = new ArrayList<>(config.assemblyCount);
		for (int a = 0; a < config.assemblyCount; a++) {
			IRI assembly = entity(ENGINEERING_NS, "assembly", a);
			assemblies.add(assembly);
			add(handler, assembly, RDF.TYPE, assemblyType);
			add(handler, assembly, hasName, literal("Assembly " + a));
		}

		List<IRI> components = new ArrayList<>(config.componentCount);
		for (int c = 0; c < config.componentCount; c++) {
			IRI component = entity(ENGINEERING_NS, "component", c);
			components.add(component);
			add(handler, component, RDF.TYPE, componentType);
			add(handler, component, hasName, literal("Component " + c));
			add(handler, component, partOf, assemblies.get(random.nextInt(assemblies.size())));
			if (components.size() > 1) {
				IRI dependency = components.get(random.nextInt(components.size() - 1));
				add(handler, component, dependsOn, dependency);
			}
		}

		List<IRI> requirements = new ArrayList<>(config.requirementCount);
		for (int r = 0; r < config.requirementCount; r++) {
			IRI requirement = entity(ENGINEERING_NS, "requirement", r);
			requirements.add(requirement);
			add(handler, requirement, RDF.TYPE, requirementType);
			add(handler, requirement, hasName, literal("REQ-" + (1000 + r)));
			IRI component = components.get(random.nextInt(components.size()));
			add(handler, requirement, satisfies, component);
		}

		int testIndex = 0;
		int measurementIndex = 0;
		for (IRI requirement : requirements) {
			for (int t = 0; t < config.testsPerRequirement; t++) {
				IRI test = entity(ENGINEERING_NS, "test", testIndex++);
				add(handler, test, RDF.TYPE, testType);
				add(handler, requirement, verifiedBy, test);

				IRI measurement = entity(ENGINEERING_NS, "measurement", measurementIndex++);
				add(handler, measurement, RDF.TYPE, measurementType);
				add(handler, measurement, measuredValue, VF.createLiteral(0.8 + random.nextDouble() * 0.2));
				add(handler, test, verifiedBy, measurement);
			}
		}

		handler.endRDF();
	}

	public static Model generateHighlyConnected(HighlyConnectedConfig config) {
		return generateModel(handler -> generateHighlyConnected(config, handler));
	}

	public static void generateHighlyConnected(HighlyConnectedConfig config, RDFHandler handler) {
		Objects.requireNonNull(config, "config");
		Objects.requireNonNull(handler, "handler");
		config.validate();

		Random random = new Random(config.seed);

		IRI nodeType = iri(CONNECTED_NS, "Node");
		IRI connectsTo = iri(CONNECTED_NS, "connectsTo");
		IRI linkWeight = iri(CONNECTED_NS, "weight");

		handler.startRDF();
		handler.handleNamespace("conn", CONNECTED_NS);

		List<IRI> nodes = new ArrayList<>(config.nodeCount);
		for (int i = 0; i < config.nodeCount; i++) {
			IRI node = entity(CONNECTED_NS, "node", i);
			nodes.add(node);
			add(handler, node, RDF.TYPE, nodeType);
		}

		List<IRI> hubs = nodes.subList(0, Math.min(config.hubCount, nodes.size()));

		for (IRI node : nodes) {
			for (int e = 0; e < config.edgesPerNode; e++) {
				IRI target = random.nextDouble() < config.hubBias
						? hubs.get(random.nextInt(hubs.size()))
						: nodes.get(random.nextInt(nodes.size()));
				if (!node.equals(target)) {
					add(handler, node, connectsTo, target);
					add(handler, node, linkWeight, VF.createLiteral(1 + random.nextInt(10)));
				}
			}
		}

		handler.endRDF();
	}

	public static Model generateTrain(TrainConfig config) {
		return generateModel(handler -> generateTrain(config, handler));
	}

	public static void generateTrain(TrainConfig config, RDFHandler handler) {
		Objects.requireNonNull(config, "config");
		Objects.requireNonNull(handler, "handler");
		config.validate();

		Random random = new Random(config.seed);

		IRI stationType = iri(TRAIN_NS, "Station");
		IRI routeType = iri(TRAIN_NS, "Route");
		IRI trainType = iri(TRAIN_NS, "Train");
		IRI tripType = iri(TRAIN_NS, "Trip");
		IRI stopType = iri(TRAIN_NS, "Stop");

		IRI hasStop = iri(TRAIN_NS, "hasStop");
		IRI atStation = iri(TRAIN_NS, "atStation");
		IRI onRoute = iri(TRAIN_NS, "onRoute");
		IRI hasTrip = iri(TRAIN_NS, "hasTrip");
		IRI departureTime = iri(TRAIN_NS, "departureTime");
		IRI hasName = iri(TRAIN_NS, "name");

		handler.startRDF();
		handler.handleNamespace("train", TRAIN_NS);

		List<IRI> stations = new ArrayList<>(config.stationCount);
		for (int s = 0; s < config.stationCount; s++) {
			IRI station = entity(TRAIN_NS, "station", s);
			stations.add(station);
			add(handler, station, RDF.TYPE, stationType);
			add(handler, station, hasName, literal("Station " + s));
		}

		List<IRI> routes = new ArrayList<>(config.routeCount);
		int stopIndex = 0;
		for (int r = 0; r < config.routeCount; r++) {
			IRI route = entity(TRAIN_NS, "route", r);
			routes.add(route);
			add(handler, route, RDF.TYPE, routeType);
			add(handler, route, hasName, literal("Route " + r));

			for (int s = 0; s < config.stopsPerRoute; s++) {
				IRI station = stations.get((r * config.stopsPerRoute + s) % stations.size());
				IRI stop = entity(TRAIN_NS, "stop", stopIndex++);
				add(handler, stop, RDF.TYPE, stopType);
				add(handler, stop, atStation, station);
				add(handler, route, hasStop, stop);
			}
		}

		int tripIndex = 0;
		for (int t = 0; t < config.trainCount; t++) {
			IRI train = entity(TRAIN_NS, "train", t);
			add(handler, train, RDF.TYPE, trainType);
			add(handler, train, hasName, literal("Train " + t));

			for (int tr = 0; tr < config.tripsPerTrain; tr++) {
				IRI trip = entity(TRAIN_NS, "trip", tripIndex++);
				IRI route = routes.get(random.nextInt(routes.size()));
				add(handler, trip, RDF.TYPE, tripType);
				add(handler, trip, onRoute, route);
				add(handler, train, hasTrip, trip);
				add(handler, trip, departureTime,
						VF.createLiteral(LocalTime.of(5, 0).plusMinutes(random.nextInt(600))));
			}
		}

		handler.endRDF();
	}

	public static Model generateElectricalGrid(ElectricalGridConfig config) {
		return generateModel(handler -> generateElectricalGrid(config, handler));
	}

	public static void generateElectricalGrid(ElectricalGridConfig config, RDFHandler handler) {
		Objects.requireNonNull(config, "config");
		Objects.requireNonNull(handler, "handler");
		config.validate();

		Random random = new Random(config.seed);

		IRI substationType = iri(GRID_NS, "Substation");
		IRI transformerType = iri(GRID_NS, "Transformer");
		IRI lineType = iri(GRID_NS, "Line");
		IRI meterType = iri(GRID_NS, "Meter");
		IRI loadType = iri(GRID_NS, "Load");
		IRI generatorType = iri(GRID_NS, "Generator");

		IRI feeds = iri(GRID_NS, "feeds");
		IRI connectsTo = iri(GRID_NS, "connectsTo");
		IRI hasMeter = iri(GRID_NS, "hasMeter");
		IRI measures = iri(GRID_NS, "measures");
		IRI loadValue = iri(GRID_NS, "loadValue");
		IRI capacity = iri(GRID_NS, "capacity");
		IRI hasName = iri(GRID_NS, "name");

		handler.startRDF();
		handler.handleNamespace("grid", GRID_NS);

		List<IRI> substations = new ArrayList<>(config.substationCount);
		for (int s = 0; s < config.substationCount; s++) {
			IRI substation = entity(GRID_NS, "substation", s);
			substations.add(substation);
			add(handler, substation, RDF.TYPE, substationType);
			add(handler, substation, hasName, literal("Substation " + s));
		}

		int transformerIndex = 0;
		int lineIndex = 0;
		int meterIndex = 0;
		int loadIndex = 0;
		for (IRI substation : substations) {
			for (int t = 0; t < config.transformersPerSubstation; t++) {
				IRI transformer = entity(GRID_NS, "transformer", transformerIndex++);
				add(handler, transformer, RDF.TYPE, transformerType);
				add(handler, transformer, feeds, substation);

				for (int m = 0; m < config.metersPerTransformer; m++) {
					IRI meter = entity(GRID_NS, "meter", meterIndex++);
					IRI load = entity(GRID_NS, "load", loadIndex++);
					add(handler, meter, RDF.TYPE, meterType);
					add(handler, load, RDF.TYPE, loadType);
					add(handler, meter, measures, load);
					add(handler, transformer, hasMeter, meter);
					add(handler, load, loadValue, VF.createLiteral(50 + random.nextInt(150)));
				}
			}

			for (int l = 0; l < config.linesPerSubstation; l++) {
				IRI line = entity(GRID_NS, "line", lineIndex++);
				IRI target = substations.get(random.nextInt(substations.size()));
				add(handler, line, RDF.TYPE, lineType);
				add(handler, line, connectsTo, substation);
				add(handler, line, connectsTo, target);
			}

			IRI generator = entity(GRID_NS, "generator", substationIndex(substation));
			add(handler, generator, RDF.TYPE, generatorType);
			add(handler, generator, feeds, substation);
			add(handler, generator, capacity, VF.createLiteral(500 + random.nextInt(500)));
		}

		handler.endRDF();
	}

	private static int substationIndex(IRI substation) {
		String local = substation.getLocalName();
		int slash = local.lastIndexOf('/');
		String value = slash >= 0 ? local.substring(slash + 1) : local;
		try {
			return Integer.parseInt(value);
		} catch (NumberFormatException e) {
			return Math.abs(local.hashCode());
		}
	}

	private static Model generateModel(Consumer<RDFHandler> generator) {
		Model model = new LinkedHashModel();
		StatementCollector collector = new StatementCollector(model);
		generator.accept(collector);
		return model;
	}

	private static IRI iri(String namespace, String localName) {
		return VF.createIRI(namespace, localName);
	}

	private static IRI entity(String namespace, String category, int id) {
		return VF.createIRI(namespace, category + "/" + id);
	}

	private static Literal literal(String value) {
		return VF.createLiteral(value);
	}

	private static void add(RDFHandler handler, Resource subject, IRI predicate, Value object) {
		handler.handleStatement(VF.createStatement(subject, predicate, object));
	}

	private static String randomWord(Random random) {
		return WORDS[random.nextInt(WORDS.length)];
	}

	private static String randomSentence(Random random, int minWords, int maxWords) {
		int total = minWords + random.nextInt(Math.max(1, maxWords - minWords + 1));
		StringBuilder builder = new StringBuilder();
		for (int i = 0; i < total; i++) {
			if (i > 0) {
				builder.append(' ');
			}
			builder.append(randomWord(random));
		}
		return builder.toString();
	}

	public static final class MedicalConfig {
		private int patientCount = 200;
		private int encountersPerPatient = 3;
		private int conditionsPerEncounter = 2;
		private int medicationsPerPatient = 2;
		private int observationsPerEncounter = 2;
		private int practitionerCount = 20;
		private long seed = 42L;

		public MedicalConfig withPatientCount(int patientCount) {
			this.patientCount = requirePositive(patientCount, "patientCount");
			return this;
		}

		public MedicalConfig withEncountersPerPatient(int encountersPerPatient) {
			this.encountersPerPatient = requirePositive(encountersPerPatient, "encountersPerPatient");
			return this;
		}

		public MedicalConfig withConditionsPerEncounter(int conditionsPerEncounter) {
			this.conditionsPerEncounter = requirePositive(conditionsPerEncounter, "conditionsPerEncounter");
			return this;
		}

		public MedicalConfig withMedicationsPerPatient(int medicationsPerPatient) {
			this.medicationsPerPatient = requirePositive(medicationsPerPatient, "medicationsPerPatient");
			return this;
		}

		public MedicalConfig withObservationsPerEncounter(int observationsPerEncounter) {
			this.observationsPerEncounter = requirePositive(observationsPerEncounter, "observationsPerEncounter");
			return this;
		}

		public MedicalConfig withPractitionerCount(int practitionerCount) {
			this.practitionerCount = requirePositive(practitionerCount, "practitionerCount");
			return this;
		}

		public MedicalConfig withSeed(long seed) {
			this.seed = seed;
			return this;
		}

		private void validate() {
			requirePositive(patientCount, "patientCount");
			requirePositive(encountersPerPatient, "encountersPerPatient");
			requirePositive(conditionsPerEncounter, "conditionsPerEncounter");
			requirePositive(medicationsPerPatient, "medicationsPerPatient");
			requirePositive(observationsPerEncounter, "observationsPerEncounter");
			requirePositive(practitionerCount, "practitionerCount");
		}
	}

	public static final class SocialMediaConfig {
		private int userCount = 200;
		private int postsPerUser = 2;
		private int commentsPerPost = 2;
		private int likesPerPost = 3;
		private int followsPerUser = 3;
		private int tagsPerPost = 2;
		private int tagCount = 30;
		private long seed = 42L;

		public SocialMediaConfig withUserCount(int userCount) {
			this.userCount = requirePositive(userCount, "userCount");
			return this;
		}

		public SocialMediaConfig withPostsPerUser(int postsPerUser) {
			this.postsPerUser = requirePositive(postsPerUser, "postsPerUser");
			return this;
		}

		public SocialMediaConfig withCommentsPerPost(int commentsPerPost) {
			this.commentsPerPost = requirePositive(commentsPerPost, "commentsPerPost");
			return this;
		}

		public SocialMediaConfig withLikesPerPost(int likesPerPost) {
			this.likesPerPost = requirePositive(likesPerPost, "likesPerPost");
			return this;
		}

		public SocialMediaConfig withFollowsPerUser(int followsPerUser) {
			this.followsPerUser = requirePositive(followsPerUser, "followsPerUser");
			return this;
		}

		public SocialMediaConfig withTagsPerPost(int tagsPerPost) {
			this.tagsPerPost = requirePositive(tagsPerPost, "tagsPerPost");
			return this;
		}

		public SocialMediaConfig withTagCount(int tagCount) {
			this.tagCount = requirePositive(tagCount, "tagCount");
			return this;
		}

		public SocialMediaConfig withSeed(long seed) {
			this.seed = seed;
			return this;
		}

		private void validate() {
			requirePositive(userCount, "userCount");
			requirePositive(postsPerUser, "postsPerUser");
			requirePositive(commentsPerPost, "commentsPerPost");
			requirePositive(likesPerPost, "likesPerPost");
			requirePositive(followsPerUser, "followsPerUser");
			requirePositive(tagsPerPost, "tagsPerPost");
			requirePositive(tagCount, "tagCount");
		}
	}

	public static final class LibraryConfig {
		private int bookCount = 100;
		private int authorCount = 30;
		private int branchCount = 5;
		private int copiesPerBook = 3;
		private int authorsPerBook = 2;
		private int memberCount = 50;
		private int loansPerMember = 2;
		private long seed = 42L;

		public LibraryConfig withBookCount(int bookCount) {
			this.bookCount = requirePositive(bookCount, "bookCount");
			return this;
		}

		public LibraryConfig withAuthorCount(int authorCount) {
			this.authorCount = requirePositive(authorCount, "authorCount");
			return this;
		}

		public LibraryConfig withBranchCount(int branchCount) {
			this.branchCount = requirePositive(branchCount, "branchCount");
			return this;
		}

		public LibraryConfig withCopiesPerBook(int copiesPerBook) {
			this.copiesPerBook = requirePositive(copiesPerBook, "copiesPerBook");
			return this;
		}

		public LibraryConfig withAuthorsPerBook(int authorsPerBook) {
			this.authorsPerBook = requirePositive(authorsPerBook, "authorsPerBook");
			return this;
		}

		public LibraryConfig withMemberCount(int memberCount) {
			this.memberCount = requirePositive(memberCount, "memberCount");
			return this;
		}

		public LibraryConfig withLoansPerMember(int loansPerMember) {
			this.loansPerMember = requirePositive(loansPerMember, "loansPerMember");
			return this;
		}

		public LibraryConfig withSeed(long seed) {
			this.seed = seed;
			return this;
		}

		private void validate() {
			requirePositive(bookCount, "bookCount");
			requirePositive(authorCount, "authorCount");
			requirePositive(branchCount, "branchCount");
			requirePositive(copiesPerBook, "copiesPerBook");
			requirePositive(authorsPerBook, "authorsPerBook");
			requirePositive(memberCount, "memberCount");
			requirePositive(loansPerMember, "loansPerMember");
		}
	}

	public static final class EngineeringConfig {
		private int componentCount = 120;
		private int assemblyCount = 15;
		private int requirementCount = 40;
		private int testsPerRequirement = 2;
		private long seed = 42L;

		public EngineeringConfig withComponentCount(int componentCount) {
			this.componentCount = requirePositive(componentCount, "componentCount");
			return this;
		}

		public EngineeringConfig withAssemblyCount(int assemblyCount) {
			this.assemblyCount = requirePositive(assemblyCount, "assemblyCount");
			return this;
		}

		public EngineeringConfig withRequirementCount(int requirementCount) {
			this.requirementCount = requirePositive(requirementCount, "requirementCount");
			return this;
		}

		public EngineeringConfig withTestsPerRequirement(int testsPerRequirement) {
			this.testsPerRequirement = requirePositive(testsPerRequirement, "testsPerRequirement");
			return this;
		}

		public EngineeringConfig withSeed(long seed) {
			this.seed = seed;
			return this;
		}

		private void validate() {
			requirePositive(componentCount, "componentCount");
			requirePositive(assemblyCount, "assemblyCount");
			requirePositive(requirementCount, "requirementCount");
			requirePositive(testsPerRequirement, "testsPerRequirement");
		}
	}

	public static final class HighlyConnectedConfig {
		private int nodeCount = 300;
		private int hubCount = 10;
		private int edgesPerNode = 8;
		private double hubBias = 0.6;
		private long seed = 42L;

		public HighlyConnectedConfig withNodeCount(int nodeCount) {
			this.nodeCount = requirePositive(nodeCount, "nodeCount");
			return this;
		}

		public HighlyConnectedConfig withHubCount(int hubCount) {
			this.hubCount = requirePositive(hubCount, "hubCount");
			return this;
		}

		public HighlyConnectedConfig withEdgesPerNode(int edgesPerNode) {
			this.edgesPerNode = requirePositive(edgesPerNode, "edgesPerNode");
			return this;
		}

		public HighlyConnectedConfig withHubBias(double hubBias) {
			if (hubBias < 0.0 || hubBias > 1.0) {
				throw new IllegalArgumentException("hubBias must be between 0 and 1");
			}
			this.hubBias = hubBias;
			return this;
		}

		public HighlyConnectedConfig withSeed(long seed) {
			this.seed = seed;
			return this;
		}

		private void validate() {
			requirePositive(nodeCount, "nodeCount");
			requirePositive(hubCount, "hubCount");
			requirePositive(edgesPerNode, "edgesPerNode");
			if (hubBias < 0.0 || hubBias > 1.0) {
				throw new IllegalArgumentException("hubBias must be between 0 and 1");
			}
		}
	}

	public static final class TrainConfig {
		private int stationCount = 40;
		private int routeCount = 6;
		private int stopsPerRoute = 8;
		private int trainCount = 12;
		private int tripsPerTrain = 3;
		private long seed = 42L;

		public TrainConfig withStationCount(int stationCount) {
			this.stationCount = requirePositive(stationCount, "stationCount");
			return this;
		}

		public TrainConfig withRouteCount(int routeCount) {
			this.routeCount = requirePositive(routeCount, "routeCount");
			return this;
		}

		public TrainConfig withStopsPerRoute(int stopsPerRoute) {
			this.stopsPerRoute = requirePositive(stopsPerRoute, "stopsPerRoute");
			return this;
		}

		public TrainConfig withTrainCount(int trainCount) {
			this.trainCount = requirePositive(trainCount, "trainCount");
			return this;
		}

		public TrainConfig withTripsPerTrain(int tripsPerTrain) {
			this.tripsPerTrain = requirePositive(tripsPerTrain, "tripsPerTrain");
			return this;
		}

		public TrainConfig withSeed(long seed) {
			this.seed = seed;
			return this;
		}

		private void validate() {
			requirePositive(stationCount, "stationCount");
			requirePositive(routeCount, "routeCount");
			requirePositive(stopsPerRoute, "stopsPerRoute");
			requirePositive(trainCount, "trainCount");
			requirePositive(tripsPerTrain, "tripsPerTrain");
		}
	}

	public static final class ElectricalGridConfig {
		private int substationCount = 12;
		private int transformersPerSubstation = 3;
		private int linesPerSubstation = 2;
		private int metersPerTransformer = 4;
		private long seed = 42L;

		public ElectricalGridConfig withSubstationCount(int substationCount) {
			this.substationCount = requirePositive(substationCount, "substationCount");
			return this;
		}

		public ElectricalGridConfig withTransformersPerSubstation(int transformersPerSubstation) {
			this.transformersPerSubstation = requirePositive(transformersPerSubstation, "transformersPerSubstation");
			return this;
		}

		public ElectricalGridConfig withLinesPerSubstation(int linesPerSubstation) {
			this.linesPerSubstation = requirePositive(linesPerSubstation, "linesPerSubstation");
			return this;
		}

		public ElectricalGridConfig withMetersPerTransformer(int metersPerTransformer) {
			this.metersPerTransformer = requirePositive(metersPerTransformer, "metersPerTransformer");
			return this;
		}

		public ElectricalGridConfig withSeed(long seed) {
			this.seed = seed;
			return this;
		}

		private void validate() {
			requirePositive(substationCount, "substationCount");
			requirePositive(transformersPerSubstation, "transformersPerSubstation");
			requirePositive(linesPerSubstation, "linesPerSubstation");
			requirePositive(metersPerTransformer, "metersPerTransformer");
		}
	}

	private static int requirePositive(int value, String name) {
		if (value <= 0) {
			throw new IllegalArgumentException(name + " must be > 0");
		}
		return value;
	}
}
