/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.benchmark.common;

import java.util.EnumMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import org.eclipse.rdf4j.benchmark.rio.util.ThemeDataSetGenerator.Theme;

public final class ThemeQueryCatalog {

	public static final int QUERY_COUNT = 8;

	private static final Map<Theme, List<String>> QUERIES = new EnumMap<>(Theme.class);

	static {
		String medicalPrefix = String.join("\n",
				"PREFIX med: <http://example.com/theme/medical/>",
				"PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>",
				"");
		QUERIES.put(Theme.MEDICAL_RECORDS, List.of(
				medicalPrefix + String.join("\n",
						"SELECT (COUNT(?patient) AS ?patientCount) WHERE {",
						"  { SELECT ?patient (COUNT(DISTINCT ?enc) AS ?encCount) WHERE {",
						"      ?patient a med:Patient .",
						"      OPTIONAL {",
						"        ?patient med:hasEncounter ?enc .",
						"        OPTIONAL { ?enc med:hasCondition ?cond . }",
						"      }",
						"    } GROUP BY ?patient HAVING(?encCount > 1)",
						"  }",
						"  FILTER EXISTS {",
						"    ?patient med:hasMedication ?med .",
						"    ?med med:code ?code .",
						"    FILTER(STRSTARTS(?code, \"MED-10\"))",
						"  }",
						"}"),
				medicalPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?person) AS ?count) WHERE {",
						"  { ?person a med:Patient ; med:hasMedication ?med . }",
						"  UNION",
						"  { ?person a med:Practitioner . }",
						"  MINUS {",
						"    ?person med:name ?name .",
						"    FILTER(CONTAINS(LCASE(STR(?name)), \"test\"))",
						"  }",
						"  BIND(STRLEN(STR(?person)) AS ?len)",
						"  FILTER(?len > 0)",
						"}"),
				medicalPrefix + String.join("\n",
						"SELECT (COUNT(?encounter) AS ?count) WHERE {",
						"  { SELECT ?encounter (COUNT(?obs) AS ?obsCount) WHERE {",
						"      ?encounter a med:Encounter .",
						"      OPTIONAL { ?encounter med:hasObservation ?obs . }",
						"      OPTIONAL { ?encounter med:handledBy ?practitioner . }",
						"    } GROUP BY ?encounter HAVING(?obsCount > 0)",
						"  }",
						"  OPTIONAL { ?encounter med:hasCondition ?cond . ?cond med:code ?code . }",
						"}"),
				medicalPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?patient) AS ?count) WHERE {",
						"  VALUES ?targetCode { \"DX-200\" \"DX-201\" \"DX-202\" }",
						"  ?patient a med:Patient ; med:hasEncounter ?encounter .",
						"  ?encounter med:hasCondition ?cond .",
						"  ?cond med:code ?targetCode .",
						"  OPTIONAL { ?patient med:hasMedication ?med . }",
						"  FILTER NOT EXISTS {",
						"    ?encounter med:hasObservation ?obs .",
						"    ?obs med:value ?v .",
						"    FILTER(?v < 55)",
						"  }",
						"}"),
				medicalPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?patient) AS ?count) WHERE {",
						"  ?patient med:hasEncounter/med:hasObservation ?obs .",
						"  ?obs med:value ?value .",
						"  BIND((?value / 10) AS ?bucket)",
						"  FILTER EXISTS { ?patient med:hasEncounter/med:handledBy ?practitioner . }",
						"  FILTER(?bucket >= 6)",
						"}"),
				medicalPrefix + String.join("\n",
						"SELECT ?practitioner (COUNT(DISTINCT ?enc) AS ?encCount) WHERE {",
						"  { ?enc a med:Encounter ; med:handledBy ?practitioner . }",
						"  UNION",
						"  { ?practitioner a med:Practitioner . OPTIONAL { ?practitioner med:name ?name . } }",
						"  OPTIONAL { ?enc med:hasCondition ?cond . }",
						"}",
						"GROUP BY ?practitioner"),
				medicalPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?enc) AS ?count) WHERE {",
						"  ?enc a med:Encounter .",
						"  FILTER EXISTS { ?enc med:hasCondition ?cond . }",
						"  FILTER NOT EXISTS {",
						"    ?enc med:hasObservation ?obs .",
						"    ?obs med:value ?v .",
						"    FILTER(?v > 95)",
						"  }",
						"  MINUS {",
						"    ?enc med:handledBy ?practitioner .",
						"    ?practitioner med:name ?name .",
						"    FILTER(CONTAINS(?name, \"3\"))",
						"  }",
						"}"),
				medicalPrefix + String.join("\n",
						"SELECT ?code (COUNT(?med) AS ?medCount) WHERE {",
						"  ?med a med:Medication ; med:code ?code .",
						"  VALUES ?threshold { 1 }",
						"  BIND((STRLEN(STR(?code)) - ?threshold) AS ?score)",
						"  FILTER(?score >= 3)",
						"  OPTIONAL { ?patient med:hasMedication ?med . }",
						"}",
						"GROUP BY ?code",
						"HAVING(COUNT(?med) > 0)")));

		String socialPrefix = String.join("\n",
				"PREFIX social: <http://example.com/theme/social/>",
				"PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>",
				"");
		QUERIES.put(Theme.SOCIAL_MEDIA, List.of(
				socialPrefix + String.join("\n",
						"SELECT (COUNT(?user) AS ?userCount) WHERE {",
						"  { SELECT ?user (COUNT(DISTINCT ?post) AS ?postCount) WHERE {",
						"      ?user a social:User .",
						"      OPTIONAL {",
						"        ?post social:authored ?user .",
						"        OPTIONAL { ?post social:hasTag ?tag . }",
						"      }",
						"    } GROUP BY ?user HAVING(?postCount > 0)",
						"  }",
						"  FILTER EXISTS { ?user social:follows ?other . }",
						"}"),
				socialPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?item) AS ?count) WHERE {",
						"  { ?item a social:Post ; social:authored ?user . }",
						"  UNION",
						"  { ?item a social:Comment ; social:authored ?user . }",
						"  MINUS {",
						"    ?user social:name ?name .",
						"    FILTER(STRSTARTS(LCASE(STR(?name)), \"user1\"))",
						"  }",
						"  BIND(STRLEN(STR(?item)) AS ?len)",
						"  FILTER(?len > 0)",
						"}"),
				socialPrefix + String.join("\n",
						"SELECT (COUNT(?post) AS ?count) WHERE {",
						"  { SELECT ?post (COUNT(?comment) AS ?commentCount) WHERE {",
						"      ?post a social:Post .",
						"      OPTIONAL { ?post social:hasComment ?comment . }",
						"      OPTIONAL { ?post social:hasTag ?tag . }",
						"    } GROUP BY ?post HAVING(?commentCount > 0)",
						"  }",
						"  OPTIONAL { ?post social:likedBy ?liker . }",
						"}"),
				socialPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?post) AS ?count) WHERE {",
						"  VALUES ?name { \"user1\" \"user2\" \"user3\" }",
						"  ?user a social:User ; social:name ?name .",
						"  ?post social:authored ?user .",
						"  OPTIONAL { ?post social:hasTag ?tag . }",
						"  FILTER NOT EXISTS { ?post social:hasComment ?comment . }",
						"}"),
				socialPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?user) AS ?count) WHERE {",
						"  ?user a social:User .",
						"  ?user (^social:authored|^social:likedBy) ?post .",
						"  BIND(CONTAINS(LCASE(STR(?post)), \"post\") AS ?isPost)",
						"  FILTER(?isPost)",
						"  FILTER EXISTS { ?post social:hasTag ?tag . }",
						"}"),
				socialPrefix + String.join("\n",
						"SELECT ?user (COUNT(DISTINCT ?post) AS ?postCount) WHERE {",
						"  { ?post a social:Post ; social:authored ?user . }",
						"  UNION",
						"  { ?comment a social:Comment ; social:authored ?user . }",
						"  OPTIONAL { ?post social:likedBy ?liker . }",
						"}",
						"GROUP BY ?user"),
				socialPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?user) AS ?count) WHERE {",
						"  ?user a social:User .",
						"  FILTER EXISTS { ?user social:follows ?other . }",
						"  FILTER NOT EXISTS { ?user social:follows ?self . FILTER(?self = ?user) }",
						"  MINUS { ?user social:name ?name . FILTER(CONTAINS(?name, \"99\")) }",
						"}"),
				socialPrefix + String.join("\n",
						"SELECT ?tag (COUNT(DISTINCT ?post) AS ?postCount) WHERE {",
						"  ?tag a social:Tag ; social:name ?tagName .",
						"  VALUES ?prefix { \"tag1\" \"tag2\" \"tag3\" }",
						"  BIND(STRSTARTS(?tagName, ?prefix) AS ?match)",
						"  FILTER(?match)",
						"  OPTIONAL { ?post social:hasTag ?tag . }",
						"}",
						"GROUP BY ?tag",
						"HAVING(COUNT(?post) > 0)")));

		String libraryPrefix = String.join("\n",
				"PREFIX lib: <http://example.com/theme/library/>",
				"PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>",
				"");
		QUERIES.put(Theme.LIBRARY, List.of(
				libraryPrefix + String.join("\n",
						"SELECT (COUNT(?book) AS ?count) WHERE {",
						"  { SELECT ?book (COUNT(DISTINCT ?copy) AS ?copyCount) WHERE {",
						"      ?book a lib:Book .",
						"      OPTIONAL {",
						"        ?book lib:hasCopy ?copy .",
						"        OPTIONAL { ?copy lib:locatedAt ?branch . }",
						"      }",
						"    } GROUP BY ?book HAVING(?copyCount > 1)",
						"  }",
						"  FILTER EXISTS { ?book lib:writtenBy ?author . }",
						"}"),
				libraryPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?entity) AS ?count) WHERE {",
						"  { ?entity a lib:Book ; lib:title ?title . }",
						"  UNION",
						"  { ?entity a lib:Member ; lib:name ?name . }",
						"  MINUS { ?entity lib:name ?n . FILTER(CONTAINS(LCASE(STR(?n)), \"member 1\")) }",
						"  BIND(STRLEN(STR(?entity)) AS ?len)",
						"  FILTER(?len > 0)",
						"}"),
				libraryPrefix + String.join("\n",
						"SELECT (COUNT(?loan) AS ?count) WHERE {",
						"  { SELECT ?loan (COUNT(?copy) AS ?copyCount) WHERE {",
						"      ?loan a lib:Loan .",
						"      OPTIONAL { ?loan lib:loanedCopy ?copy . }",
						"      OPTIONAL { ?loan lib:borrowedBy ?member . }",
						"    } GROUP BY ?loan HAVING(?copyCount > 0)",
						"  }",
						"  OPTIONAL { ?loan lib:dueDate ?due . }",
						"}"),
				libraryPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?loan) AS ?count) WHERE {",
						"  VALUES ?memberName { \"Member 1\" \"Member 2\" \"Member 3\" }",
						"  ?member a lib:Member ; lib:name ?memberName .",
						"  ?loan lib:borrowedBy ?member .",
						"  OPTIONAL { ?loan lib:loanedCopy ?copy . }",
						"  FILTER NOT EXISTS { ?loan lib:dueDate ?due . FILTER(?due < \"2024-01-10\"^^xsd:date) }",
						"}"),
				libraryPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?book) AS ?count) WHERE {",
						"  ?book lib:hasCopy/lib:locatedAt ?branch .",
						"  BIND(STRLEN(STR(?branch)) AS ?len)",
						"  FILTER EXISTS { ?branch a lib:Branch . }",
						"  FILTER(?len > 0)",
						"}"),
				libraryPrefix + String.join("\n",
						"SELECT ?author (COUNT(DISTINCT ?book) AS ?bookCount) WHERE {",
						"  { ?book a lib:Book ; lib:writtenBy ?author . }",
						"  UNION",
						"  { ?author a lib:Author . OPTIONAL { ?author lib:name ?name . } }",
						"  OPTIONAL { ?book lib:hasCopy ?copy . }",
						"}",
						"GROUP BY ?author"),
				libraryPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?book) AS ?count) WHERE {",
						"  ?book a lib:Book .",
						"  FILTER EXISTS { ?book lib:writtenBy ?author . }",
						"  FILTER NOT EXISTS { ?book lib:title ?title . FILTER(CONTAINS(LCASE(STR(?title)), \"omega\")) }",
						"  MINUS { ?book lib:hasCopy ?copy . ?copy lib:locatedAt ?branch .",
						"    FILTER(CONTAINS(STR(?branch), \"branch/0\")) }",
						"}"),
				libraryPrefix + String.join("\n",
						"SELECT ?branch (COUNT(DISTINCT ?copy) AS ?copyCount) WHERE {",
						"  ?branch a lib:Branch ; lib:name ?branchName .",
						"  VALUES ?prefix { \"Branch 0\" \"Branch 1\" }",
						"  BIND(STRSTARTS(?branchName, ?prefix) AS ?match)",
						"  FILTER(?match)",
						"  OPTIONAL { ?copy lib:locatedAt ?branch . }",
						"}",
						"GROUP BY ?branch",
						"HAVING(COUNT(?copy) > 0)")));

		String engineeringPrefix = String.join("\n",
				"PREFIX eng: <http://example.com/theme/engineering/>",
				"");
		QUERIES.put(Theme.ENGINEERING, List.of(
				engineeringPrefix + String.join("\n",
						"SELECT (COUNT(?component) AS ?count) WHERE {",
						"  { SELECT ?component (COUNT(?dep) AS ?depCount) WHERE {",
						"      ?component a eng:Component .",
						"      OPTIONAL { ?component eng:dependsOn ?dep . }",
						"      OPTIONAL { ?component eng:partOf ?assembly . }",
						"    } GROUP BY ?component HAVING(?depCount > 0)",
						"  }",
						"  FILTER EXISTS { ?component eng:partOf ?assembly . }",
						"}"),
				engineeringPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?entity) AS ?count) WHERE {",
						"  { ?entity a eng:Component ; eng:name ?name . }",
						"  UNION",
						"  { ?entity a eng:Requirement ; eng:name ?name . }",
						"  MINUS { ?entity eng:name ?n . FILTER(STRSTARTS(STR(?n), \"REQ-10\")) }",
						"  BIND(STRLEN(STR(?entity)) AS ?len)",
						"  FILTER(?len > 0)",
						"}"),
				engineeringPrefix + String.join("\n",
						"SELECT (COUNT(?requirement) AS ?count) WHERE {",
						"  { SELECT ?requirement (COUNT(?test) AS ?testCount) WHERE {",
						"      ?requirement a eng:Requirement .",
						"      OPTIONAL { ?requirement eng:verifiedBy ?test . }",
						"      OPTIONAL { ?requirement eng:satisfies ?component . }",
						"    } GROUP BY ?requirement HAVING(?testCount > 0)",
						"  }",
						"  OPTIONAL { ?test eng:verifiedBy ?measurement . }",
						"}"),
				engineeringPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?component) AS ?count) WHERE {",
						"  VALUES ?assemblyName { \"Assembly 1\" \"Assembly 2\" \"Assembly 3\" }",
						"  ?assembly a eng:Assembly ; eng:name ?assemblyName .",
						"  ?component eng:partOf ?assembly .",
						"  OPTIONAL { ?component eng:dependsOn ?dep . }",
						"  FILTER NOT EXISTS { ?component eng:dependsOn ?self . FILTER(?self = ?component) }",
						"}"),
				engineeringPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?requirement) AS ?count) WHERE {",
						"  ?requirement eng:verifiedBy/eng:verifiedBy ?measurement .",
						"  ?measurement eng:measuredValue ?value .",
						"  BIND((?value * 100) AS ?scaled)",
						"  FILTER EXISTS { ?requirement eng:satisfies ?component . }",
						"  FILTER(?scaled > 80)",
						"}"),
				engineeringPrefix + String.join("\n",
						"SELECT ?assembly (COUNT(DISTINCT ?component) AS ?componentCount) WHERE {",
						"  { ?component a eng:Component ; eng:partOf ?assembly . }",
						"  UNION",
						"  { ?assembly a eng:Assembly . OPTIONAL { ?assembly eng:name ?name . } }",
						"  OPTIONAL { ?component eng:dependsOn ?dep . }",
						"}",
						"GROUP BY ?assembly"),
				engineeringPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?requirement) AS ?count) WHERE {",
						"  ?requirement a eng:Requirement .",
						"  FILTER EXISTS { ?requirement eng:satisfies ?component . }",
						"  FILTER NOT EXISTS {",
						"    ?requirement eng:verifiedBy ?test .",
						"    ?test eng:verifiedBy ?measurement .",
						"    ?measurement eng:measuredValue ?v .",
						"    FILTER(?v < 0.85)",
						"  }",
						"  MINUS { ?requirement eng:name ?name . FILTER(CONTAINS(?name, \"REQ-100\")) }",
						"}"),
				engineeringPrefix + String.join("\n",
						"SELECT ?component (AVG(?value) AS ?avgValue) WHERE {",
						"  ?component a eng:Component .",
						"  VALUES ?threshold { 0.85 0.9 }",
						"  ?requirement eng:satisfies ?component .",
						"  ?requirement eng:verifiedBy/eng:verifiedBy ?measurement .",
						"  ?measurement eng:measuredValue ?value .",
						"  BIND(?value > ?threshold AS ?pass)",
						"  FILTER(?pass)",
						"  OPTIONAL { ?component eng:dependsOn ?dep . }",
						"}",
						"GROUP BY ?component",
						"HAVING(AVG(?value) > 0.85)")));

		String connectedPrefix = String.join("\n",
				"PREFIX conn: <http://example.com/theme/connected/>",
				"");
		QUERIES.put(Theme.HIGHLY_CONNECTED, List.of(
				connectedPrefix + String.join("\n",
						"SELECT (COUNT(?node) AS ?count) WHERE {",
						"  { SELECT ?node (COUNT(?neighbor) AS ?deg) WHERE {",
						"      ?node a conn:Node .",
						"      OPTIONAL {",
						"        ?node conn:connectsTo ?neighbor .",
						"        OPTIONAL { ?node conn:weight ?w . }",
						"      }",
						"    } GROUP BY ?node HAVING(?deg > 2)",
						"  }",
						"  FILTER EXISTS { ?node conn:connectsTo ?other . }",
						"}"),
				connectedPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?node) AS ?count) WHERE {",
						"  { ?node a conn:Node . ?node conn:connectsTo ?target . }",
						"  UNION",
						"  { ?node a conn:Node . ?target conn:connectsTo ?node . }",
						"  MINUS { ?node conn:weight ?w . FILTER(?w < 3) }",
						"  BIND(STRLEN(STR(?node)) AS ?len)",
						"  FILTER(?len > 0)",
						"}"),
				connectedPrefix + String.join("\n",
						"SELECT (COUNT(?node) AS ?count) WHERE {",
						"  { SELECT ?node (COUNT(?target) AS ?deg) WHERE {",
						"      ?node a conn:Node .",
						"      OPTIONAL { ?node conn:connectsTo ?target . }",
						"    } GROUP BY ?node HAVING(?deg > 5)",
						"  }",
						"  OPTIONAL { ?node conn:weight ?w . }",
						"}"),
				connectedPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?node) AS ?count) WHERE {",
						"  VALUES ?threshold { 3 5 }",
						"  ?node a conn:Node .",
						"  OPTIONAL { ?node conn:connectsTo ?target . }",
						"  FILTER NOT EXISTS { ?node conn:weight ?w . FILTER(?w > ?threshold) }",
						"}"),
				connectedPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?start) AS ?count) WHERE {",
						"  ?start conn:connectsTo+ ?end .",
						"  BIND(STRLEN(STR(?end)) AS ?len)",
						"  FILTER EXISTS { ?end conn:weight ?w . }",
						"  FILTER(?len > 0)",
						"}"),
				connectedPrefix + String.join("\n",
						"SELECT ?node (COUNT(DISTINCT ?neighbor) AS ?neighborCount) WHERE {",
						"  { ?node conn:connectsTo ?neighbor . }",
						"  UNION",
						"  { ?neighbor conn:connectsTo ?node . }",
						"  OPTIONAL { ?node conn:weight ?w . }",
						"}",
						"GROUP BY ?node"),
				connectedPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?node) AS ?count) WHERE {",
						"  ?node a conn:Node .",
						"  FILTER EXISTS { ?node conn:connectsTo ?neighbor . }",
						"  FILTER NOT EXISTS { ?node conn:connectsTo ?neighbor . ?neighbor conn:connectsTo ?node . }",
						"  MINUS { ?node conn:weight ?w . FILTER(?w > 9) }",
						"}"),
				connectedPrefix + String.join("\n",
						"SELECT ?node (AVG(?w) AS ?avgWeight) WHERE {",
						"  ?node a conn:Node .",
						"  VALUES ?min { 2 4 }",
						"  ?node conn:weight ?w .",
						"  BIND(?w >= ?min AS ?ok)",
						"  FILTER(?ok)",
						"  OPTIONAL { ?node conn:connectsTo ?neighbor . }",
						"}",
						"GROUP BY ?node",
						"HAVING(AVG(?w) > 4)")));

		String trainPrefix = String.join("\n",
				"PREFIX train: <http://example.com/theme/train/>",
				"PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>",
				"");
		QUERIES.put(Theme.TRAIN, List.of(
				trainPrefix + String.join("\n",
						"SELECT (COUNT(?route) AS ?count) WHERE {",
						"  { SELECT ?route (COUNT(?stop) AS ?stopCount) WHERE {",
						"      ?route a train:Route .",
						"      OPTIONAL {",
						"        ?route train:hasStop ?stop .",
						"        OPTIONAL { ?stop train:atStation ?station . }",
						"      }",
						"    } GROUP BY ?route HAVING(?stopCount > 3)",
						"  }",
						"  FILTER EXISTS { ?route train:hasStop ?s . }",
						"}"),
				trainPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?entity) AS ?count) WHERE {",
						"  { ?entity a train:Train ; train:name ?name . }",
						"  UNION",
						"  { ?entity a train:Station ; train:name ?name . }",
						"  MINUS { ?entity train:name ?n . FILTER(CONTAINS(?n, \"Station 1\")) }",
						"  BIND(STRLEN(STR(?entity)) AS ?len)",
						"  FILTER(?len > 0)",
						"}"),
				trainPrefix + String.join("\n",
						"SELECT (COUNT(?trip) AS ?count) WHERE {",
						"  { SELECT ?trip (COUNT(?route) AS ?routeCount) WHERE {",
						"      ?trip a train:Trip .",
						"      OPTIONAL { ?trip train:onRoute ?route . }",
						"      OPTIONAL { ?trip train:departureTime ?time . }",
						"    } GROUP BY ?trip HAVING(?routeCount > 0)",
						"  }",
						"  OPTIONAL { ?train train:hasTrip ?trip . }",
						"}"),
				trainPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?trip) AS ?count) WHERE {",
						"  VALUES ?stationName { \"Station 0\" \"Station 1\" \"Station 2\" }",
						"  ?station a train:Station ; train:name ?stationName .",
						"  ?stop train:atStation ?station .",
						"  ?route train:hasStop ?stop .",
						"  OPTIONAL { ?trip train:onRoute ?route . }",
						"  FILTER NOT EXISTS { ?trip train:departureTime ?time .",
						"    FILTER(?time < \"06:00:00\"^^xsd:time) }",
						"}"),
				trainPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?train) AS ?count) WHERE {",
						"  ?train train:hasTrip/train:onRoute/train:hasStop/train:atStation ?station .",
						"  BIND(STRLEN(STR(?station)) AS ?len)",
						"  FILTER EXISTS { ?station train:name ?name . }",
						"  FILTER(?len > 0)",
						"}"),
				trainPrefix + String.join("\n",
						"SELECT ?route (COUNT(DISTINCT ?trip) AS ?tripCount) WHERE {",
						"  { ?trip a train:Trip ; train:onRoute ?route . }",
						"  UNION",
						"  { ?route a train:Route . OPTIONAL { ?route train:name ?name . } }",
						"  OPTIONAL { ?route train:hasStop ?stop . }",
						"}",
						"GROUP BY ?route"),
				trainPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?train) AS ?count) WHERE {",
						"  ?train a train:Train ; train:hasTrip ?trip .",
						"  FILTER EXISTS { ?trip train:departureTime ?time . }",
						"  FILTER NOT EXISTS { ?trip train:departureTime ?late .",
						"    FILTER(?late > \"20:00:00\"^^xsd:time) }",
						"  MINUS { ?train train:name ?name . FILTER(CONTAINS(?name, \"Train 1\")) }",
						"}"),
				trainPrefix + String.join("\n",
						"SELECT ?station (COUNT(DISTINCT ?stop) AS ?stopCount) WHERE {",
						"  ?station a train:Station ; train:name ?stationName .",
						"  VALUES ?prefix { \"Station 1\" \"Station 2\" }",
						"  BIND(STRSTARTS(?stationName, ?prefix) AS ?match)",
						"  FILTER(?match)",
						"  OPTIONAL { ?stop train:atStation ?station . }",
						"}",
						"GROUP BY ?station",
						"HAVING(COUNT(?stop) > 0)")));

		String gridPrefix = String.join("\n",
				"PREFIX grid: <http://example.com/theme/grid/>",
				"");
		QUERIES.put(Theme.ELECTRICAL_GRID, List.of(
				gridPrefix + String.join("\n",
						"SELECT (COUNT(?substation) AS ?count) WHERE {",
						"  { SELECT ?substation (COUNT(?transformer) AS ?tCount) WHERE {",
						"      ?substation a grid:Substation .",
						"      OPTIONAL {",
						"        ?transformer grid:feeds ?substation .",
						"        OPTIONAL { ?transformer grid:hasMeter ?meter . }",
						"      }",
						"    } GROUP BY ?substation HAVING(?tCount > 0)",
						"  }",
						"  FILTER EXISTS { ?generator grid:feeds ?substation . }",
						"}"),
				gridPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?asset) AS ?count) WHERE {",
						"  { ?asset a grid:Transformer . }",
						"  UNION",
						"  { ?asset a grid:Generator . }",
						"  MINUS {",
						"    ?asset grid:feeds ?substation .",
						"    ?substation grid:name ?name .",
						"    FILTER(CONTAINS(?name, \"Substation 1\"))",
						"  }",
						"  BIND(STRLEN(STR(?asset)) AS ?len)",
						"  FILTER(?len > 0)",
						"}"),
				gridPrefix + String.join("\n",
						"SELECT (COUNT(?meter) AS ?count) WHERE {",
						"  { SELECT ?meter (COUNT(?load) AS ?loadCount) WHERE {",
						"      ?meter a grid:Meter .",
						"      OPTIONAL { ?meter grid:measures ?load . }",
						"      OPTIONAL { ?load grid:loadValue ?value . }",
						"    } GROUP BY ?meter HAVING(?loadCount > 0)",
						"  }",
						"  OPTIONAL { ?transformer grid:hasMeter ?meter . }",
						"}"),
				gridPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?transformer) AS ?count) WHERE {",
						"  VALUES ?subName { \"Substation 0\" \"Substation 1\" \"Substation 2\" }",
						"  ?substation a grid:Substation ; grid:name ?subName .",
						"  ?transformer grid:feeds ?substation ; grid:hasMeter ?meter .",
						"  OPTIONAL { ?meter grid:measures ?load . }",
						"  FILTER NOT EXISTS { ?meter grid:measures ?blocked .",
						"    ?blocked grid:loadValue ?v . FILTER(?v > 180) }",
						"}"),
				gridPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?transformer) AS ?count) WHERE {",
						"  ?transformer grid:hasMeter/grid:measures ?load .",
						"  ?load grid:loadValue ?value .",
						"  BIND((?value / 10) AS ?bucket)",
						"  FILTER EXISTS { ?transformer grid:feeds ?substation . }",
						"  FILTER(?bucket >= 8)",
						"}"),
				gridPrefix + String.join("\n",
						"SELECT ?substation (COUNT(DISTINCT ?asset) AS ?assetCount) WHERE {",
						"  { ?asset a grid:Transformer ; grid:feeds ?substation . }",
						"  UNION",
						"  { ?asset a grid:Generator ; grid:feeds ?substation . }",
						"  OPTIONAL { ?substation grid:name ?name . }",
						"}",
						"GROUP BY ?substation"),
				gridPrefix + String.join("\n",
						"SELECT (COUNT(DISTINCT ?line) AS ?count) WHERE {",
						"  ?line a grid:Line .",
						"  FILTER EXISTS { ?line grid:connectsTo ?substation . }",
						"  FILTER NOT EXISTS { ?line grid:connectsTo ?a . ?line grid:connectsTo ?b .",
						"    FILTER(?a = ?b) }",
						"  MINUS { ?line grid:connectsTo ?substation . ?substation grid:name ?name .",
						"    FILTER(CONTAINS(?name, \"Substation 1\")) }",
						"}"),
				gridPrefix + String.join("\n",
						"SELECT ?substation (AVG(?capacity) AS ?avgCapacity) WHERE {",
						"  ?generator a grid:Generator ; grid:feeds ?substation ; grid:capacity ?capacity .",
						"  VALUES ?threshold { 700 800 }",
						"  BIND(?capacity >= ?threshold AS ?ok)",
						"  FILTER(?ok)",
						"  OPTIONAL { ?substation grid:name ?name . }",
						"}",
						"GROUP BY ?substation",
						"HAVING(AVG(?capacity) > 650)")));

		validateQueries();
	}

	private ThemeQueryCatalog() {
	}

	public static List<String> queriesFor(Theme theme) {
		Objects.requireNonNull(theme, "theme");
		return QUERIES.get(theme);
	}

	public static String queryFor(Theme theme, int index) {
		Objects.requireNonNull(theme, "theme");
		List<String> queries = QUERIES.get(theme);
		if (queries == null) {
			throw new IllegalArgumentException("No queries registered for theme " + theme);
		}
		if (index < 0 || index >= queries.size()) {
			throw new IllegalArgumentException("Query index out of range: " + index);
		}
		return queries.get(index);
	}

	private static void validateQueries() {
		for (Theme theme : Theme.values()) {
			List<String> queries = QUERIES.get(theme);
			if (queries == null) {
				throw new IllegalStateException("Missing query list for theme " + theme);
			}
			if (queries.size() != QUERY_COUNT) {
				throw new IllegalStateException("Theme " + theme + " has " + queries.size() + " queries");
			}
		}
	}
}
