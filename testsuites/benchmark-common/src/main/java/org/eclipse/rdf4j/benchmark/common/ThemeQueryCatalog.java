/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.benchmark.common;

import java.util.EnumMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;

import org.eclipse.rdf4j.benchmark.rio.util.ThemeDataSetGenerator.Theme;

public final class ThemeQueryCatalog {

	public static final int QUERY_COUNT = 14;

	private static final Map<Theme, List<BenchmarkQuery>> QUERIES = new EnumMap<>(Theme.class);

	static {
		String medicalPrefix = String.join("\n",
				"PREFIX med: <http://example.com/theme/medical/>",
				"PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>",
				"");
		QUERIES.put(Theme.MEDICAL_RECORDS, List.of(
				query("Medical: recent encounters after June",
						medicalPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?patient) AS ?count) WHERE {",
								"  ?patient a med:Patient .",
								"  OPTIONAL {",
								"    ?patient med:hasEncounter ?enc .",
								"    ?enc med:recordedOn ?date .",
								"    BIND(?date AS ?optDate)",
								"  }",
								"  FILTER(?optDate >= \"2024-06-01\"^^xsd:date)",
								"  OPTIONAL { ?patient med:hasMedication ?med . }",
								"}"),
						1L),
				query("Medical: conditions or medications by code",
						medicalPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?entity) AS ?count) WHERE {",
								"  VALUES ?target { \"DX-200\" \"DX-201\" }",
								"  { ?entity a med:Condition ; med:code ?code . }",
								"  UNION",
								"  { ?entity a med:Medication ; med:code ?code . }",
								"  FILTER(?code = ?target || ?code = \"DX-202\")",
								"  OPTIONAL { ?entity med:code ?alt . }",
								"}"),
						1L),
				query("Medical: practitioner encounters Jan-Feb",
						medicalPrefix + String.join("\n",
								"SELECT ?practitioner (COUNT(DISTINCT ?enc) AS ?encCount) WHERE {",
								"  ?enc a med:Encounter ; med:handledBy ?practitioner ; med:recordedOn ?date .",
								"  FILTER(?date IN (\"2024-01-01\"^^xsd:date, \"2024-02-01\"^^xsd:date))",
								"  OPTIONAL { ?enc med:hasCondition ?cond . }",
								"}",
								"GROUP BY ?practitioner",
								"HAVING(COUNT(?enc) > 0)"),
						135L),
				query("Medical: high observation values excluding test",
						medicalPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?patient) AS ?count) WHERE {",
								"  ?patient a med:Patient .",
								"  OPTIONAL {",
								"    ?patient med:hasEncounter/med:hasObservation ?obs .",
								"    ?obs med:value ?value .",
								"    BIND(?value AS ?optValue)",
								"  }",
								"  FILTER(?optValue > 60)",
								"  MINUS { ?patient med:name ?name . FILTER(CONTAINS(LCASE(STR(?name)), \"test\")) }",
								"}"),
						1L),
				query("Medical: encounters with condition and observation",
						medicalPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?enc) AS ?count) WHERE {",
								"  ?enc a med:Encounter ; med:hasCondition ?cond .",
								"  ?cond med:code ?code .",
								"  FILTER(?code = \"DX-200\" || ?code = \"DX-201\")",
								"  FILTER EXISTS { ?enc med:hasObservation ?obs . }",
								"  OPTIONAL { ?enc med:handledBy ?practitioner . }",
								"}"),
						1L),
				query("Medical: observation values without conditions",
						medicalPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?patient) AS ?count) WHERE {",
								"  VALUES ?limit { 55 }",
								"  ?patient a med:Patient ; med:hasEncounter ?enc .",
								"  ?enc med:hasObservation ?obs .",
								"  ?obs med:value ?value .",
								"  FILTER(?value IN (50, 60, 70))",
								"  FILTER NOT EXISTS { ?enc med:hasCondition ?cond . }",
								"}"),
						1L),
				query("Medical: patient medication counts",
						medicalPrefix + String.join("\n",
								"SELECT ?patient (COUNT(DISTINCT ?med) AS ?medCount) WHERE {",
								"  { ?patient a med:Patient . }",
								"  UNION",
								"  { ?patient med:hasEncounter ?enc . }",
								"  OPTIONAL {",
								"    ?patient med:hasMedication ?med .",
								"    BIND(?med AS ?optMed)",
								"  }",
								"  FILTER(?optMed != ?patient)",
								"}",
								"GROUP BY ?patient",
								"HAVING(COUNT(?med) > 0)"),
						8335L),
				query("Medical: medications by code without x dosage",
						medicalPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?med) AS ?count) WHERE {",
								"  ?med a med:Medication ; med:code ?code .",
								"  FILTER(?code = \"MED-1000\" || ?code = \"MED-1001\")",
								"  FILTER EXISTS { ?patient med:hasMedication ?med . }",
								"  MINUS { ?med med:dosage ?dose . FILTER(CONTAINS(LCASE(STR(?dose)), \"x\")) }",
								"}"),
						1L),
				query("Medical: patients with multiple conditioned encounters",
						medicalPrefix + String.join("\n",
								"SELECT ?patient (COUNT(DISTINCT ?enc) AS ?encCount) WHERE {",
								"  ?patient a med:Patient .",
								"  OPTIONAL {",
								"    ?patient med:hasEncounter ?enc .",
								"    ?enc med:handledBy ?practitioner .",
								"    BIND(?practitioner AS ?optPractitioner)",
								"  }",
								"  FILTER(?optPractitioner != ?patient)",
								"  FILTER EXISTS { ?enc med:hasCondition ?cond . }",
								"}",
								"GROUP BY ?patient",
								"HAVING(COUNT(?enc) >= 2)"),
						8335L),
				query("Medical: encounters excluding low observations",
						medicalPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?enc) AS ?count) WHERE {",
								"  VALUES ?code { \"DX-200\" \"DX-201\" }",
								"  ?enc a med:Encounter ; med:hasCondition ?cond .",
								"  ?cond med:code ?condCode .",
								"  FILTER(?condCode IN (\"DX-200\", \"DX-201\", \"DX-202\"))",
								"  OPTIONAL { ?enc med:handledBy ?practitioner . }",
								"  MINUS { ?enc med:hasObservation ?obs . ?obs med:value ?value . FILTER(?value < 60) }",
								"}"),
						1L),
				query("Medical: patients with meds or observations excluding MED-1005",
						medicalPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?patient) AS ?count) WHERE {",
								"  { ?patient a med:Patient ; med:hasMedication ?med . }",
								"  UNION",
								"  { ?patient a med:Patient ; med:hasEncounter ?enc . ?enc med:hasObservation ?obs . }",
								"  OPTIONAL { ?patient med:name ?optName . }",
								"  FILTER(?optName != \"\")",
								"  FILTER NOT EXISTS { ?patient med:hasMedication ?m2 . ?m2 med:code ?c .",
								"                      FILTER(?c = \"MED-1005\") }",
								"}"),
						1L),
				query("Medical: DX-200 Q1 encounters with very high observations (optimizer torture)",
						medicalPrefix + String.join("\n",
								"SELECT ?enc ?obs ?optValue WHERE {",
								"  ?enc ?anyP ?anyO .",
								"  ?enc a med:Encounter .",
								"  OPTIONAL {",
								"    ?enc med:recordedOn ?date .",
								"    BIND(?date AS ?optDate)",
								"  }",
								"  FILTER(?optDate >= \"2024-01-01\"^^xsd:date && ?optDate < \"2024-04-01\"^^xsd:date)",
								"  OPTIONAL { ?enc med:hasCondition ?cond . ?cond med:code ?code . BIND(STR(?code) AS ?codeStr) }",
								"  FILTER(?codeStr = \"DX-200\")",
								"  OPTIONAL { ?enc med:hasObservation ?obs . ?obs med:value ?value . BIND(?value AS ?optValue) }",
								"  FILTER(?optValue > 95)",
								"}"),
						7280L), // Optimization: avoid the broad `?enc ?anyP ?anyO` scan by starting from selective
								// patterns (DX-200, date window, high observation), and rewrite OPTIONAL+FILTER into
								// inner joins with filter pushdown.
				query("Medical: MED-1000 patients excluding any DX-202 encounter (anti-join stress)",
						medicalPrefix + String.join("\n",
								"SELECT ?patient ?m ?optCode WHERE {",
								"  { ?patient a med:Patient . }",
								"  UNION",
								"  { ?patient med:hasEncounter ?e . }",
								"  OPTIONAL {",
								"    ?patient med:hasMedication ?m .",
								"    ?m med:code ?code .",
								"    BIND(?code AS ?optCode)",
								"  }",
								"  FILTER(?optCode = \"MED-1000\")",
								"  MINUS {",
								"    ?patient med:hasEncounter ?e2 .",
								"    ?e2 med:hasCondition ?c2 .",
								"    ?c2 med:code \"DX-202\" .",
								"  }",
								"  OPTIONAL { ?patient med:name ?n . }",
								"  FILTER(?n != \"\")",
								"}"),
						9863L), // Optimization: remove the redundant UNION branch, turn the medication OPTIONAL+FILTER
								// into a selective inner join, and implement the DX-202 exclusion as an indexed
								// anti-join evaluated early.
				query("Medical: practitioners treating 'patient 1*' with DX-201 (correlated EXISTS)",
						medicalPrefix + String.join("\n",
								"SELECT ?practitioner ?pp ?po WHERE {",
								"  ?practitioner a med:Practitioner .",
								"  ?practitioner ?pp ?po .",
								"  OPTIONAL { ?practitioner med:name ?pName . BIND(LCASE(STR(?pName)) AS ?pNameLc) }",
								"  FILTER(CONTAINS(?pNameLc, \"alpha\"))",
								"  FILTER EXISTS {",
								"    ?enc med:handledBy ?practitioner .",
								"    ?patient med:hasEncounter ?enc .",
								"    OPTIONAL { ?patient med:name ?name . BIND(LCASE(STR(?name)) AS ?nameLc) }",
								"    FILTER(CONTAINS(?nameLc, \"patient 1\"))",
								"    OPTIONAL { ?enc med:hasCondition ?cond . ?cond med:code ?c . BIND(?c AS ?optC) }",
								"    FILTER(?optC = \"DX-201\")",
								"  }",
								"}"),
						146L) // Optimization: decorrelate EXISTS into a semi-join, push down the patient-name + DX-201
								// filters, and avoid expanding `?practitioner ?pp ?po` until after the selective join
								// has reduced candidates.
		));

		String socialPrefix = String.join("\n",
				"PREFIX social: <http://example.com/theme/social/>",
				"PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>",
				"");
		QUERIES.put(Theme.SOCIAL_MEDIA, List.of(
				query("Social: follow pairs among users 0-2",
						socialPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?pair) AS ?count) WHERE {",
								"  VALUES ?u { <http://example.com/theme/social/user/0>",
								"              <http://example.com/theme/social/user/1>",
								"              <http://example.com/theme/social/user/2> }",
								"  VALUES ?v { <http://example.com/theme/social/user/0>",
								"              <http://example.com/theme/social/user/1>",
								"              <http://example.com/theme/social/user/2> }",
								"  FILTER(?u != ?v)",
								"  ?u social:follows ?v .",
								"  OPTIONAL { ?u social:name ?optName . }",
								"  FILTER(?optName IN (\"user0\", \"user1\", \"user2\"))",
								"  BIND(CONCAT(STR(?u), STR(?v)) AS ?pair)",
								"}"),
						1L),
				query("Social: mutual trio of users 0-2",
						socialPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?u1) AS ?count) WHERE {",
								"  VALUES ?u1 { <http://example.com/theme/social/user/0>",
								"               <http://example.com/theme/social/user/1>",
								"               <http://example.com/theme/social/user/2> }",
								"  VALUES ?u2 { <http://example.com/theme/social/user/0>",
								"               <http://example.com/theme/social/user/1>",
								"               <http://example.com/theme/social/user/2> }",
								"  VALUES ?u3 { <http://example.com/theme/social/user/0>",
								"               <http://example.com/theme/social/user/1>",
								"               <http://example.com/theme/social/user/2> }",
								"  FILTER(?u1 != ?u2 && ?u1 != ?u3 && ?u2 != ?u3)",
								"  ?u1 social:follows ?u2 .",
								"  ?u2 social:follows ?u1 .",
								"  ?u1 social:follows ?u3 .",
								"  ?u3 social:follows ?u1 .",
								"  ?u2 social:follows ?u3 .",
								"  ?u3 social:follows ?u2 .",
								"  FILTER EXISTS { ?u1 social:name ?name .",
								"                  FILTER(?name = \"user0\" || ?name = \"user1\") }",
								"  MINUS { ?u1 social:follows ?u1 . }",
								"}"),
						1L),
				query("Social: mutual follows among users 3-6",
						socialPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?u) AS ?count) WHERE {",
								"  VALUES ?u { <http://example.com/theme/social/user/3>",
								"              <http://example.com/theme/social/user/4>",
								"              <http://example.com/theme/social/user/5>",
								"              <http://example.com/theme/social/user/6> }",
								"  VALUES ?v { <http://example.com/theme/social/user/3>",
								"              <http://example.com/theme/social/user/4>",
								"              <http://example.com/theme/social/user/5>",
								"              <http://example.com/theme/social/user/6> }",
								"  FILTER(?u != ?v)",
								"  ?u social:follows ?v .",
								"  OPTIONAL { ?v social:name ?optName . }",
								"  FILTER(?optName != \"\")",
								"  FILTER EXISTS { ?v social:follows ?u . }",
								"}"),
						1L),
				query("Social: degree >=3 among users 3-6",
						socialPrefix + String.join("\n",
								"SELECT ?u (COUNT(DISTINCT ?v) AS ?degree) WHERE {",
								"  VALUES ?u { <http://example.com/theme/social/user/3>",
								"              <http://example.com/theme/social/user/4>",
								"              <http://example.com/theme/social/user/5>",
								"              <http://example.com/theme/social/user/6> }",
								"  VALUES ?v { <http://example.com/theme/social/user/3>",
								"              <http://example.com/theme/social/user/4>",
								"              <http://example.com/theme/social/user/5>",
								"              <http://example.com/theme/social/user/6> }",
								"  FILTER(?u != ?v)",
								"  ?u social:follows ?v .",
								"  OPTIONAL { ?u social:name ?optName . BIND(?optName AS ?optAlias) }",
								"  FILTER(?optAlias IN (\"user3\", \"user4\", \"user5\", \"user6\"))",
								"}",
								"GROUP BY ?u",
								"HAVING(COUNT(DISTINCT ?v) >= 3)"),
						0L),
				query("Social: follows among users 7-11",
						socialPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?u) AS ?count) WHERE {",
								"  VALUES ?u { <http://example.com/theme/social/user/7>",
								"              <http://example.com/theme/social/user/8>",
								"              <http://example.com/theme/social/user/9>",
								"              <http://example.com/theme/social/user/10>",
								"              <http://example.com/theme/social/user/11> }",
								"  VALUES ?v { <http://example.com/theme/social/user/7>",
								"              <http://example.com/theme/social/user/8>",
								"              <http://example.com/theme/social/user/9>",
								"              <http://example.com/theme/social/user/10>",
								"              <http://example.com/theme/social/user/11> }",
								"  FILTER(?u != ?v)",
								"  ?u social:follows ?v .",
								"  FILTER NOT EXISTS { ?u social:follows ?u . }",
								"  OPTIONAL { ?v social:name ?optName . }",
								"  FILTER(?optName != \"\")",
								"}"),
						1L),
				query("Social: activity from mutual follows or posts",
						socialPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?activity) AS ?count) WHERE {",
								"  VALUES ?u { <http://example.com/theme/social/user/7>",
								"              <http://example.com/theme/social/user/8>",
								"              <http://example.com/theme/social/user/9>",
								"              <http://example.com/theme/social/user/10>",
								"              <http://example.com/theme/social/user/11> }",
								"  {",
								"    ?u social:follows ?v .",
								"    ?v social:follows ?u .",
								"    BIND(?v AS ?activity)",
								"  }",
								"  UNION",
								"  {",
								"    ?post social:authored ?u .",
								"    BIND(?post AS ?activity)",
								"  }",
								"  OPTIONAL { ?u social:name ?optName . }",
								"  FILTER(?optName IN (\"user7\", \"user8\", \"user9\", \"user10\", \"user11\"))",
								"}"),
						1L),
				query("Social: connections >=5 among users 12-17",
						socialPrefix + String.join("\n",
								"SELECT ?u (COUNT(DISTINCT ?v) AS ?connections) WHERE {",
								"  VALUES ?u { <http://example.com/theme/social/user/12>",
								"              <http://example.com/theme/social/user/13>",
								"              <http://example.com/theme/social/user/14>",
								"              <http://example.com/theme/social/user/15>",
								"              <http://example.com/theme/social/user/16>",
								"              <http://example.com/theme/social/user/17> }",
								"  VALUES ?v { <http://example.com/theme/social/user/12>",
								"              <http://example.com/theme/social/user/13>",
								"              <http://example.com/theme/social/user/14>",
								"              <http://example.com/theme/social/user/15>",
								"              <http://example.com/theme/social/user/16>",
								"              <http://example.com/theme/social/user/17> }",
								"  FILTER(?u != ?v)",
								"  ?u social:follows ?v .",
								"  OPTIONAL { ?u social:name ?optName . }",
								"  FILTER(?optName != \"\")",
								"}",
								"GROUP BY ?u",
								"HAVING(COUNT(DISTINCT ?v) >= 5)"),
						0L),
				query("Social: mutual follows among users 12-17",
						socialPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?u) AS ?count) WHERE {",
								"  VALUES ?u { <http://example.com/theme/social/user/12>",
								"              <http://example.com/theme/social/user/13>",
								"              <http://example.com/theme/social/user/14>",
								"              <http://example.com/theme/social/user/15>",
								"              <http://example.com/theme/social/user/16>",
								"              <http://example.com/theme/social/user/17> }",
								"  VALUES ?v { <http://example.com/theme/social/user/12>",
								"              <http://example.com/theme/social/user/13>",
								"              <http://example.com/theme/social/user/14>",
								"              <http://example.com/theme/social/user/15>",
								"              <http://example.com/theme/social/user/16>",
								"              <http://example.com/theme/social/user/17> }",
								"  FILTER(?u != ?v)",
								"  ?u social:follows ?v .",
								"  FILTER EXISTS { ?v social:follows ?u . }",
								"  MINUS { ?v social:follows ?v . }",
								"  OPTIONAL { ?v social:name ?optName . }",
								"  FILTER(?optName IN (\"user12\", \"user13\", \"user14\", \"user15\", \"user16\", \"user17\"))",
								"}"),
						1L),
				query("Social: 3-cycle among users 0-2",
						socialPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?a) AS ?count) WHERE {",
								"  ?a social:follows ?b .",
								"  ?b social:follows ?c .",
								"  ?c social:follows ?a .",
								"  BIND(?a AS ?cycleStart)",
								"  OPTIONAL { ?a social:name ?optName . }",
								"  FILTER(?optName IN (\"user0\", \"user1\", \"user2\"))",
								"}"),
						1L),
				query("Social: 4-cycle among users 3-6",
						socialPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?a) AS ?count) WHERE {",
								"  VALUES ?b { <http://example.com/theme/social/user/3>",
								"              <http://example.com/theme/social/user/4>",
								"              <http://example.com/theme/social/user/5>",
								"              <http://example.com/theme/social/user/6> }",
								"  FILTER(?a != ?b && ?b != ?c && ?c != ?d && ?d != ?a)",
								"  ?a social:follows ?b .",
								"  ?b social:follows ?c .",
								"  ?c social:follows ?d .",
								"  ?d social:follows ?a .",
								"  OPTIONAL { ?b social:name ?optName . BIND(?optName AS ?optAlias) }",
								"  FILTER(?optAlias != \"\")",
								"}"),
						1L),
				query("Social: 5-cycle among users 7-11",
						socialPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?a) AS ?count) WHERE {",
								"  VALUES ?a { <http://example.com/theme/social/user/7>",
								"              <http://example.com/theme/social/user/8>",
								"              <http://example.com/theme/social/user/9>",
								"              <http://example.com/theme/social/user/10>",
								"              <http://example.com/theme/social/user/11> }",
								"  VALUES ?b { <http://example.com/theme/social/user/7>",
								"              <http://example.com/theme/social/user/8>",
								"              <http://example.com/theme/social/user/9>",
								"              <http://example.com/theme/social/user/10>",
								"              <http://example.com/theme/social/user/11> }",
								"  VALUES ?c { <http://example.com/theme/social/user/7>",
								"              <http://example.com/theme/social/user/8>",
								"              <http://example.com/theme/social/user/9>",
								"              <http://example.com/theme/social/user/10>",
								"              <http://example.com/theme/social/user/11> }",
								"  VALUES ?d { <http://example.com/theme/social/user/7>",
								"              <http://example.com/theme/social/user/8>",
								"              <http://example.com/theme/social/user/9>",
								"              <http://example.com/theme/social/user/10>",
								"              <http://example.com/theme/social/user/11> }",
								"  VALUES ?e { <http://example.com/theme/social/user/7>",
								"              <http://example.com/theme/social/user/8>",
								"              <http://example.com/theme/social/user/9>",
								"              <http://example.com/theme/social/user/10>",
								"              <http://example.com/theme/social/user/11> }",
								"  FILTER(?a != ?b && ?b != ?c && ?c != ?d && ?d != ?e && ?a != ?c)",
								"  ?a social:follows ?b .",
								"  ?b social:follows ?c .",
								"  ?c social:follows ?d .",
								"  ?d social:follows ?e .",
								"  ?e social:follows ?a .",
								"  FILTER EXISTS { ?a social:name ?name .",
								"                  FILTER(?name = \"user7\" || ?name = \"user8\") }",
								"  OPTIONAL { ?e social:name ?optName . }",
								"  FILTER(?optName IN (\"user7\", \"user8\", \"user9\", \"user10\", \"user11\"))",
								"}"),
						1L),
				query("Social: tag0 posts mentioning alpha with >=4 likes (optimizer torture)",
						socialPrefix + String.join("\n",
								"SELECT ?post ?l1 ?l2 ?l3 ?l4 WHERE {",
								"  ?post ?pp ?po .",
								"  ?post a social:Post .",
								"  ?post social:likedBy ?l1 .",
								"  ?post social:likedBy ?l2 .",
								"  ?post social:likedBy ?l3 .",
								"  ?post social:likedBy ?l4 .",
								"  FILTER(STR(?l1) < STR(?l2) && STR(?l2) < STR(?l3) && STR(?l3) < STR(?l4))",
								"  OPTIONAL { ?post social:hasTag ?tag . ?tag social:name ?tagName . BIND(?tagName AS ?optTagName) }",
								"  FILTER(?optTagName = \"tag0\")",
								"  OPTIONAL { ?post social:content ?content . BIND(LCASE(?content) AS ?lc) }",
								"  FILTER(CONTAINS(?lc, \"alpha\"))",
								"} LIMIT 181843"),
						181843L), // Optimization: recognize the 4-way likedBy self-join as an “at least 4 likes”
									// pattern, push down tag/content predicates before expanding likes, and (ideally)
									// rewrite to a precomputed like-degree path/index.
				query("Social: user1* with mutual follower who liked their tag1 post (join-order trap)",
						socialPrefix + String.join("\n",
								"SELECT ?u ?v ?post WHERE {",
								"  ?u a social:User .",
								"  OPTIONAL { ?u social:name ?name . BIND(?name AS ?n) }",
								"  FILTER(CONTAINS(?n, \"user1\"))",
								"  ?u social:follows ?v .",
								"  ?v social:follows ?u .",
								"  ?post a social:Post ; social:authored ?u ; social:likedBy ?v .",
								"  OPTIONAL { ?post social:hasTag ?tag . ?tag social:name ?tn . BIND(?tn AS ?optTn) }",
								"  FILTER(?optTn = \"tag1\")",
								"  OPTIONAL { ?post social:createdAt ?t . BIND(?t AS ?optT) }",
								"  FILTER(?optT > \"2024-01-10T00:00:00\"^^xsd:dateTime)",
								"}"),
						0L), // Optimization: start from selective tag/time constraints (tag1 + createdAt) and join
								// outward to post→author/liker→mutual-follows, instead of scanning large user-name
								// prefixes then exploding joins.
				query("Social: posts with likes but no comments (left-join anti-pattern)",
						socialPrefix + String.join("\n",
								"SELECT ?post ?liker ?optLn WHERE {",
								"  ?post a social:Post .",
								"  OPTIONAL { ?post social:hasComment ?c . }",
								"  FILTER(!BOUND(?c))",
								"  ?post social:likedBy ?liker .",
								"  OPTIONAL { ?liker social:name ?ln . BIND(?ln AS ?optLn) }",
								"  FILTER(?optLn != \"\")",
								"}"),
						0L) // Optimization: rewrite OPTIONAL+FILTER(!BOUND) into an anti-join (`FILTER NOT EXISTS {
							// ?post social:hasComment ?c }`) and reorder so the engine doesn’t build massive
							// NULL-extended intermediates.
		));

		String libraryPrefix = String.join("\n",
				"PREFIX lib: <http://example.com/theme/library/>",
				"PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>",
				"");
		QUERIES.put(Theme.LIBRARY, List.of(
				query("Library: books with copies and branches",
						libraryPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?book) AS ?count) WHERE {",
								"  ?book a lib:Book .",
								"  OPTIONAL {",
								"    ?book lib:hasCopy ?copy .",
								"    ?copy lib:locatedAt ?branch .",
								"    BIND(?branch AS ?optBranch)",
								"  }",
								"  FILTER(?optBranch != ?book)",
								"  OPTIONAL { ?book lib:writtenBy ?author . }",
								"}"),
						1L),
				query("Library: members or books by name",
						libraryPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?entity) AS ?count) WHERE {",
								"  VALUES ?target { \"Member 1\" \"Member 2\" }",
								"  { ?entity a lib:Member ; lib:name ?name . }",
								"  UNION",
								"  { ?entity a lib:Book ; lib:title ?name . }",
								"  FILTER(?name = ?target || ?name = \"Member 3\")",
								"  OPTIONAL { ?entity lib:hasCopy ?copy . }",
								"}"),
						1L),
				query("Library: author book counts",
						libraryPrefix + String.join("\n",
								"SELECT ?author (COUNT(DISTINCT ?book) AS ?bookCount) WHERE {",
								"  ?author a lib:Author ; lib:name ?authorName .",
								"  FILTER(?authorName IN (\"Author 1\", \"Author 2\", \"Author 3\"))",
								"  OPTIONAL { ?book lib:writtenBy ?author . }",
								"}",
								"GROUP BY ?author",
								"HAVING(COUNT(?book) > 0)"),
						3L),
				query("Library: loans due after Jan 10",
						libraryPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?loan) AS ?count) WHERE {",
								"  ?loan a lib:Loan ; lib:borrowedBy ?member .",
								"  OPTIONAL {",
								"    ?loan lib:dueDate ?due .",
								"    BIND(?due AS ?optDue)",
								"  }",
								"  FILTER(?optDue > \"2024-01-10\"^^xsd:date)",
								"  MINUS { ?member lib:name ?name . FILTER(CONTAINS(LCASE(STR(?name)), \"member 1\")) }",
								"}"),
						1L),
				query("Library: books by title with copies",
						libraryPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?book) AS ?count) WHERE {",
								"  ?book a lib:Book ; lib:title ?title .",
								"  FILTER(?title = \"Book 1\" || ?title = \"Book 2\")",
								"  FILTER EXISTS { ?book lib:hasCopy ?copy . }",
								"  OPTIONAL { ?book lib:writtenBy ?author . }",
								"}"),
						1L),
				query("Library: loans on specific dates without early due",
						libraryPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?loan) AS ?count) WHERE {",
								"  VALUES ?threshold { \"2024-01-01\"^^xsd:date }",
								"  ?loan a lib:Loan ; lib:loanDate ?loanDate .",
								"  FILTER(?loanDate IN (\"2024-01-01\"^^xsd:date, \"2024-01-02\"^^xsd:date))",
								"  FILTER NOT EXISTS { ?loan lib:dueDate ?due . FILTER(?due < ?threshold) }",
								"}"),
						1L),
				query("Library: member loan counts",
						libraryPrefix + String.join("\n",
								"SELECT ?member (COUNT(DISTINCT ?loan) AS ?loanCount) WHERE {",
								"  { ?loan a lib:Loan ; lib:borrowedBy ?member . }",
								"  UNION",
								"  { ?member a lib:Member . }",
								"  OPTIONAL {",
								"    ?loan lib:loanedCopy ?copy .",
								"    BIND(?copy AS ?optCopy)",
								"  }",
								"  FILTER(?optCopy != ?member)",
								"}",
								"GROUP BY ?member",
								"HAVING(COUNT(?loan) > 0)"),
						5081L),
				query("Library: copies at branches 0-1",
						libraryPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?copy) AS ?count) WHERE {",
								"  ?copy a lib:Copy ; lib:locatedAt ?branch .",
								"  ?branch lib:name ?branchName .",
								"  FILTER(?branchName = \"Branch 0\" || ?branchName = \"Branch 1\")",
								"  FILTER EXISTS { ?copy a lib:Copy . }",
								"  MINUS { ?copy lib:locatedAt ?branch . FILTER(CONTAINS(STR(?branch), \"branch/0\")) }",
								"}"),
						1L),
				query("Library: author loan counts",
						libraryPrefix + String.join("\n",
								"SELECT ?author (COUNT(DISTINCT ?loan) AS ?loanCount) WHERE {",
								"  ?book a lib:Book ; lib:writtenBy ?author ; lib:hasCopy ?copy .",
								"  ?copy lib:locatedAt ?branch .",
								"  ?loan a lib:Loan ; lib:loanedCopy ?copy ; lib:borrowedBy ?member .",
								"  OPTIONAL { ?member lib:name ?optName . }",
								"  FILTER(?optName IN (\"Member 1\", \"Member 2\", \"Member 3\"))",
								"}",
								"GROUP BY ?author",
								"HAVING(COUNT(?loan) > 0)"),
						10L),
				query("Library: members borrowing books by authors",
						libraryPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?member) AS ?count) WHERE {",
								"  VALUES ?target { \"Author 1\" \"Author 2\" }",
								"  ?member a lib:Member .",
								"  ?loan a lib:Loan ; lib:borrowedBy ?member ; lib:loanedCopy ?copy .",
								"  ?book lib:hasCopy ?copy ; lib:writtenBy ?author .",
								"  ?author lib:name ?authorName .",
								"  FILTER(?authorName = ?target || ?authorName = \"Author 3\")",
								"  FILTER NOT EXISTS { ?loan lib:dueDate ?due .",
								"                      FILTER(?due < \"2024-01-10\"^^xsd:date) }",
								"  OPTIONAL { ?book lib:title ?optTitle . }",
								"  FILTER(?optTitle != \"\")",
								"}"),
						1L),
				query("Library: branch inventory excluding branch 0",
						libraryPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?branch) AS ?count) WHERE {",
								"  { ?branch a lib:Branch . }",
								"  UNION",
								"  { ?branch a lib:Branch ; lib:name ?name . }",
								"  OPTIONAL { ?copy lib:locatedAt ?branch . BIND(?copy AS ?optCopy) }",
								"  FILTER(?optCopy != ?branch)",
								"  MINUS { ?branch lib:name ?name2 .",
								"          FILTER(CONTAINS(LCASE(STR(?name2)), \"branch 0\")) }",
								"}"),
						1L),
				query("Library: Branch 0 copies of Author 1 books (broad scan + OPTIONAL trap)",
						libraryPrefix + String.join("\n",
								"SELECT ?copy ?book ?author ?branch WHERE {",
								"  ?copy ?p ?o .",
								"  ?copy a lib:Copy .",
								"  OPTIONAL {",
								"    ?copy lib:locatedAt ?branch .",
								"    ?branch lib:name ?bn .",
								"    BIND(LCASE(STR(?bn)) AS ?bnLc)",
								"  }",
								"  FILTER(CONTAINS(?bnLc, \"branch 0\"))",
								"  OPTIONAL {",
								"    ?book lib:hasCopy ?copy .",
								"    ?book lib:writtenBy ?author .",
								"    ?author lib:name ?an .",
								"    BIND(?an AS ?optAuthorName)",
								"  }",
								"  FILTER(?optAuthorName = \"Author 1\")",
								"  OPTIONAL { ?book lib:title ?title . BIND(LCASE(STR(?title)) AS ?titleLc) }",
								"  FILTER(CONTAINS(?titleLc, \"book\"))",
								"}"),
						0L), // Optimization: drop/reorder the `?copy ?p ?o` scan, turn OPTIONAL+FILTER blocks into
								// inner joins, and start from the highly selective Branch/Author constraints before
								// touching the huge Book space.
				query("Library: loans for Branch 0 books due after Jan 10 (join-order nightmare)",
						libraryPrefix + String.join("\n",
								"SELECT ?loan ?book ?copy ?optDue WHERE {",
								"  ?book ?bp ?bo .",
								"  ?book a lib:Book .",
								"  OPTIONAL { ?book lib:hasCopy ?copy . BIND(?copy AS ?optCopy) }",
								"  FILTER(?optCopy != ?book)",
								"  OPTIONAL { ?copy lib:locatedAt ?branch . ?branch lib:name ?bn . BIND(LCASE(STR(?bn)) AS ?bnLc) }",
								"  FILTER(CONTAINS(?bnLc, \"branch 0\"))",
								"  OPTIONAL { ?loan a lib:Loan ; lib:loanedCopy ?copy ; lib:dueDate ?due . BIND(?due AS ?optDue) }",
								"  FILTER(?optDue > \"2024-01-10\"^^xsd:date)",
								"}"),
						14377L), // Optimization: start from the smaller Loan/Copy/Branch side (or Branch→Copy→Loan) and
									// push the dueDate filter down; avoid scanning Books and then “discovering” loans
									// late.
				query("Library: omega-title books that were ever loaned (correlated EXISTS)",
						libraryPrefix + String.join("\n",
								"SELECT ?book ?copy ?loan WHERE {",
								"  ?book a lib:Book .",
								"  OPTIONAL { ?book lib:title ?t . BIND(LCASE(STR(?t)) AS ?tlc) }",
								"  FILTER(CONTAINS(?tlc, \"omega\"))",
								"  ?book lib:hasCopy ?copy .",
								"  ?loan lib:loanedCopy ?copy .",
								"  FILTER EXISTS { ?loan lib:borrowedBy ?m . }",
								"}"),
						339L) // Optimization: treat the EXISTS as a semi-join (or remove it as redundant), and reorder
								// to start from the smaller Loan→Copy→Book path instead of scanning all book titles.
		));

		String engineeringPrefix = String.join("\n",
				"PREFIX eng: <http://example.com/theme/engineering/>",
				"");
		QUERIES.put(Theme.ENGINEERING, List.of(
				query("Engineering: components with assemblies and deps",
						engineeringPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?component) AS ?count) WHERE {",
								"  ?component a eng:Component .",
								"  OPTIONAL { ?component eng:partOf ?assembly . BIND(?assembly AS ?optAssembly) }",
								"  FILTER(?optAssembly != ?component)",
								"  OPTIONAL { ?component eng:dependsOn ?dep . }",
								"}"),
						1L),
				query("Engineering: requirements or components by name",
						engineeringPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?entity) AS ?count) WHERE {",
								"  VALUES ?target { \"REQ-1000\" \"REQ-1001\" }",
								"  { ?entity a eng:Requirement ; eng:name ?name . }",
								"  UNION",
								"  { ?entity a eng:Component ; eng:name ?name . }",
								"  FILTER(?name = ?target || ?name = \"REQ-1002\")",
								"  OPTIONAL { ?entity eng:partOf ?assembly . }",
								"}"),
						1L),
				query("Engineering: assembly component counts",
						engineeringPrefix + String.join("\n",
								"SELECT ?assembly (COUNT(DISTINCT ?component) AS ?componentCount) WHERE {",
								"  ?assembly a eng:Assembly ; eng:name ?assemblyName .",
								"  FILTER(?assemblyName IN (\"Assembly 1\", \"Assembly 2\", \"Assembly 3\"))",
								"  OPTIONAL { ?component eng:partOf ?assembly . }",
								"}",
								"GROUP BY ?assembly",
								"HAVING(COUNT(?component) > 0)"),
						3L),
				query("Engineering: requirements verified without component 1",
						engineeringPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?requirement) AS ?count) WHERE {",
								"  ?requirement a eng:Requirement ; eng:satisfies ?component .",
								"  OPTIONAL { ?requirement eng:verifiedBy ?test . BIND(?test AS ?optTest) }",
								"  FILTER(?optTest != ?requirement)",
								"  MINUS { ?component eng:name ?name . FILTER(CONTAINS(STR(?name), \"Component 1\")) }",
								"}"),
						1L),
				query("Engineering: components with dependencies",
						engineeringPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?component) AS ?count) WHERE {",
								"  ?component a eng:Component ; eng:name ?name .",
								"  FILTER(?name = \"Component 1\" || ?name = \"Component 2\")",
								"  FILTER EXISTS { ?component eng:dependsOn ?dep . }",
								"  OPTIONAL { ?component eng:partOf ?assembly . }",
								"}"),
						1L),
				query("Engineering: measurements above threshold",
						engineeringPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?measurement) AS ?count) WHERE {",
								"  VALUES ?threshold { 0.85 }",
								"  ?measurement a eng:Measurement ; eng:measuredValue ?value .",
								"  FILTER(?value IN (0.9, 0.95))",
								"  FILTER NOT EXISTS { ?measurement eng:measuredValue ?value2 . FILTER(?value2 < ?threshold) }",
								"}"),
						1L),
				query("Engineering: component requirement counts",
						engineeringPrefix + String.join("\n",
								"SELECT ?component (COUNT(DISTINCT ?requirement) AS ?reqCount) WHERE {",
								"  { ?requirement a eng:Requirement ; eng:satisfies ?component . }",
								"  UNION",
								"  { ?component a eng:Component . }",
								"  OPTIONAL { ?component eng:dependsOn ?dep . BIND(?dep AS ?optDep) }",
								"  FILTER(?optDep != ?component)",
								"}",
								"GROUP BY ?component",
								"HAVING(COUNT(?requirement) > 0)"),
						520L),
				query("Engineering: requirements with satisfies and no verification chain",
						engineeringPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?requirement) AS ?count) WHERE {",
								"  ?requirement a eng:Requirement ; eng:name ?name .",
								"  FILTER(?name = \"REQ-1000\" || ?name = \"REQ-1001\")",
								"  FILTER EXISTS { ?requirement eng:satisfies ?component . }",
								"  MINUS { ?requirement eng:verifiedBy ?test . ?test eng:verifiedBy ?measurement . }",
								"}"),
						1L),
				query("Engineering: component requirements in assemblies",
						engineeringPrefix + String.join("\n",
								"SELECT ?component (COUNT(DISTINCT ?requirement) AS ?reqCount) WHERE {",
								"  ?component a eng:Component ; eng:partOf ?assembly .",
								"  OPTIONAL { ?component eng:dependsOn ?dep . BIND(?dep AS ?optDep) }",
								"  FILTER(?optDep != ?component)",
								"  ?requirement a eng:Requirement ; eng:satisfies ?component .",
								"}",
								"GROUP BY ?component",
								"HAVING(COUNT(?requirement) >= 1)"),
						520L),
				query("Engineering: requirements verified by measurements",
						engineeringPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?requirement) AS ?count) WHERE {",
								"  VALUES ?threshold { 0.85 }",
								"  ?requirement a eng:Requirement ; eng:verifiedBy ?test .",
								"  ?test eng:verifiedBy ?measurement .",
								"  ?measurement eng:measuredValue ?value .",
								"  FILTER(?value IN (0.85, 0.9, 0.95))",
								"  FILTER EXISTS { ?requirement eng:satisfies ?component . }",
								"  OPTIONAL { ?component eng:name ?optName . }",
								"  FILTER(?optName != \"\")",
								"}"),
						1L),
				query("Engineering: assemblies without satisfied requirements",
						engineeringPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?assembly) AS ?count) WHERE {",
								"  ?assembly a eng:Assembly ; eng:name ?name .",
								"  FILTER(?name = \"Assembly 1\" || ?name = \"Assembly 2\")",
								"  OPTIONAL { ?component eng:partOf ?assembly . BIND(?component AS ?optComponent) }",
								"  FILTER(?optComponent != ?assembly)",
								"  MINUS { ?requirement eng:satisfies ?component . }",
								"}"),
						1L),
				query("Engineering: high measurements for requirements in 'Assembly 1*' (OPTIONAL chain trap)",
						engineeringPrefix + String.join("\n",
								"SELECT ?requirement ?measurement ?optV ?assembly ?optAn WHERE {",
								"  ?requirement ?p ?o .",
								"  ?requirement a eng:Requirement .",
								"  OPTIONAL {",
								"    ?requirement eng:verifiedBy ?test .",
								"    ?test eng:verifiedBy ?measurement .",
								"    ?measurement eng:measuredValue ?v .",
								"    BIND(?v AS ?optV)",
								"  }",
								"  FILTER(?optV > 0.99)",
								"  OPTIONAL {",
								"    ?requirement eng:satisfies ?component .",
								"    ?component eng:partOf ?assembly .",
								"    ?assembly eng:name ?an .",
								"    BIND(?an AS ?optAn)",
								"  }",
								"  FILTER(CONTAINS(?optAn, \"Assembly 1\"))",
								"}"),
						57L), // Optimization: convert OPTIONAL+FILTER chains into inner joins, push the `measuredValue
								// > 0.99` filter down, and join to assemblies only after the measurement filter has
								// reduced candidates.
				query("Engineering: components whose dependency is in the same assembly (redundant UNION)",
						engineeringPrefix + String.join("\n",
								"SELECT ?component ?dep ?optA1 ?optA2 WHERE {",
								"  { ?component a eng:Component . }",
								"  UNION",
								"  { ?component eng:dependsOn ?dep . }",
								"  OPTIONAL { ?component eng:partOf ?a1 . BIND(?a1 AS ?optA1) }",
								"  OPTIONAL { ?component eng:dependsOn ?dep . ?dep eng:partOf ?a2 . BIND(?a2 AS ?optA2) }",
								"  FILTER(?optA1 = ?optA2)",
								"}"),
						326L), // Optimization: eliminate the redundant UNION, rewrite OPTIONAL+FILTER into inner joins,
								// and start from the selective dependsOn edge to avoid scanning all components.
				query("Engineering: requirements for Component 1/2 with no low measurements (anti-join + string filter)",
						engineeringPrefix + String.join("\n",
								"SELECT ?requirement ?component WHERE {",
								"  ?requirement a eng:Requirement ; eng:satisfies ?component .",
								"  OPTIONAL { ?component eng:name ?cn . BIND(LCASE(STR(?cn)) AS ?cnLc) }",
								"  FILTER(CONTAINS(?cnLc, \"component 1\") || CONTAINS(?cnLc, \"component 2\"))",
								"  FILTER NOT EXISTS {",
								"    ?requirement eng:verifiedBy ?t .",
								"    ?t eng:verifiedBy ?m .",
								"    ?m eng:measuredValue ?v .",
								"    FILTER(?v < 0.85)",
								"  }",
								"}"),
						79L) // Optimization: push the component-name predicate down (prefer exact IRIs over CONTAINS),
								// and execute the NOT EXISTS as an indexed anti-join so low-measurement requirements
								// are eliminated early.
		));

		String connectedPrefix = String.join("\n",
				"PREFIX conn: <http://example.com/theme/connected/>",
				"");
		QUERIES.put(Theme.HIGHLY_CONNECTED, List.of(
				query("Connected: nodes with neighbors and weights",
						connectedPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?node) AS ?count) WHERE {",
								"  ?node a conn:Node .",
								"  OPTIONAL { ?node conn:connectsTo ?neighbor . BIND(?neighbor AS ?optNeighbor) }",
								"  FILTER(?optNeighbor != ?node)",
								"  OPTIONAL { ?node conn:weight ?w . }",
								"}"),
						1L),
				query("Connected: nodes with target weights",
						connectedPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?entity) AS ?count) WHERE {",
								"  VALUES ?target { 1 2 }",
								"  { ?entity a conn:Node ; conn:connectsTo ?targetNode . }",
								"  UNION",
								"  { ?entity a conn:Node . }",
								"  OPTIONAL { ?entity conn:weight ?w . }",
								"  FILTER(?w = ?target || ?w = 3)",
								"}"),
						1L),
				query("Connected: neighbor counts for weighted nodes",
						connectedPrefix + String.join("\n",
								"SELECT ?node (COUNT(DISTINCT ?neighbor) AS ?neighborCount) WHERE {",
								"  ?node a conn:Node ; conn:connectsTo ?neighbor .",
								"  ?node conn:weight ?w .",
								"  FILTER(?w IN (1, 2, 3))",
								"  OPTIONAL { ?neighbor conn:connectsTo ?node . }",
								"}",
								"GROUP BY ?node",
								"HAVING(COUNT(?neighbor) > 0)"),
						36767L),
				query("Connected: nodes with weight >5 excluding self loops",
						connectedPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?node) AS ?count) WHERE {",
								"  ?node a conn:Node .",
								"  OPTIONAL { ?node conn:weight ?w . BIND(?w AS ?optWeight) }",
								"  FILTER(?optWeight > 5)",
								"  MINUS { ?node conn:connectsTo ?neighbor . FILTER(?neighbor = ?node) }",
								"}"),
						1L),
				query("Connected: nodes with weights 1 or 2 and edges",
						connectedPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?node) AS ?count) WHERE {",
								"  ?node a conn:Node ; conn:weight ?w .",
								"  FILTER(?w = 1 || ?w = 2)",
								"  FILTER EXISTS { ?node conn:connectsTo ?neighbor . }",
								"  OPTIONAL { ?neighbor conn:connectsTo ?node . }",
								"}"),
						1L),
				query("Connected: nodes with weights 4-6 above threshold",
						connectedPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?node) AS ?count) WHERE {",
								"  VALUES ?threshold { 4 }",
								"  ?node a conn:Node ; conn:weight ?w .",
								"  FILTER(?w IN (4, 5, 6))",
								"  FILTER NOT EXISTS { ?node conn:weight ?w2 . FILTER(?w2 < ?threshold) }",
								"}"),
						1L),
				query("Connected: neighbor counts via incoming/outgoing",
						connectedPrefix + String.join("\n",
								"SELECT ?node (COUNT(DISTINCT ?neighbor) AS ?neighborCount) WHERE {",
								"  { ?node a conn:Node ; conn:connectsTo ?neighbor . }",
								"  UNION",
								"  { ?neighbor conn:connectsTo ?node . }",
								"  OPTIONAL { ?node conn:weight ?w . BIND(?w AS ?optWeight) }",
								"  FILTER(?optWeight != 0)",
								"}",
								"GROUP BY ?node",
								"HAVING(COUNT(?neighbor) > 0)"),
						40251L),
				query("Connected: nodes with weights 8 or 9 no self loop",
						connectedPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?node) AS ?count) WHERE {",
								"  ?node a conn:Node ; conn:weight ?w .",
								"  FILTER(?w = 8 || ?w = 9)",
								"  FILTER EXISTS { ?node conn:connectsTo ?neighbor . }",
								"  MINUS { ?neighbor conn:connectsTo ?node . FILTER(?neighbor = ?node) }",
								"}"),
						1L),
				query("Connected: length-2 path cycles for weights 7-9",
						connectedPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?node) AS ?count) WHERE {",
								"  ?node a conn:Node ; conn:connectsTo ?mid .",
								"  ?mid conn:connectsTo ?end .",
								"  OPTIONAL { ?node conn:weight ?optWeight . }",
								"  FILTER(?optWeight IN (7, 8, 9))",
								"  FILTER EXISTS { ?end conn:connectsTo ?node . }",
								"}"),
						1L),
				query("Connected: degree >1 with weighted neighbors",
						connectedPrefix + String.join("\n",
								"SELECT ?node (COUNT(DISTINCT ?neighbor) AS ?degree) WHERE {",
								"  { ?node conn:connectsTo ?neighbor . }",
								"  UNION",
								"  { ?neighbor conn:connectsTo ?node . }",
								"  OPTIONAL { ?neighbor conn:weight ?w . BIND(?w AS ?optWeight) }",
								"  FILTER(?optWeight != 0)",
								"}",
								"GROUP BY ?node",
								"HAVING(COUNT(?neighbor) > 1)"),
						40251L),
				query("Connected: nodes with weights 1-4 and no low neighbors",
						connectedPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?node) AS ?count) WHERE {",
								"  VALUES ?threshold { 3 }",
								"  ?node a conn:Node ; conn:weight ?w .",
								"  FILTER(?w IN (1, 2, 3, 4))",
								"  FILTER NOT EXISTS { ?node conn:connectsTo ?n2 .",
								"                      ?n2 conn:weight ?w2 . FILTER(?w2 < ?threshold) }",
								"  MINUS { ?node conn:connectsTo ?node . }",
								"}"),
						1L),
				query("Connected: nodes pointing to node/0 with weight>8 (IRI string trap)",
						connectedPrefix + String.join("\n",
								"SELECT ?node ?nbr ?optW WHERE {",
								"  ?node a conn:Node .",
								"  OPTIONAL { ?node conn:connectsTo ?nbr . BIND(STR(?nbr) AS ?nbrStr) }",
								"  FILTER(CONTAINS(?nbrStr, \"node/0\"))",
								"  OPTIONAL { ?node conn:weight ?w . BIND(?w AS ?optW) }",
								"  FILTER(?optW > 8)",
								"}"),
						26949L), // Optimization: rewrite CONTAINS(STR(?nbr),\"node/0\") to an equality against the
									// concrete IRI, turn OPTIONAL+FILTER into inner joins, and start from selective
									// weight/edge bindings instead of scanning all nodes.
				query("Connected: weight-10 nodes participating in a mutual edge (UNION + EXISTS redundancy)",
						connectedPrefix + String.join("\n",
								"SELECT ?node ?other ?optW WHERE {",
								"  { ?node conn:connectsTo ?other . }",
								"  UNION",
								"  { ?other conn:connectsTo ?node . }",
								"  OPTIONAL { ?node conn:weight ?w . BIND(?w AS ?optW) }",
								"  FILTER(?optW = 10)",
								"  FILTER EXISTS { ?node conn:connectsTo ?other . ?other conn:connectsTo ?node . }",
								"}"),
						54L), // Optimization: drop the redundant UNION and implement mutual-edge checking as a single
								// join/semi-join; push `weight=10` down to shrink candidates before testing mutuality.
				query("Connected: low-weight nodes with no very-low-weight neighbors (anti-join over UNION)",
						connectedPrefix + String.join("\n",
								"SELECT ?node ?optW WHERE {",
								"  ?node a conn:Node .",
								"  OPTIONAL { ?node conn:weight ?w . BIND((?w + 0) AS ?optW) }",
								"  FILTER(?optW <= 2)",
								"  FILTER NOT EXISTS {",
								"    { ?node conn:connectsTo ?n2 . }",
								"    UNION",
								"    { ?n2 conn:connectsTo ?node . }",
								"    ?n2 conn:weight ?w2 .",
								"    FILTER(?w2 < 3)",
								"  }",
								"}"),
						2L) // Optimization: collapse incoming/outgoing neighbor scans into efficient index scans
							// feeding one anti-join, and execute the NOT EXISTS with early cutoff.
		));

		String trainPrefix = String.join("\n",
				"PREFIX train: <http://example.com/theme/train/>",
				"PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>",
				"");
		QUERIES.put(Theme.TRAIN, List.of(
				query("Train: services after 08:00",
						trainPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?service) AS ?count) WHERE {",
								"  ?service a train:TrainService .",
								"  OPTIONAL {",
								"    ?service train:scheduledTime ?time .",
								"    BIND(?time AS ?optTime)",
								"  }",
								"  FILTER(?optTime > \"08:00:00\"^^xsd:time)",
								"  OPTIONAL { ?service train:name ?name . }",
								"}"),
						1L),
				query("Train: operational points or lines by name",
						trainPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?entity) AS ?count) WHERE {",
								"  VALUES ?target { \"OP 1\" \"OP 2\" }",
								"  { ?entity a train:OperationalPoint ; train:name ?name . }",
								"  UNION",
								"  { ?entity a train:Line ; train:name ?name . }",
								"  FILTER(?name = ?target || ?name = \"OP 3\")",
								"  OPTIONAL { ?entity train:connectsOperationalPoint ?op . }",
								"}"),
						1L),
				query("Train: line section counts",
						trainPrefix + String.join("\n",
								"SELECT ?line (COUNT(DISTINCT ?section) AS ?sectionCount) WHERE {",
								"  ?line a train:Line ; train:name ?lineName .",
								"  FILTER(?lineName IN (\"Line 0\", \"Line 1\", \"Line 2\"))",
								"  OPTIONAL { ?section train:partOfLine ?line . }",
								"}",
								"GROUP BY ?line",
								"HAVING(COUNT(?section) > 0)"),
						3L),
				query("Train: sections with track excluding Line 0",
						trainPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?section) AS ?count) WHERE {",
								"  ?section a train:SectionOfLine ; train:partOfLine ?line .",
								"  OPTIONAL { ?section train:hasTrackSection ?track . BIND(?track AS ?optTrack) }",
								"  FILTER(?optTrack != ?section)",
								"  MINUS { ?line train:name ?name . FILTER(CONTAINS(STR(?name), \"Line 0\")) }",
								"}"),
						1L),
				query("Train: lines with sections and ops",
						trainPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?line) AS ?count) WHERE {",
								"  ?line a train:Line ; train:name ?name .",
								"  FILTER(?name = \"Line 1\" || ?name = \"Line 2\")",
								"  FILTER EXISTS { ?section train:partOfLine ?line . }",
								"  OPTIONAL { ?section train:connectsOperationalPoint ?op . }",
								"}"),
						1L),
				query("Train: services without late departures",
						trainPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?service) AS ?count) WHERE {",
								"  VALUES ?threshold { \"10:00:00\"^^xsd:time }",
								"  ?service a train:TrainService ; train:scheduledTime ?time .",
								"  FILTER(?time IN (\"08:00:00\"^^xsd:time, \"09:00:00\"^^xsd:time))",
								"  FILTER NOT EXISTS { ?service train:scheduledTime ?late . FILTER(?late > ?threshold) }",
								"}"),
						1L),
				query("Train: line service counts",
						trainPrefix + String.join("\n",
								"SELECT ?line (COUNT(DISTINCT ?service) AS ?serviceCount) WHERE {",
								"  { ?service a train:TrainService ; train:runsOnSection ?section .",
								"    ?section train:partOfLine ?line . }",
								"  UNION",
								"  { ?line a train:Line . }",
								"  OPTIONAL { ?line train:name ?optName . }",
								"  FILTER(?optName != \"\")",
								"}",
								"GROUP BY ?line",
								"HAVING(COUNT(?service) > 0)"),
						7836L),
				query("Train: operational points with services excluding op 0",
						trainPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?op) AS ?count) WHERE {",
								"  ?op a train:OperationalPoint ; train:name ?name .",
								"  FILTER(?name = \"OP 1\" || ?name = \"OP 2\")",
								"  FILTER EXISTS { ?service train:passesThrough ?op . }",
								"  MINUS { ?op train:name ?name2 . FILTER(CONTAINS(LCASE(STR(?name2)), \"op 0\")) }",
								"}"),
						1L),
				query("Train: services on two sections of same line",
						trainPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?service) AS ?count) WHERE {",
								"  ?service a train:TrainService ; train:runsOnSection ?s1 ; train:runsOnSection ?s2 .",
								"  ?s1 train:partOfLine ?line .",
								"  ?s2 train:partOfLine ?line .",
								"  OPTIONAL { ?line train:name ?optName . }",
								"  FILTER(?optName IN (\"Line 0\", \"Line 1\"))",
								"  FILTER EXISTS { ?s1 train:connectsOperationalPoint ?op .",
								"                  ?s2 train:connectsOperationalPoint ?op . }",
								"}"),
						1L),
				query("Train: section track counts with ops",
						trainPrefix + String.join("\n",
								"SELECT ?section (COUNT(DISTINCT ?track) AS ?trackCount) WHERE {",
								"  ?section a train:SectionOfLine ; train:hasTrackSection ?track .",
								"  OPTIONAL { ?section train:connectsOperationalPoint ?op . BIND(?op AS ?optOp) }",
								"  FILTER(?optOp != ?section)",
								"  FILTER EXISTS { ?track a train:TrackSection . }",
								"}",
								"GROUP BY ?section",
								"HAVING(COUNT(?track) > 0)"),
						67388L),
				query("Train: operational points excluding op 1",
						trainPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?op) AS ?count) WHERE {",
								"  { ?op a train:OperationalPoint . }",
								"  UNION",
								"  { ?op a train:OperationalPoint ; train:name ?name . }",
								"  OPTIONAL { ?section train:connectsOperationalPoint ?op . BIND(?section AS ?optSection) }",
								"  FILTER(?optSection != ?op)",
								"  MINUS { ?op train:name ?name2 . FILTER(CONTAINS(LCASE(STR(?name2)), \"op 1\")) }",
								"}"),
						1L),
				query("Train: services whose earliest time is after noon on 'Line 1*' (anti-join + pushdown)",
						trainPrefix + String.join("\n",
								"SELECT ?service ?t ?section ?line WHERE {",
								"  ?service a train:TrainService .",
								"  ?service train:scheduledTime ?t .",
								"  FILTER(?t > \"12:00:00\"^^xsd:time)",
								"  FILTER NOT EXISTS { ?service train:scheduledTime ?t2 . FILTER(?t2 <= \"12:00:00\"^^xsd:time) }",
								"  OPTIONAL {",
								"    ?service train:runsOnSection ?section .",
								"    ?section train:partOfLine ?line .",
								"    ?line train:name ?ln .",
								"    BIND(LCASE(STR(?ln)) AS ?lnLc)",
								"  }",
								"  FILTER(CONTAINS(?lnLc, \"line 1\"))",
								"}"),
						276L), // Optimization: rewrite the time constraint into a single indexed anti-join, and push
								// the line-name restriction down (ideally avoid CONTAINS by binding concrete line IRIs
								// when possible).
				query("Train: operational points on Line 1 via track back-link (OPTIONAL self-join)",
						trainPrefix + String.join("\n",
								"SELECT ?op ?section ?track WHERE {",
								"  ?op a train:OperationalPoint .",
								"  OPTIONAL {",
								"    ?section train:connectsOperationalPoint ?op .",
								"    ?section train:partOfLine ?line .",
								"    ?line train:name ?name .",
								"    BIND(LCASE(STR(?name)) AS ?nameLc)",
								"  }",
								"  FILTER(CONTAINS(?nameLc, \"line 1\"))",
								"  OPTIONAL {",
								"    ?section train:hasTrackSection ?track .",
								"    ?track train:trackSectionOf ?section2 .",
								"    BIND(?section2 AS ?optSection2)",
								"  }",
								"  FILTER(?optSection2 = ?section)",
								"}"),
						17794L), // Optimization: drop/reorder the redundant backlink self-join (`trackSectionOf`) and
									// start from selective Line/Section bindings before touching the huge
									// OperationalPoint set.
				query("Train: services passing through OP 1* and OP 2* (Cartesian-product trap)",
						trainPrefix + String.join("\n",
								"SELECT ?service ?opA ?opB WHERE {",
								"  ?service a train:TrainService .",
								"  OPTIONAL { ?service train:passesThrough ?opA . ?opA train:name ?nA . BIND(LCASE(STR(?nA)) AS ?optNA) }",
								"  OPTIONAL { ?service train:passesThrough ?opB . ?opB train:name ?nB . BIND(LCASE(STR(?nB)) AS ?optNB) }",
								"  FILTER(CONTAINS(?optNA, \"op 1\") && CONTAINS(?optNB, \"op 2\"))",
								"}"),
						7849L) // Optimization: rewrite the two OPTIONALs into two semi-joins/EXISTS checks to avoid the
								// quadratic cross-product over multi-valued passesThrough, and push name filters down
								// to the op binding.
		));

		String gridPrefix = String.join("\n",
				"PREFIX grid: <http://example.com/theme/grid/>",
				"");
		QUERIES.put(Theme.ELECTRICAL_GRID, List.of(
				query("Grid: substations with high capacity generators",
						gridPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?substation) AS ?count) WHERE {",
								"  ?substation a grid:Substation .",
								"  OPTIONAL { ?generator grid:feeds ?substation ; grid:capacity ?cap . BIND(?cap AS ?optCap) }",
								"  FILTER(?optCap > 600)",
								"  OPTIONAL { ?substation grid:name ?name . }",
								"}"),
						1L),
				query("Grid: substations or generators by name",
						gridPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?entity) AS ?count) WHERE {",
								"  VALUES ?target { \"Substation 1\" \"Substation 2\" }",
								"  { ?entity a grid:Substation ; grid:name ?name . }",
								"  UNION",
								"  { ?entity a grid:Generator ; grid:feeds ?substation . ?substation grid:name ?name . }",
								"  FILTER(?name = ?target || ?name = \"Substation 3\")",
								"  OPTIONAL { ?entity grid:feeds ?substation2 . }",
								"}"),
						1L),
				query("Grid: transformer meter counts",
						gridPrefix + String.join("\n",
								"SELECT ?transformer (COUNT(DISTINCT ?meter) AS ?meterCount) WHERE {",
								"  ?transformer a grid:Transformer ; grid:feeds ?substation .",
								"  ?substation grid:name ?name .",
								"  FILTER(?name IN (\"Substation 0\", \"Substation 1\", \"Substation 2\"))",
								"  OPTIONAL { ?transformer grid:hasMeter ?meter . }",
								"}",
								"GROUP BY ?transformer",
								"HAVING(COUNT(?meter) > 0)"),
						10L),
				query("Grid: meters with load value window",
						gridPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?meter) AS ?count) WHERE {",
								"  ?meter a grid:Meter ; grid:measures ?load .",
								"  OPTIONAL { ?load grid:loadValue ?value . BIND(?value AS ?optValue) }",
								"  FILTER(?optValue > 100)",
								"  MINUS { ?meter grid:measures ?load2 . ?load2 grid:loadValue ?value2 . FILTER(?value2 > 180) }",
								"}"),
						1L),
				query("Grid: lines connecting substations 0-1",
						gridPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?line) AS ?count) WHERE {",
								"  ?line a grid:Line ; grid:connectsTo ?substation .",
								"  ?substation grid:name ?name .",
								"  FILTER(?name = \"Substation 0\" || ?name = \"Substation 1\")",
								"  FILTER EXISTS { ?line grid:connectsTo ?other . }",
								"  OPTIONAL { ?line grid:connectsTo ?other2 . }",
								"}"),
						1L),
				query("Grid: generators above capacity threshold",
						gridPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?generator) AS ?count) WHERE {",
								"  VALUES ?threshold { 700 }",
								"  ?generator a grid:Generator ; grid:capacity ?capacity .",
								"  FILTER(?capacity IN (700, 800, 900))",
								"  FILTER NOT EXISTS { ?generator grid:capacity ?cap2 . FILTER(?cap2 < ?threshold) }",
								"}"),
						1L),
				query("Grid: substation asset counts",
						gridPrefix + String.join("\n",
								"SELECT ?substation (COUNT(DISTINCT ?asset) AS ?assetCount) WHERE {",
								"  { ?asset a grid:Transformer ; grid:feeds ?substation . }",
								"  UNION",
								"  { ?asset a grid:Generator ; grid:feeds ?substation . }",
								"  OPTIONAL { ?asset grid:feeds ?substation . BIND(?substation AS ?optSub) }",
								"  FILTER(?optSub != ?asset)",
								"}",
								"GROUP BY ?substation",
								"HAVING(COUNT(?asset) > 0)"),
						9364L),
				query("Grid: transformers with meters excluding self load",
						gridPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?transformer) AS ?count) WHERE {",
								"  ?transformer a grid:Transformer ; grid:feeds ?substation .",
								"  ?substation grid:name ?name .",
								"  FILTER(?name = \"Substation 0\" || ?name = \"Substation 1\")",
								"  FILTER EXISTS { ?transformer grid:hasMeter ?meter . }",
								"  MINUS { ?meter grid:measures ?load . FILTER(?load = ?substation) }",
								"}"),
						1L),
				query("Grid: substation transformer counts",
						gridPrefix + String.join("\n",
								"SELECT ?substation (COUNT(DISTINCT ?transformer) AS ?transformerCount) WHERE {",
								"  ?substation a grid:Substation ; grid:name ?name .",
								"  OPTIONAL { ?substation grid:feeds ?transformer . BIND(?transformer AS ?optTransformer) }",
								"  FILTER(?optTransformer != ?substation)",
								"  FILTER EXISTS { ?transformer grid:hasMeter ?meter . }",
								"}",
								"GROUP BY ?substation",
								"HAVING(COUNT(?transformer) > 0)"),
						0L),
				query("Grid: lines by capacity range",
						gridPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?line) AS ?count) WHERE {",
								"  ?line a grid:Line ; grid:capacity ?cap .",
								"  FILTER(?cap IN (500, 600, 700))",
								"  OPTIONAL { ?line grid:connectsTo ?substation . }",
								"  MINUS { ?line grid:capacity ?cap2 . FILTER(?cap2 < 500) }",
								"}"),
						1L),
				query("Grid: meters with high loads excluding lows",
						gridPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?meter) AS ?count) WHERE {",
								"  { ?meter a grid:Meter ; grid:measures ?load . }",
								"  UNION",
								"  { ?meter a grid:Meter ; grid:measures ?load . ?load grid:loadValue ?value . }",
								"  OPTIONAL { ?load grid:loadValue ?optValue . }",
								"  FILTER(?optValue > 200)",
								"  FILTER NOT EXISTS { ?load grid:loadValue ?low . FILTER(?low < 50) }",
								"}"),
						1L),
				query("Grid: substations with a very high load (>190) (OPTIONAL value trap)",
						gridPrefix + String.join("\n",
								"SELECT ?substation ?transformer ?meter ?load ?optV WHERE {",
								"  ?substation a grid:Substation .",
								"  ?transformer a grid:Transformer ; grid:feeds ?substation ; grid:hasMeter ?meter .",
								"  ?meter grid:measures ?load .",
								"  OPTIONAL { ?load grid:loadValue ?value . BIND(?value AS ?optV) }",
								"  FILTER(?optV > 190)",
								"  OPTIONAL { ?substation grid:name ?n . BIND(LCASE(STR(?n)) AS ?nlc) }",
								"  FILTER(CONTAINS(?nlc, \"substation\"))",
								"}"),
						6714L), // Optimization: push the `loadValue > 190` predicate down to the loadValue index and
								// rewrite OPTIONAL+FILTER into a proper inner join so the engine doesn’t generate
								// NULL-extended intermediates.
				query("Grid: lines connecting substations '1*' and '2*' (IRI string + multi-join trap)",
						gridPrefix + String.join("\n",
								"SELECT ?line ?s1 ?s2 WHERE {",
								"  ?line a grid:Line .",
								"  ?line grid:connectsTo ?s1 .",
								"  ?line grid:connectsTo ?s2 .",
								"  OPTIONAL { BIND(STR(?s1) AS ?s1Str) }",
								"  OPTIONAL { BIND(STR(?s2) AS ?s2Str) }",
								"  FILTER((",
								"    (CONTAINS(?s1Str, \"substation/1\") || CONTAINS(?s2Str, \"substation/1\"))",
								"    &&",
								"    (CONTAINS(?s1Str, \"substation/2\") || CONTAINS(?s2Str, \"substation/2\"))",
								"  ))",
								"}"),
						1168L), // Optimization: replace CONTAINS-on-IRI with equality against concrete IRIs (or
								// pre-bound substation groups), and bind the target substations first so only matching
								// lines are scanned.
				query("Grid: transformers with no load <60 (anti-join via MINUS)",
						gridPrefix + String.join("\n",
								"SELECT ?transformer ?substation WHERE {",
								"  ?transformer a grid:Transformer ; grid:feeds ?substation .",
								"  OPTIONAL {",
								"    ?transformer grid:hasMeter ?m .",
								"    ?m grid:measures ?load .",
								"    ?load grid:loadValue ?v .",
								"    BIND(?v AS ?optV)",
								"  }",
								"  FILTER(?optV > 0)",
								"  MINUS {",
								"    ?transformer grid:hasMeter ?m2 .",
								"    ?m2 grid:measures ?load2 .",
								"    ?load2 grid:loadValue ?v2 .",
								"    FILTER(?v2 < 60)",
								"  }",
								"}"),
						83387L) // Optimization: execute the MINUS as an indexed anti-join (subtract transformers seen
								// with <60 loads early), and avoid building large intermediate join results before
								// applying the exclusion.
		));

		String pharmaPrefix = String.join("\n",
				"PREFIX pharma: <http://example.com/theme/pharma/>",
				"PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>",
				"");
		QUERIES.put(Theme.PHARMA, List.of(
				query("Pharma: trial drugs for diseases 0-1",
						pharmaPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?drug) AS ?count) WHERE {",
								"  VALUES ?disease { <http://example.com/theme/pharma/disease/0>",
								"                    <http://example.com/theme/pharma/disease/1> }",
								"  ?trial a pharma:ClinicalTrial ; pharma:studiesDisease ?disease ; pharma:hasArm ?arm .",
								"  ?arm pharma:armDrug ?drug ; pharma:hasResult ?result .",
								"  ?result pharma:pValue ?p ; pharma:effectSize ?effect .",
								"  OPTIONAL { ?result pharma:biomarker ?marker . BIND(?marker AS ?optMarker) }",
								"  FILTER(?optMarker != <http://example.com/theme/pharma/biomarker/999>)",
								"  FILTER(?p < 0.05 || ?effect > 0.7)",
								"}"),
						1L),
				query("Pharma: combinations with side effects and synergy",
						pharmaPrefix + String.join("\n",
								"SELECT ?combo (COUNT(DISTINCT ?drug) AS ?drugCount) WHERE {",
								"  ?combo a pharma:Combination ; pharma:combinationOf ?drug ; pharma:synergyScore ?score .",
								"  OPTIONAL {",
								"    ?drug pharma:hasSideEffect ?sideEffect .",
								"    ?sideEffect pharma:severity ?sev .",
								"    BIND(?sev AS ?optSeverity)",
								"  }",
								"  FILTER(?optSeverity IN (\"Mild\", \"Moderate\"))",
								"  FILTER(?score > 0.7)",
								"}",
								"GROUP BY ?combo",
								"HAVING(COUNT(DISTINCT ?drug) >= 2)"),
						80L),
				query("Pharma: targets with multiple drugs in trials",
						pharmaPrefix + String.join("\n",
								"SELECT ?target (COUNT(DISTINCT ?drug) AS ?drugCount) WHERE {",
								"  ?target a pharma:Target ; pharma:inPathway ?pathway .",
								"  ?drug a pharma:Drug ; pharma:targets ?target .",
								"  OPTIONAL { ?drug pharma:indicatedFor ?disease . BIND(?disease AS ?optDisease) }",
								"  FILTER(?optDisease IN (<http://example.com/theme/pharma/disease/2>,",
								"                         <http://example.com/theme/pharma/disease/3>))",
								"  FILTER EXISTS { ?trial pharma:hasArm ?arm . ?arm pharma:armDrug ?drug . }",
								"}",
								"GROUP BY ?target",
								"HAVING(COUNT(DISTINCT ?drug) > 2)"),
						0L),
				query("Pharma: drug responses without indication",
						pharmaPrefix + String.join("\n",
								"SELECT ?drug ?disease WHERE {",
								"  ?trial a pharma:ClinicalTrial ; pharma:studiesDisease ?disease ; pharma:hasArm ?arm .",
								"  ?arm pharma:armDrug ?drug ; pharma:hasResult ?result .",
								"  ?result pharma:responseRate ?rate .",
								"  FILTER(?rate > 0.6)",
								"  FILTER NOT EXISTS { ?drug pharma:indicatedFor ?disease . }",
								"  OPTIONAL { ?drug pharma:targets ?target . BIND(?target AS ?optTarget) }",
								"  FILTER(?optTarget != <http://example.com/theme/pharma/target/0>)",
								"}"),
						2216L),
				query("Pharma: drugs by class excluding contraindications",
						pharmaPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?drug) AS ?count) WHERE {",
								"  { ?drug a pharma:Drug ; pharma:hasMolecule ?mol . }",
								"  UNION",
								"  { ?combo a pharma:Combination ; pharma:combinationOf ?drug .",
								"    ?drug pharma:hasMolecule ?mol . }",
								"  ?mol pharma:inClass ?class .",
								"  OPTIONAL { ?class pharma:name ?optName . BIND(?optName AS ?optClassName) }",
								"  FILTER(?optClassName != \"\")",
								"  MINUS { ?drug pharma:contraindicatedFor ?disease .",
								"          FILTER(?disease IN (<http://example.com/theme/pharma/disease/4>,",
								"                              <http://example.com/theme/pharma/disease/5>)) }",
								"}"),
						1L),
				query("Pharma: trials with significant biomarkers",
						pharmaPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?trial) AS ?count) WHERE {",
								"  VALUES ?marker { <http://example.com/theme/pharma/biomarker/0>",
								"                   <http://example.com/theme/pharma/biomarker/1>",
								"                   <http://example.com/theme/pharma/biomarker/2> }",
								"  ?trial a pharma:ClinicalTrial ; pharma:hasArm ?arm .",
								"  ?arm pharma:hasResult ?result .",
								"  ?result pharma:biomarker ?marker ; pharma:pValue ?p .",
								"  OPTIONAL { ?result pharma:effectSize ?effect . BIND(?effect AS ?optEffect) }",
								"  FILTER(?optEffect > 0.3)",
								"  FILTER(?p < 0.05 || ?p = 0.05)",
								"}"),
						1L),
				query("Pharma: combinations with shared targets",
						pharmaPrefix + String.join("\n",
								"SELECT ?combo (COUNT(DISTINCT ?target) AS ?sharedTargets) WHERE {",
								"  ?combo a pharma:Combination ; pharma:combinationOf ?drugA ; pharma:combinationOf ?drugB .",
								"  FILTER(?drugA != ?drugB)",
								"  ?drugA pharma:targets ?target .",
								"  ?drugB pharma:targets ?target .",
								"  OPTIONAL { ?drugA pharma:hasSideEffect ?sideEffect . BIND(?sideEffect AS ?optSideEffect) }",
								"  FILTER(?optSideEffect != <http://example.com/theme/pharma/side-effect/0>)",
								"  FILTER EXISTS { ?drugB pharma:hasSideEffect ?sideEffect2 . }",
								"}",
								"GROUP BY ?combo",
								"HAVING(COUNT(DISTINCT ?target) > 1)"),
						1L),
				query("Pharma: clinical trial arms with comparators",
						pharmaPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?arm) AS ?count) WHERE {",
								"  ?trial a pharma:ClinicalTrial ; pharma:hasArm ?arm .",
								"  { ?arm pharma:armComparator ?comp . }",
								"  UNION",
								"  { ?arm pharma:armDrug ?comp . }",
								"  OPTIONAL { ?comp pharma:name ?optName . BIND(?optName AS ?optCompName) }",
								"  FILTER(?optCompName != \"\")",
								"  FILTER NOT EXISTS { ?arm pharma:hasResult ?r . ?r pharma:pValue ?p .",
								"                      FILTER(?p IN (0.08, 0.09)) }",
								"}"),
						1L),
				query("Pharma: drug target counts excluding contraindications",
						pharmaPrefix + String.join("\n",
								"SELECT ?drug (COUNT(DISTINCT ?target) AS ?targetCount) WHERE {",
								"  ?drug a pharma:Drug ; pharma:targets ?target .",
								"  OPTIONAL { ?drug pharma:hasMolecule ?mol . BIND(?mol AS ?optMol) }",
								"  FILTER(?optMol != <http://example.com/theme/pharma/molecule/0>)",
								"  MINUS { ?drug pharma:contraindicatedFor ?disease .",
								"          FILTER(?disease = <http://example.com/theme/pharma/disease/6>",
								"                 || ?disease = <http://example.com/theme/pharma/disease/7>) }",
								"}",
								"GROUP BY ?drug",
								"HAVING(COUNT(DISTINCT ?target) >= 3)"),
						1635L),
				query("Pharma: drugs with strong average effects",
						pharmaPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?drug) AS ?count) WHERE {",
								"  {",
								"    SELECT ?drug (AVG(?effect) AS ?avgEffect) WHERE {",
								"      ?trial a pharma:ClinicalTrial ; pharma:hasArm ?arm .",
								"      ?arm pharma:armDrug ?drug ; pharma:hasResult ?result .",
								"      ?result pharma:effectSize ?effect .",
								"      OPTIONAL { ?result pharma:responseRate ?rate . BIND(?rate AS ?optRate) }",
								"      FILTER(?optRate > 0.2)",
								"    }",
								"    GROUP BY ?drug",
								"    HAVING(AVG(?effect) > 0.4)",
								"  }",
								"  FILTER EXISTS { ?drug pharma:hasSideEffect ?se . }",
								"  OPTIONAL { ?drug pharma:indicatedFor ?disease . BIND(?disease AS ?optDisease) }",
								"  FILTER(?optDisease IN (<http://example.com/theme/pharma/disease/8>,",
								"                         <http://example.com/theme/pharma/disease/9>))",
								"}"),
						1L),
				query("Pharma: pathways with biomarker trials",
						pharmaPrefix + String.join("\n",
								"SELECT ?pathway (COUNT(DISTINCT ?drug) AS ?drugCount) WHERE {",
								"  VALUES ?marker { <http://example.com/theme/pharma/biomarker/3>",
								"                   <http://example.com/theme/pharma/biomarker/4> }",
								"  ?drug a pharma:Drug ; pharma:targets ?target .",
								"  ?target pharma:inPathway ?pathway .",
								"  OPTIONAL { ?drug pharma:testedIn ?trial . BIND(?trial AS ?optTrial) }",
								"  FILTER(?optTrial != <http://example.com/theme/pharma/trial/0>)",
								"  FILTER EXISTS { ?trial pharma:hasArm ?arm . ?arm pharma:hasResult ?result .",
								"                  ?result pharma:biomarker ?marker . }",
								"}",
								"GROUP BY ?pathway",
								"HAVING(COUNT(DISTINCT ?drug) > 1)"),
						51L),
				query("Pharma: disease '1*' drugs with strong trial results excluding Severe SE (optimizer torture)",
						pharmaPrefix + String.join("\n",
								"SELECT ?drug ?trial ?result ?optEffect ?optP ?optBv WHERE {",
								"  ?drug ?dp ?do .",
								"  ?drug a pharma:Drug .",
								"  OPTIONAL { ?drug pharma:indicatedFor ?disease . BIND(STR(?disease) AS ?dStr) }",
								"  FILTER(CONTAINS(?dStr, \"disease/1\"))",
								"  OPTIONAL { ?drug pharma:hasSideEffect ?se . ?se pharma:severity ?sev . BIND(?sev AS ?optSev) }",
								"  FILTER(?optSev != \"\")",
								"  MINUS { ?drug pharma:hasSideEffect ?seBad . ?seBad pharma:severity \"Severe\" . }",
								"  ?trial a pharma:ClinicalTrial ; pharma:hasArm ?arm .",
								"  ?arm pharma:armDrug ?drug ; pharma:hasResult ?result .",
								"  OPTIONAL { ?result pharma:effectSize ?effect . BIND(?effect AS ?optEffect) }",
								"  OPTIONAL { ?result pharma:pValue ?p . BIND(?p AS ?optP) }",
								"  FILTER(?optEffect > 0.7 && ?optP < 0.05)",
								"  OPTIONAL { ?result pharma:biomarkerValue ?bv . BIND(?bv AS ?optBv) }",
								"  FILTER(?optBv > 1.0)",
								"}"),
						1535L), // Optimization: turn OPTIONAL+FILTER blocks into inner joins with pushdown (especially
								// effect/pValue/biomarker thresholds), and run the “no Severe side effects” MINUS as an
								// indexed anti-join early.
				query("Pharma: phase-3 trials with extreme biomarker or p-value (common-subexpression UNION)",
						pharmaPrefix + String.join("\n",
								"SELECT ?trial ?result ?bv WHERE {",
								"  {",
								"    ?trial a pharma:ClinicalTrial ; pharma:phase ?phase .",
								"    FILTER(?phase = 3)",
								"    ?trial pharma:hasArm ?arm .",
								"    ?arm pharma:hasResult ?result .",
								"    ?result pharma:biomarkerValue ?bv .",
								"    FILTER(?bv > 2.0)",
								"  }",
								"  UNION",
								"  {",
								"    ?trial a pharma:ClinicalTrial ; pharma:phase ?phase .",
								"    FILTER(?phase = 3)",
								"    ?trial pharma:hasArm ?arm .",
								"    ?arm pharma:hasResult ?result .",
								"    ?result pharma:pValue ?p .",
								"    FILTER(?p < 0.001)",
								"    OPTIONAL { ?result pharma:biomarkerValue ?bv . }",
								"  }",
								"}"),
						65L), // Optimization: factor out the duplicated `trial→arm→result` prefix (evaluate once) and
								// convert UNION to a single scan with an OR filter when beneficial.
				query("Pharma: high-synergy combinations whose member drugs share a target (O(n^2) member join)",
						pharmaPrefix + String.join("\n",
								"SELECT ?combo ?a ?b ?t WHERE {",
								"  ?combo a pharma:Combination ; pharma:synergyScore ?score .",
								"  FILTER(?score > 0.9)",
								"  OPTIONAL { ?combo pharma:combinationOf ?drugA . BIND(?drugA AS ?a) }",
								"  OPTIONAL { ?combo pharma:combinationOf ?drugB . BIND(?drugB AS ?b) }",
								"  FILTER(?a != ?b)",
								"  FILTER EXISTS { ?a pharma:targets ?t . ?b pharma:targets ?t . }",
								"}"),
						0L) // Optimization: avoid the quadratic self-join over combination members by using a
							// grouped/member-scan strategy (or specialized intersection join), and evaluate the
							// shared-target EXISTS as a semi-join with early pruning.
		));

		validateQueries();
	}

	private ThemeQueryCatalog() {
	}

	public static List<String> queriesFor(Theme theme) {
		List<BenchmarkQuery> queries = queriesForTheme(theme);
		return queries.stream()
				.map(BenchmarkQuery::getQuery)
				.collect(Collectors.toUnmodifiableList());
	}

	public static List<BenchmarkQuery> benchmarkQueriesFor(Theme theme) {
		return queriesForTheme(theme);
	}

	public static BenchmarkQuery benchmarkQueryFor(Theme theme, int index) {
		List<BenchmarkQuery> queries = queriesForTheme(theme);
		if (index < 0 || index >= queries.size()) {
			throw new IllegalArgumentException("Query index out of range: " + index);
		}
		return queries.get(index);
	}

	public static String queryFor(Theme theme, int index) {
		return benchmarkQueryFor(theme, index).getQuery();
	}

	public static long expectedCountFor(Theme theme, int index) {
		return benchmarkQueryFor(theme, index).getExpectedCount();
	}

	private static void validateQueries() {
		for (Theme theme : Theme.values()) {
			List<BenchmarkQuery> queries = QUERIES.get(theme);
			if (queries == null) {
				throw new IllegalStateException("Missing query list for theme " + theme);
			}
			if (queries.size() != QUERY_COUNT) {
				throw new IllegalStateException("Theme " + theme + " has " + queries.size() + " queries");
			}
		}
	}

	private static List<BenchmarkQuery> queriesForTheme(Theme theme) {
		Objects.requireNonNull(theme, "theme");
		List<BenchmarkQuery> queries = QUERIES.get(theme);
		if (queries == null) {
			throw new IllegalArgumentException("No queries registered for theme " + theme);
		}
		return queries;
	}

	private static BenchmarkQuery query(String name, String query, long expectedCount) {
		return new BenchmarkQuery(name, query, expectedCount);
	}

}
