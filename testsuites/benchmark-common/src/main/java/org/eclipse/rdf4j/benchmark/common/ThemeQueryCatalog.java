/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.benchmark.common;

import java.util.EnumMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;

import org.eclipse.rdf4j.benchmark.rio.util.ThemeDataSetGenerator.Theme;

public final class ThemeQueryCatalog {

	public static final int QUERY_COUNT = 11;

	private static final Map<Theme, List<BenchmarkQuery>> QUERIES = new EnumMap<>(Theme.class);

	static {
		String medicalPrefix = String.join("\n",
				"PREFIX med: <http://example.com/theme/medical/>",
				"PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>",
				"");
		QUERIES.put(Theme.MEDICAL_RECORDS, List.of(
				query("Medical: recent encounters after June",
						medicalPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?patient) AS ?count) WHERE {",
								"  ?patient a med:Patient .",
								"  OPTIONAL {",
								"    ?patient med:hasEncounter ?enc .",
								"    ?enc med:recordedOn ?date .",
								"    BIND(?date AS ?optDate)",
								"  }",
								"  FILTER(?optDate >= \"2024-06-01\"^^xsd:date)",
								"  OPTIONAL { ?patient med:hasMedication ?med . }",
								"}"),
						1L),
				query("Medical: conditions or medications by code",
						medicalPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?entity) AS ?count) WHERE {",
								"  VALUES ?target { \"DX-200\" \"DX-201\" }",
								"  { ?entity a med:Condition ; med:code ?code . }",
								"  UNION",
								"  { ?entity a med:Medication ; med:code ?code . }",
								"  FILTER(?code = ?target || ?code = \"DX-202\")",
								"  OPTIONAL { ?entity med:code ?alt . }",
								"}"),
						1L),
				query("Medical: practitioner encounters Jan-Feb",
						medicalPrefix + String.join("\n",
								"SELECT ?practitioner (COUNT(DISTINCT ?enc) AS ?encCount) WHERE {",
								"  ?enc a med:Encounter ; med:handledBy ?practitioner ; med:recordedOn ?date .",
								"  FILTER(?date IN (\"2024-01-01\"^^xsd:date, \"2024-02-01\"^^xsd:date))",
								"  OPTIONAL { ?enc med:hasCondition ?cond . }",
								"}",
								"GROUP BY ?practitioner",
								"HAVING(COUNT(?enc) > 0)"),
						180L),
				query("Medical: high observation values excluding test",
						medicalPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?patient) AS ?count) WHERE {",
								"  ?patient a med:Patient .",
								"  OPTIONAL {",
								"    ?patient med:hasEncounter/med:hasObservation ?obs .",
								"    ?obs med:value ?value .",
								"    BIND(?value AS ?optValue)",
								"  }",
								"  FILTER(?optValue > 60)",
								"  MINUS { ?patient med:name ?name . FILTER(CONTAINS(LCASE(STR(?name)), \"test\")) }",
								"}"),
						1L),
				query("Medical: encounters with condition and observation",
						medicalPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?enc) AS ?count) WHERE {",
								"  ?enc a med:Encounter ; med:hasCondition ?cond .",
								"  ?cond med:code ?code .",
								"  FILTER(?code = \"DX-200\" || ?code = \"DX-201\")",
								"  FILTER EXISTS { ?enc med:hasObservation ?obs . }",
								"  OPTIONAL { ?enc med:handledBy ?practitioner . }",
								"}"),
						1L),
				query("Medical: observation values without conditions",
						medicalPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?patient) AS ?count) WHERE {",
								"  VALUES ?limit { 55 }",
								"  ?patient a med:Patient ; med:hasEncounter ?enc .",
								"  ?enc med:hasObservation ?obs .",
								"  ?obs med:value ?value .",
								"  FILTER(?value IN (50, 60, 70))",
								"  FILTER NOT EXISTS { ?enc med:hasCondition ?cond . }",
								"}"),
						1L),
				query("Medical: patient medication counts",
						medicalPrefix + String.join("\n",
								"SELECT ?patient (COUNT(DISTINCT ?med) AS ?medCount) WHERE {",
								"  { ?patient a med:Patient . }",
								"  UNION",
								"  { ?patient med:hasEncounter ?enc . }",
								"  OPTIONAL {",
								"    ?patient med:hasMedication ?med .",
								"    BIND(?med AS ?optMed)",
								"  }",
								"  FILTER(?optMed != ?patient)",
								"}",
								"GROUP BY ?patient",
								"HAVING(COUNT(?med) > 0)"),
						10000L),
				query("Medical: medications by code without x dosage",
						medicalPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?med) AS ?count) WHERE {",
								"  ?med a med:Medication ; med:code ?code .",
								"  FILTER(?code = \"MED-1000\" || ?code = \"MED-1001\")",
								"  FILTER EXISTS { ?patient med:hasMedication ?med . }",
								"  MINUS { ?med med:dosage ?dose . FILTER(CONTAINS(LCASE(STR(?dose)), \"x\")) }",
								"}"),
						1L),
				query("Medical: patients with multiple conditioned encounters",
						medicalPrefix + String.join("\n",
								"SELECT ?patient (COUNT(DISTINCT ?enc) AS ?encCount) WHERE {",
								"  ?patient a med:Patient .",
								"  OPTIONAL {",
								"    ?patient med:hasEncounter ?enc .",
								"    ?enc med:handledBy ?practitioner .",
								"    BIND(?practitioner AS ?optPractitioner)",
								"  }",
								"  FILTER(?optPractitioner != ?patient)",
								"  FILTER EXISTS { ?enc med:hasCondition ?cond . }",
								"}",
								"GROUP BY ?patient",
								"HAVING(COUNT(?enc) >= 2)"),
						10000L),
				query("Medical: encounters excluding low observations",
						medicalPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?enc) AS ?count) WHERE {",
								"  VALUES ?code { \"DX-200\" \"DX-201\" }",
								"  ?enc a med:Encounter ; med:hasCondition ?cond .",
								"  ?cond med:code ?condCode .",
								"  FILTER(?condCode IN (\"DX-200\", \"DX-201\", \"DX-202\"))",
								"  OPTIONAL { ?enc med:handledBy ?practitioner . }",
								"  MINUS { ?enc med:hasObservation ?obs . ?obs med:value ?value . FILTER(?value < 60) }",
								"}"),
						1L),
				query("Medical: patients with meds or observations excluding MED-1005",
						medicalPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?patient) AS ?count) WHERE {",
								"  { ?patient a med:Patient ; med:hasMedication ?med . }",
								"  UNION",
								"  { ?patient a med:Patient ; med:hasEncounter ?enc . ?enc med:hasObservation ?obs . }",
								"  OPTIONAL { ?patient med:name ?optName . }",
								"  FILTER(?optName != \"\")",
								"  FILTER NOT EXISTS { ?patient med:hasMedication ?m2 . ?m2 med:code ?c .",
								"                      FILTER(?c = \"MED-1005\") }",
								"}"),
						1L)));

		String socialPrefix = String.join("\n",
				"PREFIX social: <http://example.com/theme/social/>",
				"PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>",
				"");
		QUERIES.put(Theme.SOCIAL_MEDIA, List.of(
				query("Social: follow pairs among users 0-2",
						socialPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?pair) AS ?count) WHERE {",
								"  VALUES ?u { <http://example.com/theme/social/user/0>",
								"              <http://example.com/theme/social/user/1>",
								"              <http://example.com/theme/social/user/2> }",
								"  VALUES ?v { <http://example.com/theme/social/user/0>",
								"              <http://example.com/theme/social/user/1>",
								"              <http://example.com/theme/social/user/2> }",
								"  FILTER(?u != ?v)",
								"  ?u social:follows ?v .",
								"  OPTIONAL { ?u social:name ?optName . }",
								"  FILTER(?optName IN (\"user0\", \"user1\", \"user2\"))",
								"  BIND(CONCAT(STR(?u), STR(?v)) AS ?pair)",
								"}"),
						1L),
				query("Social: mutual trio of users 0-2",
						socialPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?u1) AS ?count) WHERE {",
								"  VALUES ?u1 { <http://example.com/theme/social/user/0>",
								"               <http://example.com/theme/social/user/1>",
								"               <http://example.com/theme/social/user/2> }",
								"  VALUES ?u2 { <http://example.com/theme/social/user/0>",
								"               <http://example.com/theme/social/user/1>",
								"               <http://example.com/theme/social/user/2> }",
								"  VALUES ?u3 { <http://example.com/theme/social/user/0>",
								"               <http://example.com/theme/social/user/1>",
								"               <http://example.com/theme/social/user/2> }",
								"  FILTER(?u1 != ?u2 && ?u1 != ?u3 && ?u2 != ?u3)",
								"  ?u1 social:follows ?u2 .",
								"  ?u2 social:follows ?u1 .",
								"  ?u1 social:follows ?u3 .",
								"  ?u3 social:follows ?u1 .",
								"  ?u2 social:follows ?u3 .",
								"  ?u3 social:follows ?u2 .",
								"  FILTER EXISTS { ?u1 social:name ?name .",
								"                  FILTER(?name = \"user0\" || ?name = \"user1\") }",
								"  MINUS { ?u1 social:follows ?u1 . }",
								"}"),
						1L),
				query("Social: mutual follows among users 3-6",
						socialPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?u) AS ?count) WHERE {",
								"  VALUES ?u { <http://example.com/theme/social/user/3>",
								"              <http://example.com/theme/social/user/4>",
								"              <http://example.com/theme/social/user/5>",
								"              <http://example.com/theme/social/user/6> }",
								"  VALUES ?v { <http://example.com/theme/social/user/3>",
								"              <http://example.com/theme/social/user/4>",
								"              <http://example.com/theme/social/user/5>",
								"              <http://example.com/theme/social/user/6> }",
								"  FILTER(?u != ?v)",
								"  ?u social:follows ?v .",
								"  OPTIONAL { ?v social:name ?optName . }",
								"  FILTER(?optName != \"\")",
								"  FILTER EXISTS { ?v social:follows ?u . }",
								"}"),
						1L),
				query("Social: degree >=3 among users 3-6",
						socialPrefix + String.join("\n",
								"SELECT ?u (COUNT(DISTINCT ?v) AS ?degree) WHERE {",
								"  VALUES ?u { <http://example.com/theme/social/user/3>",
								"              <http://example.com/theme/social/user/4>",
								"              <http://example.com/theme/social/user/5>",
								"              <http://example.com/theme/social/user/6> }",
								"  VALUES ?v { <http://example.com/theme/social/user/3>",
								"              <http://example.com/theme/social/user/4>",
								"              <http://example.com/theme/social/user/5>",
								"              <http://example.com/theme/social/user/6> }",
								"  FILTER(?u != ?v)",
								"  ?u social:follows ?v .",
								"  OPTIONAL { ?u social:name ?optName . BIND(?optName AS ?optAlias) }",
								"  FILTER(?optAlias IN (\"user3\", \"user4\", \"user5\", \"user6\"))",
								"}",
								"GROUP BY ?u",
								"HAVING(COUNT(DISTINCT ?v) >= 3)"),
						4L),
				query("Social: follows among users 7-11",
						socialPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?u) AS ?count) WHERE {",
								"  VALUES ?u { <http://example.com/theme/social/user/7>",
								"              <http://example.com/theme/social/user/8>",
								"              <http://example.com/theme/social/user/9>",
								"              <http://example.com/theme/social/user/10>",
								"              <http://example.com/theme/social/user/11> }",
								"  VALUES ?v { <http://example.com/theme/social/user/7>",
								"              <http://example.com/theme/social/user/8>",
								"              <http://example.com/theme/social/user/9>",
								"              <http://example.com/theme/social/user/10>",
								"              <http://example.com/theme/social/user/11> }",
								"  FILTER(?u != ?v)",
								"  ?u social:follows ?v .",
								"  FILTER NOT EXISTS { ?u social:follows ?u . }",
								"  OPTIONAL { ?v social:name ?optName . }",
								"  FILTER(?optName != \"\")",
								"}"),
						1L),
				query("Social: activity from mutual follows or posts",
						socialPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?activity) AS ?count) WHERE {",
								"  VALUES ?u { <http://example.com/theme/social/user/7>",
								"              <http://example.com/theme/social/user/8>",
								"              <http://example.com/theme/social/user/9>",
								"              <http://example.com/theme/social/user/10>",
								"              <http://example.com/theme/social/user/11> }",
								"  {",
								"    ?u social:follows ?v .",
								"    ?v social:follows ?u .",
								"    BIND(?v AS ?activity)",
								"  }",
								"  UNION",
								"  {",
								"    ?post social:authored ?u .",
								"    BIND(?post AS ?activity)",
								"  }",
								"  OPTIONAL { ?u social:name ?optName . }",
								"  FILTER(?optName IN (\"user7\", \"user8\", \"user9\", \"user10\", \"user11\"))",
								"}"),
						1L),
				query("Social: connections >=5 among users 12-17",
						socialPrefix + String.join("\n",
								"SELECT ?u (COUNT(DISTINCT ?v) AS ?connections) WHERE {",
								"  VALUES ?u { <http://example.com/theme/social/user/12>",
								"              <http://example.com/theme/social/user/13>",
								"              <http://example.com/theme/social/user/14>",
								"              <http://example.com/theme/social/user/15>",
								"              <http://example.com/theme/social/user/16>",
								"              <http://example.com/theme/social/user/17> }",
								"  VALUES ?v { <http://example.com/theme/social/user/12>",
								"              <http://example.com/theme/social/user/13>",
								"              <http://example.com/theme/social/user/14>",
								"              <http://example.com/theme/social/user/15>",
								"              <http://example.com/theme/social/user/16>",
								"              <http://example.com/theme/social/user/17> }",
								"  FILTER(?u != ?v)",
								"  ?u social:follows ?v .",
								"  OPTIONAL { ?u social:name ?optName . }",
								"  FILTER(?optName != \"\")",
								"}",
								"GROUP BY ?u",
								"HAVING(COUNT(DISTINCT ?v) >= 5)"),
						6L),
				query("Social: mutual follows among users 12-17",
						socialPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?u) AS ?count) WHERE {",
								"  VALUES ?u { <http://example.com/theme/social/user/12>",
								"              <http://example.com/theme/social/user/13>",
								"              <http://example.com/theme/social/user/14>",
								"              <http://example.com/theme/social/user/15>",
								"              <http://example.com/theme/social/user/16>",
								"              <http://example.com/theme/social/user/17> }",
								"  VALUES ?v { <http://example.com/theme/social/user/12>",
								"              <http://example.com/theme/social/user/13>",
								"              <http://example.com/theme/social/user/14>",
								"              <http://example.com/theme/social/user/15>",
								"              <http://example.com/theme/social/user/16>",
								"              <http://example.com/theme/social/user/17> }",
								"  FILTER(?u != ?v)",
								"  ?u social:follows ?v .",
								"  FILTER EXISTS { ?v social:follows ?u . }",
								"  MINUS { ?v social:follows ?v . }",
								"  OPTIONAL { ?v social:name ?optName . }",
								"  FILTER(?optName IN (\"user12\", \"user13\", \"user14\", \"user15\", \"user16\", \"user17\"))",
								"}"),
						1L),
				query("Social: 3-cycle among users 0-2",
						socialPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?a) AS ?count) WHERE {",
								"  ?a social:follows ?b .",
								"  ?b social:follows ?c .",
								"  ?c social:follows ?a .",
								"  OPTIONAL { ?a social:name ?optName . }",
								"  FILTER(?optName IN (\"user0\", \"user1\", \"user2\"))",
								"}"),
						1L),
				query("Social: 4-cycle among users 3-6",
						socialPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?a) AS ?count) WHERE {",
								"  VALUES ?b { <http://example.com/theme/social/user/3>",
								"              <http://example.com/theme/social/user/4>",
								"              <http://example.com/theme/social/user/5>",
								"              <http://example.com/theme/social/user/6> }",
								"  FILTER(?a != ?b && ?b != ?c && ?c != ?d && ?d != ?a)",
								"  ?a social:follows ?b .",
								"  ?b social:follows ?c .",
								"  ?c social:follows ?d .",
								"  ?d social:follows ?a .",
								"  OPTIONAL { ?b social:name ?optName . BIND(?optName AS ?optAlias) }",
								"  FILTER(?optAlias != \"\")",
								"}"),
						1L),
				query("Social: 5-cycle among users 7-11",
						socialPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?a) AS ?count) WHERE {",
								"  VALUES ?a { <http://example.com/theme/social/user/7>",
								"              <http://example.com/theme/social/user/8>",
								"              <http://example.com/theme/social/user/9>",
								"              <http://example.com/theme/social/user/10>",
								"              <http://example.com/theme/social/user/11> }",
								"  VALUES ?b { <http://example.com/theme/social/user/7>",
								"              <http://example.com/theme/social/user/8>",
								"              <http://example.com/theme/social/user/9>",
								"              <http://example.com/theme/social/user/10>",
								"              <http://example.com/theme/social/user/11> }",
								"  VALUES ?c { <http://example.com/theme/social/user/7>",
								"              <http://example.com/theme/social/user/8>",
								"              <http://example.com/theme/social/user/9>",
								"              <http://example.com/theme/social/user/10>",
								"              <http://example.com/theme/social/user/11> }",
								"  VALUES ?d { <http://example.com/theme/social/user/7>",
								"              <http://example.com/theme/social/user/8>",
								"              <http://example.com/theme/social/user/9>",
								"              <http://example.com/theme/social/user/10>",
								"              <http://example.com/theme/social/user/11> }",
								"  VALUES ?e { <http://example.com/theme/social/user/7>",
								"              <http://example.com/theme/social/user/8>",
								"              <http://example.com/theme/social/user/9>",
								"              <http://example.com/theme/social/user/10>",
								"              <http://example.com/theme/social/user/11> }",
								"  FILTER(?a != ?b && ?b != ?c && ?c != ?d && ?d != ?e && ?a != ?c)",
								"  ?a social:follows ?b .",
								"  ?b social:follows ?c .",
								"  ?c social:follows ?d .",
								"  ?d social:follows ?e .",
								"  ?e social:follows ?a .",
								"  FILTER EXISTS { ?a social:name ?name .",
								"                  FILTER(?name = \"user7\" || ?name = \"user8\") }",
								"  OPTIONAL { ?e social:name ?optName . }",
								"  FILTER(?optName IN (\"user7\", \"user8\", \"user9\", \"user10\", \"user11\"))",
								"}"),
						1L)));

		String libraryPrefix = String.join("\n",
				"PREFIX lib: <http://example.com/theme/library/>",
				"PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>",
				"");
		QUERIES.put(Theme.LIBRARY, List.of(
				query("Library: books with copies and branches",
						libraryPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?book) AS ?count) WHERE {",
								"  ?book a lib:Book .",
								"  OPTIONAL {",
								"    ?book lib:hasCopy ?copy .",
								"    ?copy lib:locatedAt ?branch .",
								"    BIND(?branch AS ?optBranch)",
								"  }",
								"  FILTER(?optBranch != ?book)",
								"  OPTIONAL { ?book lib:writtenBy ?author . }",
								"}"),
						1L),
				query("Library: members or books by name",
						libraryPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?entity) AS ?count) WHERE {",
								"  VALUES ?target { \"Member 1\" \"Member 2\" }",
								"  { ?entity a lib:Member ; lib:name ?name . }",
								"  UNION",
								"  { ?entity a lib:Book ; lib:title ?name . }",
								"  FILTER(?name = ?target || ?name = \"Member 3\")",
								"  OPTIONAL { ?entity lib:hasCopy ?copy . }",
								"}"),
						1L),
				query("Library: author book counts",
						libraryPrefix + String.join("\n",
								"SELECT ?author (COUNT(DISTINCT ?book) AS ?bookCount) WHERE {",
								"  ?author a lib:Author ; lib:name ?authorName .",
								"  FILTER(?authorName IN (\"Author 1\", \"Author 2\", \"Author 3\"))",
								"  OPTIONAL { ?book lib:writtenBy ?author . }",
								"}",
								"GROUP BY ?author",
								"HAVING(COUNT(?book) > 0)"),
						3L),
				query("Library: loans due after Jan 10",
						libraryPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?loan) AS ?count) WHERE {",
								"  ?loan a lib:Loan ; lib:borrowedBy ?member .",
								"  OPTIONAL {",
								"    ?loan lib:dueDate ?due .",
								"    BIND(?due AS ?optDue)",
								"  }",
								"  FILTER(?optDue > \"2024-01-10\"^^xsd:date)",
								"  MINUS { ?member lib:name ?name . FILTER(CONTAINS(LCASE(STR(?name)), \"member 1\")) }",
								"}"),
						1L),
				query("Library: books by title with copies",
						libraryPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?book) AS ?count) WHERE {",
								"  ?book a lib:Book ; lib:title ?title .",
								"  FILTER(?title = \"Book 1\" || ?title = \"Book 2\")",
								"  FILTER EXISTS { ?book lib:hasCopy ?copy . }",
								"  OPTIONAL { ?book lib:writtenBy ?author . }",
								"}"),
						1L),
				query("Library: loans on specific dates without early due",
						libraryPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?loan) AS ?count) WHERE {",
								"  VALUES ?threshold { \"2024-01-01\"^^xsd:date }",
								"  ?loan a lib:Loan ; lib:loanDate ?loanDate .",
								"  FILTER(?loanDate IN (\"2024-01-01\"^^xsd:date, \"2024-01-02\"^^xsd:date))",
								"  FILTER NOT EXISTS { ?loan lib:dueDate ?due . FILTER(?due < ?threshold) }",
								"}"),
						1L),
				query("Library: member loan counts",
						libraryPrefix + String.join("\n",
								"SELECT ?member (COUNT(DISTINCT ?loan) AS ?loanCount) WHERE {",
								"  { ?loan a lib:Loan ; lib:borrowedBy ?member . }",
								"  UNION",
								"  { ?member a lib:Member . }",
								"  OPTIONAL {",
								"    ?loan lib:loanedCopy ?copy .",
								"    BIND(?copy AS ?optCopy)",
								"  }",
								"  FILTER(?optCopy != ?member)",
								"}",
								"GROUP BY ?member",
								"HAVING(COUNT(?loan) > 0)"),
						5000L),
				query("Library: copies at branches 0-1",
						libraryPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?copy) AS ?count) WHERE {",
								"  ?copy a lib:Copy ; lib:locatedAt ?branch .",
								"  ?branch lib:name ?branchName .",
								"  FILTER(?branchName = \"Branch 0\" || ?branchName = \"Branch 1\")",
								"  FILTER EXISTS { ?copy a lib:Copy . }",
								"  MINUS { ?copy lib:locatedAt ?branch . FILTER(CONTAINS(STR(?branch), \"branch/0\")) }",
								"}"),
						1L),
				query("Library: author loan counts",
						libraryPrefix + String.join("\n",
								"SELECT ?author (COUNT(DISTINCT ?loan) AS ?loanCount) WHERE {",
								"  ?book a lib:Book ; lib:writtenBy ?author ; lib:hasCopy ?copy .",
								"  ?copy lib:locatedAt ?branch .",
								"  ?loan a lib:Loan ; lib:loanedCopy ?copy ; lib:borrowedBy ?member .",
								"  OPTIONAL { ?member lib:name ?optName . }",
								"  FILTER(?optName IN (\"Member 1\", \"Member 2\", \"Member 3\"))",
								"}",
								"GROUP BY ?author",
								"HAVING(COUNT(?loan) > 0)"),
						12L),
				query("Library: members borrowing books by authors",
						libraryPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?member) AS ?count) WHERE {",
								"  VALUES ?target { \"Author 1\" \"Author 2\" }",
								"  ?member a lib:Member .",
								"  ?loan a lib:Loan ; lib:borrowedBy ?member ; lib:loanedCopy ?copy .",
								"  ?book lib:hasCopy ?copy ; lib:writtenBy ?author .",
								"  ?author lib:name ?authorName .",
								"  FILTER(?authorName = ?target || ?authorName = \"Author 3\")",
								"  FILTER NOT EXISTS { ?loan lib:dueDate ?due .",
								"                      FILTER(?due < \"2024-01-10\"^^xsd:date) }",
								"  OPTIONAL { ?book lib:title ?optTitle . }",
								"  FILTER(?optTitle != \"\")",
								"}"),
						1L),
				query("Library: branch inventory excluding branch 0",
						libraryPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?branch) AS ?count) WHERE {",
								"  { ?branch a lib:Branch . }",
								"  UNION",
								"  { ?branch a lib:Branch ; lib:name ?name . }",
								"  OPTIONAL { ?copy lib:locatedAt ?branch . BIND(?copy AS ?optCopy) }",
								"  FILTER(?optCopy != ?branch)",
								"  MINUS { ?branch lib:name ?name2 .",
								"          FILTER(CONTAINS(LCASE(STR(?name2)), \"branch 0\")) }",
								"}"),
						1L)));

		String engineeringPrefix = String.join("\n",
				"PREFIX eng: <http://example.com/theme/engineering/>",
				"");
		QUERIES.put(Theme.ENGINEERING, List.of(
				query("Engineering: components with assemblies and deps",
						engineeringPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?component) AS ?count) WHERE {",
								"  ?component a eng:Component .",
								"  OPTIONAL { ?component eng:partOf ?assembly . BIND(?assembly AS ?optAssembly) }",
								"  FILTER(?optAssembly != ?component)",
								"  OPTIONAL { ?component eng:dependsOn ?dep . }",
								"}"),
						1L),
				query("Engineering: requirements or components by name",
						engineeringPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?entity) AS ?count) WHERE {",
								"  VALUES ?target { \"REQ-1000\" \"REQ-1001\" }",
								"  { ?entity a eng:Requirement ; eng:name ?name . }",
								"  UNION",
								"  { ?entity a eng:Component ; eng:name ?name . }",
								"  FILTER(?name = ?target || ?name = \"REQ-1002\")",
								"  OPTIONAL { ?entity eng:partOf ?assembly . }",
								"}"),
						1L),
				query("Engineering: assembly component counts",
						engineeringPrefix + String.join("\n",
								"SELECT ?assembly (COUNT(DISTINCT ?component) AS ?componentCount) WHERE {",
								"  ?assembly a eng:Assembly ; eng:name ?assemblyName .",
								"  FILTER(?assemblyName IN (\"Assembly 1\", \"Assembly 2\", \"Assembly 3\"))",
								"  OPTIONAL { ?component eng:partOf ?assembly . }",
								"}",
								"GROUP BY ?assembly",
								"HAVING(COUNT(?component) > 0)"),
						3L),
				query("Engineering: requirements verified without component 1",
						engineeringPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?requirement) AS ?count) WHERE {",
								"  ?requirement a eng:Requirement ; eng:satisfies ?component .",
								"  OPTIONAL { ?requirement eng:verifiedBy ?test . BIND(?test AS ?optTest) }",
								"  FILTER(?optTest != ?requirement)",
								"  MINUS { ?component eng:name ?name . FILTER(CONTAINS(STR(?name), \"Component 1\")) }",
								"}"),
						1L),
				query("Engineering: components with dependencies",
						engineeringPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?component) AS ?count) WHERE {",
								"  ?component a eng:Component ; eng:name ?name .",
								"  FILTER(?name = \"Component 1\" || ?name = \"Component 2\")",
								"  FILTER EXISTS { ?component eng:dependsOn ?dep . }",
								"  OPTIONAL { ?component eng:partOf ?assembly . }",
								"}"),
						1L),
				query("Engineering: measurements above threshold",
						engineeringPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?measurement) AS ?count) WHERE {",
								"  VALUES ?threshold { 0.85 }",
								"  ?measurement a eng:Measurement ; eng:measuredValue ?value .",
								"  FILTER(?value IN (0.9, 0.95))",
								"  FILTER NOT EXISTS { ?measurement eng:measuredValue ?value2 . FILTER(?value2 < ?threshold) }",
								"}"),
						1L),
				query("Engineering: component requirement counts",
						engineeringPrefix + String.join("\n",
								"SELECT ?component (COUNT(DISTINCT ?requirement) AS ?reqCount) WHERE {",
								"  { ?requirement a eng:Requirement ; eng:satisfies ?component . }",
								"  UNION",
								"  { ?component a eng:Component . }",
								"  OPTIONAL { ?component eng:dependsOn ?dep . BIND(?dep AS ?optDep) }",
								"  FILTER(?optDep != ?component)",
								"}",
								"GROUP BY ?component",
								"HAVING(COUNT(?requirement) > 0)"),
						397L),
				query("Engineering: requirements with satisfies and no verification chain",
						engineeringPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?requirement) AS ?count) WHERE {",
								"  ?requirement a eng:Requirement ; eng:name ?name .",
								"  FILTER(?name = \"REQ-1000\" || ?name = \"REQ-1001\")",
								"  FILTER EXISTS { ?requirement eng:satisfies ?component . }",
								"  MINUS { ?requirement eng:verifiedBy ?test . ?test eng:verifiedBy ?measurement . }",
								"}"),
						1L),
				query("Engineering: component requirements in assemblies",
						engineeringPrefix + String.join("\n",
								"SELECT ?component (COUNT(DISTINCT ?requirement) AS ?reqCount) WHERE {",
								"  ?component a eng:Component ; eng:partOf ?assembly .",
								"  OPTIONAL { ?component eng:dependsOn ?dep . BIND(?dep AS ?optDep) }",
								"  FILTER(?optDep != ?component)",
								"  ?requirement a eng:Requirement ; eng:satisfies ?component .",
								"}",
								"GROUP BY ?component",
								"HAVING(COUNT(?requirement) >= 1)"),
						397L),
				query("Engineering: requirements verified by measurements",
						engineeringPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?requirement) AS ?count) WHERE {",
								"  VALUES ?threshold { 0.85 }",
								"  ?requirement a eng:Requirement ; eng:verifiedBy ?test .",
								"  ?test eng:verifiedBy ?measurement .",
								"  ?measurement eng:measuredValue ?value .",
								"  FILTER(?value IN (0.85, 0.9, 0.95))",
								"  FILTER EXISTS { ?requirement eng:satisfies ?component . }",
								"  OPTIONAL { ?component eng:name ?optName . }",
								"  FILTER(?optName != \"\")",
								"}"),
						1L),
				query("Engineering: assemblies without satisfied requirements",
						engineeringPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?assembly) AS ?count) WHERE {",
								"  ?assembly a eng:Assembly ; eng:name ?name .",
								"  FILTER(?name = \"Assembly 1\" || ?name = \"Assembly 2\")",
								"  OPTIONAL { ?component eng:partOf ?assembly . BIND(?component AS ?optComponent) }",
								"  FILTER(?optComponent != ?assembly)",
								"  MINUS { ?requirement eng:satisfies ?component . }",
								"}"),
						1L)));

		String connectedPrefix = String.join("\n",
				"PREFIX conn: <http://example.com/theme/connected/>",
				"");
		QUERIES.put(Theme.HIGHLY_CONNECTED, List.of(
				query("Connected: nodes with neighbors and weights",
						connectedPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?node) AS ?count) WHERE {",
								"  ?node a conn:Node .",
								"  OPTIONAL { ?node conn:connectsTo ?neighbor . BIND(?neighbor AS ?optNeighbor) }",
								"  FILTER(?optNeighbor != ?node)",
								"  OPTIONAL { ?node conn:weight ?w . }",
								"}"),
						1L),
				query("Connected: nodes with target weights",
						connectedPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?entity) AS ?count) WHERE {",
								"  VALUES ?target { 1 2 }",
								"  { ?entity a conn:Node ; conn:connectsTo ?targetNode . }",
								"  UNION",
								"  { ?entity a conn:Node . }",
								"  OPTIONAL { ?entity conn:weight ?w . }",
								"  FILTER(?w = ?target || ?w = 3)",
								"}"),
						1L),
				query("Connected: neighbor counts for weighted nodes",
						connectedPrefix + String.join("\n",
								"SELECT ?node (COUNT(DISTINCT ?neighbor) AS ?neighborCount) WHERE {",
								"  ?node a conn:Node ; conn:connectsTo ?neighbor .",
								"  ?node conn:weight ?w .",
								"  FILTER(?w IN (1, 2, 3))",
								"  OPTIONAL { ?neighbor conn:connectsTo ?node . }",
								"}",
								"GROUP BY ?node",
								"HAVING(COUNT(?neighbor) > 0)"),
						28281L),
				query("Connected: nodes with weight >5 excluding self loops",
						connectedPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?node) AS ?count) WHERE {",
								"  ?node a conn:Node .",
								"  OPTIONAL { ?node conn:weight ?w . BIND(?w AS ?optWeight) }",
								"  FILTER(?optWeight > 5)",
								"  MINUS { ?node conn:connectsTo ?neighbor . FILTER(?neighbor = ?node) }",
								"}"),
						1L),
				query("Connected: nodes with weights 1 or 2 and edges",
						connectedPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?node) AS ?count) WHERE {",
								"  ?node a conn:Node ; conn:weight ?w .",
								"  FILTER(?w = 1 || ?w = 2)",
								"  FILTER EXISTS { ?node conn:connectsTo ?neighbor . }",
								"  OPTIONAL { ?neighbor conn:connectsTo ?node . }",
								"}"),
						1L),
				query("Connected: nodes with weights 4-6 above threshold",
						connectedPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?node) AS ?count) WHERE {",
								"  VALUES ?threshold { 4 }",
								"  ?node a conn:Node ; conn:weight ?w .",
								"  FILTER(?w IN (4, 5, 6))",
								"  FILTER NOT EXISTS { ?node conn:weight ?w2 . FILTER(?w2 < ?threshold) }",
								"}"),
						1L),
				query("Connected: neighbor counts via incoming/outgoing",
						connectedPrefix + String.join("\n",
								"SELECT ?node (COUNT(DISTINCT ?neighbor) AS ?neighborCount) WHERE {",
								"  { ?node a conn:Node ; conn:connectsTo ?neighbor . }",
								"  UNION",
								"  { ?neighbor conn:connectsTo ?node . }",
								"  OPTIONAL { ?node conn:weight ?w . BIND(?w AS ?optWeight) }",
								"  FILTER(?optWeight != 0)",
								"}",
								"GROUP BY ?node",
								"HAVING(COUNT(?neighbor) > 0)"),
						30000L),
				query("Connected: nodes with weights 8 or 9 no self loop",
						connectedPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?node) AS ?count) WHERE {",
								"  ?node a conn:Node ; conn:weight ?w .",
								"  FILTER(?w = 8 || ?w = 9)",
								"  FILTER EXISTS { ?node conn:connectsTo ?neighbor . }",
								"  MINUS { ?neighbor conn:connectsTo ?node . FILTER(?neighbor = ?node) }",
								"}"),
						1L),
				query("Connected: length-2 path cycles for weights 7-9",
						connectedPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?node) AS ?count) WHERE {",
								"  ?node a conn:Node ; conn:connectsTo ?mid .",
								"  ?mid conn:connectsTo ?end .",
								"  OPTIONAL { ?node conn:weight ?optWeight . }",
								"  FILTER(?optWeight IN (7, 8, 9))",
								"  FILTER EXISTS { ?end conn:connectsTo ?node . }",
								"}"),
						1L),
				query("Connected: degree >1 with weighted neighbors",
						connectedPrefix + String.join("\n",
								"SELECT ?node (COUNT(DISTINCT ?neighbor) AS ?degree) WHERE {",
								"  { ?node conn:connectsTo ?neighbor . }",
								"  UNION",
								"  { ?neighbor conn:connectsTo ?node . }",
								"  OPTIONAL { ?neighbor conn:weight ?w . BIND(?w AS ?optWeight) }",
								"  FILTER(?optWeight != 0)",
								"}",
								"GROUP BY ?node",
								"HAVING(COUNT(?neighbor) > 1)"),
						30000L),
				query("Connected: nodes with weights 1-4 and no low neighbors",
						connectedPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?node) AS ?count) WHERE {",
								"  VALUES ?threshold { 3 }",
								"  ?node a conn:Node ; conn:weight ?w .",
								"  FILTER(?w IN (1, 2, 3, 4))",
								"  FILTER NOT EXISTS { ?node conn:connectsTo ?n2 .",
								"                      ?n2 conn:weight ?w2 . FILTER(?w2 < ?threshold) }",
								"  MINUS { ?node conn:connectsTo ?node . }",
								"}"),
						1L)));

		String trainPrefix = String.join("\n",
				"PREFIX train: <http://example.com/theme/train/>",
				"PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>",
				"");
		QUERIES.put(Theme.TRAIN, List.of(
				query("Train: services after 08:00",
						trainPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?service) AS ?count) WHERE {",
								"  ?service a train:TrainService .",
								"  OPTIONAL {",
								"    ?service train:scheduledTime ?time .",
								"    BIND(?time AS ?optTime)",
								"  }",
								"  FILTER(?optTime > \"08:00:00\"^^xsd:time)",
								"  OPTIONAL { ?service train:name ?name . }",
								"}"),
						1L),
				query("Train: operational points or lines by name",
						trainPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?entity) AS ?count) WHERE {",
								"  VALUES ?target { \"OP 1\" \"OP 2\" }",
								"  { ?entity a train:OperationalPoint ; train:name ?name . }",
								"  UNION",
								"  { ?entity a train:Line ; train:name ?name . }",
								"  FILTER(?name = ?target || ?name = \"OP 3\")",
								"  OPTIONAL { ?entity train:connectsOperationalPoint ?op . }",
								"}"),
						1L),
				query("Train: line section counts",
						trainPrefix + String.join("\n",
								"SELECT ?line (COUNT(DISTINCT ?section) AS ?sectionCount) WHERE {",
								"  ?line a train:Line ; train:name ?lineName .",
								"  FILTER(?lineName IN (\"Line 0\", \"Line 1\", \"Line 2\"))",
								"  OPTIONAL { ?section train:partOfLine ?line . }",
								"}",
								"GROUP BY ?line",
								"HAVING(COUNT(?section) > 0)"),
						3L),
				query("Train: sections with track excluding Line 0",
						trainPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?section) AS ?count) WHERE {",
								"  ?section a train:SectionOfLine ; train:partOfLine ?line .",
								"  OPTIONAL { ?section train:hasTrackSection ?track . BIND(?track AS ?optTrack) }",
								"  FILTER(?optTrack != ?section)",
								"  MINUS { ?line train:name ?name . FILTER(CONTAINS(STR(?name), \"Line 0\")) }",
								"}"),
						1L),
				query("Train: lines with sections and ops",
						trainPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?line) AS ?count) WHERE {",
								"  ?line a train:Line ; train:name ?name .",
								"  FILTER(?name = \"Line 1\" || ?name = \"Line 2\")",
								"  FILTER EXISTS { ?section train:partOfLine ?line . }",
								"  OPTIONAL { ?section train:connectsOperationalPoint ?op . }",
								"}"),
						1L),
				query("Train: services without late departures",
						trainPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?service) AS ?count) WHERE {",
								"  VALUES ?threshold { \"10:00:00\"^^xsd:time }",
								"  ?service a train:TrainService ; train:scheduledTime ?time .",
								"  FILTER(?time IN (\"08:00:00\"^^xsd:time, \"09:00:00\"^^xsd:time))",
								"  FILTER NOT EXISTS { ?service train:scheduledTime ?late . FILTER(?late > ?threshold) }",
								"}"),
						1L),
				query("Train: line service counts",
						trainPrefix + String.join("\n",
								"SELECT ?line (COUNT(DISTINCT ?service) AS ?serviceCount) WHERE {",
								"  { ?service a train:TrainService ; train:runsOnSection ?section .",
								"    ?section train:partOfLine ?line . }",
								"  UNION",
								"  { ?line a train:Line . }",
								"  OPTIONAL { ?line train:name ?optName . }",
								"  FILTER(?optName != \"\")",
								"}",
								"GROUP BY ?line",
								"HAVING(COUNT(?service) > 0)"),
						5989L),
				query("Train: operational points with services excluding op 0",
						trainPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?op) AS ?count) WHERE {",
								"  ?op a train:OperationalPoint ; train:name ?name .",
								"  FILTER(?name = \"OP 1\" || ?name = \"OP 2\")",
								"  FILTER EXISTS { ?service train:passesThrough ?op . }",
								"  MINUS { ?op train:name ?name2 . FILTER(CONTAINS(LCASE(STR(?name2)), \"op 0\")) }",
								"}"),
						1L),
				query("Train: services on two sections of same line",
						trainPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?service) AS ?count) WHERE {",
								"  ?service a train:TrainService ; train:runsOnSection ?s1 ; train:runsOnSection ?s2 .",
								"  ?s1 train:partOfLine ?line .",
								"  ?s2 train:partOfLine ?line .",
								"  OPTIONAL { ?line train:name ?optName . }",
								"  FILTER(?optName IN (\"Line 0\", \"Line 1\"))",
								"  FILTER EXISTS { ?s1 train:connectsOperationalPoint ?op .",
								"                  ?s2 train:connectsOperationalPoint ?op . }",
								"}"),
						1L),
				query("Train: section track counts with ops",
						trainPrefix + String.join("\n",
								"SELECT ?section (COUNT(DISTINCT ?track) AS ?trackCount) WHERE {",
								"  ?section a train:SectionOfLine ; train:hasTrackSection ?track .",
								"  OPTIONAL { ?section train:connectsOperationalPoint ?op . BIND(?op AS ?optOp) }",
								"  FILTER(?optOp != ?section)",
								"  FILTER EXISTS { ?track a train:TrackSection . }",
								"}",
								"GROUP BY ?section",
								"HAVING(COUNT(?track) > 0)"),
						48000L),
				query("Train: operational points excluding op 1",
						trainPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?op) AS ?count) WHERE {",
								"  { ?op a train:OperationalPoint . }",
								"  UNION",
								"  { ?op a train:OperationalPoint ; train:name ?name . }",
								"  OPTIONAL { ?section train:connectsOperationalPoint ?op . BIND(?section AS ?optSection) }",
								"  FILTER(?optSection != ?op)",
								"  MINUS { ?op train:name ?name2 . FILTER(CONTAINS(LCASE(STR(?name2)), \"op 1\")) }",
								"}"),
						1L)));

		String gridPrefix = String.join("\n",
				"PREFIX grid: <http://example.com/theme/grid/>",
				"");
		QUERIES.put(Theme.ELECTRICAL_GRID, List.of(
				query("Grid: substations with high capacity generators",
						gridPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?substation) AS ?count) WHERE {",
								"  ?substation a grid:Substation .",
								"  OPTIONAL { ?generator grid:feeds ?substation ; grid:capacity ?cap . BIND(?cap AS ?optCap) }",
								"  FILTER(?optCap > 600)",
								"  OPTIONAL { ?substation grid:name ?name . }",
								"}"),
						1L),
				query("Grid: substations or generators by name",
						gridPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?entity) AS ?count) WHERE {",
								"  VALUES ?target { \"Substation 1\" \"Substation 2\" }",
								"  { ?entity a grid:Substation ; grid:name ?name . }",
								"  UNION",
								"  { ?entity a grid:Generator ; grid:feeds ?substation . ?substation grid:name ?name . }",
								"  FILTER(?name = ?target || ?name = \"Substation 3\")",
								"  OPTIONAL { ?entity grid:feeds ?substation2 . }",
								"}"),
						1L),
				query("Grid: transformer meter counts",
						gridPrefix + String.join("\n",
								"SELECT ?transformer (COUNT(DISTINCT ?meter) AS ?meterCount) WHERE {",
								"  ?transformer a grid:Transformer ; grid:feeds ?substation .",
								"  ?substation grid:name ?name .",
								"  FILTER(?name IN (\"Substation 0\", \"Substation 1\", \"Substation 2\"))",
								"  OPTIONAL { ?transformer grid:hasMeter ?meter . }",
								"}",
								"GROUP BY ?transformer",
								"HAVING(COUNT(?meter) > 0)"),
						9L),
				query("Grid: meters with load value window",
						gridPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?meter) AS ?count) WHERE {",
								"  ?meter a grid:Meter ; grid:measures ?load .",
								"  OPTIONAL { ?load grid:loadValue ?value . BIND(?value AS ?optValue) }",
								"  FILTER(?optValue > 100)",
								"  MINUS { ?meter grid:measures ?load2 . ?load2 grid:loadValue ?value2 . FILTER(?value2 > 180) }",
								"}"),
						1L),
				query("Grid: lines connecting substations 0-1",
						gridPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?line) AS ?count) WHERE {",
								"  ?line a grid:Line ; grid:connectsTo ?substation .",
								"  ?substation grid:name ?name .",
								"  FILTER(?name = \"Substation 0\" || ?name = \"Substation 1\")",
								"  FILTER EXISTS { ?line grid:connectsTo ?other . }",
								"  OPTIONAL { ?line grid:connectsTo ?other2 . }",
								"}"),
						1L),
				query("Grid: generators above capacity threshold",
						gridPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?generator) AS ?count) WHERE {",
								"  VALUES ?threshold { 700 }",
								"  ?generator a grid:Generator ; grid:capacity ?capacity .",
								"  FILTER(?capacity IN (700, 800, 900))",
								"  FILTER NOT EXISTS { ?generator grid:capacity ?cap2 . FILTER(?cap2 < ?threshold) }",
								"}"),
						1L),
				query("Grid: substation asset counts",
						gridPrefix + String.join("\n",
								"SELECT ?substation (COUNT(DISTINCT ?asset) AS ?assetCount) WHERE {",
								"  { ?asset a grid:Transformer ; grid:feeds ?substation . }",
								"  UNION",
								"  { ?asset a grid:Generator ; grid:feeds ?substation . }",
								"  OPTIONAL { ?asset grid:feeds ?substation . BIND(?substation AS ?optSub) }",
								"  FILTER(?optSub != ?asset)",
								"}",
								"GROUP BY ?substation",
								"HAVING(COUNT(?asset) > 0)"),
						12000L),
				query("Grid: transformers with meters excluding self load",
						gridPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?transformer) AS ?count) WHERE {",
								"  ?transformer a grid:Transformer ; grid:feeds ?substation .",
								"  ?substation grid:name ?name .",
								"  FILTER(?name = \"Substation 0\" || ?name = \"Substation 1\")",
								"  FILTER EXISTS { ?transformer grid:hasMeter ?meter . }",
								"  MINUS { ?meter grid:measures ?load . FILTER(?load = ?substation) }",
								"}"),
						1L),
				query("Grid: substation transformer counts",
						gridPrefix + String.join("\n",
								"SELECT ?substation (COUNT(DISTINCT ?transformer) AS ?transformerCount) WHERE {",
								"  ?substation a grid:Substation ; grid:name ?name .",
								"  OPTIONAL { ?substation grid:feeds ?transformer . BIND(?transformer AS ?optTransformer) }",
								"  FILTER(?optTransformer != ?substation)",
								"  FILTER EXISTS { ?transformer grid:hasMeter ?meter . }",
								"}",
								"GROUP BY ?substation",
								"HAVING(COUNT(?transformer) > 0)"),
						0L),
				query("Grid: lines by capacity range",
						gridPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?line) AS ?count) WHERE {",
								"  ?line a grid:Line ; grid:capacity ?cap .",
								"  FILTER(?cap IN (500, 600, 700))",
								"  OPTIONAL { ?line grid:connectsTo ?substation . }",
								"  MINUS { ?line grid:capacity ?cap2 . FILTER(?cap2 < 500) }",
								"}"),
						1L),
				query("Grid: meters with high loads excluding lows",
						gridPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?meter) AS ?count) WHERE {",
								"  { ?meter a grid:Meter ; grid:measures ?load . }",
								"  UNION",
								"  { ?meter a grid:Meter ; grid:measures ?load . ?load grid:loadValue ?value . }",
								"  OPTIONAL { ?load grid:loadValue ?optValue . }",
								"  FILTER(?optValue > 200)",
								"  FILTER NOT EXISTS { ?load grid:loadValue ?low . FILTER(?low < 50) }",
								"}"),
						1L)));

		String pharmaPrefix = String.join("\n",
				"PREFIX pharma: <http://example.com/theme/pharma/>",
				"PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>",
				"");
		QUERIES.put(Theme.PHARMA, List.of(
				query("Pharma: trial drugs for diseases 0-1",
						pharmaPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?drug) AS ?count) WHERE {",
								"  VALUES ?disease { <http://example.com/theme/pharma/disease/0>",
								"                    <http://example.com/theme/pharma/disease/1> }",
								"  ?trial a pharma:ClinicalTrial ; pharma:studiesDisease ?disease ; pharma:hasArm ?arm .",
								"  ?arm pharma:armDrug ?drug ; pharma:hasResult ?result .",
								"  ?result pharma:pValue ?p ; pharma:effectSize ?effect .",
								"  OPTIONAL { ?result pharma:biomarker ?marker . BIND(?marker AS ?optMarker) }",
								"  FILTER(?optMarker != <http://example.com/theme/pharma/biomarker/999>)",
								"  FILTER(?p < 0.05 || ?effect > 0.7)",
								"}"),
						1L),
				query("Pharma: combinations with side effects and synergy",
						pharmaPrefix + String.join("\n",
								"SELECT ?combo (COUNT(DISTINCT ?drug) AS ?drugCount) WHERE {",
								"  ?combo a pharma:Combination ; pharma:combinationOf ?drug ; pharma:synergyScore ?score .",
								"  OPTIONAL {",
								"    ?drug pharma:hasSideEffect ?sideEffect .",
								"    ?sideEffect pharma:severity ?sev .",
								"    BIND(?sev AS ?optSeverity)",
								"  }",
								"  FILTER(?optSeverity IN (\"Mild\", \"Moderate\"))",
								"  FILTER(?score > 0.7)",
								"}",
								"GROUP BY ?combo",
								"HAVING(COUNT(DISTINCT ?drug) >= 2)"),
						133L),
				query("Pharma: targets with multiple drugs in trials",
						pharmaPrefix + String.join("\n",
								"SELECT ?target (COUNT(DISTINCT ?drug) AS ?drugCount) WHERE {",
								"  ?target a pharma:Target ; pharma:inPathway ?pathway .",
								"  ?drug a pharma:Drug ; pharma:targets ?target .",
								"  OPTIONAL { ?drug pharma:indicatedFor ?disease . BIND(?disease AS ?optDisease) }",
								"  FILTER(?optDisease IN (<http://example.com/theme/pharma/disease/2>,",
								"                         <http://example.com/theme/pharma/disease/3>))",
								"  FILTER EXISTS { ?trial pharma:hasArm ?arm . ?arm pharma:armDrug ?drug . }",
								"}",
								"GROUP BY ?target",
								"HAVING(COUNT(DISTINCT ?drug) > 2)"),
						0L),
				query("Pharma: drug responses without indication",
						pharmaPrefix + String.join("\n",
								"SELECT ?drug ?disease WHERE {",
								"  ?trial a pharma:ClinicalTrial ; pharma:studiesDisease ?disease ; pharma:hasArm ?arm .",
								"  ?arm pharma:armDrug ?drug ; pharma:hasResult ?result .",
								"  ?result pharma:responseRate ?rate .",
								"  FILTER(?rate > 0.6)",
								"  FILTER NOT EXISTS { ?drug pharma:indicatedFor ?disease . }",
								"  OPTIONAL { ?drug pharma:targets ?target . BIND(?target AS ?optTarget) }",
								"  FILTER(?optTarget != <http://example.com/theme/pharma/target/0>)",
								"}"),
						2749L),
				query("Pharma: drugs by class excluding contraindications",
						pharmaPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?drug) AS ?count) WHERE {",
								"  { ?drug a pharma:Drug ; pharma:hasMolecule ?mol . }",
								"  UNION",
								"  { ?combo a pharma:Combination ; pharma:combinationOf ?drug .",
								"    ?drug pharma:hasMolecule ?mol . }",
								"  ?mol pharma:inClass ?class .",
								"  OPTIONAL { ?class pharma:name ?optName . BIND(?optName AS ?optClassName) }",
								"  FILTER(?optClassName != \"\")",
								"  MINUS { ?drug pharma:contraindicatedFor ?disease .",
								"          FILTER(?disease IN (<http://example.com/theme/pharma/disease/4>,",
								"                              <http://example.com/theme/pharma/disease/5>)) }",
								"}"),
						1L),
				query("Pharma: trials with significant biomarkers",
						pharmaPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?trial) AS ?count) WHERE {",
								"  VALUES ?marker { <http://example.com/theme/pharma/biomarker/0>",
								"                   <http://example.com/theme/pharma/biomarker/1>",
								"                   <http://example.com/theme/pharma/biomarker/2> }",
								"  ?trial a pharma:ClinicalTrial ; pharma:hasArm ?arm .",
								"  ?arm pharma:hasResult ?result .",
								"  ?result pharma:biomarker ?marker ; pharma:pValue ?p .",
								"  OPTIONAL { ?result pharma:effectSize ?effect . BIND(?effect AS ?optEffect) }",
								"  FILTER(?optEffect > 0.3)",
								"  FILTER(?p < 0.05 || ?p = 0.05)",
								"}"),
						1L),
				query("Pharma: combinations with shared targets",
						pharmaPrefix + String.join("\n",
								"SELECT ?combo (COUNT(DISTINCT ?target) AS ?sharedTargets) WHERE {",
								"  ?combo a pharma:Combination ; pharma:combinationOf ?drugA ; pharma:combinationOf ?drugB .",
								"  FILTER(?drugA != ?drugB)",
								"  ?drugA pharma:targets ?target .",
								"  ?drugB pharma:targets ?target .",
								"  OPTIONAL { ?drugA pharma:hasSideEffect ?sideEffect . BIND(?sideEffect AS ?optSideEffect) }",
								"  FILTER(?optSideEffect != <http://example.com/theme/pharma/side-effect/0>)",
								"  FILTER EXISTS { ?drugB pharma:hasSideEffect ?sideEffect2 . }",
								"}",
								"GROUP BY ?combo",
								"HAVING(COUNT(DISTINCT ?target) > 1)"),
						0L),
				query("Pharma: clinical trial arms with comparators",
						pharmaPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?arm) AS ?count) WHERE {",
								"  ?trial a pharma:ClinicalTrial ; pharma:hasArm ?arm .",
								"  { ?arm pharma:armComparator ?comp . }",
								"  UNION",
								"  { ?arm pharma:armDrug ?comp . }",
								"  OPTIONAL { ?comp pharma:name ?optName . BIND(?optName AS ?optCompName) }",
								"  FILTER(?optCompName != \"\")",
								"  FILTER NOT EXISTS { ?arm pharma:hasResult ?r . ?r pharma:pValue ?p .",
								"                      FILTER(?p IN (0.08, 0.09)) }",
								"}"),
						1L),
				query("Pharma: drug target counts excluding contraindications",
						pharmaPrefix + String.join("\n",
								"SELECT ?drug (COUNT(DISTINCT ?target) AS ?targetCount) WHERE {",
								"  ?drug a pharma:Drug ; pharma:targets ?target .",
								"  OPTIONAL { ?drug pharma:hasMolecule ?mol . BIND(?mol AS ?optMol) }",
								"  FILTER(?optMol != <http://example.com/theme/pharma/molecule/0>)",
								"  MINUS { ?drug pharma:contraindicatedFor ?disease .",
								"          FILTER(?disease = <http://example.com/theme/pharma/disease/6>",
								"                 || ?disease = <http://example.com/theme/pharma/disease/7>) }",
								"}",
								"GROUP BY ?drug",
								"HAVING(COUNT(DISTINCT ?target) >= 3)"),
						0L),
				query("Pharma: drugs with strong average effects",
						pharmaPrefix + String.join("\n",
								"SELECT (COUNT(DISTINCT ?drug) AS ?count) WHERE {",
								"  {",
								"    SELECT ?drug (AVG(?effect) AS ?avgEffect) WHERE {",
								"      ?trial a pharma:ClinicalTrial ; pharma:hasArm ?arm .",
								"      ?arm pharma:armDrug ?drug ; pharma:hasResult ?result .",
								"      ?result pharma:effectSize ?effect .",
								"      OPTIONAL { ?result pharma:responseRate ?rate . BIND(?rate AS ?optRate) }",
								"      FILTER(?optRate > 0.2)",
								"    }",
								"    GROUP BY ?drug",
								"    HAVING(AVG(?effect) > 0.4)",
								"  }",
								"  FILTER EXISTS { ?drug pharma:hasSideEffect ?se . }",
								"  OPTIONAL { ?drug pharma:indicatedFor ?disease . BIND(?disease AS ?optDisease) }",
								"  FILTER(?optDisease IN (<http://example.com/theme/pharma/disease/8>,",
								"                         <http://example.com/theme/pharma/disease/9>))",
								"}"),
						1L),
				query("Pharma: pathways with biomarker trials",
						pharmaPrefix + String.join("\n",
								"SELECT ?pathway (COUNT(DISTINCT ?drug) AS ?drugCount) WHERE {",
								"  VALUES ?marker { <http://example.com/theme/pharma/biomarker/3>",
								"                   <http://example.com/theme/pharma/biomarker/4> }",
								"  ?drug a pharma:Drug ; pharma:targets ?target .",
								"  ?target pharma:inPathway ?pathway .",
								"  OPTIONAL { ?drug pharma:testedIn ?trial . BIND(?trial AS ?optTrial) }",
								"  FILTER(?optTrial != <http://example.com/theme/pharma/trial/0>)",
								"  FILTER EXISTS { ?trial pharma:hasArm ?arm . ?arm pharma:hasResult ?result .",
								"                  ?result pharma:biomarker ?marker . }",
								"}",
								"GROUP BY ?pathway",
								"HAVING(COUNT(DISTINCT ?drug) > 1)"),
						77L)));

		validateQueries();
	}

	private ThemeQueryCatalog() {
	}

	public static List<String> queriesFor(Theme theme) {
		List<BenchmarkQuery> queries = queriesForTheme(theme);
		return queries.stream()
				.map(BenchmarkQuery::getQuery)
				.collect(Collectors.toUnmodifiableList());
	}

	public static List<BenchmarkQuery> benchmarkQueriesFor(Theme theme) {
		return queriesForTheme(theme);
	}

	public static BenchmarkQuery benchmarkQueryFor(Theme theme, int index) {
		List<BenchmarkQuery> queries = queriesForTheme(theme);
		if (index < 0 || index >= queries.size()) {
			throw new IllegalArgumentException("Query index out of range: " + index);
		}
		return queries.get(index);
	}

	public static String queryFor(Theme theme, int index) {
		return benchmarkQueryFor(theme, index).getQuery();
	}

	public static long expectedCountFor(Theme theme, int index) {
		return benchmarkQueryFor(theme, index).getExpectedCount();
	}

	private static void validateQueries() {
		for (Theme theme : Theme.values()) {
			List<BenchmarkQuery> queries = QUERIES.get(theme);
			if (queries == null) {
				throw new IllegalStateException("Missing query list for theme " + theme);
			}
			if (queries.size() != QUERY_COUNT) {
				throw new IllegalStateException("Theme " + theme + " has " + queries.size() + " queries");
			}
		}
	}

	private static List<BenchmarkQuery> queriesForTheme(Theme theme) {
		Objects.requireNonNull(theme, "theme");
		List<BenchmarkQuery> queries = QUERIES.get(theme);
		if (queries == null) {
			throw new IllegalArgumentException("No queries registered for theme " + theme);
		}
		return queries;
	}

	private static BenchmarkQuery query(String name, String query, long expectedCount) {
		return new BenchmarkQuery(name, query, expectedCount);
	}

}
