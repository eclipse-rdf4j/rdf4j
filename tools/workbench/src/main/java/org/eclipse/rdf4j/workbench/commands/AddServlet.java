/*******************************************************************************
 * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.workbench.commands;

import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Set;

import javax.servlet.http.HttpServletResponse;

import org.eclipse.rdf4j.common.transaction.IsolationLevel;
import org.eclipse.rdf4j.common.transaction.IsolationLevels;
import org.eclipse.rdf4j.common.transaction.TransactionSetting;
import org.eclipse.rdf4j.common.transaction.TransactionSettingRegistry;
import org.eclipse.rdf4j.http.protocol.Protocol;
import org.eclipse.rdf4j.model.Resource;
import org.eclipse.rdf4j.query.QueryResultHandlerException;
import org.eclipse.rdf4j.repository.RepositoryConnection;
import org.eclipse.rdf4j.repository.RepositoryException;
import org.eclipse.rdf4j.rio.RDFFormat;
import org.eclipse.rdf4j.rio.RDFParseException;
import org.eclipse.rdf4j.rio.Rio;
import org.eclipse.rdf4j.workbench.base.TransformationServlet;
import org.eclipse.rdf4j.workbench.exceptions.BadRequestException;
import org.eclipse.rdf4j.workbench.util.TupleResultBuilder;
import org.eclipse.rdf4j.workbench.util.WorkbenchRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class AddServlet extends TransformationServlet {

	private static final String URL = "url";
	private static final String ISOLATION_LEVEL_OPTION = "isolation-level-option";
	private static final String ISOLATION_LEVEL_OPTION_LABEL = "isolation-level-option-label";
	private static final String ISOLATION_LEVEL_PARAM = Protocol.TRANSACTION_SETTINGS_PREFIX + IsolationLevel.NAME;

	private final Logger logger = LoggerFactory.getLogger(AddServlet.class);

	@Override
	protected void doPost(WorkbenchRequest req, HttpServletResponse resp, String xslPath)
			throws IOException, RepositoryException, QueryResultHandlerException {
		try {
			String baseURI = req.getParameter("baseURI");
			String contentType = req.getParameter("Content-Type");
			TransactionSetting isolationLevel = parseIsolationLevel(req);
			if (req.isParameterPresent(CONTEXT)) {
				Resource context = req.getResource(CONTEXT);
				if (req.isParameterPresent(URL)) {
					add(req.getUrl(URL), baseURI, contentType, isolationLevel, context);
				} else {
					add(req.getContentParameter(), baseURI, contentType, req.getContentFileName(), isolationLevel,
							context);
				}
			} else {
				if (req.isParameterPresent(URL)) {
					add(req.getUrl(URL), baseURI, contentType, isolationLevel);
				} else {
					add(req.getContentParameter(), baseURI, contentType, req.getContentFileName(), isolationLevel);
				}
			}
			resp.sendRedirect("summary");
		} catch (BadRequestException exc) {
			logger.warn(exc.toString(), exc);
			TupleResultBuilder builder = getTupleResultBuilder(req, resp, resp.getOutputStream());
			builder.transform(xslPath, "add.xsl");
			builder.start("error-message", "baseURI", CONTEXT, "Content-Type", ISOLATION_LEVEL_PARAM,
					ISOLATION_LEVEL_OPTION, ISOLATION_LEVEL_OPTION_LABEL);
			builder.link(List.of(INFO));
			String baseURI = req.getParameter("baseURI");
			String context = req.getParameter(CONTEXT);
			String contentType = req.getParameter("Content-Type");
			String isolationLevel = req.getParameter(ISOLATION_LEVEL_PARAM);
			builder.result(exc.getMessage(), baseURI, context, contentType, isolationLevel, null, null);
			for (String option : determineIsolationLevels()) {
				String optionLabel = isolationLevelLabel(option);
				String selectedIsolation = option.equals(isolationLevel) ? isolationLevel : null;
				builder.result(null, null, null, null, selectedIsolation, option, optionLabel);
			}
			builder.end();
		}
	}

	private void add(InputStream stream, String baseURI, String contentType, String contentFileName,
			TransactionSetting isolationLevel, Resource... context)
			throws BadRequestException, RepositoryException, IOException {
		if (contentType == null) {
			throw new BadRequestException("No Content-Type provided");
		}

		RDFFormat format;
		if ("autodetect".equals(contentType)) {
			format = Rio.getParserFormatForFileName(contentFileName)
					.orElseThrow(() -> new BadRequestException(
							"Could not automatically determine Content-Type for content: " + contentFileName));
		} else {
			format = Rio.getParserFormatForMIMEType(contentType)
					.orElseThrow(() -> new BadRequestException("Unknown Content-Type: " + contentType));
		}

		try (RepositoryConnection con = repository.getConnection()) {
			boolean transactionStarted = beginIfRequested(con, isolationLevel);
			try {
				con.add(stream, baseURI, format, context);
				commitIfNeeded(con, transactionStarted);
			} catch (RDFParseException | IllegalArgumentException exc) {
				rollbackIfNeeded(con, transactionStarted);
				throw new BadRequestException(exc.getMessage(), exc);
			}
		}
	}

	private void add(URL url, String baseURI, String contentType, TransactionSetting isolationLevel,
			Resource... context)
			throws BadRequestException, RepositoryException, IOException {
		if (contentType == null) {
			throw new BadRequestException("No Content-Type provided");
		}

		RDFFormat format;
		if ("autodetect".equals(contentType)) {
			format = Rio.getParserFormatForFileName(url.getFile())
					.orElseThrow(() -> new BadRequestException(
							"Could not automatically determine Content-Type for content: " + url.getFile()));
		} else {
			format = Rio.getParserFormatForMIMEType(contentType)
					.orElseThrow(() -> new BadRequestException("Unknown Content-Type: " + contentType));
		}

		try {
			try (RepositoryConnection con = repository.getConnection()) {
				boolean transactionStarted = beginIfRequested(con, isolationLevel);
				try {
					con.add(url, baseURI, format, context);
					commitIfNeeded(con, transactionStarted);
				} catch (RDFParseException | MalformedURLException | IllegalArgumentException exc) {
					rollbackIfNeeded(con, transactionStarted);
					throw exc;
				}
			}
		} catch (RDFParseException | MalformedURLException | IllegalArgumentException exc) {
			throw new BadRequestException(exc.getMessage(), exc);
		}
	}

	@Override
	public void service(TupleResultBuilder builder, String xslPath)
			throws RepositoryException, QueryResultHandlerException {
		builder.transform(xslPath, "add.xsl");
		builder.start();
		builder.link(List.of(INFO));
		builder.end();
	}

	@Override
	protected void service(WorkbenchRequest req, HttpServletResponse resp, String xslPath) throws Exception {
		TupleResultBuilder builder = getTupleResultBuilder(req, resp, resp.getOutputStream());
		builder.transform(xslPath, "add.xsl");
		builder.start(ISOLATION_LEVEL_OPTION, ISOLATION_LEVEL_OPTION_LABEL, ISOLATION_LEVEL_PARAM);
		builder.link(List.of(INFO));
		String selected = req.getParameter(ISOLATION_LEVEL_PARAM);
		if (selected != null && !selected.isBlank()) {
			builder.result(selected, isolationLevelLabel(selected), selected);
		}
		for (String option : determineIsolationLevels()) {
			if (!option.equals(selected)) {
				builder.result(option, isolationLevelLabel(option), null);
			}
		}
		builder.end();
	}

	private TransactionSetting parseIsolationLevel(WorkbenchRequest req) throws BadRequestException {
		String requested = req.getParameter(ISOLATION_LEVEL_PARAM);
		if (requested != null && !requested.isBlank()) {
			return TransactionSettingRegistry.getInstance()
					.get(IsolationLevel.NAME)
					.flatMap(factory -> factory.getTransactionSetting(requested))
					.orElseThrow(() -> new BadRequestException("Unknown isolation level: " + requested));
		}
		return null;
	}

	private boolean beginIfRequested(RepositoryConnection connection, TransactionSetting isolationLevel)
			throws RepositoryException {
		if (isolationLevel != null) {
			connection.begin(isolationLevel);
			return true;
		}
		return false;
	}

	private void commitIfNeeded(RepositoryConnection connection, boolean transactionStarted)
			throws RepositoryException {
		if (transactionStarted && connection.isActive()) {
			connection.commit();
		}
	}

	private void rollbackIfNeeded(RepositoryConnection connection, boolean transactionStarted) {
		if (transactionStarted) {
			try {
				if (connection.isActive()) {
					connection.rollback();
				}
			} catch (RepositoryException e) {
				logger.warn("Failed to roll back add transaction", e);
			}
		}
	}

	List<String> determineIsolationLevels() {
		if (repository == null) {
			return List.of();
		}
		Set<String> supported = new LinkedHashSet<>();
		try (RepositoryConnection connection = repository.getConnection()) {
			IsolationLevel original = connection.getIsolationLevel();
			for (IsolationLevels level : IsolationLevels.values()) {
				if (supportsIsolationLevel(connection, level)) {
					supported.add(isolationLevelName(level));
				}
			}
			if (original != null) {
				String originalName = isolationLevelName(original);
				if (!supported.contains(originalName)) {
					supported.add(originalName);
				}
			}
		} catch (RepositoryException e) {
			logger.warn("Unable to determine supported isolation levels", e);
		}
		return new ArrayList<>(supported);
	}

	private boolean supportsIsolationLevel(RepositoryConnection connection, IsolationLevel level) {
		try {
			connection.begin(level);
			connection.rollback();
			return true;
		} catch (RepositoryException e) {
			try {
				if (connection.isActive()) {
					connection.rollback();
				}
			} catch (RepositoryException ex) {
				logger.debug("Unable to rollback after failed isolation test", ex);
			}
			logger.debug("Isolation level {} is not supported by {}", level, repository.getClass().getSimpleName(), e);
			return false;
		}
	}

	private String isolationLevelName(IsolationLevel level) {
		String value = level.getValue();
		if (value != null && !value.isBlank()) {
			return value;
		}
		return (level instanceof Enum<?>) ? ((Enum<?>) level).name() : level.toString();
	}

	private String isolationLevelLabel(String value) {
		String normalized = value.replace('.', '_');
		String[] parts = normalized.toLowerCase(Locale.ROOT).split("_");
		StringBuilder label = new StringBuilder();
		for (String part : parts) {
			if (part.isEmpty()) {
				continue;
			}
			if (label.length() > 0) {
				label.append(' ');
			}
			label.append(Character.toUpperCase(part.charAt(0)));
			if (part.length() > 1) {
				label.append(part.substring(1));
			}
		}
		return label.length() == 0 ? value : label.toString();
	}

}
