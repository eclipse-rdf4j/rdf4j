/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.tools.serverboot;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.WriteListener;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;

/**
 * Replaces {@code ${path}} placeholders inside CSS responses after buffering the downstream output. The buffering
 * avoids calling {@link ServletResponse#getWriter()} before the target resource starts writing, preventing
 * writer/output stream conflicts on binary responses.
 */
class CssPathFilter implements Filter {

	private static final String PLACEHOLDER = "${path}";
	private static final Charset DEFAULT_CHARSET = StandardCharsets.ISO_8859_1;

	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {
		if (!(request instanceof HttpServletRequest) || !(response instanceof HttpServletResponse)) {
			chain.doFilter(request, response);
			return;
		}

		HttpServletRequest httpRequest = (HttpServletRequest) request;
		HttpServletResponse httpResponse = (HttpServletResponse) response;
		BufferingResponseWrapper bufferingResponse = new BufferingResponseWrapper(httpResponse);

		chain.doFilter(request, bufferingResponse);

		byte[] body = bufferingResponse.getBody();
		if (body.length == 0) {
			return;
		}

		Charset charset = bufferingResponse.getCharset();
		String rendered = new String(body, charset);
		if (!rendered.contains(PLACEHOLDER)) {
			writeBody(httpResponse, body);
			return;
		}

		String contextPath = httpRequest.getContextPath();
		if (contextPath == null) {
			contextPath = "";
		}
		byte[] replaced = rendered.replace(PLACEHOLDER, contextPath).getBytes(charset);
		writeBody(httpResponse, replaced);
	}

	private void writeBody(HttpServletResponse response, byte[] body) throws IOException {
		response.setContentLengthLong(body.length);
		ServletOutputStream outputStream = response.getOutputStream();
		outputStream.write(body);
		outputStream.flush();
	}

	private static final class BufferingResponseWrapper extends HttpServletResponseWrapper {

		private final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
		private ServletOutputStream outputStream;
		private PrintWriter writer;

		BufferingResponseWrapper(HttpServletResponse response) {
			super(response);
		}

		Charset getCharset() {
			String encoding = getCharacterEncoding();
			if (encoding == null) {
				return DEFAULT_CHARSET;
			}
			try {
				return Charset.forName(encoding);
			} catch (IllegalArgumentException ignored) {
				return DEFAULT_CHARSET;
			}
		}

		byte[] getBody() throws IOException {
			flushBuffer();
			return buffer.toByteArray();
		}

		@Override
		public ServletOutputStream getOutputStream() throws IOException {
			if (writer != null) {
				throw new IllegalStateException("getWriter() has already been called for this response");
			}
			if (outputStream == null) {
				outputStream = new ServletOutputStream() {
					@Override
					public boolean isReady() {
						return true;
					}

					@Override
					public void setWriteListener(WriteListener writeListener) {
						// no async support
					}

					@Override
					public void write(int b) {
						buffer.write(b);
					}
				};
			}
			return outputStream;
		}

		@Override
		public PrintWriter getWriter() throws IOException {
			if (outputStream != null) {
				throw new IllegalStateException("getOutputStream() has already been called for this response");
			}
			if (writer == null) {
				writer = new PrintWriter(new OutputStreamWriter(buffer, getCharset()), true);
			}
			return writer;
		}

		@Override
		public void flushBuffer() throws IOException {
			if (writer != null) {
				writer.flush();
			}
			if (outputStream != null) {
				outputStream.flush();
			}
		}

		@Override
		public void resetBuffer() {
			buffer.reset();
		}
	}
}
