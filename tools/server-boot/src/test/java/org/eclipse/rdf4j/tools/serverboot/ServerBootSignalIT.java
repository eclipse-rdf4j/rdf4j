/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.tools.serverboot;

import static java.util.concurrent.TimeUnit.SECONDS;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.fail;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.ServerSocket;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicBoolean;

import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Literal;
import org.eclipse.rdf4j.model.ValueFactory;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.query.TupleQuery;
import org.eclipse.rdf4j.query.TupleQueryResult;
import org.eclipse.rdf4j.repository.Repository;
import org.eclipse.rdf4j.repository.RepositoryConnection;
import org.eclipse.rdf4j.repository.RepositoryException;
import org.eclipse.rdf4j.repository.config.RepositoryConfig;
import org.eclipse.rdf4j.repository.config.RepositoryConfigException;
import org.eclipse.rdf4j.repository.manager.RemoteRepositoryManager;
import org.eclipse.rdf4j.repository.sail.config.SailRepositoryConfig;
import org.eclipse.rdf4j.sail.memory.config.MemoryStoreConfig;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.condition.EnabledOnOs;
import org.junit.jupiter.api.condition.OS;

@EnabledOnOs({ OS.LINUX, OS.MAC })
class ServerBootSignalIT {

	private static final int MIN_TEST_PORT = 32768;
	private static final int PORT_ALLOCATION_ATTEMPTS = 100;

	private ExecutorService streamExecutor;
	private final List<Runnable> cleanupActions = new ArrayList<>();

	@BeforeEach
	void setUp() {
		streamExecutor = Executors.newFixedThreadPool(2, runnable -> {
			Thread thread = new Thread(runnable);
			thread.setDaemon(true);
			thread.setName("server-boot-signal-it");
			return thread;
		});
	}

	@AfterEach
	void tearDown() {
		for (Runnable cleanup : cleanupActions) {
			try {
				cleanup.run();
			} catch (Exception ignored) {
				// best-effort cleanup
			}
		}
		streamExecutor.shutdownNow();
	}

	@Test
	void gracefullyStopsOnSigint() throws Exception {
		assertGracefulShutdown("INT");
	}

	@Test
	void gracefullyStopsOnSigterm() throws Exception {
		assertGracefulShutdown("TERM");
	}

	private void assertGracefulShutdown(String signalName) throws Exception {
		Path projectRoot = Path.of("").toAbsolutePath();
		String javaBin = Path.of(System.getProperty("java.home"), "bin", "java").toString();
		int serverPort = findFreePort();
		int managementPort = findFreePort();
		Instant startedAt = Instant.now();

		// Find the executable JAR
		Path targetDir = projectRoot.resolve("target");
		Path jarPath = Files.list(targetDir)
				.sorted(Comparator.comparing(Path::toString))
				.filter(p -> p.toString().endsWith(".jar"))
				.filter(p -> !p.toString().endsWith("-sources.jar"))
				.filter(p -> !p.toString().endsWith("-javadoc.jar"))
				.findFirst()
				.orElseThrow(() -> new IllegalStateException("Could not find executable JAR in " + targetDir));

		ProcessBuilder processBuilder = new ProcessBuilder(javaBin, "-jar", jarPath.toString(),
				"--server.port=" + serverPort,
				"--management.server.port=" + managementPort);
		processBuilder.directory(projectRoot.toFile());
		processBuilder.redirectErrorStream(true);

		StringBuilder outputBuffer = new StringBuilder();
		appendOutput(outputBuffer, "Starting signal test with signal=SIG" + signalName + ", startTime=" + startedAt);
		appendOutput(outputBuffer, "Launch command: " + processBuilder.command());
		appendOutput(outputBuffer, "Launch directory: " + processBuilder.directory());
		appendOutput(outputBuffer,
				"Allocated ports: server.port=" + serverPort + ", management.server.port=" + managementPort);

		Process process = processBuilder.start();
		cleanupActions.add(() -> process.destroyForcibly());
		appendOutput(outputBuffer, "Launched process pid=" + process.pid());
		logProcessState(outputBuffer, process, "immediately after process launch");

		CountDownLatch started = new CountDownLatch(1);
		startStreamGobbler(process, started, outputBuffer);

		boolean startedInTime = started.await(90, SECONDS);
		appendOutput(outputBuffer,
				"Startup marker observed=" + startedInTime + " after "
						+ Duration.between(startedAt, Instant.now()).toMillis() + "ms");
		logProcessState(outputBuffer, process, "after startup wait");
		assertThat(startedInTime)
				.as(() -> "Server failed to start within timeout. Output:\n" + outputBuffer)
				.isTrue();

		String serverUrl = serverUrl(serverPort);
		appendOutput(outputBuffer, "Using remote repository URL " + serverUrl);
		exerciseRemoteRepository(serverUrl, outputBuffer);

		long pid = process.pid();
		sendSignal(pid, signalName, outputBuffer);
		logProcessState(outputBuffer, process, "after first SIG" + signalName);

		boolean exited = process.waitFor(30, SECONDS);
		appendOutput(outputBuffer, "Waited 30s after SIG" + signalName + ", exited=" + exited);
		if (!exited) {
			if ("INT".equals(signalName)) {
				appendOutput(outputBuffer,
						"Process still running 30s after first SIGINT; sending SIGTERM fallback.");
				sendSignal(pid, "TERM", outputBuffer);
			} else {
				appendOutput(outputBuffer,
						"Process still running 30s after first SIG" + signalName + "; retrying signal delivery.");
				sendSignal(pid, signalName, outputBuffer);
			}
			exited = process.waitFor(30, SECONDS);
			appendOutput(outputBuffer,
					"Waited additional 30s after retry/fallback signal, exited=" + exited);
		}
		logProcessState(outputBuffer, process, "after shutdown wait(s)");
		assertThat(exited)
				.as(() -> "Process did not exit after SIG" + signalName + ". Output:\n" + outputBuffer)
				.isTrue();
		assertThat(process.exitValue())
				.as(() -> "Process exit value after SIG" + signalName + ". Output:\n" + outputBuffer)
				.isEqualTo(0);
	}

	private void startStreamGobbler(Process process, CountDownLatch started, StringBuilder outputBuffer) {
		AtomicBoolean signalLogged = new AtomicBoolean(false);
		streamExecutor.submit(() -> {
			try (BufferedReader reader = new BufferedReader(
					new InputStreamReader(process.getInputStream(), StandardCharsets.UTF_8))) {
				String line;
				while ((line = reader.readLine()) != null) {
					synchronized (outputBuffer) {
						outputBuffer.append(line).append(System.lineSeparator());
					}
					if (!signalLogged.get() && (line.contains("Tomcat initialized with port")
							|| line.contains("Started Rdf4jServerWorkbenchApplication"))) {
						started.countDown();
						signalLogged.set(true);
						appendOutput(outputBuffer, "Detected startup marker line: " + line);
					}
				}
				appendOutput(outputBuffer, "Process output stream ended.");
			} catch (IOException e) {
				synchronized (outputBuffer) {
					outputBuffer.append("Failed to read process output: ")
							.append(e.getMessage())
							.append(System.lineSeparator());
				}
			}
		});
	}

	private void sendSignal(long pid, String signalName, StringBuilder outputBuffer)
			throws IOException, InterruptedException {
		appendOutput(outputBuffer, "Sending SIG" + signalName + " to pid=" + pid);
		Process signalProcess = new ProcessBuilder("kill", "-s", signalName, Long.toString(pid))
				.redirectErrorStream(true)
				.start();
		cleanupActions.add(() -> signalProcess.destroyForcibly());
		if (!signalProcess.waitFor(5, SECONDS)) {
			signalProcess.destroyForcibly();
			signalProcess.waitFor(5, SECONDS);
			throw new IOException("Timed out sending SIG" + signalName + " to process " + pid);
		}
		String signalOutput = new String(signalProcess.getInputStream().readAllBytes(), StandardCharsets.UTF_8).trim();
		int exitCode = signalProcess.exitValue();
		appendOutput(outputBuffer,
				"kill -s " + signalName + " " + pid + " completed with exitCode=" + exitCode
						+ (signalOutput.isEmpty() ? "" : ", output=" + signalOutput));
		if (exitCode != 0) {
			appendOutput(outputBuffer,
					"kill command failed while sending SIG" + signalName + " to " + pid + " (exit " + exitCode
							+ "). Output: " + signalOutput);
			throw new IOException("Failed to send SIG" + signalName + " to process " + pid + " (exit " + exitCode
					+ (signalOutput.isEmpty() ? "" : ", output: " + signalOutput) + ")");
		}
	}

	private void appendOutput(StringBuilder outputBuffer, String line) {
		synchronized (outputBuffer) {
			outputBuffer.append(line).append(System.lineSeparator());
		}
	}

	private void exerciseRemoteRepository(String serverUrl, StringBuilder outputBuffer)
			throws InterruptedException, RepositoryException, RepositoryConfigException {
		RemoteRepositoryManager manager = awaitRepositoryManager(serverUrl, outputBuffer);
		String repoId = "signal-" + UUID.randomUUID();
		try {
			RepositoryConfig config = new RepositoryConfig(repoId,
					new SailRepositoryConfig(new MemoryStoreConfig()));
			manager.addRepositoryConfig(config);

			Repository repository = manager.getRepository(repoId);
			repository.init();

			ValueFactory valueFactory = SimpleValueFactory.getInstance();
			IRI subject = valueFactory.createIRI("urn:signal:test");
			IRI predicate = valueFactory.createIRI("urn:signal:predicate");
			Literal object = valueFactory.createLiteral("signal");

			try (RepositoryConnection connection = repository.getConnection()) {
				connection.add(subject, predicate, object);
				TupleQuery query = connection.prepareTupleQuery(
						"select ?o where { <urn:signal:test> <urn:signal:predicate> ?o }");
				try (TupleQueryResult result = query.evaluate()) {
					assertThat(result.hasNext())
							.as("Tuple query returned a result row")
							.isTrue();
					assertThat(result.next().getValue("o"))
							.as("Tuple query binding value")
							.isEqualTo(object);
				}
			} finally {
				repository.shutDown();
			}
		} finally {
			try {
				manager.removeRepository(repoId);
			} catch (RepositoryException ignored) {
				// best-effort cleanup
			}
			manager.shutDown();
		}
	}

	private RemoteRepositoryManager awaitRepositoryManager(String serverUrl, StringBuilder outputBuffer)
			throws InterruptedException {
		RepositoryException lastException = null;
		long deadline = System.nanoTime() + SECONDS.toNanos(90);
		int attempts = 0;
		while (System.nanoTime() < deadline) {
			attempts++;
			RemoteRepositoryManager manager = null;
			try {
				manager = RemoteRepositoryManager.getInstance(serverUrl);
				manager.getRepositoryIDs();
				appendOutput(outputBuffer,
						"Repository manager reachable at " + serverUrl + " after " + attempts + " attempts.");
				return manager;
			} catch (RepositoryException e) {
				lastException = e;
				appendOutput(outputBuffer,
						"Repository probe attempt " + attempts + " failed: " + summarizeException(e));
				if (manager != null) {
					try {
						manager.shutDown();
					} catch (RepositoryException ignored) {
						// ignore cleanup failure
					}
				}
				Thread.sleep(500);
			}
		}
		String errorMessage = "Timed out connecting to " + serverUrl + " Output:\n" + outputBuffer
				+ (lastException == null ? "" : ("\nLast error: " + lastException));
		fail(errorMessage);
		return null;
	}

	private void logProcessState(StringBuilder outputBuffer, Process process, String label) {
		ProcessHandle handle = process.toHandle();
		ProcessHandle.Info info = handle.info();
		long descendantCount = handle.descendants().count();
		appendOutput(outputBuffer,
				"Process state [" + label + "]: pid=" + process.pid()
						+ ", alive=" + process.isAlive()
						+ ", descendants=" + descendantCount
						+ ", command=" + info.command().orElse("<unknown>")
						+ ", arguments=" + describeArguments(info.arguments())
						+ ", start=" + info.startInstant().map(Object::toString).orElse("<unknown>")
						+ ", cpu=" + info.totalCpuDuration().map(Duration::toString).orElse("<unknown>"));
	}

	private String describeArguments(Optional<String[]> arguments) {
		if (arguments.isEmpty()) {
			return "<unknown>";
		}
		return String.join(" ", arguments.get());
	}

	private String summarizeException(Throwable throwable) {
		Throwable root = throwable;
		while (root.getCause() != null && root.getCause() != root) {
			root = root.getCause();
		}
		String message = root.getMessage();
		return root.getClass().getName() + (message == null || message.isBlank() ? "" : ": " + message);
	}

	private String serverUrl(int port) {
		return "http://localhost:" + port + "/rdf4j-server";
	}

	private int findFreePort() throws IOException {
		for (int attempt = 0; attempt < PORT_ALLOCATION_ATTEMPTS; attempt++) {
			try (ServerSocket socket = new ServerSocket(0)) {
				socket.setReuseAddress(true);
				int candidate = socket.getLocalPort();
				if (candidate > MIN_TEST_PORT) {
					return candidate;
				}
			}
		}
		throw new IOException("Unable to allocate random test port above " + MIN_TEST_PORT);
	}
}
