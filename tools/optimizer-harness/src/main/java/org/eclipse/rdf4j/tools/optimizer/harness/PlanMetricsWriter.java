/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.tools.optimizer.harness;

import java.io.BufferedWriter;
import java.io.Closeable;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Map;

import org.eclipse.rdf4j.query.algebra.evaluation.optimizer.CardinalityEstimator;
import org.eclipse.rdf4j.query.explanation.GenericPlanNode;

final class PlanMetricsWriter implements Closeable {

	private final BufferedWriter writer;

	PlanMetricsWriter(Path outputFile) throws IOException {
		writer = Files.newBufferedWriter(outputFile, StandardCharsets.UTF_8);
		writer.write(String.join(",",
				"runId",
				"queryId",
				"nodeId",
				"opType",
				"algorithm",
				"newScope",
				"costEstimate",
				"resultSizeEstimate",
				"cardRowsEstimate",
				"cardWorkEstimate",
				"resultSizeActual",
				"totalTimeMs"));
		writer.newLine();
	}

	void writePlan(String runId, String queryId, GenericPlanNode plan,
			Map<String, CardinalityEstimator.Estimate> estimates) throws IOException {
		visit(runId, queryId, plan, "0", estimates);
		writer.flush();
	}

	private void visit(String runId, String queryId, GenericPlanNode node, String nodeId,
			Map<String, CardinalityEstimator.Estimate> estimates) throws IOException {
		writeRow(runId, queryId, nodeId, node, estimates.get(nodeId));
		List<GenericPlanNode> children = node.getPlans();
		if (children == null || children.isEmpty()) {
			return;
		}
		for (int i = 0; i < children.size(); i++) {
			visit(runId, queryId, children.get(i), nodeId + "." + i, estimates);
		}
	}

	private void writeRow(String runId, String queryId, String nodeId, GenericPlanNode node,
			CardinalityEstimator.Estimate estimate) throws IOException {
		Double rowsEstimate = estimate == null ? null : estimate.getRows();
		Double workEstimate = estimate == null ? null : estimate.getWork();
		writer.write(String.join(",",
				escape(runId),
				escape(queryId),
				escape(nodeId),
				escape(node.getType()),
				escape(node.getAlgorithm()),
				escape(toStringOrEmpty(node.isNewScope())),
				escape(toStringOrEmpty(node.getCostEstimate())),
				escape(toStringOrEmpty(node.getResultSizeEstimate())),
				escape(toStringOrEmpty(rowsEstimate)),
				escape(toStringOrEmpty(workEstimate)),
				escape(toStringOrEmpty(node.getResultSizeActual())),
				escape(toStringOrEmpty(node.getTotalTimeActual()))));
		writer.newLine();
	}

	private static String toStringOrEmpty(Object value) {
		return value == null ? "" : String.valueOf(value);
	}

	private static String escape(String value) {
		if (value == null) {
			return "";
		}
		boolean needsQuotes = value.contains(",") || value.contains("\"") || value.contains("\n");
		String escaped = value.replace("\"", "\"\"");
		return needsQuotes ? "\"" + escaped + "\"" : escaped;
	}

	@Override
	public void close() throws IOException {
		writer.close();
	}
}
