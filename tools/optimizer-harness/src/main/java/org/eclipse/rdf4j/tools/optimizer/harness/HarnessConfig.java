/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.tools.optimizer.harness;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Instant;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.Locale;

final class HarnessConfig {

	private static final DateTimeFormatter RUN_TIMESTAMP = DateTimeFormatter.ofPattern("yyyyMMdd-HHmmss")
			.withLocale(Locale.ROOT)
			.withZone(ZoneOffset.UTC);

	final long seed;
	final int subjects;
	final int fanout;
	final int objects;
	final double optionalRate;
	final double unionSkew;
	final double filterSelectivity;
	final double maxRegression;
	final boolean baselineOnly;
	final Path outputDir;

	private HarnessConfig(long seed, int subjects, int fanout, int objects, double optionalRate, double unionSkew,
			double filterSelectivity, double maxRegression, boolean baselineOnly, Path outputDir) {
		this.seed = seed;
		this.subjects = subjects;
		this.fanout = fanout;
		this.objects = objects;
		this.optionalRate = optionalRate;
		this.unionSkew = unionSkew;
		this.filterSelectivity = filterSelectivity;
		this.maxRegression = maxRegression;
		this.baselineOnly = baselineOnly;
		this.outputDir = outputDir;
	}

	static HarnessConfig fromArgs(String[] args) {
		long seed = 1L;
		int subjects = 200;
		int fanout = 3;
		int objects = 50;
		double optionalRate = 0.35;
		double unionSkew = 0.05;
		double filterSelectivity = 0.1;
		double maxRegression = 0.10;
		boolean baselineOnly = false;
		Path outputDir = defaultOutputDir();

		for (int i = 0; i < args.length; i++) {
			String arg = args[i];
			if ("--seed".equals(arg)) {
				seed = parseLong(nextArg(args, ++i, arg));
			} else if ("--subjects".equals(arg)) {
				subjects = parseInt(nextArg(args, ++i, arg));
			} else if ("--fanout".equals(arg)) {
				fanout = parseInt(nextArg(args, ++i, arg));
			} else if ("--objects".equals(arg)) {
				objects = parseInt(nextArg(args, ++i, arg));
			} else if ("--optional-rate".equals(arg)) {
				optionalRate = parseDouble(nextArg(args, ++i, arg));
			} else if ("--union-skew".equals(arg)) {
				unionSkew = parseDouble(nextArg(args, ++i, arg));
			} else if ("--filter-selectivity".equals(arg)) {
				filterSelectivity = parseDouble(nextArg(args, ++i, arg));
			} else if ("--max-regression".equals(arg)) {
				maxRegression = parseDouble(nextArg(args, ++i, arg));
			} else if ("--output".equals(arg)) {
				outputDir = Paths.get(nextArg(args, ++i, arg));
			} else if ("--baseline-only".equals(arg)) {
				baselineOnly = true;
			} else if ("--help".equals(arg) || "-h".equals(arg)) {
				throw new IllegalArgumentException(usage());
			} else {
				throw new IllegalArgumentException("Unknown argument: " + arg + System.lineSeparator() + usage());
			}
		}

		return new HarnessConfig(seed, subjects, fanout, objects, optionalRate, unionSkew, filterSelectivity,
				maxRegression, baselineOnly, outputDir);
	}

	int filterThreshold() {
		int threshold = (int) Math.round(objects * filterSelectivity);
		return Math.max(1, Math.min(objects, threshold));
	}

	private static Path defaultOutputDir() {
		String runId = RUN_TIMESTAMP.format(Instant.now());
		return Paths.get("tools", "optimizer-harness", "target", "harness", "run-" + runId);
	}

	private static String nextArg(String[] args, int index, String arg) {
		if (index >= args.length) {
			throw new IllegalArgumentException("Missing value for " + arg + System.lineSeparator() + usage());
		}
		return args[index];
	}

	private static int parseInt(String value) {
		return Integer.parseInt(value.trim());
	}

	private static long parseLong(String value) {
		return Long.parseLong(value.trim());
	}

	private static double parseDouble(String value) {
		return Double.parseDouble(value.trim());
	}

	static String usage() {
		return String.join(System.lineSeparator(),
				"Optimizer harness options:",
				"  --seed <long>",
				"  --subjects <int>",
				"  --fanout <int>",
				"  --objects <int>",
				"  --optional-rate <double>",
				"  --union-skew <double>",
				"  --filter-selectivity <double>",
				"  --max-regression <double>",
				"  --output <dir>",
				"  --baseline-only",
				"  --help | -h");
	}
}
