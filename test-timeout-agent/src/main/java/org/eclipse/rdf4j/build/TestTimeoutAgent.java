/*******************************************************************************
 * Copyright (c) 2025 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.build;

import java.lang.management.ManagementFactory;
import java.lang.management.ThreadInfo;
import java.lang.management.ThreadMXBean;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;

public final class TestTimeoutAgent {
	private static final String TIMEOUT_PROPERTY = "test.timeout.seconds";

	private TestTimeoutAgent() {
	}

	public static void premain(String agentArgs) {
		long timeoutSeconds = parseTimeoutSeconds(agentArgs);
		if (timeoutSeconds <= 0) {
			return;
		}

		ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor(new TimeoutThreadFactory());
		scheduler.schedule(() -> dumpAndHalt(timeoutSeconds), timeoutSeconds, TimeUnit.SECONDS);
	}

	private static long parseTimeoutSeconds(String agentArgs) {
		Long parsed = parseLong(agentArgs);
		if (parsed != null) {
			return parsed;
		}
		Long propertyValue = parseLong(System.getProperty(TIMEOUT_PROPERTY));
		return propertyValue == null ? 0L : propertyValue;
	}

	private static Long parseLong(String value) {
		if (value == null) {
			return null;
		}
		String trimmed = value.trim();
		if (trimmed.isEmpty()) {
			return null;
		}
		try {
			return Long.parseLong(trimmed);
		} catch (NumberFormatException e) {
			return null;
		}
	}

	private static void dumpAndHalt(long timeoutSeconds) {
		try {
			ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
			boolean includeMonitors = threadMXBean.isObjectMonitorUsageSupported();
			boolean includeSynchronizers = threadMXBean.isSynchronizerUsageSupported();
			ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(includeMonitors, includeSynchronizers);
			StringBuilder dump = new StringBuilder(16384);
			dump.append("=== Test timeout after ").append(timeoutSeconds).append(" seconds ===\n");
			if (threadInfos != null) {
				for (ThreadInfo threadInfo : threadInfos) {
					if (threadInfo != null) {
						dump.append(threadInfo.toString());
					}
				}
			}
			System.err.print(dump.toString());
			System.err.flush();
		} catch (Throwable throwable) {
			throwable.printStackTrace(System.err);
		} finally {
			Runtime.getRuntime().halt(1);
		}
	}

	private static final class TimeoutThreadFactory implements ThreadFactory {
		@Override
		public Thread newThread(Runnable runnable) {
			Thread thread = new Thread(runnable, "test-timeout-watchdog");
			thread.setDaemon(true);
			return thread;
		}
	}
}
